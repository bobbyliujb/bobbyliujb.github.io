<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[拼扯惹斯特]]></title>
    <url>%2F2018%2F09%2F29%2Fpinterest%2F</url>
    <content type="text"><![CDATA[迎难而上，祝我好运。面朝大海，春暖花开。 2018.8.9269. alien-dictionary x3 给一个按照某种外星人字典序排好序的String数组，只包含小写字母，求这些出现过的字母的顺序。若有多种可能（平级）则任意顺序均可。 topo排序问题，前后两个字符串逐个字符找到第一对不同的字符，确定先后顺序（前-&gt;后）构成一条边，两两字符串全部遍历完之后就形成了一个graph。维护一个inDegree，每次BFS时从入度为0的节点出发，将它可达的所有邻接点的入度都减1（删掉这些边），最后如果全部字符都遍历到了即可。如果出现了环，则一定会又入度不为0的点残留。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution &#123; public String alienOrder(String[] words) &#123; if (words == null || words.length == 0) &#123; return ""; &#125; Map&lt;Character, Set&lt;Character&gt;&gt; graph = new HashMap&lt;&gt;(); Map&lt;Character, Integer&gt; inDegree = new HashMap&lt;&gt;(); initInDegree(words, inDegree); buildGraph(words, graph, inDegree); Queue&lt;Character&gt; q = new LinkedList&lt;&gt;(); for (char c : inDegree.keySet()) &#123; if (inDegree.get(c) == 0) &#123; q.offer(c); &#125; &#125; StringBuilder sb = new StringBuilder(); while (!q.isEmpty()) &#123; char c = q.poll(); sb.append(c); if (graph.containsKey(c)) &#123; Set&lt;Character&gt; neighbors = graph.get(c); for (char neighbor : neighbors) &#123; inDegree.put(neighbor, inDegree.get(neighbor) - 1); if (inDegree.get(neighbor) == 0) &#123; q.offer(neighbor); &#125; &#125; &#125; &#125; if (sb.length() != inDegree.size()) &#123; return ""; &#125; return sb.toString(); &#125; private void initInDegree(String[] words, Map&lt;Character, Integer&gt; inDegree) &#123; for (String word : words) &#123; for (char c : word.toCharArray()) &#123; inDegree.put(c, 0); &#125; &#125; &#125; private void buildGraph(String[] words, Map&lt;Character, Set&lt;Character&gt;&gt; graph, Map&lt;Character, Integer&gt; inDegree) &#123; for (int i = 1; i &lt; words.length; i++) &#123; String prev = words[i - 1]; String curr = words[i]; int len = Math.min(prev.length(), curr.length()); for (int j = 0; j &lt; len; j++) &#123; char c1 = prev.charAt(j); char c2 = curr.charAt(j); if (c1 != c2) &#123; // 找到第一个不同的字母 graph.putIfAbsent(c1, new HashSet&lt;Character&gt;()); if (graph.get(c1).add(c2)) &#123; inDegree.put(c2, inDegree.get(c2) + 1); &#125; break; &#125; &#125; &#125; &#125;&#125; 271. encode-and-decode-strings 实现encode和decode函数，将字符串List和单一条字符串互相转换。 字符含有哪些？（所有ASCII字符都可能出现） 由于每个符号都有可能出现，所以不能想着用某个特殊符号来拼接和拆分。因此需要额外的信息进行标记，这里用的是在/之前加上所跟字符串的长度的方式，decode时每次从特定位置开始找/，然后取出它前面的长度信息直接截取后面的子字符串。1234567891011121314151617181920212223public class Codec &#123; // Encodes a list of strings to a single string. public String encode(List&lt;String&gt; strs) &#123; StringBuilder sb = new StringBuilder(); for (String str : strs) &#123; sb.append(str.length()).append("/").append(str); // 长度 + / + 字符串内容 &#125; return sb.toString(); &#125; // Decodes a single string to a list of strings. public List&lt;String&gt; decode(String s) &#123; List&lt;String&gt; ans = new ArrayList&lt;&gt;(); int i = 0; while (i &lt; s.length()) &#123; int index = s.indexOf("/", i); int len = Integer.valueOf(s.substring(i, index)); ans.add(s.substring(index + 1, index + 1 + len)); i = index + 1 + len; &#125; return ans; &#125;&#125; 2018.8.4 电面 给一个n，返回所有可能的factor组合。lc 254 x21234567891011121314151617181920212223public List&lt;List&lt;Integer&gt;&gt; getFactors(int n) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); if (n &lt; 4) &#123; return ans; &#125; getFactors(n, 2, new ArrayList&lt;Integer&gt;(), ans); return ans;&#125;private void getFactors(int n, int start, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; ans) &#123; if (n &lt;= 1) &#123; // 已经除尽了，说明没有更多factor if (path.size() &gt; 1) &#123; // 当前path就是一路走过来用过的factor ans.add(new ArrayList&lt;Integer&gt;(path)); &#125; return; &#125; for (int i = start; i &lt;= n; i++) &#123; if (n % i == 0) &#123; // 可以整除，说明i是n的一个factor path.add(i); // 将i加入path，将n除掉i，再递归从i开始继续往后找大于等于i的factor getFactors(n / i, i, path, ans); path.remove(path.size() - 1); &#125; &#125;&#125; 2018.9.14 Onsite 给一个连接关系{A - &gt; B; B - &gt; A,C; C - &gt; B; D - &gt; E; E -&gt; D}，group这些node并返回这些group：[(A,B,C), (D,E)]. 123456789101112131415161718192021222324252627282930313233public static List&lt;List&lt;Node&gt;&gt; getGroups(Map&lt;Node, List&lt;Node&gt;&gt; graph) &#123; if (graph == null) &#123; return null; &#125; Set&lt;Node&gt; nodeSet = new HashSet&lt;&gt;(); for (Node key : graph) &#123; nodeSet.add(key); for (Node neighbor : graph.get(key)) &#123; nodeSet.add(neighbor); &#125; &#125; List&lt;List&lt;Node&gt;&gt; ans = new ArrayList&lt;&gt;(); while (!nodeSet.isEmpty()) &#123; List&lt;Node&gt; group = new ArrayList&lt;&gt;(); Iterator&lt;Node&gt; it = nodeSet.iterator(); dfs(it.next(), graph, nodeSet, group); ans.add(group); &#125; return ans;&#125;private void dfs(Node curr, Map&lt;Node, List&lt;Node&gt;&gt; graph, Set&lt;Node&gt; nodeSet, List&lt;Node&gt; group) &#123; group.add(curr); nodeSet.remove(curr); // 移除表示已访问 List&lt;Node&gt; neighbors = graph.get(curr); if (neighbors == null) &#123; return; &#125; for (Node neighbor : neighbors) &#123; if (nodeSet.contains(neighbor)) &#123; dfs(neighbor, graph, nodeSet, group); &#125; &#125;&#125; 425. word-squares x2 给一个wordList，将List中的String放入matrix中使得行、列的单词都来自于这个List。 Trie + DFS，对于每个Trie节点，除了正常的nexts数组、isWord布尔值，额外维护一个List保存以「到达当前TrieNode路径」为prefix的所有word。固定一个word之后，下一个词的prefix可以通过纵向append得到，具体规律见这个discussion.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class Solution &#123; class TrieNode &#123; TrieNode[] nexts; List&lt;String&gt; prefixWords; boolean isWord; public TrieNode() &#123; nexts = new TrieNode[26]; prefixWords = new ArrayList&lt;&gt;(); isWord = false; &#125; &#125; class Trie &#123; TrieNode root; public Trie(String[] words) &#123; root = new TrieNode(); for (String word : words) &#123; TrieNode curr = root; for (int i = 0; i &lt; word.length(); i++) &#123; int index = word.charAt(i) - 'a'; if (curr.nexts[index] == null) &#123; curr.nexts[index] = new TrieNode(); &#125; curr.prefixWords.add(word); curr = curr.nexts[index]; &#125; curr.isWord = true; &#125; &#125; public List&lt;String&gt; getByPrefix(String prefix) &#123; List&lt;String&gt; ans = new ArrayList&lt;&gt;(); TrieNode curr = root; for (int i = 0; i &lt; prefix.length(); i++) &#123; int index = prefix.charAt(i) - 'a'; if (curr.nexts[index] == null) &#123; return ans; &#125; curr = curr.nexts[index]; &#125; ans.addAll(curr.prefixWords); return ans; &#125; &#125; private void dfs(int len, Trie trie, List&lt;List&lt;String&gt;&gt; ans, List&lt;String&gt; curr) &#123; if (curr.size() == len) &#123; ans.add(new ArrayList&lt;&gt;(curr)); return; &#125; int index = curr.size(); StringBuilder prefix = new StringBuilder(); for (String s : curr) &#123; prefix.append(s.charAt(index)); &#125; List&lt;String&gt; candidates = trie.getByPrefix(prefix.toString()); for (String candidate : candidates) &#123; curr.add(candidate); dfs(len, trie, ans, curr); curr.remove(curr.size() - 1); &#125; &#125; public List&lt;List&lt;String&gt;&gt; wordSquares(String[] words) &#123; List&lt;List&lt;String&gt;&gt; ans = new ArrayList&lt;&gt;(); if (words == null || words.length == 0) &#123; return ans; &#125; int len = words[0].length(); Trie root = new Trie(words); List&lt;String&gt; curr = new ArrayList&lt;&gt;(); for (String word : words) &#123; curr.add(word); dfs(len, root, ans, curr); curr.remove(curr.size() - 1); &#125; return ans; &#125;&#125; 2018.4 Onsiteindex sum 一个array自己跟自己的element可以组成一个pair，这个pair有个sum，求the kth sum分别对应的index。应该类似于lc 215 k-th element吧，只不过需要多存一个index作为返回。 方法一：PriorityQueue维护top K元素即可。 12345678910111213public int findKthLargest(int[] nums, int k) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; pq.offer(nums[i]); if (pq.size() &gt; k) &#123; pq.poll(); &#125; &#125; return pq.peek();&#125; 方法二：quickSelect，用快排的partition来找到元素。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public int findKthLargest(int[] nums, int k) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; shuffle(nums); int lo = 0, hi = nums.length - 1; k = nums.length - k; // 转换成第k小的 while (lo &lt; hi) &#123; int j = partition(nums, lo, hi); if (j == k) &#123; break; &#125; else if (j &lt; k) &#123; // 说明第k小的还在后面 lo = j + 1; &#125; else &#123; // 说明第k小的还在前面 hi = j - 1; &#125; &#125; return nums[k];&#125;private int partition(int[] nums, int lo, int hi) &#123; int i = lo, j = hi + 1; while (i &lt; j) &#123; while (nums[++i] &lt; nums[lo]) &#123; if (i == hi) &#123; break; &#125; &#125; while (nums[--j] &gt; nums[lo]) &#123; if (j == lo) &#123; break; &#125; &#125; if (i &gt;= j) &#123; break; &#125; swap(nums, i, j); &#125; swap(nums, lo, j); return j;&#125;public void shuffle(int[] arr) &#123; Random r = new Random(); for (int i = 0; i &lt; arr.length; i++) &#123; swap(arr, i, r.nextInt(i + 1)); &#125;&#125;private void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp;&#125; 463. island-perimeter x2 给一个0/1二维矩阵，求其中为1的island的周长。 方法一：BFS，每个1都先算它有四条边，然后根据邻接情况减掉不是边的即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public int islandPerimeter(int[][] grid) &#123; if (grid == null || grid.length == 0) &#123; return 0; &#125; boolean[][] visited = new boolean[grid.length][grid[0].length]; int perimeter = 0; for (int i = 0; i &lt; grid.length; i++) &#123; for (int j = 0; j &lt; grid[0].length; j++) &#123; if (grid[i][j] == 1 &amp;&amp; !visited[i][j]) &#123; perimeter += bfs(grid, i, j, visited); &#125; &#125; &#125; return perimeter; &#125; private int[][] dirs = new int[][] &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;; private int bfs(int[][] grid, int i, int j, boolean[][] visited) &#123; Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;(); q.add(new int[] &#123;i, j&#125;); visited[i][j] = true; int perimeter = 0; while (!q.isEmpty()) &#123; int[] curr = q.poll(); perimeter += 4; for (int[] dir : dirs) &#123; int row = curr[0] + dir[0], col = curr[1] + dir[1]; if (isIsland(grid, row, col)) &#123; perimeter--; if (!visited[row][col]) &#123; q.add(new int[] &#123;row, col&#125;); visited[row][col] = true; &#125; &#125; &#125; &#125; return perimeter; &#125; private boolean isIsland(int[][] grid, int i, int j) &#123; return i &gt;= 0 &amp;&amp; i &lt; grid.length &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; grid[0].length &amp;&amp; grid[i][j] == 1; &#125;&#125; 方法二：找规律。对于每一个1的cell，看它的下方和右方neighbor是不是1，记录neighbor数，最后周长就是islands 4 - neighbours 2。 1234567891011121314public int islandPerimeter(int[][] grid) &#123; int islands = 0, neighbours = 0; for (int i = 0; i &lt; grid.length; i++) &#123; for (int j = 0; j &lt; grid[i].length; j++) &#123; if (grid[i][j] == 1) &#123; islands++; // count islands if (i &lt; grid.length - 1 &amp;&amp; grid[i + 1][j] == 1) neighbours++; // count down neighbours if (j &lt; grid[i].length - 1 &amp;&amp; grid[i][j + 1] == 1) neighbours++; // count right neighbours &#125; &#125; &#125; return islands * 4 - neighbours * 2;&#125; 2018.9 Onsitepermutation系列 Permutations(无重复元素全排列) 1234567891011121314151617181920public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); backtrack(list, new ArrayList&lt;&gt;(), nums, new boolean[nums.length]); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int[] nums, boolean[] used) &#123; if (tempList.size() == nums.length) &#123; list.add(new ArrayList&lt;&gt;(tempList)); &#125; else &#123; for (int i = 0; i &lt; nums.length; i++) &#123; if (used[i]) continue; tempList.add(nums[i]); used[i] = true; backtrack(list, tempList, nums); used[i] = false; tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Permutations(有重复元素全排列) 123456789101112131415161718192021public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, new boolean[nums.length]); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int[] nums, boolean[] used) &#123; if (tempList.size() == nums.length) &#123; list.add(new ArrayList&lt;&gt;(tempList)); &#125; else &#123; for (int i = 0; i &lt; nums.length; i++) &#123; if (used[i] || i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]) continue; tempList.add(nums[i]); used[i] = true; backtrack(list, tempList, nums, used); used[i] = false; tempList.remove(tempList.size() - 1); &#125; &#125;&#125; 2016.8 onsiteLetter Combinations of a Phone Number with isWord() API 和lc 17 Letter Combinations of a Phone Number类似，但会多给一个isWord()的API，需要判断生成的word是否在dict中。123456789101112131415161718192021222324252627282930313233343536373839final char[][] num2Char = new char [][] &#123; &#123;&#125;, &#123;&#125;, &#123;'a', 'b', 'c'&#125;, &#123;'d', 'e', 'f'&#125;, &#123;'g', 'h', 'i'&#125;, &#123;'j', 'k', 'l'&#125;, &#123;'m', 'n', 'o'&#125;, &#123;'p', 'q', 'r', 's'&#125;, &#123;'t', 'u', 'v'&#125;, &#123;'w', 'x', 'y', 'z'&#125;&#125;;// 判断是否在给定的dict中// public boolean isWord(String word);public List&lt;String&gt; letterCombinations(String digits) &#123; List&lt;String&gt; ans = new ArrayList&lt;&gt;(); if (digits == null || digits.length() == 0 || digits.indexOf('1') &gt;= 0 || digits.indexOf('0') &gt;= 0) &#123; return ans; &#125; char[] str = digits.toCharArray(); dfs(str, 0, num2Char, new StringBuilder(), ans); return ans;&#125;private void dfs(char[] str, int index, final char[][] num2Char, StringBuilder sb, List&lt;String&gt; ans) &#123; if (index == str.length &amp;&amp; isWord(sb.toString())) &#123; ans.add(sb.toString()); return; &#125; int temp = str[index] - '0'; for (int i = 0; i &lt; num2Char[temp].length; i++) &#123; sb.append(num2Char[temp][i]); dfs(str, index + 1, num2Char, sb, ans); sb.deleteCharAt(sb.length() - 1); &#125;&#125; Duplicate Files in directory 给一个文件目录，设计一个方法能够找出该目录下（包括子目录）所有的duplicate files（文件内容一样但文件名不一定一样）， 先DFS把所有file找出来，然后用MD5哈希值作为Map的key、file的Set作为value，将相同key的Set中的文件两两比较，防止是不同文件因为collision而放到这里。 但如果目录中只有少量的重复文件也要全部扫一遍算MD5，这样很不划算。因此考虑利用文件大小来归类，然后只有文件大小相同的才有可能出现duplicate，但这样可能还是要计算很多个相同文件大小的MD5。 再考虑是不是可以不求整个文件的MD5，而是只取一部分来MD5求哈希作为key（例如前1k个bytes），然后对于size &gt; 1的组再根据[1k + 1, 2k]部分内容求MD5.这样如果只有少量的dulicate，通过这样拆分求key在前面几步就会把大量文件给排除了，后面求MD5的时候就少很多了。 走到0 可能类似于lc 457 ，但是不是找loop，也不要求移动方向一致，只是找是否存在arr[index] == 0。直接用Set存走过的index即可。或者也可以快慢指针，每次判断快指针是否指向了一个0即可，若快慢指针相遇都没有遇到0，说明不存在。12345678910111213141516171819202122public boolean hasZero(int[] nums, int start) &#123; if (nums == null || nums.length == 0 || start &lt; 0 || start &gt;= nums.length) &#123; return false; &#125; if (nums[start] == 0) &#123; // 防止一个元素的时候slow == fast进不去while-loop return true; &#125; int n = nums.length, slow = start, fast = getNextIndex(start, nums[start], n); while (slow != fast) &#123; if (nums[slow] == 0 || nums[fast] == 0) &#123; return true; &#125; slow = getNextIndex(slow, nums[slow], n); // 慢快指针分别移动一步两步 fast = getNextIndex(fast, nums[fast], n); fast = getNextIndex(fast, nums[fast], n); &#125; return false;&#125;private int getNextIndex(int index, int step, int len) &#123; int nextIndex = index + step; return nextIndex &gt;= 0 ? nextIndex % len : nextIndex % len + len; // java的%求的是余数而不是真正的modulo&#125; merge K sorted list 可以直接把元素通通存入PriorityQueue，然后从头取元素即可。或者用分治法递归来搞，1234567891011121314151617181920212223242526272829303132333435public ListNode mergeKLists(ListNode[] lists) &#123; if (lists == null || lists.length == 0) &#123; return null; &#125; // last two params are used for dividing into sub problems return mergeKLists(lists, 0, lists.length);&#125;private ListNode mergeKLists(ListNode[] lists, int start, int end) &#123; if (end - start == 1) &#123; // only one list return lists[start]; &#125; else if (end - start == 2) &#123; // merge two lists return mergeTwoLists(lists[start], lists[start + 1]); &#125; else &#123; int mid = start + (end - start) / 2; // cut into first and second halves return mergeTwoLists(mergeKLists(lists, start, mid), mergeKLists(lists, mid, end)); // warning not mid + 1 &#125;&#125;private ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) &#123; return l2; &#125; if (l2 == null) &#123; return l1; &#125; if (l1.val &lt;= l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125;&#125; 2018.4 Onsite x2battle ship游戏 lc有个算battleship个数的，直接O(NM)求第一次出现的ship坐标即可。但游戏应该是给一个坐标进行轰炸，如果反复调用O(NM)太慢了，可以考虑存坐标-船的map，这样就是O(1)了。 277. find-the-celebrity x2 给一个API函数判断i是否认识j，celebrity的定义是在n个人中，n-1个人都认识他、他却完全不认识他们。 naive方法是O(n^2)搞定，对于每个人，一旦他认识别人、或者别人不认识他就跳出循环。 12345678910111213141516171819202122/* The knows API is defined in the parent class Relation. boolean knows(int a, int b); */public class Solution extends Relation &#123; public int findCelebrity(int n) &#123; for (int i = 0; i &lt; n; i++) &#123; boolean found = true; for (int j = 0; j &lt; n; j++) &#123; if (j == i) &#123; continue; &#125; if (!knows(j, i) || knows(i, j)) &#123; // 看别人是否都认识i且i完全不认识别人 found = false; break; &#125; &#125; if (found) &#123; return i; &#125; &#125; return -1; &#125;&#125; 更巧妙的办法，从头开始一个pass，判断如果i认识j则把candidate设为j，如果i不认识j则j不可能是candidate；完了之后再一个pass看这个candidate是不是不认识所有人、且所有人都认识他。 12345678910public int findCelebrity(int n) &#123; int candidate = 0; // 先假设第一个人是名人 for (int i = 1; i &lt; n; i++) &#123; // 他认识别人就，把他排除掉了 if (knows(candidate, i)) candidate = i; &#125; for (int i = 0; i &lt; n; i++) &#123; // 确认他是否认识某个人或者某个人不认识他，那他也不是名人 if (i != candidate &amp;&amp; (knows(candidate, i) || !knows(i, candidate))) return -1; &#125; return candidate;&#125; 759. employee-free-time 给一个List of List，每一个子List存放每个employee的工作时间，求所有employee的共同空闲时间。没有则返回空List。 直接将List flatten，然后按照工作开始时间从小到大排序，再往后依次取工作时间，若当前开始时间比之前的结束时间长，说明出现了空闲时间；否则需要更新prev的end，保证prev的结束时间cover到所有结束时间，即取max。12345678910111213141516171819public List&lt;Interval&gt; employeeFreeTime(List&lt;List&lt;Interval&gt;&gt; schedule) &#123; List&lt;Interval&gt; ans = new ArrayList&lt;&gt;(); if (schedule == null || schedule.size() == 0) &#123; return ans; &#125; List&lt;Interval&gt; workingTimes = new ArrayList&lt;&gt;(); schedule.forEach(e -&gt; workingTimes.addAll(e)); Collections.sort(workingTimes, (a, b) -&gt; a.start - b.start); Interval prev = workingTimes.get(0); for (int i = 1; i &lt; workingTimes.size(); i++) &#123; if (workingTimes.get(i).start &gt; prev.end) &#123; ans.add(new Interval(prev.end, workingTimes.get(i).start)); prev = workingTimes.get(i); &#125; else &#123; prev.end = Math.max(prev.end, workingTimes.get(i).end); &#125; &#125; return ans;&#125; 求出现次数多于n/4的元素 169. majority-element是求n/2、229. majority-element-ii是求n/3。区别是这些给的都不是sorted array. 这题已经排序了，可以想到的是用两个相隔n/4的指针，若两端元素相等说明存在n/4 + 1个相同元素，这个就是其中一个答案了。 2018.5 Onisteblacklist of words scan 某个query里面存不存在blacklist里面的word。借此机会复习一下trie吧。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Trie &#123; class TrieNode &#123; boolean isWord; TrieNode[] next; public TrieNode() &#123; isWord = false; next = new TrieNode[26]; &#125; &#125; TrieNode root; public Trie() &#123; root = new TrieNode(); &#125; public void insert(String word) &#123; if (word == null || word.length() == 0) &#123; return; &#125; char[] wordChar = word.toCharArray(); TrieNode curr = root; for (int i = 0; i &lt; wordChar.length; i++) &#123; int index = wordChar[i] - 'a'; if (curr.next[index] == null) &#123; curr.next[index] = new TrieNode(); &#125; curr = curr.next[index]; &#125; curr.isWord = true; &#125; public boolean search(String word) &#123; if (word == null || word.length() == 0) &#123; return false; &#125; char[] wordChar = word.toCharArray(); TrieNode curr = root; for (int i = 0; i &lt; wordChar.length; i++) &#123; int index = wordChar[i] - 'a'; if (curr.next[index] == null) &#123; return false; &#125; curr = curr.next[index]; &#125; return curr.isWord; &#125; public boolean startsWith(String prefix) &#123; if (prefix == null || prefix.length() == 0) &#123; return false; &#125; char[] prefixChar = prefix.toCharArray(); TrieNode curr = root; for (int i = 0; i &lt; prefixChar.length; i++) &#123; int index = prefixChar[i] - 'a'; if (curr.next[index] == null) &#123; return false; &#125; curr = curr.next[index]; &#125; return true; &#125;&#125; 2018.3 Onsite x2Longest increasing path in the binary tree 具体题意不明，可能是从root到leaf的上升序列（类似lc 298），或者是可以转折的（类似lc 549）。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution &#123; // 从上到下的单向路径 private int max = 0; public int longestConsecutive(TreeNode root) &#123; helper(root); return max; &#125; private int helper(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; int len = 1; // 以当前节点结束，则长度为1 int left = helper(root.left), right = helper(root.right); if (root.left != null &amp;&amp; root.left.val == root.val + 1) &#123; len = left + 1; // 根据孩子节点val判断长度是否累加 &#125; if (root.right != null &amp;&amp; root.right.val == root.val + 1) &#123; len = Math.max(len, right + 1); // 取两个孩子长度的max &#125; max = Math.max(max, len); return len; &#125;&#125;class Solution &#123; // 允许转折的路径 int max = 0; public int longestConsecutive(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; helper(root); return max; &#125; private int[] helper(TreeNode root) &#123; if (root == null) &#123; return new int[] &#123;0, 0&#125;; &#125; int[] left = helper(root.left), right = helper(root.right); int inc = 1, dec = 1; if (root.left != null) &#123; if (root.left.val == root.val + 1) &#123; // 确认是否能和孩子形成升序/降序列 inc = left[0] + 1; &#125; if (root.left.val == root.val - 1) &#123; dec = left[1] + 1; &#125; &#125; if (root.right != null) &#123; if (root.right.val == root.val + 1) &#123; inc = Math.max(inc, right[0] + 1); // 取左右中最大的 &#125; if (root.right.val == root.val - 1) &#123; dec = Math.max(dec, right[1] + 1); &#125; &#125; max = Math.max(inc + dec - 1, max); return new int[] &#123;inc, dec&#125;; // 返回以当前节点为起点的上升、下降序列长度 &#125;&#125; 2018.6 Onsite 实现min stack，需要多一个popMin方法. 思路是在push的时候如果min发生了变化就把当前的min push进去，再更新min。这样在pop的时候就可以通过对比min和当前pop的元素知道是否需要更新min，若min已经被pop了，那么前一个再pop出来就是当前的min。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class MinStack &#123; private Stack&lt;Integer&gt; stack; private int min; /** initialize your data structure here. */ public MinStack() &#123; stack = new Stack&lt;Integer&gt;(); min = Integer.MAX_VALUE; &#125; public void push(int x) &#123; if (stack.isEmpty()) &#123; min = x; &#125; else &#123; if (x &lt;= min) &#123; stack.push(min); min = x; &#125; &#125; stack.push(x); &#125; public void pop() &#123; if (stack.isEmpty()) &#123; return; &#125; int temp = stack.pop(); if (temp == min &amp;&amp; !stack.isEmpty()) &#123; // means the min has gone min = stack.pop(); // need to update &#125; // return temp; &#125; public int top() &#123; if (stack.isEmpty()) &#123; return 0; &#125; return stack.peek(); &#125; public int getMin() &#123; if (stack.isEmpty()) &#123; return 0; &#125; return min; &#125; public int popMin() &#123; int temp = 0; while (!stack.isEmpty()) &#123; temp = stack.pop(); if (temp == min) &#123; if (!isEmpty()) &#123; min = stack.pop(); &#125; break; &#125; &#125; return temp; &#125;&#125; 2018.2 电面 给一个grid，里面有空地、墙和守卫，求离最近守卫距离最远的点的坐标集合。 从所有守卫开始BFS，最后一个level到达的点就是所求了。类似lc 286. 2018.3 Onsite31. next-permutation 给一个int数组，将它改造成按字典序的下一个排列，若不存在则直接按从小到大的顺序调整。要求In-place对原数组操作，不能申请额外空间。 从右往左找相邻的两个数使得nums[i - 1] &lt; nums[i]找到第一个升序对，然后再从右往左找首次出现的比nums[i]大的数nums[j]，二者对调，然后将nums[i + 1]及其之后的内容（一定是降序的）reverse一下即可。123456789101112131415161718192021222324252627282930public void nextPermutation(int[] nums) &#123; if (nums == null || nums.length &lt; 2) &#123; return; &#125; int i = nums.length - 1; for (; i &gt;= 1; i--) &#123; if (nums[i - 1] &lt; nums[i]) &#123; // 第一个升序对；后续一定是完美降序 int j = nums.length - 1; while (j &gt;= i) &#123; // 找第一个恰好大于nums[i - 1]的数 if (nums[j] &gt; nums[i - 1]) &#123; swap(nums, i - 1, j); break; &#125; j--; &#125; break; &#125; &#125; reverse(nums, i);&#125;private void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp;&#125;private void reverse(int[] nums, int start) &#123; for (int i = start, j = nums.length - 1; i &lt; j; i++, j--) &#123; swap(nums, i, j); &#125;&#125; 2018.7 Onsite133. clone-graph 给一个无向有环全联通图的其中一个节点，要求拷贝一个完整的无向有环图，并返回拷贝而成的对应的该节点。而且两个节点之间可以有多条通路。 直接用map + DFS搞，对于每一个节点直接new一个相同label的节点出来，然后遍历所有的邻居递归调用clone即可。12345678910111213141516private Map&lt;Integer, UndirectedGraphNode&gt; map = new HashMap&lt;&gt;();public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) &#123; return clone(node);&#125;public UndirectedGraphNode clone(UndirectedGraphNode node) &#123; if (node == null) return null; if (map.containsKey(node.label)) &#123; return map.get(node.label); &#125; UndirectedGraphNode cloned = new UndirectedGraphNode(node.label); map.put(clone.label, cloned); for (UndirectedGraphNode neighbor : node.neighbors) &#123; cloned.neighbors.add(clone(neighbor)); &#125; return cloned;&#125; 20. valid-parentheses 给一个字符串，判断其中三种括号(), [], {}是否匹配。用stack搞即可。 follow-up: 求最少删几个字符可以使原字符串合法。例如(([{))就是把中间两个删除即可。 思路应该类似301. remove-invalid-parentheses，也是一个图论BFS。从当前字符串开始出发，所有可达点就是「删除一个字符串所得的新字符串」，注意需要用Set防止重复。每次对相同level的字符串判断是否valid，一旦出现了valid，则当前level所有的valid的字符串就是「最少删除之后的valid字符串」。123456789101112131415161718192021222324252627282930313233343536373839404142434445public List&lt;String&gt; removeInvalidParentheses(String s) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); if (s == null) return res; Set&lt;String&gt; visited = new HashSet&lt;&gt;(); Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); queue.add(s); visited.add(s); boolean found = false; while (!queue.isEmpty()) &#123; curr = queue.poll(); if (isValid(curr)) &#123; res.add(curr); found = true; &#125; if (found) continue; // generate all possible states for (int i = 0; i &lt; curr.length(); i++) &#123; String neighbor = curr.substring(0, i) + curr.substring(i + 1); if (!visited.contains(neighbor)) &#123; queue.add(neighbor); visited.add(neighbor); &#125; &#125; &#125; return res;&#125;public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for (char c : s.toCharArray()) &#123; if (c == '(') stack.push(')'); else if (c == '&#123;') stack.push('&#125;'); else if (c == '[') stack.push(']'); else if (stack.isEmpty() || stack.pop() != c) return false; &#125; return stack.isEmpty();&#125; 2018.5 Onsite29. divide-two-integers 给两个数字，不使用乘、除、模运算前者除以后者之商，若结果越界则返回MAX_INT。 除了傻傻地一路减法减下去，还可以用位运算提速。提取出正负号之后统一按照正long数来处理。用sum来累计当前已经用了多少除数(dividend)，将next初始化为除数，在循环中找到恰好让sum + next &gt; longDividend的next，然后把next往回移一位就是当前这一波累计的除数总和了，加到sum即可。同时用一个count计数记录用了多少个除数，这就是所求的商了，也是累计即可。123456789101112131415161718192021222324252627282930public int divide(int dividend, int divisor) &#123; if ((dividend == Integer.MIN_VALUE &amp;&amp; divisor == -1) || divisor == 0) &#123; return Integer.MAX_VALUE; &#125; if (dividend == 0) &#123; return 0; &#125; // using XOR to adjust sign int sign = (dividend &lt; 0) ^ (divisor &lt; 0) ? -1 : 1; int ans = 0; long longDividend = Math.abs((long)dividend); long longDivisor = Math.abs((long)divisor); long sum = 0; while (sum &lt; longDividend) &#123; // warning use long abs value! int count = -1; long next = longDivisor; while (sum + next &lt;= longDividend) &#123; count++; next &lt;&lt;= 1; &#125; if (next == longDivisor) &#123; // 没有变化 break; &#125; sum += (next &gt;&gt; 1); // how much has accumulated ans += (1 &lt;&lt; count); // how many divisor used &#125; return sign * ans;&#125; 2018.5.21 电面 lc 34 binary search123456789101112131415161718192021222324252627282930313233343536373839public int[] searchRange(int[] nums, int target) &#123; if (nums == null || nums.length == 0) &#123; return new int [] &#123;-1, -1&#125;; &#125; int first = searchFirst(nums, target); if (first == -1) &#123; return new int [] &#123;-1, -1&#125;; &#125; int last = searchLast(nums, target); return new int[] &#123;first, last&#125;;&#125;private int searchFirst(int[] nums, int target) &#123; // hope to biase to the front // invariant relation: A[start] &lt; target &lt;= A[end] int start = -1, end = nums.length; while (end - start &gt; 1) &#123; int mid = start + (end - start) / 2; if (nums[mid] &gt;= target) &#123; // end need to be more aggresive end = mid; // shrink down &#125; else &#123; start = mid; // step up &#125; &#125; return end == nums.length || nums[end] != target? -1: end; // end will proceed at front&#125;private int searchLast(int[] nums, int target) &#123; // biase to the back // invariant relation: A[start] &lt;= target &lt; A[end] int start = -1, end = nums.length; while (end - start &gt; 1) &#123; int mid = start + (end - start) / 2; if (nums[mid] &gt; target) &#123; end = mid; // shrink down &#125; else &#123; // start need to be more aggressive start = mid; // step up &#125; &#125; return start;&#125; 2018.7.1 电面 x2 lc 72 edit distance 给两个字符串word1, word2，求使用addition, replacement, removement三种操作的情况下最少多少步可以从word1转换成word2。 dp[i][j]表示当前长度i的子字符串1转换成长度j的子字符串2最少需要的操作数。初始条件显然是dp[0][x] = dp[x][0] = x。对于任意一个dp[i][j]，需要由上、左上、左三个方格的计算结果决定，往上dp[i-1][j]表示一个deletion，往左dp[i][j-1]表示一个addition，左上dp[i-1][j-1]表示一个replacement。每次选取三者中最小的，加上1就是当前的最小操作数了。12345678910111213141516171819202122232425262728public int minDistance(String word1, String word2) &#123; if (word1 == null || word2 == null) &#123; return 0; &#125; int len1 = word1.length(), len2 = word2.length(); int[][] dp = new int [len1 + 1][len2 + 1]; for (int i = 0; i &lt;= len1; i++) &#123; for (int j = 0; j &lt;= len2; j++) &#123; if (i == 0) &#123; dp[i][j] = j; &#125; else if (j == 0) &#123; dp[i][j] = i; &#125; else &#123; // s1取i-1、s2取j-1个字符的情况，然后s1和s2都取，不需要增加操作数 if (word1.charAt(i - 1) == word2.charAt(j - 1)) &#123; dp[i][j] = dp[i - 1][j - 1]; &#125; else &#123; // left: s1取i、s2取j-1个字符的操作数，现在相当于需要往s1中加s2对应位置的字符才能匹配上 // up: s1取i-1、s2取j个字符的操作数，相当于要从s1中删除字符才能匹配上 // left-up: s1取i-1、s2取j-1个字符的操作数，现在相当于要进行替换才能匹配上 int left = dp[i][j - 1], up = dp[i - 1][j], upLeft = dp[i - 1][j - 1]; dp[i][j] = Math.min(Math.min(left, up), upLeft) + 1; &#125; &#125; &#125; &#125; return dp[len1][len2];&#125; 2018.2.13 电面 x3 给一堆time range，可能有重合。比如[1,3], [2,4], [5,6]。总共的uniq的时间，即merge之后的总时间长度。类似lc 56，但不需要维护所有的interval了，只需要保存prev，当后续interval没有overlap的时候就累加time range即可。 12345678910111213141516171819202122232425262728public int getTimeRange(List&lt;Interval&gt; intervals) &#123; if (intervals == null) &#123; return new ArrayList&lt;Interval&gt;(); &#125; Collections.sort(intervals, (a, b) -&gt; &#123; if (a.start != b.start) &#123; return a.start - b.start; &#125; else &#123; return a.end - b.end; &#125; &#125;); Interval prev = null; int range = 0; for (Interval itv : intervals) &#123; if (prev == null) &#123; prev = itv; &#125; else &#123; if (itv.start &gt; prev.end) &#123; range += (prev.end - prev.start); prev = itv; &#125; else &#123; prev.end = Math.max(prev.end, itv.end); &#125; &#125; &#125; range += (prev.end - prev.start); return range;&#125; follow-up: 最长的连续range（能合并的合并，最长的range）.直接在上面加个取长度即可。 follow-up2: 求出现次数最多的range。思路也是先排序，利用一个currCount统计当前的time range数，出现了重叠就将prev设置为overlap的部分并累加，当overlap结束就更新maxCount即可。1234567891011121314151617181920212223242526272829303132public static Interval getMaxInterval(List&lt;Interval&gt; intervals) &#123; if (intervals == null || intervals.size() == 0) &#123; return null; &#125; Collections.sort(intervals, (a, b) -&gt; &#123; if (a.start != b.start) &#123; return a.start - b.start; &#125; else &#123; return a.end - b.end; &#125; &#125;); int maxCount = 1, currCount = 1; Interval prev = null, ret = null; for (Interval itv : intervals) &#123; if (prev == null) &#123; prev = itv; currCount = 1; &#125; else &#123; if (itv.start &gt;= prev.end) &#123; prev = itv; currCount = 1; &#125; else &#123; prev = new Interval(itv.start, Math.min(prev.end, itv.end)); currCount += 1; if (currCount &gt; maxCount) &#123; ret = prev; &#125; &#125; &#125; &#125; return ret;&#125; 2017.11 电面 类似于lc 158，给一个API read4(char[] buf)，每次可以从某个file中读4个字符到buf，并返回实际读取的字符数。123456789101112131415161718192021222324252627282930313233public class Solution extends Reader4 &#123; /** * @param buf Destination buffer * @param n Maximum number of characters to read * @return The number of characters read */ private int N = 4, tempIndex = 0, lastLimit = 0; char[] temp = new char[N]; public int read(char[] buf, int n) &#123; if (n &lt; 1) &#123; return n; &#125; int index = 0; if (tempIndex == lastLimit) &#123; lastLimit = read4(temp); tempIndex = 0; &#125; while (lastLimit &gt; 0) &#123; while (n &gt; 0 &amp;&amp; tempIndex &lt; lastLimit &amp;&amp; index &lt; buf.length) &#123; buf[index++] = temp[tempIndex++]; n--; &#125; // 如果n读够了，直接返回 if (n == 0) &#123; return index; &#125; // 如果tempIndex到头了，可以继续读 lastLimit = read4(temp); tempIndex = 0; &#125; return index; &#125;&#125; 2015.10 电面785. is-graph-bipartite x3 给一个数组，每个index对应着该node的所有邻接点。问这个graph能否只用两个颜色给node上色使得相邻两个点的颜色都不一样。 方法一：DFS。对于每一个点都一波直接深度搜索上色，用一个数组存储上色状态，0表示未访问过，-1和1分别表示两个颜色，在dfs时对于当前的点若已经访问过就判断是否符合当前给定的颜色，若未访问则直接上色并DFS到它所有邻接点。需要注意可能有若干独立的cluster，因此不能一次DFS搜索就结束了，而是需要一个循环保证对所有未访问过的点都进行一次DFS。 1234567891011121314151617181920212223242526class Solution &#123; public boolean isBipartite(int[][] graph) &#123; if (graph == null || graph.length == 0) &#123; return true; &#125; int[] colors = new int[graph.length]; for (int i = 0; i &lt; graph.length; i++) &#123; if (colors[i] == 0 &amp;&amp; !checkColor(graph, colors, -1, i)) &#123; return false; &#125; &#125; return true; &#125; private boolean checkColor(int[][] graph, int[] colors, int currColor, int currNode) &#123; if (colors[currNode] != 0) &#123; return colors[currNode] == currColor; &#125; colors[currNode] = currColor; for (int neighbor : graph[currNode]) &#123; if (!checkColor(graph, colors, -currColor, neighbor)) &#123; return false; &#125; &#125; return true; &#125;&#125; 方法二：BFS，还是用queue存放所有邻接点然后逐一上色。 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public boolean isBipartite(int[][] graph) &#123; if (graph == null || graph.length == 0) &#123; return true; &#125; int[] colors = new int[graph.length]; for (int i = 0; i &lt; graph.length; i++) &#123; // 只check没有访问过的点，即各个独立的cluster if (colors[i] == 0 &amp;&amp; !checkColor(graph, colors, -1, i)) &#123; return false; &#125; &#125; return true; &#125; private boolean checkColor(int[][] graph, int[] colors, int currColor, int currNode) &#123; if (colors[currNode] != 0) &#123; return colors[currNode] == currColor; &#125; Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); int color = currColor; q.offer(currNode); while (!q.isEmpty()) &#123; int size = q.size(); while (size-- &gt; 0) &#123; int node = q.poll(); if (colors[node] != 0) &#123; if (colors[node] != color) return false; &#125; else &#123; colors[node] = color; &#125; for (int neighbor : graph[node]) &#123; if (colors[neighbor] == 0) q.offer(neighbor); // 避免回头路 &#125; &#125; color = -color; &#125; return true; &#125;&#125; 2017.10 电面720. longest-word-in-dictionary 给一个string数组，只含有小写字母，这些word可能形成链式如a, ap, app, appl, apple，求能形成链式的最长的单词，若有多个则取lexicographical最小的。 用sort + Set的方式比较trivial，排序后就可以逐个取word判断prefix是否在Set中。 想考的方法其实是Trie。根据所给的word构建Trie，每个节点直接存储word而不是boolean isWord，因为最后要求的是最长的String，直接存String方便返回。构建完Trie之后就从root开始找最长的连续的到达leaf的路径，要求路径上每一个word都长度更长（increasing）。12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123; class TrieNode &#123; TrieNode[] nexts = new TrieNode[26]; String word = ""; &#125; class Trie &#123; TrieNode root; public Trie() &#123; root = new TrieNode(); &#125; public void insert(String word) &#123; TrieNode curr = root; for (int i = 0; i &lt; word.length(); i++) &#123; char c = word.charAt(i); int index = c - 'a'; if (curr.nexts[index] == null) &#123; curr.nexts[index] = new TrieNode(); &#125; curr = curr.nexts[index]; &#125; curr.word = word; &#125; &#125; private String dfs(TrieNode node) &#123; String ret = node.word; for (TrieNode next : node.nexts) &#123; if (next != null &amp;&amp; next.word.length() &gt; 0) &#123; String childWord = dfs(next); if (childWord.length() &gt; ret.length()) &#123; ret = childWord; &#125; &#125; &#125; return ret; &#125; public String longestWord(String[] words) &#123; if (words == null || words.length == 0) &#123; return ""; &#125; Trie trie = new Trie(); for (String word : words) &#123; trie.insert(word); &#125; return dfs(trie.root); &#125;&#125; 2018.3 电面 将二叉树转换成双向链表。应该是类似lc 426的。426. convert-binary-search-tree-to-sorted-doubly-linked-list 给一个BST，将它转换成排好序的循环双向链表（头尾相接），返回头部。可以把左右孩子就看作是当前节点的前后链表节点，不需要额外搞ListNode类。 BST要维持顺序，那就是用中序遍历。利用全局变量prev来记录每一个子树的结尾节点，先build左子树，然后把当前节点拼到prev的后面，再去继续build右子树即可。 123456789101112131415161718192021222324private Node prev = null;public Node treeToDoublyList(Node root) &#123; if (root == null) &#123; return null; &#125; Node dummy = new Node(); // 伪头部的next就是head prev = dummy; buildDoublyList(root); prev.right = dummy.right; dummy.right.left = prev; dummy.left = dummy.right = null; // 清理dummy return prev.right;&#125;// 执行buildDoublyList后会将node下面的部分都形成双向链表public void buildDoublyList(Node node) &#123; if (node == null) &#123; return; &#125; buildDoublyList(node.left); // 先对左子树build一下，prev会指向最后一个节点 prev.right = node; // 将node拼进去 node.left = prev; prev = node; // 左半部分+当前节点的结尾就是node buildDoublyList(node.right);// 继续build右子树&#125; 方法二：分治法。先把左右子树的循环双向链表build好，再把当前节点塞到中间，同时把新的前后循环连接一下。注意在分别build的时候，需要把root本身设一个自循环，这样就可以重复使用connect方法了。 12345678910111213141516171819202122232425public Node treeToDoublyList(Node root) &#123; if (root == null) &#123; return null; &#125; Node leftHead = treeToDoublyList(root.left); Node rightHead = treeToDoublyList(root.right); root.left = root; root.right = root; return connect(connect(leftHead, root), rightHead);&#125;public Node connect(Node leftHead, Node rightHead) &#123; if (leftHead == null) &#123; return rightHead; &#125; if (rightHead == null) &#123; return leftHead; &#125; Node leftTail = leftHead.left; Node rightTail = rightHead.left; leftTail.right = rightHead; rightHead.left = leftTail; leftHead.left = rightTail; rightTail.right = leftHead; return leftHead;&#125; 2017.12 电面127. word-ladder 给一个List的String，然后一个初始String一个目标String，要求每次变动一个字母且变动后的词语来自该List的情况下，最短需要变几次得到目标String。 可以看作BFS问题，每个word就是一个node，neighbor就是换掉一个字母后且在wordList中存在的词。这样BFS最快到达dest的就是最短了。 12345678910111213141516171819202122232425262728293031323334353637383940public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; if (beginWord == null || endWord == null || beginWord.length() == 0 || endWord.length() == 0 || beginWord.length() != endWord.length() || wordList == null || wordList.size() == 0) &#123; return 0; &#125; Set&lt;String&gt; wordSet = new HashSet&lt;&gt;(wordList); Queue&lt;String&gt; toVisit = new LinkedList&lt;&gt;(); bfs(beginWord, wordSet, toVisit); int dist = 2; while (!toVisit.isEmpty()) &#123; int size = toVisit.size(); for (int i = 0; i &lt; size; i++) &#123; String curr = toVisit.poll(); if (curr.equals(endWord)) &#123; return dist; &#125; else &#123; bfs(curr, wordSet, toVisit); &#125; &#125; dist++; &#125; return 0;&#125;private void bfs(String beginWord, Set&lt;String&gt; wordSet, Queue&lt;String&gt; toVisit) &#123; wordSet.remove(beginWord); StringBuilder sb = new StringBuilder(beginWord); for (int i = 0; i &lt; sb.length(); i++) &#123; char origin = sb.charAt(i); for (int k = 0; k &lt; 26; k++) &#123; char c = (char)('a' + k); sb.setCharAt(i, c); String curr = sb.toString(); if (wordSet.contains(curr)) &#123; toVisit.add(curr); wordSet.remove(curr); &#125; &#125; sb.setCharAt(i, origin); &#125;&#125; follow-up：如何记录最短路径？其实就是126。还是用BFS找最短路径，维护一个distMap记录每个节点到达时所经过的步数，到达终点后再从头开始DFS，每次只去步数增长1的邻居点。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; List&lt;List&lt;String&gt;&gt; ans = new ArrayList&lt;&gt;(); if (beginWord == null || endWord == null || beginWord.length() == 0 || endWord.length() == 0 || beginWord.length() != endWord.length() || wordList == null || wordList.size() == 0) &#123; return ans; &#125; Map&lt;String, Integer&gt; distMap = new HashMap&lt;&gt;(); for (String word : wordList) &#123; distMap.put(word, Integer.MAX_VALUE); &#125; if (!distMap.containsKey(endWord)) &#123; return ans; &#125; distMap.put(beginWord, 0); Map&lt;String, Set&lt;String&gt;&gt; neighborMap = new HashMap&lt;&gt;(); Queue&lt;String&gt; toVisit = new LinkedList&lt;&gt;(); toVisit.offer(beginWord); boolean found = false; while (!toVisit.isEmpty() &amp;&amp; !found) &#123; int size = toVisit.size(); for (int i = 0; i &lt; size; i++) &#123; String currWord = toVisit.poll(); if (currWord.equals(endWord)) &#123; break; &#125; else &#123; bfs(currWord, distMap, neighborMap, toVisit); &#125; &#125; &#125; dfs(beginWord, endWord, distMap, neighborMap, ans, new ArrayList&lt;&gt;()); return ans;&#125;public void bfs(String fromWord, Map&lt;String, Integer&gt; distMap, Map&lt;String, Set&lt;String&gt;&gt; neighborMap, Queue&lt;String&gt; q) &#123; StringBuilder sb = new StringBuilder(fromWord); for (int i = 0; i &lt; sb.length(); i++) &#123; char origin = sb.charAt(i); for (int k = 0; k &lt; 26; k++) &#123; char c = (char)('a' + k); sb.setCharAt(i, c); String curr = sb.toString(); if (distMap.containsKey(curr) &amp;&amp; distMap.get(fromWord) + 1 &lt;= distMap.get(curr)) &#123; q.add(curr); distMap.put(curr, distMap.get(fromWord) + 1); neighborMap.putIfAbsent(fromWord, new HashSet&lt;&gt;()); neighborMap.get(fromWord).add(curr); &#125; &#125; sb.setCharAt(i, origin); &#125;&#125;public void dfs(String fromWord, String toWord, Map&lt;String, Integer&gt; distMap, Map&lt;String, Set&lt;String&gt;&gt; neighborMap, List&lt;List&lt;String&gt;&gt; ans, List&lt;String&gt; path) &#123; path.add(fromWord); if (fromWord.equals(toWord)) &#123; ans.add(new ArrayList&lt;&gt;(path)); path.remove(path.size() - 1); return; &#125; Set&lt;String&gt; neighbors = neighborMap.get(fromWord); if (neighbors != null) &#123; for (String neighbor : neighbors) &#123; if (distMap.get(neighbor) == distMap.get(fromWord) + 1) &#123; dfs(neighbor, toWord, distMap, neighborMap, ans, path); &#125; &#125; &#125; path.remove(path.size() - 1);&#125; 2017.10 电面 x4 pinterest页面例子，每个图片都等宽但不等高，给一堆pin的id、高度，求放置pin的策略，让每个col的pin都比较好看，即按顺序拼pin，每次选最短的column append到底部。例如输入pins = [{&#39;id&#39;:1, &#39;height&#39;: 100}, {&#39;id&#39;:2, &#39;height&#39;:300}, {&#39;id&#39;:3, &#39;height&#39;:150}.....]，以及col = 3。返回List of List[[1,.....],[2,...],[3,...]]，每一个List表示该column存放的图片的id。 如何保证每次都取最短的col去append？联想到了PriorityQueue，可以logK插入，每次都直接取到最短的进行append。时间复杂度O(NlogK)，其中K是col数量。 12345678910111213141516171819public static List&lt;List&lt;Integer&gt;&gt; getColumnPinIds(Map&lt;Integer, Integer&gt; heightMap, int colTotal) &#123; int[] colHeights = new int[colTotal]; PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;((i, j) -&gt; colHeights[i] != colHeights[j] ? colHeights[i] - colHeights[j] : i - j); for (int i = 0; i &lt; colTotal; i++) &#123; pq.offer(i); &#125; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; colTotal; i++) &#123; ans.add(new ArrayList&lt;&gt;()); &#125; for (int pinId : heightMap.keySet()) &#123; int colIndex = pq.poll(); colHeights[colIndex] += heightMap.get(pinId); ans.get(colIndex).add(pinId); pq.offer(colIndex); &#125; return ans;&#125; 如果不让用heap？那就直接O(NK)，每次都遍历k个col看看谁最小即可。 follow-up: resize一下窗口，如何快速rearrange这些pin？ 2017.10 电面 behavior tree. 给一对用户的action如 12345678user_id, timestamp, action100, 1000, A200, 1003, A300, 1009, B100, 1026, B100, 1030, C200, 1109, B200, 1503, A 如何从上面的log file构造成一个system log的graph如 12345|---A (2)| |---B (2)| | |---C (1)| | |---A (1)|---B (1) 这个和Trie很类似。可以考虑对于序列中每一个动作，维护一个TrieNode，其中包含action, count, 和后续操作节点nexts. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class LogParser &#123; static class TrieNode &#123; String action; int count; Map&lt;String, TrieNode&gt; nexts; public TrieNode() &#123; count = 0; nexts = new HashMap&lt;&gt;(); &#125; &#125; public static void insertActions(TrieNode root, List&lt;String&gt; actions) &#123; TrieNode curr = root; for (String action : actions) &#123; curr.nexts.putIfAbsent(action, new TrieNode()); curr.nexts.get(action).count++; curr = curr.nexts.get(action); &#125; &#125; static class Record &#123; int userId; int timestamp; String action; public Record(int userId, int timestamp, String action) &#123; this.userId = userId; this.timestamp = timestamp; this.action = action; &#125; &#125; public static TrieNode getGraph(String[] logs) &#123; Record[] records = new Record[logs.length]; for (int i = 0; i &lt; logs.length; i++) &#123; String[] splitted = logs[i].split(","); int userId = Integer.parseInt(splitted[0].trim()); int timestamp = Integer.parseInt(splitted[1].trim()); String action = splitted[2].trim(); records[i] = new Record(userId, timestamp, action); &#125; Arrays.sort(records, (a, b) -&gt; a.timestamp - b.timestamp); Map&lt;Integer, List&lt;String&gt;&gt; userActionMap = new HashMap&lt;&gt;(); for (Record record : records) &#123; userActionMap.putIfAbsent(record.userId, new ArrayList&lt;&gt;()); userActionMap.get(record.userId).add(record.action); &#125; TrieNode root = new TrieNode(); for (int userId : userActionMap.keySet()) &#123; insertActions(root, userActionMap.get(userId)); &#125; return root; &#125; public final static String PADDING_STRING = "| "; public final static String LEADING_STRING = "|---"; public static void printGraph(TrieNode node, StringBuilder sb) &#123; for (String nextAction : node.nexts.keySet()) &#123; System.out.print(sb); System.out.print(LEADING_STRING); System.out.print(nextAction); System.out.println("(" + node.nexts.get(nextAction).count + ")"); sb.append(PADDING_STRING); printGraph(node.nexts.get(nextAction), sb); sb.delete(sb.length() - PADDING_STRING.length(), sb.length()); &#125; &#125;&#125; 2018.3 OnsiteLC 146 LRU 说是设计Gmail界面，说是类似实现LRU。实现Cache就是用Map，但是least recent特性就需要额外的数据结构来提升效率：双向链表。Map中存放key - Node映射，所有的cache都放在一个双向链表上，每次get的时候就将get到的node挪到第一位。put时若capacity超了就将链表最后一个节点删除即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class LRUCache &#123; class Node &#123; int key; int val; Node prev; Node next; public Node(int key, int val) &#123; this.key = key; this.val = val; prev = null; next = null; &#125; &#125; Map&lt;Integer, Node&gt; map; Node fakeHead, fakeTail; int capacity; public LRUCache(int capacity) &#123; this.capacity = capacity; map = new HashMap&lt;&gt;(); fakeHead = new Node(-1, -1); fakeTail = new Node(-1, -1); fakeHead.next = fakeTail; fakeTail.prev = fakeHead; &#125; public int get(int key) &#123; if (map.containsKey(key)) &#123; Node ret = map.get(key); moveToFirst(ret); return ret.val; &#125; else &#123; return -1; &#125; &#125; public void put(int key, int value) &#123; if (capacity == 0) &#123; return; &#125; if (map.containsKey(key)) &#123; Node oldNode = map.get(key); oldNode.val = value; moveToFirst(oldNode); return; &#125; if (map.size() == capacity) &#123; map.remove(fakeTail.prev.key); remove(fakeTail.prev); &#125; Node newNode = new Node(key, value); insertToFirst(newNode); map.put(key, newNode); &#125; private void moveToFirst(Node node) &#123; remove(node); insertToFirst(node); &#125; private void insertToFirst(Node node) &#123; node.next = fakeHead.next; fakeHead.next = node; node.prev = fakeHead; node.next.prev = node; &#125; private void remove(Node node) &#123; if (node.prev == null) &#123; return; &#125; node.prev.next = node.next; node.next.prev = node.prev; &#125;&#125; 2018.1 Onsite437. path-sum-iii 给一个二叉树，给一个目标值sum，求有几条从上往下累加的路径之和等于sum。 除了O(N^2)的笨方法，考虑使用cache保存已有结果，这里用到的是prefixSum的思路。在深入下层节点的时候直接累计currSum，同时在cache中找是否存在若干段path是currSum - target，这样就可以把这些prefix从path中给去掉就可以得到target了。在深入更下层节点之前，需要更新currSum的计数，这样在更深层的时候就知道最新的currSum作为prefixSum的计数。1234567891011121314151617181920public int pathSum(TreeNode root, int sum) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); map.put(0, 1); dfs(root, 0, sum, map); return count;&#125;int count;private void dfs(TreeNode root, int currSum, int target, Map&lt;Integer, Integer&gt; map) &#123; if (root == null) &#123; return; &#125; currSum += root.val; count += map.getOrDefault(currSum - target, 0); map.put(currSum, map.getOrDefault(currSum, 0) + 1); dfs(root.left, currSum, target, map); dfs(root.right, currSum, target, map); map.put(currSum, map.get(currSum) - 1);&#125; 362. design-hit-counter 实现一个hitCount类，通过hit(timestamp)表示在什么时候出现了hit（可能同一时刻有多次hit），然后通过getHits得到最近300s内hit了多少次。 利用循环数组记录hits即可，容量可以直接设为300，这样最多就可以同时记录300s中每一秒的hit数量，在getHis的时候直接遍历一边如何保证每个bucket都是valid的count呢，就需要记录每一个bucket对应的hit的时刻是几时，因此需要另一个time数组来记录。12345678910111213141516171819202122232425262728293031323334class HitCounter &#123; private int[] hits; private int[] time; final private int TIMEWINDOW = 300; /** Initialize your data structure here. */ public HitCounter() &#123; hits = new int [TIMEWINDOW]; time = new int [TIMEWINDOW]; &#125; /** Record a hit. @param timestamp - The current timestamp (in seconds granularity). */ public void hit(int timestamp) &#123; int index = timestamp % TIMEWINDOW; if (time[index] != timestamp) &#123; time[index] = timestamp; hits[index] = 1; &#125; else &#123; hits[index]++; &#125; &#125; /** Return the number of hits in the past 5 minutes. @param timestamp - The current timestamp (in seconds granularity). */ public int getHits(int timestamp) &#123; int count = 0; for (int i = 0; i &lt; TIMEWINDOW; i++) &#123; if (timestamp - time[i] &lt; TIMEWINDOW) &#123; count += hits[i]; &#125; &#125; return count; &#125;&#125; 2017.12 Onsite392. is-subsequence 给两个字符串，判断其中一个字符串s是否是另一个字符串t的子序列串，这个字串不要求字符连续出现，只要求出现顺序一致且全部出现即可。 trivail的方法是直接两个指针扫，只有当s的字符和t匹配了才挪动s的指针。 如果t很大，而s是很多个小字符串需要连续调用这个函数呢？这就可以考虑使用记录索引+二分查找了。首先对t中每个字符记录出现的索引并存入List，这个是不会变的。然后对于输入s，每个字符都对该字符的List用二分查找找索引的「第一次出现/插入位置」，找到后就作为后一次搜索的索引。如果插入位置是在最后，说明t无法满足s的对应位置；12345678910111213141516171819202122232425262728293031323334public boolean isSubsequence(String s, String t) &#123; if (s == null || s.length() == 0) &#123; return true; &#125; List&lt;Integer&gt;[] indexCache = new List [26]; char[] tChar = t.toCharArray(); for (int i = 0; i &lt; tChar.length; i++) &#123; int index = tChar[i] - 'a'; if (indexCache[index] == null) &#123; indexCache[index] = new ArrayList&lt;Integer&gt;(); &#125; indexCache[index].add(i); &#125; char[] sChar = s.toCharArray(); int pos = 0; // 在t中出现的最小索引 for (int i = 0; i &lt; sChar.length; i++) &#123; int index = sChar[i] - 'a'; if (indexCache[index] == null) &#123; return false; &#125; int insertPos = Collections.binarySearch(indexCache[index], pos); if (insertPos &lt; 0) &#123; insertPos = -insertPos - 1; &#125; if (insertPos == indexCache[index].size()) &#123; return false; &#125; pos = indexCache[index].get(insertPos) + 1; // 下一步所需最小索引更新为已有索引的下一位 &#125; return true;&#125; 2018.5 电面67. add-binary 给两个String表示的二进制数，返回二者相加后的二进制字符串。 模拟加法，可以从两个数的最后一位开始加，最后reverse一下即可，注意最后需要确认首位是否需要加上carry。123456789101112131415161718192021222324252627public String addBinary(String a, String b) &#123; if (a == null || a.length() == 0) &#123; return b; &#125; else &#123; if (b == null || b.length() == 0) &#123; return a; &#125; &#125; StringBuilder sb = new StringBuilder(); char[] aChar = a.toCharArray(), bChar = b.toCharArray(); int i = aChar.length - 1, j = bChar.length - 1, carry = 0; while (i &gt;= 0 || j &gt;= 0) &#123; int sum = carry; // from prev result if (i &gt;= 0) &#123; sum += aChar[i--] - '0'; &#125; if (j &gt;= 0) &#123; sum += bChar[j--] - '0'; &#125; sb.append(sum % 2); // what's left after taking out carry carry = sum / 2; // 3,2 -&gt; 1; 1,0 -&gt; 0 &#125; if (carry != 0) &#123; sb.append(carry); // warning! the most significant position &#125; return sb.reverse().toString();&#125; 2017.11 Onsite14. longest-common-prefix 给一串字符串数组，求这些字符串开头的公共部分。 直接按照字典序排序，找首位和末尾的字符串比较看看有多少公共部分即可。12345678910111213141516public String longestCommonPrefix(String[] strs) &#123; if (strs == null || strs.length == 0) &#123; return ""; &#125; Arrays.sort(strs); String s1 = strs[0]; String s2 = strs[strs.length - 1]; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; s1.length(); i++) &#123; if (s1.charAt(i) != s2.charAt(i)) &#123; break; &#125; sb.append(s1.charAt(i)); &#125; return sb.toString();&#125; 2018.8 Onsite560. subarray-sum-equals-k 给一个int数组和一个k，问有多少连续的subarray之和等于k。这些int都在[-1000, 1000]，数组长度最多20000。 一开始想用双指针，但有正有负，更新条件不好搞。正解是使用Map，在计算sum的时候顺便看看之前是否出现过sum - k。这其实和path sum III 很像，都是利用prefix sum.12345678910111213141516public int subarraySum(int[] nums, int k) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); map.put(0, 1); int count = 0, sum = 0; for (int i = 0; i &lt; nums.length; i++) &#123; sum += nums[i]; if (map.containsKey(sum - k)) &#123; // 看之前是否已经出现了这一段prefix count += map.get(sum - k); // 这样sum - prefix就等于k了 &#125; map.put(sum, map.getOrDefault(sum, 0) + 1); &#125; return count;&#125; 2018.5 Onsite698. partition-to-k-equal-sum-subsets 给一个只含有(0, 10000)的int数组和一个k，判断是否可以将该数组划分为k个相等sum的partition。 似乎是个NP-hard的问题。只能用暴力办法，DFS+标记数组，每次累加过后进入下一层看看是否达到了targetSum，达到了就清空继续往后找新的一组subset.最后如果只剩下一组了，直接返回true，因为此时其他k - 1个组都已经达到targetSum了，当前的sum = k * targetSum - (k - 1) * targetSum = targetSum. 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public boolean canPartitionKSubsets(int[] nums, int k) &#123; if (nums == null || nums.length == 0 || k &gt; nums.length || k &lt; 1) &#123; return false; &#125; if (k == 1) &#123; return true; &#125; int sum = IntStream.of(nums).sum(); // Java8的stream! if (sum % k != 0) &#123; return false; &#125; int targetSum = sum / k; boolean[] visited = new boolean[nums.length]; return checkPartition(nums, visited, 0, targetSum, 0, k); &#125; public boolean checkPartition(int[] nums, boolean[] visited, int startIndex, int targetSum, int currSum, int k) &#123; if (k == 1) &#123; // 提前break return true; &#125; if (currSum == targetSum) &#123; return checkPartition(nums, visited, 0, targetSum, 0, k - 1); &#125; for (int i = startIndex; i &lt; nums.length; i++) &#123; if (!visited[i]) &#123; visited[i] = true; if (checkPartition(nums, visited, i + 1, targetSum, currSum + nums[i], k)) &#123; return true; &#125; visited[i] = false; &#125; &#125; return false; &#125;&#125; 方法二：更快的做法是先对数组排序，然后存k个bucket，每个bucket从后往前取元素不断累加. 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public boolean canPartitionKSubsets(int[] nums, int k) &#123; if (nums == null || nums.length == 0 || k &gt; nums.length || k &lt; 1) &#123; return false; &#125; if (k == 1) &#123; return true; &#125; int sum = IntStream.of(nums).sum(); // Java8的stream! if (sum % k != 0) &#123; return false; &#125; int targetSum = sum / k; Arrays.sort(nums); return checkPartition(nums, targetSum, new int[k], nums.length - 1); &#125; public boolean checkPartition(int[] nums, int targetSum, int[] buckets, int numsIndex) &#123; if (numsIndex &lt; 0) &#123; for (int bucket : buckets) &#123; if (bucket != targetSum) &#123; return false; &#125; &#125; return true; &#125; for (int i = 0; i &lt; buckets.length; i++) &#123; if (buckets[i] + nums[numsIndex] &lt;= targetSum) &#123; buckets[i] += nums[numsIndex]; if (checkPartition(nums, targetSum, buckets, numsIndex - 1)) &#123; return true; &#125; buckets[i] -= nums[numsIndex]; &#125; &#125; return false; &#125;&#125; follow-up: 如果去掉正数的限制，允许出现负数和0？ 上面的方法只考虑了直接累积叠加，无法解决负数问题。因此需要引入一个elementCount来统计当前这一波存入了多少element，当达到targetSum的时候需要判断当前这一波是否真的存入了元素。 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public boolean canPartitionKSubsets(int[] nums, int k) &#123; if (nums == null || nums.length == 0 || k &gt; nums.length || k &lt; 1) &#123; return false; &#125; if (k == 1) &#123; return true; &#125; int sum = IntStream.of(nums).sum(); if (sum % k != 0) &#123; return false; &#125; int targetSum = sum / k; boolean[] visited = new boolean[nums.length]; return checkPartition(nums, visited, 0, targetSum, 0, k, 0); &#125; public boolean checkPartition(int[] nums, boolean[] visited, int startIndex, int targetSum, int currSum, int k, int elementCount) &#123; if (k == 0) &#123; // 必须算完才行 return true; &#125; if (currSum == targetSum &amp;&amp; elementCount &gt; 0) &#123; return checkPartition(nums, visited, 0, targetSum, 0, k - 1, 0); &#125; for (int i = startIndex; i &lt; nums.length; i++) &#123; if (!visited[i]) &#123; visited[i] = true; if (checkPartition(nums, visited, i + 1, targetSum, currSum + nums[i], k, elementCount + 1)) &#123; return true; &#125; visited[i] = false; &#125; &#125; return false; &#125;&#125; follow-up: 如何记录路径？也就是在dfs的时候多用一个List记录存入的数字即可。 数组与query x2 给一个长度为N的数组，其中每一个数字都是8bit的正整数（0～255）。给一个二维数组M，类似于[[1,100],[5,1000],etc]，求所给range的mean。 naive方法是对于每一个query，都求一个sum / size，复杂度O(M*N)。可以用lc 303 rangeSum的思路，先求一波和，然后求sum的时候直接用两个位置的相减即可。 1234567891011121314151617181920public int[] getMeans(int[] nums, int[][] queries) &#123; if (nums == null || nums.length == 0 || queries == null || queries.length == 0) &#123; return null; &#125; int N = nums.length, M = queries.length; int[] sums = new int[N]; sums[0] = nums[0]; for (int i = 1; i &lt; N; i++) &#123; sums[i] = sums[i - 1] + nums[i]; &#125; double[] means = new double[M]; for (int i = 0; i &lt; M; i++) &#123; int start = quries[i][0]; int end = quries[i][1]; means[i] = (sum[end] - (start &gt; 0 ? sums[start - 1] : 0)) / (double)(end - start + 1); &#125;&#125; follow-up: 还是这些input，但query内容变为「求每个range的median」。median自然想到排序，而这个0～255的限制范围就容易想到木桶排序，然后根据个数就可以找到median了。在预处理的时候直接给每一个元素维护一个长度为256的bucket， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static public double[] getMedians(int[] nums, int[][] queries) &#123; if (nums == null || nums.length == 0 || queries == null || queries.length == 0) &#123; return null; &#125; int N = nums.length, M = queries.length; int[][] buckets = new int[N][256]; buckets[0][nums[0]]++; for (int i = 1; i &lt; N; i++) &#123; buckets[i] = Arrays.copyOf(buckets[i - 1], 256); buckets[i][nums[i]]++; &#125; double[] medians = new double[M]; for (int i = 0; i &lt; M; i++) &#123; int start = queries[i][0]; int end = queries[i][1]; int[] tempBucket = Arrays.copyOf(buckets[end], 256); if (start &gt; 0) &#123; for (int j = 0; j &lt; 256; j++) &#123; tempBucket[j] -= buckets[start - 1][j]; &#125; &#125; medians[i] = getMedian(tempBucket, (end - start) / 2, ((end - start + 1) &amp; 1) == 0); &#125; return medians;&#125;static private double getMedian(int[] bucket, int pos, boolean isEven) &#123; int i = 0, index = -1; while (i &lt; 256) &#123; index += bucket[i++]; if (index &gt;= pos) &#123; break; &#125; &#125; if (!isEven || index &gt; pos) &#123; return i - 1; &#125; int first = i - 1; while (i &lt; 256) &#123; index += bucket[i++]; if (index &gt; pos) &#123; return (first + i - 1) / 2.0; &#125; &#125; return first;&#125; 再follow-up: 当N特别大的时候，无法全部放入内存，如何在预处理的时候进行压缩。(给定一个压缩指标K, K&lt;&lt;N， 问怎么在预处理的时候进行压缩，同时效率还是O(M+N). 答案是每次隔K个进行存储，这样在查找的时候每次需要K次，但是K是常数，所以效率还是O(M+N).????) 2017.11 Onsite139. word-break 给一个List表示词典，给一个String，求能否把该String按照某种方式以空格分割，使得每个单词都来自于字典。 利用DP状态转换，若当前子字符串在dict中且子字符串之前的部分也符合要求，则当前这一段都true。 12345678910111213141516171819202122public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123; if (s == null || s.length() == 0 || wordDict == null || wordDict.size() == 0) &#123; return false; &#125; Set&lt;String&gt; set = new HashSet&lt;&gt;(); int maxLen = 0; for (String word : wordDict) &#123; maxLen = Math.max(word.length(), maxLen); set.add(word); &#125; boolean[] dp = new boolean[s.length() + 1]; dp[0] = true; for (int end = 1; end &lt;= s.length(); end++) &#123; for (int start = end - 1; end - start &lt;= maxLen &amp;&amp; start &gt;= 0; start--) &#123; if (set.contains(s.substring(start, end)) &amp;&amp; dp[start]) &#123; dp[end] = true; break; &#125; &#125; &#125; return dp[s.length()];&#125; follow-up: 如果wordDict很大怎么存？用Trie。用Trie也存不下呢？？？ theyearofdragon可以分成the year of dragon或者they ear of dragon，显然第一种分法好些，问怎么去判断分成不同语句哪种最好。？？？ column放pin Pinterest主页上有N个column，给一个set of pins，pins有score和length，每次把score最高的pin贴到最短的column上，return List&lt;List&lt;Pin&gt;&gt;表示每个column里的pins。 123456789101112131415161718192021222324252627282930313233static class Pin implements Comparable&lt;Pin&gt; &#123; double score; double height; public Pin(double score, double height) &#123; this.score = score; this.height = height; &#125; @Override public int compareTo(Pin that) &#123; return this.score == that.score ? (int)(this.height - that.height) : (int)(that.score - this.score); &#125;&#125;public static List&lt;List&lt;Pin&gt;&gt; getPinPos(List&lt;Pin&gt; pinList, int col) &#123; Collections.sort(pinList); List&lt;List&lt;Pin&gt;&gt; ret = new ArrayList&lt;&gt;(); double[] heights = new double[col]; PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;((i, j) -&gt; heights[i] != heights[j] ? (int)(heights[i] - heights[j]) : i - j); for (int i = 0; i &lt; col; i++) &#123; ret.add(new ArrayList&lt;&gt;()); pq.offer(i); &#125; for (Pin pin : pinList) &#123; int index = pq.poll(); heights[index] += pin.height; ret.get(index).add(pin); pq.offer(index); &#125; return ret;&#125; follow up: 用户的手机屏幕只有M长，如果屏幕的顶点距离主页顶点距离为K(???)，求出能显示出的pins。 Merge interval 给List of Interval，含有start, end, weight属性。如果两个interval overlap了，overlap部分的weight相加变成新的interval，返回merge之后的interval list。但是如果有多个overlap怎么办？比如[0,1], [0,4], [0,5], [3,6]这种，merge多次吗？ 2018.7 Onsite相似Set 输入一个data stream，比如：a -&gt; [b]; b -&gt; [a, d, f]; c -&gt; [b, j]; ...，表示这些元素是相似的，且相似具有传递性，最后输出所有相似的set。 可以考虑用并查集，每一个起始点作为root，其余点就是它的children。 123456789101112131415161718192021222324252627282930// TODOpublic static void printGroup(Map&lt;String, List&lt;String&gt;&gt; map) &#123; if (map == null || map.size() == 0) &#123; return; &#125; Map&lt;String, String&gt; parentMap = new HashMap&lt;&gt;(); Set&lt;String&gt; nodeSet = new HashSet&lt;&gt;(); for (String key : map.keySet()) &#123; map.putIfAbsent(key, key); nodeSet.add(key); String parent = findParent(key); List&lt;String&gt; equivalents = map.get(key); for (String equivalent : equivalent) &#123; nodeSet.add(equivalent); String currParent = findParent(equivalent); if (!currParent.equals(parent)) &#123; map.put(currParent, parent); &#125; &#125; &#125; // ....&#125;public static String findParent(String str, Map&lt;String, String&gt; parentMap) &#123; while (!parentMap.getOrDefault(str, str).equals(str)) &#123; String parent = parentMap.get(str); parentMap.put(str, parentMap.getOrDefault(parent, parent)); str = parent; &#125; return str;&#125; 或者直接建graph之后，找connected component来搞，似乎实现起来更不容易出错？ [2016.5 Onsite]124. binary-tree-maximum-path-sum 给一个二叉树，求其中的任意一条路径使得经过所有节点的值最大，不一定要经过root。12345678910111213141516class Solution &#123; private int max; // store the value of taking current root as swag point "^" public int maxPathSum(TreeNode root) &#123; max = Integer.MIN_VALUE; return Math.max(dfs(root), max); &#125; private int dfs(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; int left = Math.max(0, dfs(root.left)); int right = Math.max(0, dfs(root.right)); max = Math.max(max, left + right + root.val); // take both of the branches return root.val + Math.max(left, right); // means only take one of the branches &#125;&#125; meeting-rooms-ii变种 给一堆task的开始和结束时间和每个task所需的cpu数量，求完成所有task的最小cpu数。 先根据开始时间排序，然后往PriorityQueue中逐个加入task，若当前开始时间比队首的结束时间大，说明可以复用前面的cpu了，每次注意要更新cpu数量保证是最大值即可。123456789101112131415161718public int minCPU(Task[] tasks) &#123; if (tasks == null || tasks.length == 0) &#123; return 0; &#125; Arrays.sort(tasks, (a, b) -&gt; a.start - b.start); PriorityQueue&lt;Task&gt; pq = new PriorityQueue&lt;&gt;(); // 同时执行的task int max = 0, curr = 0; for (int i = 0; i &lt; tasks.length; i++) &#123; // 若当前task比最先结束的task晚开始，就可以用之前释放的cpu了 while (!pq.isEmpty() &amp;&amp; tasks[i].start &gt;= pq.peek().end) &#123; curr -= pq.poll().cpu; // 更新当前pq中所有任务所需cpu &#125; curr += tasks[i].cpu; max = Math.max(curr, max); pq.offer(tasks[i]); &#125; return max;&#125; 判断相同文件 给定两个函数，get_files(dir), get_dir(dir) 返回所有内容相同的file. 问怎么定义内容相同，用文件名还是binary， 小哥说要内容相同，那我就用recursion遍历所有file， 然后用hashing把文件的内容hash成key放在dictionary，最后返回这个dictionary。 follow up说， 如果hashing非常expensive怎么办? hashing前先check file size，如果文件大小一样，再用hashing判断是不是一样。 2nd follow up说get_files, get_dir如果expensive怎么办，答曰用parrallel programming （gpu or multi core） 可以优化。 2018.5 Onsiteread-n-characters-given-read4变种 给一堆有序号的无限block，给你一个读给定index的单个block的API，每个block 64MB，然后给你一个开始的byte位置(例如：3MB，就是从index = 0 开始)，和要读的byte长度(例如：67MB)，返回读的结果。就分情况，慢慢写，先是第一个block(可能，只是读部分)，然后中间连续读几个block(计算一下就好)，最后一个block可能只读部分。 感觉整体就是玩index。 见上面的word-ladder36. valid-sudoku 给一个二维char数组，里面是一个未完成的数独9x9棋盘，要求每一行、每一列、每个3x3方块中数字1-9有且仅有出现一次。判断这个棋盘是否符合数独规则，返回布尔值。123456789101112131415161718public boolean isValidSudoku(char[][] board) &#123; if (board == null || board.length == 0 || board[0].length == 0) &#123; return false; &#125; Set&lt;String&gt; set = new HashSet&lt;&gt;(); for (int i = 0; i &lt; board.length; i++) &#123; for (int j = 0; j &lt; board[0].length; j++) &#123; if (board[i][j] != '.') &#123; if (!set.add(board[i][j] + " in row " + i) || !set.add(board[i][j] + " in col " + j) || !set.add(board[i][j] + " in block " + (i / 3) + '-' + (j / 3))) &#123; return false; &#125; &#125; &#125; &#125; return true;&#125; 类似362. design-hit-counter详情母鸡 定义 eventOccur()，numEvent() 方法，有个sliding window size N。然后扩展，减少空间，Map，加一个功能，返回当前时间eventOccur() call次数最多的时间，要求 amortized O(1), 楼主一时想不到，最后只想到类似 LFU 的那种 2 map + DLL，1 个 map key 是 count，DLL 存 Cell(time, count)，一个就是整个cell。这个能保证O(logN), 面试官表示满意，方法不错，但是他后来是说，既然之前用了 queue 存所有 time + count，直接maintain 一个 max variable，每次 max variable 超过了 sliding window，则遍历 剩下的queue里的 count 就好，对于无限流，这个就是 amortized O(1), 但是楼主想不通，就举了个，每次 时间下 call evenOccur() 次数是递减的，那么就是每次都是O(n); 面试官表示是的，这个特殊的例子是O(n), generally 还是每 N 次才更新。 以下是卡拉特面经统计点击率 给一堆网址和点击率，求不同部分域名的点击率。如mobile.sports.yahoo.com就需要统计四个部分。lc 811 split之后搞就行了。123456789101112131415161718192021public List&lt;String&gt; subdomainVisits(String[] cpdomains) &#123; List&lt;String&gt; ans = new ArrayList&lt;&gt;(); if (cpdomains == null || cpdomains.length == 0) &#123; return ans; &#125; Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); for (String cpdomain : cpdomains) &#123; String[] data = cpdomain.split(" "); int count = Integer.parseInt(data[0]); int index = 0; while (index &gt;= 0) &#123; String key = data[1].substring(index == 0 ? index : index + 1); map.put(key, map.getOrDefault(key, 0) + count); index = data[1].indexOf(".", index + 1); &#125; &#125; for (String key : map.keySet()) &#123; ans.add(map.get(key) + " " + key); &#125; return ans;&#125; 求最长公共子数组 实现一个函数取两个数组作为input，求这两个数组的最长公共元素。123456789101112131415161718192021222324252627282930public static String[] longestCommonSubarray(String[] log1, String[] log2) &#123; if (log1 == null || log2 == null || log1.length == 0 || log2.length == 0) &#123; return null; &#125; int maxLen = 0, end = -1; int[][] dp = new int[log1.length + 1][log2.length + 1]; for (int i = 0; i &lt;= log1.length; i++) &#123; for (int j = 0; j &lt;= log2.length; j++) &#123; if (i == 0 || j == 0) &#123; dp[i][j] = 0; &#125; else &#123; if (log1[i - 1].equals(log2[j - 1])) &#123; dp[i][j] = 1 + dp[i - 1][j - 1]; if (dp[i][j] &gt; maxLen) &#123; maxLen = dp[i][j]; end = i; &#125; &#125; &#125; &#125; &#125; if (maxLen == 0) &#123; return new String[] &#123;"None"&#125;; &#125; String[] ret = new String[maxLen]; for (int i = 0; i &lt; ret.length; i++) &#123; ret[i] = log1[end - maxLen + i]; &#125; return ret;&#125; 矩阵中最长上升序列 给一个矩阵，求最长上升序列的长度。lc 329.123456789101112131415161718192021222324252627282930313233343536public static int longestIncreasingPath(int[][] matrix) &#123; if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123; return 0; &#125; int rowTotal = matrix.length, colTotal = matrix[0].length, len = 0; int[][] cache = new int[rowTotal][colTotal]; for (int i = 0; i &lt; rowTotal; i++) &#123; for (int j = 0; j &lt; colTotal; j++) &#123; len = Math.max(len, getLen(matrix, cache, i, j)); &#125; &#125; return len;&#125;private static int[][] dirs = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;;private static int getLen(int[][] matrix, int[][] cache, int i, int j) &#123; if (i &lt; 0 || i &gt; matrix.length || j &lt; 0 || j &gt; matrix[i].length) &#123; return 0; &#125; if (cache[i][j] &gt; 0) &#123; return cache[i][j]; &#125; int len = 1; for (int[] dir : dirs) &#123; int rowNext = i + dir[0]; int colNext = j + dir[1]; if (rowNext &lt; 0 || rowNext &gt;= matrix.length || colNext &lt; 0 || colNext &gt;= matrix[rowNext].length || matrix[rowNext][colNext] &lt;= matrix[i][j]) &#123; continue; &#125; int nextLen = getLen(matrix, cache, rowNext, colNext); len = Math.max(nextLen + 1, len); &#125; cache[i][j] = len; return len;&#125; 2018.9.20 电面 给一个String，只含有数字和加、减。实现eval返回算式的结果。 遇到符号就把前面的数字累加/减即可。 1234567891011121314151617public int calculate(String s) &#123; if (s == null || s.length() == 0) &#123; return 0; &#125; int val = 0, num = 0, sign = 1; for (char c : s.toCharArray()) &#123; if (Character.isDigit(c)) &#123; num = num * 10 + (int)(c - '0'); &#125; else if (c == '+' || c == '-') &#123; val = val + sign * num; num = 0; sign = c == '+' ? 1 : -1; &#125; &#125; val = val + sign * num; return val;&#125; follow-up: 除了上面这些，还含有括号。lc 224。利用Stack，遇到加减还是直接算个num出来，遇到左括号说明前面的计算告一段落，将前面的数字和符号都push进stack，遇到右括号时就说明当前括号以内的结果出来了，就从栈顶取数值和符号，合并出整体num之后再继续往后。 123456789101112131415161718192021222324252627282930public int calculate(String s) &#123; if (s == null || s.length() == 0) &#123; return 0; &#125; int val = 0, sign = 1; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for (int i = 0; i &lt; s.length(); i++) &#123; if (Character.isDigit(s.charAt(i))) &#123; int num = s.charAt(i) - '0'; while (i + 1 &lt; s.length() &amp;&amp; Character.isDigit(s.charAt(i + 1))) &#123; num = num * 10 + (int)(s.charAt(++i) - '0'); &#125; val += sign * num; &#125; else &#123; if (s.charAt(i) == '+') &#123; sign = 1; &#125; else if (s.charAt(i) == '-') &#123; sign = -1; &#125; else if (s.charAt(i) == '(') &#123; stack.push(val); stack.push(sign); val = 0; sign = 1; &#125; else if (s.charAt(i) == ')') &#123; val = stack.pop() * val + stack.pop(); &#125; &#125; &#125; return val;&#125; follow-up2: 如果再输入一个map包含一些exp: val对，但是算式中并不是所有的变量都能找到对应的val。可以考虑用replaceAll+正则表达式将输入字符串中的部分换成有效数字。然后还是用stack，只不过现在需要一个类来把数字、字符串、符号wrap起来。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public static String calculate(String s, Map&lt;String, Integer&gt; map) &#123; if (s == null || s.length() == 0) &#123; return null; &#125; for (String key : map.keySet()) &#123; String regStr = String.format("(?&lt;!\\w)%s(?!\\w)", key); s = s.replaceAll(regStr, Integer.toString(map.get(key))); &#125; System.out.println(s); Stack&lt;Part&gt; stack = new Stack&lt;&gt;(); Part curr = new Part(0, null, 1); for (int i = 0; i &lt; s.length(); i++) &#123; if (Character.isDigit(s.charAt(i))) &#123; int num = s.charAt(i) - '0'; while (i + 1 &lt; s.length() &amp;&amp; Character.isDigit(s.charAt(i + 1))) &#123; num = num * 10 + (int)(s.charAt(++i) - '0'); &#125; curr.num += curr.sign * num; &#125; else &#123; if (s.charAt(i) == '+') &#123; curr.sign = 1; &#125; else if (s.charAt(i) == '-') &#123; curr.sign = -1; &#125; else if (s.charAt(i) == '(') &#123; stack.push(curr); curr = new Part(0, null, 1); &#125; else if (s.charAt(i) == ')') &#123; Part prev = stack.pop(); curr.num = prev.sign * curr.num + prev.num; if (curr.var != null &amp;&amp; prev.sign &lt; 0) &#123; curr.var.setCharAt(0, curr.var.charAt(0) == '+' ? '-' : '+'); if (prev.var != null) &#123; curr.var.insert(0, prev.var); &#125; &#125; &#125; else if (s.charAt(i) == ' ') &#123; continue; &#125; else &#123; StringBuilder sb = new StringBuilder().append(s.charAt(i)); while (i + 1 &lt; s.length() &amp;&amp; s.charAt(i + 1) != ' ' &amp;&amp; s.charAt(i + 1) != '+' &amp;&amp; s.charAt(i + 1) != '-' &amp;&amp; s.charAt(i + 1) != '(' &amp;&amp; s.charAt(i + 1) != ')') &#123; sb.append(s.charAt(++i)); &#125; if (curr.sign &gt; 0) &#123; sb.insert(0, '+'); &#125; else &#123; sb.insert(0, '-'); &#125; if (curr.var != null) &#123; sb.insert(0, curr.var); &#125; curr.var = sb; &#125; &#125; &#125; return curr.toString();&#125; 2018.3.14电面 给一个二维String数组，每一行存放每个点赞记录url, user, timestamp。1.求每个网站的最早点赞记录。2.给一个user，求与他点赞过的url重复最多的用户。 第一问略。第二问，将数据存入user -&gt; set(url)，和url -&gt; set(user)，根据给定user找到他点赞过的url集合，然后对于里面的每个url找点赞过的用户集合，统计每个用户出现的次数即可。注意这个不是最省memory的方法，可以只维护url2User，同时把这个user访问过的url存入Set，这样就可以只遍历这个set了而不用额外维护每个user访问过那些网站。12345678910111213141516171819202122232425262728293031323334public static String getCommonUser(String[][] logs, String user) &#123; if (logs == null || logs.length == 0 || user == null) &#123; return null; &#125; Map&lt;String, Set&lt;String&gt;&gt; user2Url = new HashMap&lt;&gt;(); Map&lt;String, Set&lt;String&gt;&gt; url2User = new HashMap&lt;&gt;(); for (String[] log : logs) &#123; user2Url.putIfAbsent(log[0], new HashSet&lt;String&gt;()); user2Url.get(log[0]).add(log[1]); url2User.putIfAbsent(log[1], new HashSet&lt;String&gt;()); url2User.get(log[1]).add(log[0]); &#125; if (!user2Url.containsKey(user)) &#123; return null; &#125; Set&lt;String&gt; urls = user2Url.get(user); int max = 0; String ret = null; Map&lt;String, Integer&gt; overlapCount = new HashMap&lt;&gt;(); for (String url : urls) &#123; Set&lt;String&gt; users = url2User.get(url); for (String curr : users) &#123; if (curr.equals(user)) &#123; continue; &#125; overlapCount.put(curr, overlapCount.getOrDefault(curr, 0) + 1); if (overlapCount.get(curr) &gt; max) &#123; max = overlapCount.get(curr); ret = curr; &#125; &#125; &#125; return ret;&#125; 2018.9.15 电面 给一堆edges。1. 找nodes that have no parents, and nodes that have 1 parent； 2. 找graph中两个node有无common ancestor（直接相连的不算共同祖先）；3. 找furthest ancestor from node。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public static List&lt;Integer&gt; getIndependentNode(int[][] edges) &#123; if (edges == null) &#123; return null; &#125; Map&lt;Integer, Set&lt;Integer&gt;&gt; parentMap = getParentMap(edges); List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for (int key : parentMap.keySet()) &#123; if (parentMap.get(key).size() &lt;= 1) &#123; ans.add(key); &#125; &#125; return ans;&#125;public static boolean hasCommonAncestor(int[][] edges, int node1, int node2) &#123; Map&lt;Integer, Set&lt;Integer&gt;&gt; parentMap = getParentMap(edges); Set&lt;Integer&gt; ancestorSet = new HashSet&lt;&gt;(); Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); q.offer(node1); while (!q.isEmpty()) &#123; Set&lt;Integer&gt; parentSet = parentMap.get(q.poll()); for (int parent : parentSet) &#123; q.offer(parent); ancestorSet.add(parent); &#125; &#125; q.offer(node2); while (!q.isEmpty()) &#123; Set&lt;Integer&gt; parentSet = parentMap.get(q.poll()); for (int parent : parentSet) &#123; if (ancestorSet.contains(parent)) &#123; return true; &#125; q.offer(parent); &#125; &#125; return false;&#125;public static int getFurthestAncestor(int[][] edges, int node) &#123; int ret = -1; if (edges == null) &#123; return ret; &#125; Map&lt;Integer, Set&lt;Integer&gt;&gt; parentMap = getParentMap(edges); if (parentMap.get(node).isEmpty()) &#123; return ret; &#125; Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); q.offer(node); while (!q.isEmpty()) &#123; ret = q.peek(); int size = q.size(); while (size-- &gt; 0) &#123; Set&lt;Integer&gt; parentSet = parentMap.get(q.poll()); for (int parent : parentSet) &#123; q.offer(parent); &#125; &#125; &#125; return ret;&#125;private static Map&lt;Integer, Set&lt;Integer&gt;&gt; getParentMap(int[][] edges) &#123; if (edges == null) &#123; return null; &#125; Map&lt;Integer, Set&lt;Integer&gt;&gt; parentMap = new HashMap&lt;&gt;(); for (int[] edge : edges) &#123; parentMap.putIfAbsent(edge[0], new HashSet&lt;&gt;()); parentMap.putIfAbsent(edge[1], new HashSet&lt;&gt;()); parentMap.get(edge[1]).add(edge[0]); &#125; return parentMap;&#125;]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>algorithm</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[推特]]></title>
    <url>%2F2018%2F09%2F19%2Ftwitter%2F</url>
    <content type="text"><![CDATA[迎难而上，祝我好运。面朝大海，春暖花开。 OA 总共有n个节点，给两个List表示从first到second有一条undirected edge，再给一个values数组表示对应编号的node的值。然后给一堆query，找这些编号为root的子树中素数的节点count。注意编号为1的节点作为根。 直接把自己做的存下来了：利用1作为根这个条件用BFS构建多叉树，然后用递归count有多少个素数。为了避免重复计算，用了memo（一个用在判断prime，一个用在计数prime node）.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394static class TreeNode &#123; int id; int val; List&lt;TreeNode&gt; children; public TreeNode(int id, int val) &#123; this.id = id; this.val = val; children = new ArrayList&lt;&gt;(); &#125;&#125;// Complete the primeQuery function below.static List&lt;Integer&gt; primeQuery(int n, List&lt;Integer&gt; first, List&lt;Integer&gt; second, List&lt;Integer&gt; values, List&lt;Integer&gt; queries) &#123; if (first == null || second == null || first.size() != second.size() || values.size() != n) &#123; return null; &#125; Map&lt;Integer, Set&lt;Integer&gt;&gt; edgeMap = new HashMap&lt;&gt;(); // map from node-id to a set of its neighbors' id for (int i = 0; i &lt; first.size(); i++) &#123; edgeMap.putIfAbsent(first.get(i), new HashSet&lt;&gt;()); edgeMap.putIfAbsent(second.get(i), new HashSet&lt;&gt;()); edgeMap.get(first.get(i)).add(second.get(i)); // undirected: add the mapping relation to both sides edgeMap.get(second.get(i)).add(first.get(i)); &#125; Map&lt;Integer, TreeNode&gt; id2Node = new HashMap&lt;&gt;(); // map from id to actual TreeNode object TreeNode root = constructTree(edgeMap, values, id2Node); List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); Map&lt;Integer, Integer&gt; countCache = new HashMap&lt;&gt;(); Map&lt;Integer, Boolean&gt; primeCache = new HashMap&lt;&gt;(); for (int query : queries) &#123; ans.add(getPrimeCount(id2Node.get(query), countCache, primeCache)); &#125; return ans;&#125;// use BFS to constrct treestatic TreeNode constructTree(Map&lt;Integer, Set&lt;Integer&gt;&gt; edgeMap, List&lt;Integer&gt; values, Map&lt;Integer, TreeNode&gt; id2Node) &#123; Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); TreeNode root = new TreeNode(1, values.get(0)); // start from root with id 1 id2Node.put(1, root); q.add(root); while (!q.isEmpty()) &#123; TreeNode curr = q.poll(); Set&lt;Integer&gt; childIds = edgeMap.get(curr.id); // get all its neighbors' id if (childIds == null) &#123; continue; &#125; for (int childId : childIds) &#123; TreeNode child = new TreeNode(childId, values.get(childId - 1)); id2Node.put(childId, child); // from id to node q.offer(child); curr.children.add(child); // add neighbor node into curr node's children list edgeMap.get(childId).remove(curr.id); // remove curr's id from the neighbor's "neighbor set" &#125; edgeMap.remove(curr.id); // finish process curr node, remove it from edgeMap &#125; return root;&#125;// given a TreeNode, return the count of nodes with prime valuestatic int getPrimeCount(TreeNode node, Map&lt;Integer, Integer&gt; countCache, Map&lt;Integer, Boolean&gt; primeCache) &#123; if (node == null) &#123; return 0; &#125; if (countCache.containsKey(node.id)) &#123; // hit in cache, simply return return countCache.get(node.id); &#125; int count = isPrime(node.val, primeCache) ? 1 : 0; for (TreeNode child : node.children) &#123; // get prime count at each child count += getPrimeCount(child, countCache, primeCache); &#125; countCache.put(node.id, count); // put into cache return count;&#125;static boolean isPrime(int val, Map&lt;Integer, Boolean&gt; primeCache) &#123; if (primeCache.containsKey(val)) &#123; // hit in cache, simply return return primeCache.get(val); &#125; if (val &lt;= 1) &#123; primeCache.put(val, false); return false; &#125; int limit = (int) Math.sqrt(val); for (int i = 2; i &lt;= limit; i++) &#123; if (val % i == 0) &#123; primeCache.put(val, false); return false; &#125; &#125; primeCache.put(val, true); return true;&#125;]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>algorithm</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[易贝]]></title>
    <url>%2F2018%2F09%2F11%2Febay%2F</url>
    <content type="text"><![CDATA[迎难而上，祝我好运。面朝大海，春暖花开。 k way merge LC23。给K个排好序的链表头节点数组，将他们merge到一个list中。 方法一：利用PriorityQueue存储，先一波流将所有链表头加入pq，然后每次poll掉最小的同时将它后续的节点也放进pq中。pq的offer, poll, remove复杂度都是log(N)，因此在这里维护规模为K的就需要log(K)，而总共有KN个节点，时间复杂度是O(KNlogK)。 1234567891011121314151617181920public ListNode mergeKLists(ListNode[] lists) &#123; if (lists == null || lists.length == 0) &#123; return null; &#125; PriorityQueue&lt;ListNode&gt; pq = new PriorityQueue&lt;&gt;((a, b) -&gt; &#123; return a.val - b.val; &#125;); for (ListNode l: lists) &#123; if (l != null) pq.add(l); &#125; ListNode fakeHead = new ListNode(0), curr = fakeHead; while (!pq.isEmpty()) &#123; curr.next = pq.poll(); curr = curr.next; if (curr.next != null) pq.add(curr.next); &#125; return fakeHead.next;&#125; 方法二：递归+分治法，归结为merge两个List的问题。时间复杂度是O(KNlogK)，因为一开始K个数组，需要遍历每个元素合并之后形成K/2个数组，以此类推，每次需要遍历需要O(KN)，总共有logK次，因此是O(KNlogK)。 123456789101112131415161718192021222324252627282930313233343536// divide and conquerpublic ListNode mergeKLists(ListNode[] lists) &#123; if (lists == null || lists.length == 0) &#123; return null; &#125; // last two params are used to divide into sub problems return mergeKLists(lists, 0, lists.length);&#125;private ListNode mergeKLists(ListNode[] lists, int start, int end) &#123; if (end - start == 1) &#123; // only one list return lists[start]; &#125; else if (end - start == 2) &#123; // merge two lists return mergeTwoLists(lists[start], lists[start + 1]); &#125; else &#123; int mid = start + (end - start) / 2; // cut into first and second halves return mergeTwoLists(mergeKLists(lists, start, mid), mergeKLists(lists, mid, end)); // warning not mid + 1 &#125;&#125;private ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) &#123; return l2; &#125; if (l2 == null) &#123; return l1; &#125; if (l1.val &lt;= l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125;&#125; longest common substring 给两个String，求最长的连续的共同的子串。例如s1 = 12358和s2 = 1242358，最长的子序列就是2358. DP.用二维int数组维护dp[i][j]表示s1以i结尾处、s2以j结尾处的substring情况。当s1.charAt(i) == s2.charAt(j)时，就更新为dp[i - 1][j - 1] + 1。1234567891011121314151617181920public static String maxCommonSubstring(String s1, String s2) &#123; if (s1 == null || s1.length() == 0 || s2 == null || s2.length() == 0) &#123; return ""; &#125; int len1 = s1.length(), len2 = s2.length(); int[][] dp = new int[len1][len2]; int maxLen = 0, index = -1; for (int i = 0; i &lt; len1; i++) &#123; for (int j = 0; j &lt; len2; j++) &#123; if (s1.charAt(i) == s2.charAt(j)) &#123; dp[i][j] = i &gt; 0 &amp;&amp; j &gt; 0 ? dp[i - 1][j - 1] + 1 : 1; if (maxLen &lt; dp[i][j]) &#123; maxLen = dp[i][j]; index = i; &#125; &#125; &#125; &#125; return index &lt; 0 ? "" : s1.substring(index + 1 - maxLen, index + 1);&#125; reverse word in string 给一个字符串和一个分隔符，将每个单词翻转，同时大小写翻转。注意这个Zillow的那个翻转字符串不一样。skip. decimal to hex 将一个十进制数转换成十六进制。1234567891011121314final private char[] map = &#123;'0', '1', '2', '3','4','5','6','7','8','9','a','b','c','d','e','f'&#125;;public String toHex(int num) &#123; if (num == 0) &#123; return "0"; &#125; long longNum = num &amp; 0x00000000ffffffffL; // 不能直接强制转换，不然会保留符号 String hexStr = ""; while (longNum != 0) &#123; // System.out.println(); hexStr = map[(int)(longNum % 16)] + hexStr; longNum /= 16; &#125; return hexStr;&#125; 最大正方形 类似LC 221，给一个0/1 grid，求其中最大的正方形面积。 DP。当前位置为1，则需要看看左、左上、上三个方向的最小值+1作为边长，最后返回最大的即可。1234567891011121314151617181920212223public int maximalSquare(char[][] matrix) &#123; if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123; return 0; &#125; int rowTotal = matrix.length, colTotal = matrix[0].length; int max = 0; int[][] dp = new int[rowTotal][colTotal]; for (int i = 0; i &lt; rowTotal; i++) &#123; for (int j = 0; j &lt; colTotal; j++) &#123; if (matrix[i][j] == '1') &#123; dp[i][j] = getMin(dp, i, j) + 1; max = Math.max(max, dp[i][j]); &#125; &#125; &#125; return max * max;&#125;private int getMin(int[][] dp, int i, int j) &#123; int up = i &gt; 0 ? dp[i - 1][j] : 0; int left = j &gt; 0 ? dp[i][j - 1] : 0; int upLeft = i &gt; 0 &amp;&amp; j &gt; 0 ? dp[i - 1][j - 1] : 0; return Math.min(Math.min(up, left), upLeft);&#125; 第N个BLAH数 如果一个数字可以被5，7，11整除 那么这个数称之为BLAH数 (5,7,10,11,14,15…). 求第n个BLAH数。 用三个变量存下一个5、7、11整除的blah数，从1到n每次取最小的，并更新到下一个。注意出现重复的时候就需要跳到下一个。 移动0到数组末尾 给一个数组，将所有的0移动到数组末尾，其余数组需要维持相对次序。 先走一波循环讲非0的项往前覆盖，走完之后剩余的数直接覆盖为0即可。123456789public void moveZeroes(int[] nums) &#123; int k = 0; for (int i = 0; i &lt; nums.length; ++i)&#123; if (nums[i] != 0) nums[k++] = nums[i]; &#125; for(; k &lt; nums.length; ++k)&#123; nums[k] = 0; &#125;&#125; 反转链表 给一个链表头，反转之。LC 206 方法一：Iterative就直接前后两个节点直接把next指向对调一下就好了。 方法二：Recursive就先将当前节点后面的节点都reverse一波，当前节点的next原本指的是后续第一个节点、现在就变成了后续最末尾的节点，那么调整一下next指向即可。123456789public ListNode reverseList(ListNode head) &#123; if (head == null || head.next == null) &#123; return head; &#125; ListNode newHead = reverseList(head.next); head.next.next = head; head.next = null; return newHead;&#125; 找第一次、最后一次出现位置 LC 34给一个有序数组，给一个target，找第一个和最后一个出现的位置。复习一波二分查找了。1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; if (nums == null || nums.length == 0) &#123; return new int [] &#123;-1, -1&#125;; &#125; int first = searchFirst(nums, target); if (first == -1) &#123; return new int [] &#123;-1, -1&#125;; &#125; int last = searchLast(nums, target); return new int[] &#123;first, last&#125;; &#125; private int searchFirst(int[] nums, int target) &#123; // hope to biase to the front // invariant relation: A[start] &lt; target &lt;= A[end] int start = -1, end = nums.length; while (end - start &gt; 1) &#123; int mid = start + (end - start) / 2; if (nums[mid] &gt;= target) &#123; // end need to be more aggresive end = mid; // shrink down &#125; else &#123; start = mid; // step up &#125; &#125; return end == nums.length || nums[end] != target? -1: end; // end will proceed at front &#125; private int searchLast(int[] nums, int target) &#123; // biase to the back // invariant relation: A[start] &lt;= target &lt; A[end] int start = -1, end = nums.length; while (end - start &gt; 1) &#123; int mid = start + (end - start) / 2; if (nums[mid] &gt; target) &#123; end = mid; // shrink down &#125; else &#123; // start need to be more aggressive start = mid; // step up &#125; &#125; return start; &#125;&#125; 二维矩阵二分查找 LC 240。矩阵中每一行、每一列都是有序的，给一个target，判断是否存在。 方法一：仍然是二分查找的思想，取行和列的中间元素，若target小了则需要到左侧细长竖矩形和上方的肥扁矩形查找，否则是到右侧的细长竖矩形和下方的肥扁矩形中查找。 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public boolean searchMatrix(int[][] matrix, int target) &#123; if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123; return false; &#125; return binarySearch(matrix, target, -1, -1, matrix.length, matrix[0].length); &#125; private boolean binarySearch(int[][] matrix, int target, int lowRow, int lowCol, int hiRow, int hiCol) &#123; if (hiCol - lowCol &lt;= 2 || hiRow - lowRow &lt;= 2) &#123; return false; &#125; int midCol = lowCol + (hiCol - lowCol) / 2; int midRow = lowRow + (hiRow - lowRow) / 2; if (target == matrix[midRow][midCol]) &#123; return true; &#125; if (target &lt; matrix[midRow][midCol]) &#123; if (binarySearch(matrix, target, lowRow, lowCol, midRow + 1, hiCol)) &#123; // (lowRow, lowCol) to (midRow + 1, hiCol), exclusive return true; &#125; else if (binarySearch(matrix, target, lowRow, lowCol, hiRow, midCol)) &#123; // (lowRow, lowCol) to (hiRow, midCol) return true; &#125; else &#123; return false; &#125; &#125; else &#123; if (binarySearch(matrix, target, midRow - 1, lowCol, hiRow, hiCol)) &#123; // (midRow - 1, lowCol) to (hiRow, hiCol), exclusive return true; &#125; else if (binarySearch(matrix, target, lowRow, midCol, hiRow, hiCol)) &#123; // (lowRow, lowCol) to (hiRow, midCol) return true; &#125; else &#123; return false; &#125; &#125; &#125;&#125; 方法二：直接扫，首先从右上角开始，如果小了说明当前这一行都不可能了，如果大了说明当前这列都不可能了，因此每次都会排除掉一整行/一整列，时间复杂度是O(M + N)，相当于线性查找。 1234567891011121314151617public boolean searchMatrix(int[][] matrix, int target) &#123; if (matrix == null || matrix.length ==0 || matrix[0].length == 0) &#123; return false; &#125; int col = matrix[0].length - 1; int row = 0; while (col &gt;= 0 &amp;&amp; row &lt;= matrix.length - 1) &#123; if (target == matrix[row][col]) &#123; return true; &#125; else if (target &lt; matrix[row][col]) &#123; col--; &#125; else if (target &gt; matrix[row][col]) &#123; row++; &#125; &#125; return false;&#125; 实现LRU LC 146. 实现Cache就是用Map，但是least recent特性就需要额外的数据结构来提升效率：双向链表。Map中存放key - Node映射，所有的cache都放在一个双向链表上，每次get的时候就将get到的node挪到第一位。put时若capacity超了就将链表最后一个节点删除即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class LRUCache &#123; class Node &#123; int key; int val; Node prev; Node next; public Node(int key, int val) &#123; this.key = key; this.val = val; prev = null; next = null; &#125; &#125; Map&lt;Integer, Node&gt; map; Node fakeHead, fakeTail; int capacity; public LRUCache(int capacity) &#123; this.capacity = capacity; map = new HashMap&lt;&gt;(); fakeHead = new Node(-1, -1); fakeTail = new Node(-1, -1); fakeHead.next = fakeTail; fakeTail.prev = fakeHead; &#125; public int get(int key) &#123; if (map.containsKey(key)) &#123; Node ret = map.get(key); moveToFirst(ret); return ret.val; &#125; else &#123; return -1; &#125; &#125; public void put(int key, int value) &#123; if (capacity == 0) &#123; return; &#125; if (map.containsKey(key)) &#123; Node oldNode = map.get(key); oldNode.val = value; moveToFirst(oldNode); return; &#125; if (map.size() == capacity) &#123; map.remove(fakeTail.prev.key); remove(fakeTail.prev); &#125; Node newNode = new Node(key, value); insertToFirst(newNode); map.put(key, newNode); &#125; private void moveToFirst(Node node) &#123; remove(node); insertToFirst(node); &#125; private void insertToFirst(Node node) &#123; node.next = fakeHead.next; fakeHead.next = node; node.prev = fakeHead; node.next.prev = node; &#125; private void remove(Node node) &#123; if (node.prev == null) &#123; return; &#125; node.prev.next = node.next; node.next.prev = node.prev; &#125;&#125; 2018.3.23 Onsite15. 3Sum 给一个int数组，列出三个数使得它们的和为0. 先排序，然后固定当前数，设置target为0 - curr，然后用双指针在后方找，当left + right == target就是一组数了。1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); if (nums == null || nums.length == 0) &#123; return ans; &#125; Arrays.sort(nums); // sort from least to largest for (int i = 0; i &lt; nums.length; i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; // fix nums[i] and let two pointers get target's indices int left = i + 1, right = nums.length - 1, target = 0 - nums[i]; while (left &lt; right) &#123; int sum = nums[left] + nums[right]; if (sum == target) &#123; List&lt;Integer&gt; currList = new ArrayList&lt;&gt;(); currList.add(nums[i]); currList.add(nums[left]); currList.add(nums[right]); ans.add(currList); do &#123; left++; // for duplicate &#125; while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]); do &#123; right--; &#125; while (right &gt; left &amp;&amp; nums[right] == nums[right + 1]); &#125; else if (sum &lt; target) &#123; left++; &#125; else &#123; right--; &#125; &#125; &#125; return ans; &#125;&#125; 216. combination sum 在1～9中选k个数之和等于n，求所有可能的组合。DFS/backtracking搞定。123456789101112131415161718class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); dfs(k, n, 1, ans, new ArrayList&lt;&gt;()); return ans; &#125; private void dfs(int k, int n, int start, List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; curr) &#123; if (n == 0 &amp;&amp; curr.size() == k) &#123; ans.add(new ArrayList&lt;Integer&gt;(curr)); return; &#125; for (int i = start; i &lt;= 9; i++) &#123; curr.add(i); dfs(k, n - i, i + 1, ans, curr); curr.remove(curr.size() - 1); &#125; &#125;&#125; 535. tinyURL 实现长URL和短URL的互相转换。 在生成短链接时，先利用随机数生成index逐个字符地拼接成短链接，然后判断是否存在。123456789101112131415161718192021222324252627282930313233public class Codec &#123; private static final String HOST = "http://tinyurl.com/"; private static final String CHAR = "abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"; private static final int LIMIT = CHAR.length(); Map&lt;String, String&gt; url2tiny = new HashMap&lt;&gt;(); Map&lt;String, String&gt; tiny2url = new HashMap&lt;&gt;(); // Encodes a URL to a shortened URL. public String encode(String longUrl) &#123; if (url2tiny.containsKey(longUrl)) &#123; return HOST + url2tiny.get(longUrl); &#125; String ret = null; do &#123; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; 6; i++) &#123; int index = (int) (Math.random() * LIMIT); sb.append(CHAR.charAt(index)); &#125; ret = sb.toString(); &#125; while (tiny2url.containsKey(ret)); url2tiny.put(longUrl, ret); tiny2url.put(ret, longUrl); return HOST + ret; &#125; // Decodes a shortened URL to its original URL. public String decode(String shortUrl) &#123; return tiny2url.get(shortUrl.replace(HOST, "")); &#125;&#125; 4. Median of 2 sorted arrays 给两个int数组，返回二者合并后的中位数，要求在O(log(m+n))的时间复杂度以内。 上来可以先讲讲mergesort的那种线性扫到中位数的O(m + n)做法。二分查找找的是能将两个数组恰好分成两个部分的index，而且确定了第一个数组的index之后，第二个数组的index也就确定了（因为每个部分取多少数是已知的）。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; if (nums1 == null || nums2 == null) &#123; return 0; &#125; int m = nums1.length, n = nums2.length; if (nums1.length &gt; nums2.length) &#123; // ensure the len of 1 &lt;= 2 return findMedianSortedArrays(nums2, nums1); &#125; // to ensure equality of the two parts after merged, i + j = m - i + n - j int iLo = 0, iHi = m, allMid = (n + m + 1) / 2; // but why (n + m + 1)/2? // i stands for "how many num taken from nums1 as front part" 0 ~ i-1 | i ~ m-1 // j stands for "how many num taken from nums2 as front part" 0 ~ j-1 | j ~ n-1 while (iLo &lt;= iHi) &#123; int i = (iLo + iHi) / 2, j = allMid - i; // nums1[i-1], nums2[j-1] are the largest element of front part of nums1, nums2 // nums1[i], nums2[j] are the smallest of lag part of nums1, nums2 if (i &lt; m &amp;&amp; nums2[j - 1] &gt; nums1[i]) &#123; // i not big enough iLo = i + 1; &#125; else if (i &gt; 0 &amp;&amp; nums1[i - 1] &gt; nums2[j]) &#123; iHi = i - 1; &#125; else &#123; int maxLeft = 0, minRight = 0; if (i == 0) &#123; maxLeft = nums2[j - 1]; &#125; else if (j == 0) &#123; maxLeft = nums1[i - 1]; &#125; else &#123; maxLeft = Math.max(nums1[i - 1], nums2[j - 1]); &#125; if ((m + n) % 2 == 1) &#123; // I think thats why to make (allMid = (n + m + 1)/2) return maxLeft; // -- to make left part always at least no fewer than right &#125; if (i == m) &#123; minRight = nums2[j]; &#125; else if (j == n) &#123; minRight = nums1[i]; &#125; else &#123; minRight = Math.min(nums1[i], nums2[j]); &#125; return (maxLeft + minRight) / 2.0; &#125; &#125; return 0; &#125;&#125; 572. Subtree of Another Tree 给两个二叉树，判断其中一棵是否说另一个的子树（存在val、结构完全相同的子树）。 naive的方法是无脑recursive，但是这样每个节点可能会被重复访问。另一种做法是用preorder将两个树encode成字符串，然后用contains判断是否是substring即可。但注意这个contains本身并不是O(N)的，可以提一句KMP算法。123456789101112131415161718 public class Solution &#123; public boolean isSubtree(TreeNode s, TreeNode t) &#123; StringBuilder spre = new StringBuilder(); StringBuilder tpre = new StringBuilder(); preOrder(s, spre.append(",")); preOrder(t, tpre.append(",")); return spre.toString().contains(tpre.toString()); &#125; public void preOrder(TreeNode root, StringBuilder str)&#123; if(root == null)&#123; str.append("#,"); return; &#125; str.append(root.val).append(","); preOrder(root.left, str); preOrder(root.right, str); &#125;&#125; 130. surrounded-regions 给一个只含有XXOO的char二维数组，要求把所有被X完美包围的O替换成X，而绵延到边界的O就不替换。 先将四个边边遍历一波，将所有的O以及连绵的O替换成特殊字符，然后再从头遍历，将特殊字符换回O、将中间的O换成X。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class Solution &#123; private class Point &#123; int x; int y; Point(int x, int y) &#123; this.x = x; this.y = y; &#125; &#125; public void solve(char[][] board) &#123; if (board == null || board.length == 0 || board[0].length == 0) &#123; return; &#125; int m = board.length, n = board[0].length; for (int i = 0; i &lt; n; i++) &#123; if (board[0][i] == 'O') &#123; bfs(board, 0, i); &#125; if (board[m-1][i] == 'O') &#123; bfs(board, m - 1, i); &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; if (board[i][0] == 'O') &#123; bfs(board, i, 0); &#125; if (board[i][n-1] == 'O') &#123; bfs(board, i, n - 1); &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (board[i][j] == 'O') &#123; board[i][j] = 'X'; &#125; else if (board[i][j] == '!') &#123; board[i][j] = 'O'; &#125; &#125; &#125; &#125; private void bfs(char[][] board, int x, int y) &#123; int m = board.length, n = board[0].length; Queue&lt;Point&gt; q = new LinkedList&lt;Point&gt;(); q.add(new Point(x, y)); board[x][y] = '!'; while (!q.isEmpty()) &#123; Point curr = q.poll(); int i = curr.x; int j = curr.y; if (i &gt; 0 &amp;&amp; board[i-1][j] == 'O') &#123; // up q.add(new Point(i-1, j)); board[i-1][j] = '!'; &#125; if (i &lt; m - 1 &amp;&amp; board[i+1][j] == 'O') &#123; // down q.add(new Point(i+1, j)); board[i+1][j] = '!'; &#125; if (j &gt; 0 &amp;&amp; board[i][j-1] == 'O') &#123; // left q.add(new Point(i, j-1)); board[i][j-1] = '!'; &#125; if (j &lt; n - 1 &amp;&amp; board[i][j+1] == 'O') &#123; // left q.add(new Point(i, j+1)); board[i][j+1] = '!'; &#125; &#125; &#125;&#125; 2016.10.5 Onsite698. partition-to-k-equal-sum-subsets 给一个数组，判断是否能划分成K个sum相等的子集。 累加当前元素后到达下一层，判断是否达到了targetSum并且确实有元素（防止targetSum == 0且有负数的case）的情况下，开始往后遍历下一个group。1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public boolean canPartitionKSubsets(int[] nums, int k) &#123; if (nums == null || nums.length == 0 || k &gt; nums.length || k &lt; 1) &#123; return false; &#125; if (k == 1) &#123; return true; &#125; int sum = IntStream.of(nums).sum(); if (sum % k != 0) &#123; return false; &#125; int targetSum = sum / k; boolean[] visited = new boolean[nums.length]; return checkPartition(nums, visited, 0, targetSum, 0, k, 0); &#125; public boolean checkPartition(int[] nums, boolean[] visited, int startIndex, int targetSum, int currSum, int k, int elementCount) &#123; if (k == 0) &#123; // 必须算完才行 return true; &#125; if (currSum == targetSum &amp;&amp; elementCount &gt; 0) &#123; // 保证每个部分真正有元素存入 return checkPartition(nums, visited, 0, targetSum, 0, k - 1, 0); &#125; for (int i = startIndex; i &lt; nums.length; i++) &#123; if (!visited[i]) &#123; visited[i] = true; if (checkPartition(nums, visited, i + 1, targetSum, currSum + nums[i], k, elementCount + 1)) &#123; return true; &#125; visited[i] = false; &#125; &#125; return false; &#125;&#125; 252. meeting-rooms 给一个Interval的数组，每个Interval含有meeting的开始和结束时间戳，问是否能参加所有会议。 贪心算法，根据start排序，然后取前后两个看有没有overlap。1234567891011121314class Solution &#123; public boolean canAttendMeetings(Interval[] intervals) &#123; if (intervals == null || intervals.length == 0) &#123; return true; &#125; Arrays.sort(intervals, (a, b) -&gt; a.start - b.start); for (int i = 1; i &lt; intervals.length; i++) &#123; if (intervals[i].start &lt; intervals[i - 1].end) &#123; return false; &#125; &#125; return true; &#125;&#125; 2018.5.1 电面97. interleaving-string 给三个字符串s1, s2, s3，判断s3是否由s1和s2拼接而成，这里的拼接可以是交错的，但必须维持字符原本的出现顺序。 方法一：DP。dp[i][j]表示从s1中取i个字符、从s2中取j个字符能否交错组成s3[i + j - 1]。判断时若从s1中取i个字符，即s1[i] == s3[i + j - 1]且dp[i - 1][j]能交错形成，或者从s2中取j个字符，即s2[j] == s3[i + j - 1]且dp[i][j - 1]能交错，则当前这个也可以，设为true即可。 1234567891011121314151617181920212223242526272829303132public boolean isInterleave(String s1, String s2, String s3) &#123; if (s1 == null || s2 == null || s3 == null) &#123; return false; &#125; int len1 = s1.length(), len2 = s2.length(), len3 = s3.length(); if (len1 + len2 != len3) &#123; return false; &#125; char[] cs1 = s1.toCharArray(), cs2 = s2.toCharArray(), cs3 = s3.toCharArray(); boolean[][] dp = new boolean [len1 + 1][len2 + 1]; for (int i = 0; i &lt; dp.length; i++) &#123; for (int j = 0; j &lt; dp[0].length; j++) &#123; if (i == 0) &#123; if (j == 0) &#123; dp[i][j] = true; &#125; else &#123; dp[i][j] = cs2[j - 1] == cs3[i + j - 1] &amp;&amp; dp[i][j - 1]; &#125; &#125; else &#123; if (j == 0) &#123; dp[i][j] = cs1[i - 1] == cs3[i + j - 1] &amp;&amp; dp[i - 1][j]; &#125; else &#123; // take char from s1(move i) or from s2(move j) dp[i][j] = (dp[i - 1][j] &amp;&amp; cs1[i - 1] == cs3[i + j - 1]) || (dp[i][j - 1] &amp;&amp; cs2[j - 1] == cs3[i + j - 1]); &#125; &#125; &#125; &#125; return dp[len1][len2];&#125; 方法二：DFS。也需要利用二维boolean数组标记是否能组成interleaving字符串，若之前已经判断是false了就不用继续DFS了。判断时也是分别尝试从s1中和s2中取字符，然后与s3比较。 12345678910111213141516171819202122public boolean isInterleave(String s1, String s2, String s3) &#123; if (s1 == null || s2 == null || s3 == null || s1.length() + s2.length() != s3.length()) &#123; return false; &#125; char[] cs1 = s1.toCharArray(), cs2 = s2.toCharArray(), cs3 = s3.toCharArray(); boolean[][] invalid = new boolean [cs1.length + 1][cs2.length + 1]; return dfs(cs1, cs2, cs3, 0, 0, invalid);&#125;private boolean dfs(char[] cs1, char[] cs2, char[] cs3, int i, int j, boolean[][] invalid) &#123; if (invalid[i][j]) &#123; return false; &#125; if (i + j == cs3.length) &#123; // end case: reach the end of s3 return true; &#125; if ((i &lt; cs1.length &amp;&amp; cs1[i] == cs3[i + j] &amp;&amp; dfs(cs1, cs2, cs3, i + 1, j, invalid)) || (j &lt; cs2.length &amp;&amp; cs2[j] == cs3[i + j] &amp;&amp; dfs(cs1, cs2, cs3, i, j + 1, invalid))) &#123; return true; &#125; invalid[i][j] = true; return false;&#125; 方法三：BFS。和DFS类似，将可达的i/j组合存入queue，直到遍历完s3。 1234567891011121314151617181920212223242526public boolean isInterleave(String s1, String s2, String s3) &#123; if (s1 == null || s2 == null || s3 == null || s1.length() + s2.length() != s3.length()) &#123; return false; &#125; char[] cs1 = s1.toCharArray(), cs2 = s2.toCharArray(), cs3 = s3.toCharArray(); boolean[][] visited = new boolean [cs1.length + 1][cs2.length + 1]; Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;(); q.add(new int[] &#123;0, 0&#125;); while (!q.isEmpty()) &#123; int[] curr = q.poll(); if (visited[curr[0]][curr[1]]) &#123; continue; &#125; if (curr[0] + curr[1] == cs3.length) &#123; // reaches the end of s3 return true; &#125; if (curr[0] &lt; cs1.length &amp;&amp; cs1[curr[0]] == cs3[curr[0] + curr[1]]) &#123; q.add(new int[] &#123;curr[0] + 1, curr[1]&#125;); &#125; if (curr[1] &lt; cs2.length &amp;&amp; cs2[curr[1]] == cs3[curr[0] + curr[1]]) &#123; q.add(new int[] &#123;curr[0], curr[1] + 1&#125;); &#125; visited[curr[0]][curr[1]] = true; &#125; return false;&#125; 2018.4.6279. perfect-squares 给一个正整数，求至少由多少个平方数相加能得到它。 DP。dp[i]表示数字i至少需要多少个平方数相加，那么对于每个i，遍历i - j * j即可。1234567891011121314public int numSquares(int n) &#123; if (n &lt;= 0) &#123; return 0; &#125; int[] dp = new int[n + 1]; Arrays.fill(dp, Integer.MAX_VALUE); dp[0] = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j * j &lt;= i; j++) &#123; dp[i] = Math.min(dp[i], dp[i - j * j] + 1); &#125; &#125; return dp[n];&#125; [???] 给一个BST，给一个区间[min, max]，将在区间之外的节点删除。1234567891011121314public TreeNode deleteOutliers(TreeNode root, int min, int max) &#123; if (root == null || min &gt; max) &#123; return null; &#125; if (root.val &gt; max) &#123; return deleteOutliers(root.left, min, max); &#125; else if (root.val &lt; min) &#123; return deleteOutliers(root.right, min, max); &#125; else &#123; root.left = deleteOutliers(root.left, min, root.val - 1); root.right = deleteOutliers(root.right, root.val + 1, max); return root; &#125;&#125; 2018.4.6 电面53. maximum-subarray 给一个int数组，求最大的subarry sum。 方法一：直接O(N)搞定，维护一个当前的sum，要么是前面累加的结果、要么从当前开始加。 12345678910111213class Solution &#123; public int maxSubArray(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; int ans = Integer.MIN_VALUE, prev = 0; for (int i = 0; i &lt; nums.length; i++) &#123; prev = Math.max(prev + nums[i], nums[i]); ans = Math.max(ans, prev); &#125; return ans; &#125;&#125; 方法二：分治法，要么纯左边、要么纯右边、要么从交界处向左右取元素。 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int maxSubArray(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; return getMax(nums, 0, nums.length - 1); &#125; private int getMax(int[] nums, int left, int right) &#123; if (left == right) &#123; // end case return nums[left]; &#125; int mid = (right + left) / 2; int leftMax = getMax(nums, left, mid); // get max subarray only with left elements int rightMax = getMax(nums, mid + 1, right); // get max ~ right int midMax = getMidMax(nums, left, mid, right); // get max sub that uses both left and right return Math.max(leftMax, Math.max(rightMax, midMax)); &#125; private int getMidMax(int[] nums, int left, int mid, int right) &#123; int leftMax = Integer.MIN_VALUE, rightMax = Integer.MIN_VALUE; int sum = 0; for (int i = mid; i &gt;= left; i--) &#123; sum += nums[i]; leftMax = Math.max(sum, leftMax); // at least take one element from left &#125; sum = 0; for (int i = mid + 1; i &lt;= right; i++) &#123; sum += nums[i]; rightMax = Math.max(sum, rightMax); // at least take one element from right &#125; return leftMax + rightMax; &#125;&#125; 2018.4.4 Onsite103. binary-tree-zigzag-level-order-traversal level层面的遍历二叉树，但是遍历顺序不是固定的从左到右，而是蛇形，这一层从左到右、下一行从右到左。 方法一：BFS+Queue，正一下反一下。 方法二：DFS时将level数也传入，对于偶数层则append到对应的List中，对于奇数层则insert到首位。 Longest common subsequence(注意和前面的max substring有异曲同工之妙) 给两个字符串，求最长的公共子序列的长度。 DP。用两个指针i和j分别遍历s1和s2，若字符相同则取dp[i - 1][j - 1] + 1，否则取max{dp[i - 1][j], dp[i][j - 1]}. 1234567891011121314151617public int maxCommonSubsequenceLen(String s1, String s2) &#123; if (s1 == null || s2 == null) &#123; return 0; &#125; int len1 = s1.length(), len2 = s2.length(); int[][] dp = new int[len1][len2]; for (int i = 0; i &lt; len1; i++) &#123; for (int j = 0; j &lt; len2; j++) &#123; if (s1.charAt(i) == s2.charAt(j)) &#123; dp[i][j] = i &gt; 0 &amp;&amp; j &gt; 0 ? dp[i - 1][j - 1] + 1 : 1; &#125; else &#123; dp[i][j] = Math.max(i &gt; 0 ? dp[i - 1][j] : 0, j &gt; 0 ? dp[i][j - 1] : 0); &#125; &#125; &#125; return dp[len1 - 1][len2 - 1];&#125; Follow-up：如果需要返回任意一个这样的字符串呢？ 根据DP table一路回溯，若当前两个字符串的所取字符相等则放入结果中。1234567891011121314151617181920212223242526272829303132public static String maxCommonSubsequence(String s1, String s2) &#123; if (s1 == null || s2 == null) &#123; return null; &#125; int len1 = s1.length(), len2 = s2.length(); int[][] dp = new int[len1][len2]; for (int i = 0; i &lt; len1; i++) &#123; for (int j = 0; j &lt; len2; j++) &#123; if (s1.charAt(i) == s2.charAt(j)) &#123; dp[i][j] = i &gt; 0 &amp;&amp; j &gt; 0 ? dp[i - 1][j - 1] + 1 : 1; &#125; else &#123; dp[i][j] = Math.max(i &gt; 0 ? dp[i - 1][j] : 0, j &gt; 0 ? dp[i][j - 1] : 0); &#125; &#125; &#125; char[] ret = new char[dp[len1 - 1][len2 - 1]]; int index = ret.length - 1, i = len1 - 1, j = len2 - 1; while (index &gt;= 0) &#123; if (s1.charAt(i) == s2.charAt(j)) &#123; ret[index--] = s1.charAt(i); i--; j--; &#125; else &#123; if (i &gt; 0 &amp;&amp; dp[i][j] == dp[i - 1][j]) &#123; i--; &#125; else if (j &gt; 0 &amp;&amp; dp[i][j] == dp[i][j - 1]) &#123; j--; &#125; &#125; &#125; return new String(ret);&#125; 2018.1.21 Onsite348. design-tic-tac-toe XXOO游戏，两个玩家，每一行、每一列、两条对角线都是一样的话，对应玩家就赢了。要设计一个class，其中包含move函数，给坐标和玩家编号，在图里放，如果该玩家赢了就返回玩家编号。每行、每列需要统计两个玩家各自的个数，如果都是其中一个玩家都就赢了，两条对角线也是。 记录行、列、两条对较线。区分两个玩家的O和X就通过正负一来判断，这样如果有一个玩家赢了就意味着一路相加结果是n或者-n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class TicTacToe &#123; private int[] rows; private int[] cols; private int diag1, diag2; private int n; /** Initialize your data structure here. */ public TicTacToe(int n) &#123; rows = new int [n]; cols = new int [n]; diag1 = 0; diag2 = 0; this.n = n; &#125; /** Player &#123;player&#125; makes a move at (&#123;row&#125;, &#123;col&#125;). @param row The row of the board. @param col The column of the board. @param player The player, can be either 1 or 2. @return The current winning condition, can be either: 0: No one wins. 1: Player 1 wins. 2: Player 2 wins. */ public int move(int row, int col, int player) &#123; if (row &lt; 0 || row &gt;= n || col &lt; 0 || row &gt;= n || player &lt; 1 || player &gt; 2) &#123; return 0; &#125; int addVal = player == 1? -1: 1; // for diag1 if (row == col) &#123; diag1 += addVal; if (isConnect(diag1)) &#123; return player; &#125; &#125; // for diag2 if (row + col == n - 1) &#123; diag2 += addVal; if (isConnect(diag2)) &#123; return player; &#125; &#125; // for row rows[row] += addVal; if (isConnect(rows[row])) &#123; return player; &#125; // for col cols[col] += addVal; if (isConnect(cols[col])) &#123; return player; &#125; return 0; &#125; private boolean isConnect(int val) &#123; return val / n != 0; &#125;&#125; 2017.9.19 Onsite297. serialize-and-deserialize-binary-tree 实现二叉树的序列化与反序列化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Codec &#123; private final String NULL_NODE = "N"; private final String SPLITTER = ","; // Encodes a tree to a single string. public String serialize(TreeNode root) &#123; StringBuilder sb = new StringBuilder(); preorder(root, sb); return sb.toString(); &#125; private void preorder(TreeNode root, StringBuilder sb) &#123; if (root == null) &#123; sb.append(NULL_NODE).append(SPLITTER); return; &#125; sb.append(root.val).append(","); preorder(root.left, sb); preorder(root.right, sb); &#125; // Decodes your encoded data to tree. public TreeNode deserialize(String data) &#123; if (data == null || data.length() == 0) &#123; return null; &#125; String[] vals = data.split(SPLITTER); Queue&lt;String&gt; q = new LinkedList&lt;&gt;(); for (String val : vals) &#123; q.offer(val); &#125; return deserialize(q); &#125; private TreeNode deserialize(Queue&lt;String&gt; q) &#123; if (q.isEmpty()) &#123; return null; &#125; String first = q.poll(); if (first.equals(NULL_NODE)) &#123; return null; &#125; TreeNode root = new TreeNode(Integer.parseInt(first)); root.left = deserialize(q); root.right = deserialize(q); return root; &#125;&#125; follow-up：如果是BST呢？那么在序列化的时候可以直接忽略掉null节点，因为在反序列化的时候可以直接通过val来判定root的值情况。 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Codec &#123; // Encodes a tree to a single string. public String serialize(TreeNode root) &#123; StringBuilder sb = new StringBuilder(); preorder(root, sb); return sb.toString(); &#125; private void preorder(TreeNode root, StringBuilder sb) &#123; if (root == null) &#123; return; &#125; sb.append(root.val).append(","); preorder(root.left, sb); preorder(root.right, sb); &#125; // Decodes your encoded data to tree. public TreeNode deserialize(String data) &#123; if (data == null || data.length() == 0) &#123; return null; &#125; String[] vals = data.split(","); Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); for (String val : vals) &#123; q.offer(Integer.parseInt(val)); &#125; return deserialize(q); &#125; private TreeNode deserialize(Queue&lt;Integer&gt; q) &#123; if (q.isEmpty()) &#123; return null; &#125; TreeNode root = new TreeNode(q.poll()); Queue&lt;Integer&gt; smallerQueue = new LinkedList&lt;&gt;(); while (!q.isEmpty() &amp;&amp; q.peek() &lt; root.val) &#123; smallerQueue.offer(q.poll()); &#125; root.left = deserialize(smallerQueue); root.right = deserialize(q); return root; &#125;&#125; 24. swap-nodes-in-pairs 给一个链表头，要去反转所有相邻的节点，返回反转后的头。不可以修改头的val，这能修改next。 Iterative: 1234567891011121314151617public ListNode swapPairs(ListNode head) &#123; if (head == null) &#123; return null; &#125; ListNode fakeHead = new ListNode(0); fakeHead.next = head; ListNode curr = fakeHead; while (curr.next != null &amp;&amp; curr.next.next != null) &#123; ListNode first = curr.next; ListNode second = curr.next.next; first.next = second.next; second.next = first; curr.next = second; curr = first; // actually it is curr.next.next &#125; return fakeHead.next;&#125; Follow-up: 用Recursive来做呢？ 123456789public ListNode swapPairs(ListNode head) &#123; if (head == null || head.next == null) &#123; return head; &#125; ListNode temp = head.next; head.next = swapPairs(head.next.next); temp.next = head; return temp;&#125; 382. linked-list-random-node 面经里说的是“给一个stream of int”取随机取数字，要求每个数字被取到的概率相同。和这个LC原理相同，假设stream元素为[1, 2, 3]，每次只能读入一个数字。一开始读入1，只能保留它，概率为1；然后读入2，这是1和2之间保留谁的概率就是1/2；然后读入3，此时保留的数字与3只能保留一个，为了保证概率均等，需要在0~2中产生随机数，只有等于2的时候才选择索引为2的元素即3，概率为1/3，而上一步保留的那个数字留下来的概率则是1/2 * 2/3 = 1/3，概率依然相等。这个算法还可以推广到取k个元素出来的情况，这样内存中始终就只有非常少量（k + 1）的数字需要读入了。123456789101112131415161718192021222324public class Solution &#123; ListNode head; java.util.Random random; /** @param head The linked list's head. Note that the head is guaranteed to be not null, so it contains at least one node. */ public Solution(ListNode head) &#123; this.head = head; random = new java.util.Random(); &#125; /** Returns a random node's value. */ public int getRandom() &#123; ListNode curr = head; int ret = curr.val; for (int i = 1; curr.next != null; i++) &#123; curr = curr.next; if (random.nextInt(i + 1) == i) &#123; ret = curr.val; &#125; &#125; return ret; &#125;&#125; 2017.10.29 电面98. validate-binary-search-tree 常见的错误是直接greedy，只判断当前节点和孩子的大小。但BST的定义是比「所有的左子树都大、比右都小」。 方法一：中序遍历时每次都判断前后两个元素的大小关系。又分为recursive和iterative的。 12345678910111213141516171819202122232425262728293031323334353637 // recursive: 全局的prev记录当前节点前一个是谁，比较大小private TreeNode prev = null;private boolean validateBST1(TreeNode root) &#123; if (root == null) &#123; return true; &#125; if (!validateBST1(root.left)) &#123; return false; &#125; if (prev != null &amp;&amp; prev.val &gt;= root.val) &#123; return false; &#125; prev = root; return validateBST1(root.right);&#125; // iterative: 用stack不断深入左节点，直到空再将栈顶与prev比较，然后进入右子树，继续不断向左。private boolean validateBST2(TreeNode root) &#123; if (root == null) &#123; return true; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode prev = null; while (root != null || !stack.isEmpty()) &#123; while (root != null) &#123; stack.push(root); root = root.left; &#125; root = stack.pop(); if (prev != null &amp;&amp; prev.val &gt;= root.val) &#123; return false; &#125; prev = root; root = root.right; &#125; return true;&#125; 方法二：分治，为左右子树给定范围（min, max），在递归时更新左子树的上界、更新右子树的下界。 12345678910111213private boolean validateBST3(TreeNode root) &#123; return dvcq(root, Long.MIN_VALUE, Long.MAX_VALUE);&#125;private boolean isValidBST(TreeNode root, long min, long max) &#123; if (root == null) &#123; return true; &#125; if (root.val &lt;= min || root.val &gt;= max) &#123; return false; &#125; return isValidBST(root.left, min, root.val) &amp;&amp; isValidBST(root.right, root.val, max);&#125; 2018.1.29 电面 + Onsite235. lowest-common-ancestor-of-a-binary-search-tree 给一个BST和两个其中的节点，求他们的LCA。根据值来划分即可，若p和q的值都在root同侧则递归到那里，一旦发现不同侧就返回当前root。123456789101112131415public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if (root == null || p == null || q == null || p == root || q == root) &#123; return root; &#125; if (p == q) &#123; return p; &#125; if (Math.max(p.val, q.val) &lt; root.val) &#123; return lowestCommonAncestor(root.left, p, q); &#125; else if (Math.min(p.val, q.val) &gt; root.val) &#123; return lowestCommonAncestor(root.right, p, q); &#125; else &#123; return root; &#125;&#125; 236. lowest-common-ancestor-of-a-binary-tree 给一个任意的二叉树和两个其中的节点，求他们的LCA。无法用值来比较，只能直接查找节点了。分别往左边和右边找，若root为其中一个节点则返回。这样在上层拿到左边和右边的搜索结果后就可以判断出现在哪一侧，若两边都找到了则说明当前节点就是LCA.1234567891011121314151617public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if (root == null) &#123; return null; &#125; if (root == p || root == q) &#123; return root; &#125; TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); if (left != null &amp;&amp; right != null) &#123; return root; &#125; if (left == null &amp;&amp; right == null) &#123; return null; &#125; return left == null? right: left;&#125;]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>algorithm</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[飘儿斯朵瑞吉]]></title>
    <url>%2F2018%2F09%2F08%2Fpure_storage%2F</url>
    <content type="text"><![CDATA[迎难而上，祝我好运。面朝大海，春暖花开。 valid square 给二维平面上的四个点，判断能否组成正方形。lc593 对于这些点计算两两之间的距离，如果最大的长度出现两次且剩余的4个长度都相等，则可以构成正方形。 1234567891011121314151617181920212223public boolean validSquare(int[] p1, int[] p2, int[] p3, int[] p4) &#123; long[] distances = new long[] &#123;getDistance(p1, p2), getDistance(p1, p3), getDistance(p1, p4), getDistance(p2, p3), getDistance(p2, p4), getDistance(p3, p4)&#125;; Map&lt;Long, Integer&gt; map = new HashMap&lt;&gt;(); long max = 0l; long min = Long.MAX_VALUE; for (long d : distances) &#123; map.put(d, map.getOrDefault(d, 0) + 1); max = Math.max(max, d); min = Math.min(min, d); &#125; return map.get(max) == 2 &amp;&amp; map.get(min) == 4 &amp;&amp; map.size() == 2 &amp;&amp; 2 * min == max; // !!!&#125;private long getDistance(int[] p1, int[] p2) &#123; int xDiff = Math.abs(p1[0] - p2[0]); int yDiff = Math.abs(p1[1] - p2[1]); return (long)xDiff * xDiff + (long)yDiff * yDiff;&#125; follow-up: 给一大堆点，求总共可以组成多少个正方形。 暴力法，四重循环固定四个点，然后调用上面的函数判断是否组成一个正方形。 优化1:先把所有坐标存入Set，然后双重循环固定两个点作为一个边，然后求对边的那两个点（注意两侧都有可能），看是否都在set中，是则可以组成一个正方形。去重直接除以2. 优化2:可以将两个点作为对角线来找另外两个点。 CallBack Eventfire 给一个Event类，它可能会fire。Event对象中可以register一些callback，当Event执行fire的时候，所有这些callback都需要依次执行，之后再register的callback就直接执行。先实现一个单线程的版本。 12345678910111213141516171819202122232425262728class Callback &#123; ... public void run();&#125;class EventSystem &#123; public boolean fired = false; private Queue&lt;Callback&gt; queue; public EventSystem() &#123; queue = new LinkedList&lt;&gt;(); &#125; public void register(Callback cb) &#123; if (fired) &#123; cb.run(); &#125; else &#123; queue.offer(cb); &#125; &#125; public void fire() &#123; while (!queue.empty()) &#123; Callback cb = queue.poll(); cb.run(); &#125; fired = true; &#125;&#125; 如何实现一个加锁机制保证执行的atomicity. 首先看看上面的register。如果在执行check fired之后，Event突然fire了，那当前这个cb还是会进入queue，那就永远不会执行了。因此考虑给register加锁，同时对fire也加锁，保证只有拿到锁才能执行。 123456789101112131415161718public void register(callback_t cb) &#123; lock.acquire(); if (fired) &#123; cb.run(); &#125; else &#123; queue.add(cb); &#125; lock.release();&#125;public void fire() &#123; lock.acquire(); while (!queue.empty()) &#123; Callback cb = queue.poll(); cb.run(); &#125; fired = true; lock.release();&#125; 但是上面这个可能效率比较差，因为run可能得执行很久，这样别的线程一直要等待锁。必须保证检查是否fired这个判断不被抢占，同时在run之前就释放掉。而加入queue的操作则必须收到锁的保护，不能还没加进去就已经fire了，那之后又永远执行不了了。 12345678910111213141516171819202122public void register(callback_t cb) &#123; lock.acquire(); if (fired) &#123; lock.release(); cb.run(); &#125; else &#123; queue.add(cb); lock.release(); &#125;&#125;public void fire() &#123; lock.acquire(); while (!queue.empty()) &#123; Callback cb = queue.poll(); lock.release(); cb.run(); lock.acquire(); &#125; fired = true; lock.release();&#125; happy number 朴素做法，直接严格按照定义来做。可能需要证明的是为什么这些数字最终会回到一个较小的范围内（单调递减性）。 123456789101112131415public boolean isHappy(int n) &#123; int r = 0, sum = 0; if (n == 1 || n == 7) &#123; return true; &#125; else if (n &lt; 10) &#123; return false; &#125; else &#123; while (n != 0) &#123; r = n % 10; sum += r * r; n /= 10; &#125; &#125; return isHappy(sum);&#125; 最终所有的non-happy都会进入一个环，因此考虑使用快慢指针判断环的做法，一旦有环就直接返回false了。 1234567891011121314151617181920212223public boolean isHappy(int n) &#123; int slow, fast; slow = fast = n; while (true) &#123; slow = digitSquareSum(slow); fast = digitSquareSum(fast); fast = digitSquareSum(fast); if (fast == 1) return true; if (slow == fast) return false; &#125;&#125;public int digitSquareSum(int n) &#123; int sum = 0, tmp; while (n != 0) &#123; tmp = n % 10; sum += tmp * tmp; n /= 10; &#125; return sum;&#125; 画圆 给一个半径，以原点为圆心，返回所有圆上的点的坐标（近似），这些坐标都是整数。类似于在电脑屏幕的pixel上显示一个完整的圆。 基本方法：通过循环以半径正方形，产生所有点。 1234567891011121314private static List&lt;int[]&gt; drawCircle(int r) &#123; List&lt;int[]&gt; list = new ArrayList&lt;&gt;(); int l = -r; int u = r; for (int i = l; i &lt;= u; i++) &#123; for (int j = u; j &gt;= l; j--) &#123; int diff = i * i + j * j - r * r; if (diff ) &#123; list.add(new int[] &#123; i, j &#125;); &#125; &#125; &#125; return list;&#125; 注意到圆的对称性，因此可以只研究1/8个圆 123456789101112131415161718192021private static List&lt;int[]&gt; drawCircle(int r) &#123; List&lt;int[]&gt; list = new ArrayList&lt;&gt;(); double end = r / 0.141; int y = r; for (int x = 0; x &lt;= end; x++) &#123; int diff = x * x + y * y - r * r; if (diff ) &#125; return list;&#125;private static void addPoints(int x, int y, List&lt;int[]&gt; list) &#123; list.add(new int[] &#123;x, y&#125;); list.add(new int[] &#123;-x, y&#125;); list.add(new int[] &#123;x, -y&#125;); list.add(new int[] &#123;-x, -y&#125;); list.add(new int[] &#123;y, x&#125;); list.add(new int[] &#123;-y, x&#125;); list.add(new int[] &#123;y, -x&#125;); list.add(new int[] &#123;-y, -x&#125;);&#125; 实现O(1) Set 实现一个只含有1~N的integer set，支持add, remove, contains, clear, iterate. 方法一：直接使用bucket数组，add, remove, contains都是O(1)，但是clear和iterate都是O(N) 方法二：使用类似于sequential的数组，即元素按照插入顺序append，add就直接O(1)插到结尾即可，remove, contains都需要线性搜索找到对应位置O(count)，clear就直接把链表头设置为空即可O(1)，iterate则是O(count). follow-up: 如何实现add, remove, contains, clear全O(1)，iterate O(count)？ sequential数组作为主体，每当add一个元素，就把当前count作为该元素的索引存入bucket数组。例如插入顺序是[2,0,1]，在bucket中就存放插入的这些元素的索引[1,2,0]. remove时在bucket中拎出这个元素的索引，在sequential数组就可以直接访问到，此时可以直接将该元素和末尾元素swap，然后将长度缩小，同时在bucket中也对应修改一下索引即可。contains则是直接通过bucket看看存放的索引是否valid（可以用负数标记为invalid）。clear则是直接将长度设为0，那么之后再add就又会从0开始append到sequential数组了。iterate则是遍历sequential即可。 计算parlindrone数 给一个String，求其中一共包含多少个回文子串。 类似于lc 647，给一个DP做法。123456789101112131415161718public int checkSequence(String S) &#123; if (S == null || S.length() == 0) &#123; return 0; &#125; int len = S.length(), count = 0; boolean[][] dp = new boolean[len][len]; for (int right = 0; right &lt; len; right++) &#123; dp[right][right] = true; count++; for (int left = right - 1; left &gt;= 0; left--) &#123; if (S.charAt(left) == S.charAt(right) &amp;&amp; (left + 1 == right || dp[left + 1][right - 1])) &#123; dp[left][right] = true; count++; &#125; &#125; &#125; return count;&#125;]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>algorithm</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[威安姆位尔]]></title>
    <url>%2F2018%2F08%2F21%2Fvmware%2F</url>
    <content type="text"><![CDATA[迎难而上，祝我好运。面朝大海，春暖花开。 minimum cost 给一个int数组，要把它变成单调递增或者单调递减（相等也行），可以对数组内任意一个数字加或者减任意值，把这个加减的绝对值称为cost，问要实现最后单调递增或者递减的效果，最少的cost总和是多少？ 参考了DP做法。原数组为nums，先尝试递增，排序得到sorted。input作row，sorted作col，dp[i][j]表示以sorted[j]为最大值、input[0~i]所需的minCost，dp[0][0]表示input[0]维持单调需要的minCost，自然就是abs(input[0] - sorted[0])了，dp[i][0]表示以sorted[0]为基准的到input[i]为止累计的minCost，dp[0][j]表示任选sorted[0~j]元素将input[0]变到它所需的cost。12345678910111213141516171819202122232425262728293031public int getMinimumCost(int[] input) &#123; if (input == null || input.length == 0) &#123; return 0; &#125; return Math.min(getMinimumCost(input, false), getMinimumCost(input, true));&#125;private int getMinimumCost(int[] input, boolean reverse) &#123; int[] sorted = Arrays.copyOf(input, input.length); Arrays.sort(sorted); if (reverse) &#123; for (int i = 0, j = sorted.length - 1; i &lt; j; i++, j --) &#123; int temp = sorted[i]; sorted[i] = sorted[j]; sorted[j] = temp; &#125; &#125; int[][] dp = new int[input.length][sorted.length]; dp[0][0] = Math.abs(input[0] - sorted[0]); for (int i = 1; i &lt; input.length; i++) &#123; dp[i][0] = dp[i - 1][0] + Math.abs(input[i] - sorted[0]); &#125; for (int j = 1; j &lt; sorted.length; j++) &#123; dp[0][j] = Math.min(dp[0][j - 1], Math.abs(input[0] - sorted[j])); &#125; for (int i = 1; i &lt; input.length; i++) &#123; for (int j = 1; j &lt; sorted.length; j++) &#123; dp[i][j] = Math.min(dp[i][j - 1], dp[i - 1][j] + Math.abs(input[i] - sorted[j])); &#125; &#125; return dp[input.length - 1][sorted.length - 1];&#125; 完美分配队员 根据skill看最多能分成几个组，由最少skill的学生数决定。1234567891011121314151617public int getTeamCount(String skills) &#123; if (skills == null || skills.length() == 0 || skills.length() % 5 != 0) &#123; return 0; &#125; Map&lt;Character, Integer&gt; skillCount = new HashMap&lt;&gt;(); for (char c : skills.toCharArray()) &#123; skillCount.put(c, skillCount.getOrDefault(c, 0) + 1); &#125; if (skillCount.size() &lt; 5) &#123; return 0; &#125; int min = Integer.MAX_VALUE; for (char c : skillCount.keySet()) &#123; min = Math.min(min, skillCount.get(c)); &#125; return min;&#125; 平移数组 字符串循环平移。12345678910public String getShiftedString(String str, int leftShifts, int rightShifts) &#123; if (str == null || str.length() == 0) &#123; return null; &#125; if (leftShifts + rightShifts == 0) &#123; return str; &#125; leftShifts = (leftShifts - rightShifts) % str.length(); return str.substring(leftShifts) + str.substring(0, leftShifts);&#125; 偶数子数组 给一个int数组，求有多少个至多含有k个奇数的、不重复出现的子数组。使用滑动窗口保证奇数count不超过k，同时每次右指针纳入新元素时就从左指针开始将已有的元素encode成字符串存入set，这样就可以保证是dinstinct的subarray了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public int getDistinctSubarray(int[] nums, int k) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; int left = 0, right = 0, oddCount = 0; Set&lt;String&gt; set = new HashSet&lt;&gt;(); StringBuilder sb = new StringBuilder(); while (right &lt; nums.length) &#123; oddCount += nums[right] % 2 == 1 ? 1 : 0; while (oddCount &gt; k) &#123; if (nums[left] % 2 == 1) &#123; oddCount--; &#125; left++; sb.delete(0, sb.indexOf(",") + 1); &#125; sb.append(nums[right]); sb.append(','); updateSet(set, sb); right++; &#125; return set.size();&#125;private void updateSet(Set&lt;String&gt; set, StringBuilder sb) &#123; int start = 0, end = sb.indexOf(","); while (end &gt; 0) &#123; set.add(sb.substring(start, sb.length())); start = end + 1; end = sb.indexOf(",", start); &#125;&#125;// 然而超时了，没搞出来。当时想用两个set来做的：public int getDistinctSubarray2(int[] nums, int k) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; int left = 0, right = 0, oddCount = 0; Set&lt;String&gt; set = new LinkedHashSet&lt;&gt;(); Set&lt;String&gt; prevSet = new LinkedHashSet&lt;&gt;(); prevSet.add(""); while (right &lt; nums.length) &#123; oddCount += nums[right] % 2 == 1 ? 1 : 0; while (oddCount &gt; k) &#123; if (nums[left] % 2 == 1) &#123; oddCount--; &#125; List&lt;String&gt; prevSetList = new ArrayList&lt;&gt;(prevSet); for (int i = prevSetList.size() - 1; i &gt;= 0 &amp;&amp; prevSetList.get(i).startsWith(String.valueOf(nums[left])); i--) &#123; prevSet.remove(prevSetList.get(i)); &#125; left++; &#125; prevSet = updateSet2(set, prevSet, nums[right]); right++; &#125; return set.size();&#125;private Set&lt;String&gt; updateSet2(Set&lt;String&gt; set, Set&lt;String&gt; prevSet, int num) &#123; Set&lt;String&gt; newSet = new LinkedHashSet&lt;&gt;(); newSet.add(""); for (String prev : prevSet) &#123; String curr = prev + num + ","; if (!set.contains(curr)) &#123; set.add(curr); newSet.add(curr); &#125; &#125; return newSet;&#125; minimum increments 给一个int数组，其中可能含有duplicate，对其中的元素进行++操作，使得所有数字都distinct，返回最小sum。 先排序，然后遍历原数组，用一个prev记录之前的元素（可能经过++）了，若当前元素小于等于prev，就需要++，直接累加到sum中；否则就直接累加并将prev赋值为当前元素。12345678910111213141516public int getMinSum(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; int sum = nums[0], prev = nums[0]; for (int i = 1; i &lt; nums.length; i++) &#123; if (nums[i] &lt;= prev) &#123; prev++; sum += prev; &#125; else &#123; sum += nums[i]; prev = nums[i]; &#125; &#125; return sum;&#125; 孪生字符串 个字符串a和b，同字符串内，奇数位和奇数位的字符可以互相交换，偶数位和偶数位的字符也可以。判断能否通过这种交换操作使两个字符串相等。 分别统计奇数位和偶数位每个字母的出现次数，然后比较两个字符串的统计结果是否相等即可。]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>algorithm</tag>
        <tag>interview</tag>
        <tag>vmware</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Note for Cracking the Coding Interview]]></title>
    <url>%2F2018%2F05%2F31%2Fcracking_the_code_interview%2F</url>
    <content type="text"><![CDATA[Note for Cracking the Coding Interview 6th Edition. Big OMultipart Algorithms Add: do A, then when A is all done, do B. Multiply: do B each time you do A. (recall Zillow mistake…) Recursive Runtimes See branched recursive calls from parent calls to form a “tree”. Pattern: O(barnches ^ depth), branches = #times each recursive call branches. Arrays and StringsHash Tables Array of linked lists: O(1) general lookup time. Balanced BST: O(logN) lookup time, less space. Resizable Arrays ArrayList: O(1) amortized insertion time. String v.s.StringBuilder String: immutable, always create a new copy of the string when concatenating(might bring the runtime to O(N^2)) StringBuilder: resizable char array. Problems Q：给一个String，判断它是否包含完全不同的unique characters。 用一个bucket数组，ASCII一共有128个字符。O(N)时间和空间。 O(NlogN) sort之后遍历一波，判断相邻的char即可。无额外空间。 如果只是26个字母，可以直接用bit当作bucket来用，一旦有一个bit之前已经设为1了就说明不unique。 Q：给两个String，判断它们是否是同一个permutation. O(NlogN) sort之后比较一波。 用一个bucket数组统计每个字符出现的个数。 Q：给一个char array和它的real length（array.length足够hold住替换之后的所有字符），将其中所有的空格都替换成%20，. 从给定的len - 1开始从后往前遍历，依次复制／替换到char数组的末尾。String manipulation问题通常可以尝试从后往前做，因为这样相当于在末尾有一个inplace的buffer。 Q：给一个String，判断它是否是palindrome的permutation。 用一个bucket记录所有字符出现的个数，最后再一波O(N)统计是否有超过一个的count是odd。 用一个countOdd变量在统计个数的时候顺便记录有多少个是odd的，全部统计完了之后直接就可以判断了。 我们并不关心『每个字符具体有多少个』，而只是想知道『每个字符个数是even还是odd』。因此直接用bit作为on/off即可，最后要么为0（全是even），要么只有一位是1（判断x &amp; (x-1) == 0即可）。 Q：给两个String，判断他们是否之多差一步操作即可相互转换：插入一个字符／删除一个字符／替换一个字符。 关键在于发现插入和删除其实是逆操作，直接根据长度判断一下即可知道是哪个操作。 Q：给一个String，将相邻连续出现的字符压缩成a2b3c1的形式，若压缩后长度并没有缩短则维持原字符串。 在实际操作之前先判断一下压缩之后的长度再决定要不要执行压缩。 Q：给一个nn的方matrix，向右旋转90度。* 老老实实进行四位替换，top-left, left-bottom, bottom-right, right-top. Q：给一个mn的matrix，若其中一个位置为0则将它所处的行和列全都设为0.* 维护两个boolean array分别存放row和column的0的位置，最后再设为0。 直接用矩阵的第一行和第一列存放0的位置（需要额外用两个变量mark一下第一行和第一列本身有没有0），就不需要额外空间了。 Q：给两个String，判断其中一个是否是另一个通过rotate形成的，例如abbc-&gt;bcab。 假设rotation point前面的部分为x，后面的为y，则形成xy的形式。要判断另一个字符是不是yx，其实只需要将xy自己拼接一下形成xyxy，直接看另一个字符串是否是它的substring即可。 Linked List Runner technique: iterate through linked list with two pointers simultaneously, with one ahead or faster movement. Problems Q：给一个unsorted的链表，删除其中重复的元素。 fix一个节点然后一路往后删，O(N^2)时间。 用Set。 Q：给一个链表，返回倒数第k个元素。 利用双指针，让后一个指针先挪k，然后两个一起挪即可。 Q：给一个链表中间的某个节点，删除它。 其实这题是假的删除，因为无法拿到该节点前面一个节点，因此只能把后面节点的值往前覆盖。 Q：给一个链表和一个int，要求将链表中小于x的元素都排在前面、大于等于x的元素都排在后面，而两个partition内部的顺序不需要维护。 链表问题有个经典做法是建“新”的链表、而节点都是原来的。这里就是用两个“新链表”，一个存小于的节点、一个存大于等于的节点，最后合起来。 Q：给两个链表，表示从低位到高位的整数，求它们的和（也用链表表示）。 就直接加，需要处理进位和两个链表长度不一样的情况。 如果链表表示的是从高位到低位的数字，首先需要将较短的链表前面pad zero，然后再用自定义类（因为需要进位）recursive地求。 Q：给一个链表，判断是否palindrome。 先拷贝一份reverse的链表，然后直接比较两个链表是否相等。 用快慢指针将前半部分投入stack，然后一边pop一边往后比较。 用自定义类（需要boolean以及后续指针）recursive地判断，若之前都为true且当前元素和返回的元素相等，则继续返回true。 Q：给两个链表，判断它们是否相交并返回第一个汇合点。 先走两波获取两个链表的长度求出delta，然后让长的先走delta，再一起遍历即得汇合点。 交叉走法：A和B同时往后走，当A走到尽头就再从B出发、B同理，最后如果汇合了即为汇合点。假设A的独立部分长度为a，B的独立部分长度为b，公用部分为c，(a+c+b) = (b+c+a). Q：给一个链表，判断它是否有环并返回环的入口。 快慢指针出发，相遇之后再从起点走一个慢指针，相遇处即为入口。设环长度为l，环之前长度为a，相遇时慢指针在环内走了b。有(a+l+b) = 2(a+b)，即l - b = a，因此继续走必定相遇。 Stacks and Queues Stack: LIFO Queue: FIFOProblems Q：用一个array实现三个Stack。 将array划分成3等份，然后每个stack就只有固定一部分的capacity进行pop, push. 如果想要flexible size，可以学习arraylist那样在一开始先有一个initial capacity，满了之后再进行扩容。 Q：实现一个stack，支持push, pop, min方法，其中min可以返回当前所有stack中元素的最小值。 push的时候如果最小值更新了，则先把当前最小值push进去，然后再把新值push进去并更新最小值；pop的时候如果最小值和栈顶一致，则需要再pop一下把最小值更新。 Q：实现stacks的ArrayList，当一个stack满了之后就新建另一个stack继续存。 push好办，对应index进行存放，满了就在下一个index新建stack继续放。pop则需要考虑是否需要维护『前面所有stack都维持在满的状态』这个条件，如果需要就得把指定index之后的stack都进行roll over，将栈底釜底抽薪放到前面。 Q：用两个stack实现queue。 一个stackA只负责存、另一个stackB只负责取。如果peek的时候没有东西了，就需要将B中所有内容都pop到A中，再从A中取，这样就可以保证FIFO。 Q：给一个stack，将它排序，最小值在栈顶。只允许使用一个辅助stack。 s2作为辅助stack，维持从大到小的顺序。s1中pop栈顶元素先存入一个变量temp，若发现temp比s2栈顶大则完美存入，否则需要先将s2的元素不断pop并存入直到temp元素可以放入，然后再重复从s1 pop存入temp的过程插入s2。 如果有无限制的辅助stack可以使用，就可以实现类似于mergesort和quicksort的排序。mergesort在每一个recursion level都需要两个辅助stack来排序，将他们各自排好序然后将他们汇集到输入的原始stack中，依次递归就能将整个stack排序完成；quicksort也需要在每一个recursion level两个辅助stack，将他们divide based on pivot value最后再汇集到原始stack。 Q：动物收容所领养动物必须遵循FIFO规则，只能选择动物种类cat/dog，或者随机选择入队最久的anything。要求使用linkedlist。 维护两个LinkedList分别存放cat和dog，直接append到List末尾即可，dequeue就直接从头部取；dequeueAny则利用timestamp保证取最久的。 Trees and GraphsTypes of Trees Complete Binary Tree: Every level is fully filled, except last level; In each level, nodes are filled from left to right. Full Binary Tree: Every node has either 0 or 2 children. Perfect Binary Tree: Both Full and Complete Binary Tree. BST: left &lt;= n &lt; right Traverse DFS: simpler implementation(recursion) for visiting all nodes in graph. Need to check if the node has been visited. BFS: find path(shortest path) between two nodes. Bidirectional Search: find the shortest path between a src and dest node by running two BFS from src and dest simultaneously. Problems Q：给一个有向图和两个node，判断它们之间是否有path 就是简单的考察BFS和DFS。 Q：给一个含有不同int的升序数组，创建一个对应的最小height的BST 要想生成高度最小的BST，也就是root需要是数组中间元素。因此一个递归方法就出来了，先找到中间元素作为root，然后递归生成左半边的BST和右半边的BST分别作为左右孩子。 Q：给一个二叉树，求每一个depth处的nodes，存在LinkedList中 其实就是level traverse，用BFS层级遍历即可。时间O(N)，空间不包括输出的话是O(1)。 也可以用DFS的preorder traversal，附加传入一个level信息即可。时间O(N)，空间O(logN)。 Q：给一个二叉树，判断它是否balanced（左右子树的高度相差不超过1） 暴力递归，对于每一个节点递归地求深度，对于每一个节点都会被在它上面的节点访问一次，因此时间是O(NlogN)。 考虑优化求height的过程，在递归的时候事实上可以通过传回「特殊值」来表示unbalanced的情况，这样可以保证每一个节点只会被访问一次，因此时间是O(N)。 Q：判断一个BST是否合法 用in-order traverse和一个全局变量来比较prev和curr，保证完全小于。 传入min和max值限定孩子节点的值域，一旦不符合就直接false了。 Q：给一个二叉树中的node，求它在in-order traverse中的successor(假设每一个节点都可以访问到parent节点) 需要分情况讨论：如果当前node有右子树，则需要访问到右子树的最左节点；如果没有右子树，则说明当前节点及其孩子已经全部访问完了，需要回到parent，而这parent又要分node是它的左孩子还是右孩子，是右孩子的话说明是已经访问过parent才来到node的，因此还要往parent的parent找，只有当node是parent的左孩子时，parent才是successor.12345678910111213141516171819202122232425TreeNode inorderSuccessor(TreeNode node) &#123; if (node == null) &#123; return null; &#125; if (node.right != null) &#123; return getLeftMostChild(node.right); &#125; else &#123; TreeNode curr = node; TreeNode prev = curr.parent; while (prev != null &amp;&amp; prev.left != curr) &#123; curr = prev; prev = prev.parent; &#125; return prev; &#125;&#125;TreeNode getLeftMostChild(TreeNode node) &#123; if (node == null) &#123; return null; &#125; while (node.left != null) &#123; node = node.left; &#125; return node;&#125; Q：给一个List包含一系列project，然后给出部分dependencies表示要想做b必须先完成a。求一个可以完成所有project的顺序。 经典拓扑排序，和利口210一样。BFS方法是先遍历一遍dependencies维护一个inDegree数组，然后找出所有入度为0的点入队作为起点，将所有相邻的点的入度减1（删掉从起点到该点的这条边），同时将新的入度为0的点入队。时间是O(v + e). DFS也可以做，首先构建邻接链表，然后用一个for-loop尝试从某一点出发能够完全走完所有node的，在DFS时维护一个visited和onpath分别表示当前节点已经访问过or当前节点正在被访问，一旦出现cycle（onpath为true）就说明有cyclic dependencies，不可能走完；如果都ok则吧当前节点插入到当前遍历path的最前面，表示从当前节点出发可以走到后续这些节点，这样回溯到上一层递归调用时又会把对应的incoming node加进来。时间也是O(v + e). Q：First Common Ancestor 如果是正常的二叉树，只有从parent到child的Link，就是利口236。但注意限制条件，p和q不同且p和q都必须在二叉树中存在。如果拿掉这些限制条件，就无法区分p是q的ancestor和p在树中而q不存在的情况，此时就需要对return的结果小小修改一下，增加返回一个boolean值表示这个是不是真的找到了ancestor. 123456789101112131415161718192021222324252627282930313233343536373839class Result &#123; public TreeNode node; public boolean isAncestor; public Result(TreeNode node, boolean isAncestor) &#123; this.node = node; this.isAncestor = isAncestor; &#125;&#125;TreeNode LCA(TreeNode root, TreeNode p, TreeNode q) &#123; Result r = helper(root, p, q); if (r.isAncestor) &#123; return r.node; &#125; return null;&#125;Result helper(TreeNode root, TreeNode p, TreeNode q) &#123; if (root == null) &#123; return new Result(null, false); &#125; if (root == p &amp;&amp; root == q) &#123; // p和q相等且存在于树中 return new Result(root, true); &#125; Result rLeft = helper(root.left, p, q); if (rLeft.isAncestor) &#123; return rLeft; &#125; Result rRight = helper(root.right, p, q); if (rRight.isAncestor) &#123; return rRight; &#125; if (rLeft.node != null &amp;&amp; rRight.node != null) &#123; // 左右两边分别找到了p和q return new Result(root, true); // 当前root即为LCA &#125; else if (root == p || root == q) &#123; // 当前root恰好为p/q时，需要确定另一方是否在子树中 boolean inSubTree = rLeft.node != null || rRight.node != null; return new Result(root, inSubTree); &#125; else &#123; return new Result(rLeft.node != null ? rLeft : rRight, false); &#125;&#125; 如果有Link可以访问parent，则类似于intersection of two linkedlist，利用depth的差值先把较深的节点往上提几个level，然后一起向上挪，汇合处即为ancestor。时间复杂度为O(depth)。 此外还可以选择从其中一个节点出发，在向上的时候总会解锁另一侧的child（即使为null），这时去那一侧check是否包含另一个节点即可，如果不包含就再往上走，继续解锁继续搜。时间复杂度为O(t)，t为ancestor所在subtree的节点数，这个t也可能包含所有节点。 123456789101112131415161718192021222324252627282930313233 TreeNode commonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if (!contains(root, p) || !contains(root, q)) &#123; return null; &#125; else if (contains(p, q)) &#123; return p; &#125; else if (contains(q, p)) &#123; return q; &#125; TreeNode sibling = getSibling(p); TreeNode parent = p.parent; while (!contains(sibling, q)) &#123; sibling = getSibling(parent); parent = parent.parent; &#125; return parent;&#125;boolean contains(TreeNode root, TreeNode p) &#123; if (root == null) &#123; return false; &#125; if (root == p) &#123; return true; &#125; return contains(root.left, p) || contains(root.right, p);&#125;TreeNode getSibling(TreeNode node) &#123; // 得到和node相同地位的兄弟节点 if (node == null || node.parent == null) &#123; return null; &#125; TreeNode parent = node.parent; return parent.left == node ? parent.right : parent.left;&#125; Q:假设BST是通过一个List从左到右填充出来的。给一个BST，求所有可能形成该BST的List of List。例如root为2、左孩子为1、右孩子为3的BST可能是[2,1,3]或者[2,3,1]生成的，需要返回所有可能的List. BST虽然要求当前节点所有左子树都小于它、所有右子树都大于它，但给定一个List和树的形状之后，只要知道了根节点，左右节点出现的先后顺序没有关系，因为一定是大的在右、小的在左。因此需要递归来实现“把所有左右子树可能情形枚举完后，将当前root插入到所有情况的开头”。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495 List&lt;List&lt;Integer&gt;&gt; allSeq(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if (root == null) &#123; result.add(new LinkedList&lt;Integer&gt;()); return result; &#125; List&lt;Integer&gt; prefix = new LinkedList&lt;&gt;(); prefix.add(root.val); // 将左右子树的所有情况都列出来 List&lt;List&lt;Integer&gt;&gt; leftSeq = allSeq(root.left); List&lt;List&lt;Integer&gt;&gt; rightSeq = allSeq(root.right); for (List&lt;Integer&gt; left : leftSeq) &#123; // 两两组合一波 for (List&lt;Integer&gt; right : rightSeq) &#123; List&lt;List&lt;Integer&gt;&gt; weaved = new ArrayList&lt;&gt;(); weaveLists(left, right, weaved, prefix); result.addAll(weaved); &#125; &#125; return result; &#125; void weaveLists(List&lt;Integer&gt; first, List&lt;Integer&gt; second, List&lt;List&lt;Integer&gt;&gt; results, List&lt;Integer&gt; prefix) &#123; if (first.size() == 0 || second.size() == 0) &#123; List&lt;Integer&gt; result = (List&lt;Integer&gt;) prefix.clone(); result.addAll(first); result.addAll(second); results.add(result); return; &#125; int headFirst = first.removeFirst(); prefix.addLast(headFirst); weaveLists(first, second, results, prefix); // 递归，将前半部分的第一个元素append到prefix中 prefix.removeLast(); first.addFirst(headFirst); int headSecond = second.removeFirst(); prefix.addLast(headSecond); weaveLists(first, second, results, prefix); // 将后半部分的第一个元素append到prefix中 prefix.removeLast(); second.addFirst(headSecond); &#125; ``` * *Q: 给两个binary tree T1和T2（含有N和M个节点，可能很大），判断T2是否是T1的subtree。* - 用类似于二叉树serialized的办法，前序遍历将所有节点都append成StringBuilder，注意null节点也需要表示出来。这样需要O(N + M)空间和O(N + M)时间。 - 递归的办法，遍历T1的节点，只有当T2的root出现时才开始逐一匹配每一个节点。需要O(log(N) + log(M))空间和O(N + k*M)的时间，其中k是T2的root出现在T1中的次数。（WHY空间是那个？？？？？？？？？）* *Q: 要求实现一个BST类，含有insert, find, delete以及一个`getRandomNode()`以相等概率返回任意一个节点。* - 方法一：如果有`N`个节点，那么相等概率就是`1/N`.因此考虑在每个节点处保存它下属总共有多少个节点，然后就以`1/N`的概率取。 ```Java class TreeNode &#123; public int val; // 简化了 public TreeNode left; public TreeNode right; public int size = 0; ... public TreeNode getRandomNode() &#123; int leftSize = left == null ? 0 : left.size; Random random = new Random(); int index = random.nextInt(size); // 根据当前tree总共有多少节点来决定 if (index &lt; leftSize) &#123; return left.getRandomNode(); &#125; else if (index == leftSize) &#123; return this; &#125; else &#123; return right.getRandomNode(); &#125; &#125; public void insertInOrder(int d) &#123; if (d &lt;= val) &#123; if (left == null) &#123; left = new TreeNode(d); &#125; else &#123; left.insertInOrder(d); &#125; &#125; else &#123; if (right == null) &#123; right = new TreeNode(d); &#125; else &#123; right.insertInOrder(d); &#125; &#125; size++; // 当前这个node的size需要增长 &#125; public TreeNode find(int d) &#123; if (d == val) &#123; return this; &#125; else if (d &lt;= val) &#123; return left != null ? left.find(d) : null; &#125; else &#123; return right != null ? right.find(d) : null; &#125; &#125; &#125; 方法二：方法一调用Random次数较多，因为每次递归下去都要pick一个随机数。考虑在最开始就根据总size选定一个随机数i，然后一路递归下去，按照中序遍历找到第i个节点。 1234567891011121314151617181920212223242526272829303132class Tree &#123; TreeNode root = null; private treeSize = root == null ? 0 : root.size; public TreeNode getRandomNode() &#123; if (root == null) &#123; return null; &#125; Random random = new Random(); int i = random.nextInt(treeSize); return root.getIthNode(i); &#125; public void insertInOrder(int value) &#123; if (root == null) &#123; root = new TreeNode(value); &#125; else &#123; root.insertInOrder(value); &#125; &#125;&#125;class TreeNode &#123; public TreeNode getIthNode(int i) &#123; int leftSize = left == null ? 0 : left.size; if (i &lt; leftSize) &#123; return left.getIthNode(i); &#125; else if (i == leftSize) &#123; return this; &#125; else &#123; return right.getIthNode(i - (leftSize + 1)); &#125; &#125;&#125; Q: path sum: 给一个二叉树，每个节点含有任意整数，给一个sum，求有多少条从上往下的路径之和等于该sum。 暴力枚举，尝试从root出发看有多少，然后尝试从left和right出发。时间复杂度推导可以这样考虑，对于深度为d的节点，会被在它上面的d个节点touch到，因此对于一个balanced tree来说，时间为O(NlogN)。对于unbalanced的来说，例如一条单边的tree下来，就是O(N^2) 显然暴力方法有很多可以reuse的东西，可以将问题抽象一下。从root往下走的时候，可以看作是一个数组，每一个bucket就是走到该处的runningSum，而给的targetSum其实就是某两个runningSum之间的差，这就转换成了2 Sum的问题，如何在更新runningSum的时候快速判断是否能和之前的某个runningSum刚好相差targetSum. 1234567891011121314151617181920212223242526272829int countPathSum(TreeNode root, int targetSum) &#123; return countPathSum(root, targetSum, 0, new HashMap&lt;Integer, Integer&gt;());&#125;int countPathSum(TreeNode node, int targetSum, int runningSum, Map&lt;Integer, Integer&gt; pathSumCount) &#123; if (node == null) return 0; runningSum += node.val; int previousSum = runningSum - targetSum; int totalPaths = pathSumCount.getOrDefault(previousSum, 0); // 和之前的某个sum恰好形成差值为target if (runningSum == targetSum) &#123; // running其实就表示从root开始的pathSum totalPaths++; &#125; updatePathSumCount(pathSumCount, runningSum, 1); totalPaths += countPathSum(node.left, targetSum, runningSum, pathSumCount); // 只能选一边往下走（链式） totalPaths += countPathSum(node.right, targetSum, runningSum, pathSumCount); updatePathSumCount(pathSumCount, runningSum, -1); return totalPaths;&#125;void updatePathSumCount(Map&lt;Integer, Integer&gt; pathSumCount, int key, int delta) &#123; int newCount = pathSumCount.getOrDefault(key, 0) + delta; if (newCount == 0) &#123; pathSumCount.remove(key); &#125; else &#123; pathSumCount.put(key, newCount); &#125;&#125; Bit Manipulation2’s Complement Negative K’s binary represenetation is concat(1, 2^(N-1) - K), where N is the total length of bits. Another interpretation: -K = ~K + 1, then prepend 1 at the beginning. Arithmetic right shift = divides by two; Logical right shift = visually shiftying of bits. Common bit tasks 12345678910111213141516171819202122232425262728boolean getBit(int num, int i) &#123; return ((num &amp; (1 &lt;&lt; i)) != 0);&#125;int setBit(int num, int i) &#123; return num | (1 &lt;&lt; i);&#125;int clearBit(int num, int i) &#123; int mask = ~(1 &lt;&lt; i); return num &amp; mask;&#125;int clearBitsMSBthroughI(int num, int i) &#123; // 把最高位到i清0 int mask = (1 &lt;&lt; i) - 1; return num &amp; mask;&#125;int clearBitsIthrough0(int num, int i) &#123; // 把i到最低位清0 int mask = (-1 &lt;&lt; (i + 1)); return num &amp; mask; &#125;int updateBit(int num, int i, boolean bitIs1) &#123; int value = bitIs1 ? 1 : 0; int mask = ~(1 &lt;&lt; i); // 先将该bit重置为0 return (num &amp; mask) | (value &lt;&lt; i);&#125; Problems Q: 给两个32bit的整数N和M，给定两个索引i和j(j &gt; i且一定可以包含所有M的有效bit)。将N中j~i的部分替换成M的对应部分。 可以考虑分成三步：将N中j~i置为0、shift M挪到正确的j~i范围中、合并。 12345678int updateBits(int N, int M, int i, int j) &#123; int allOnes = ~0;// 或者直接用-1 int left = allOnes &lt;&lt; (j + 1); int right = ((1 &lt;&lt; i) - 1); int mask = left | right; return (N &amp; mask) | (M &lt;&lt; i);&#125; Q: 给一个(0, 1)之间的double，求它的binary字符串表示，如果超过32bit则返回“ERROR”。 小数的二进制表示其实就是小数点后的bit乘以2^(-i)。因此直接先乘一个2上去看看是否超过1，决定bit。如果不能乘，那么直接和1/2, 1/4, 1/8这样一路比下去也可以。123456789101112131415161718192021String getBinary(double num) &#123; if (num &gt;= 1 || num &lt;= 0) &#123; return "ERROR"; &#125; StringBuilder binary = new StringBuilder(); binary.append("."); while (num &gt; 0) &#123; if (binary.length() &gt; 32) &#123; return "ERROR"; &#125; double r = num * 2; if (r &gt; 1) &#123; binary.append('1'); num = r - 1; &#125; else &#123; binary.append('0'); num = r; &#125; &#125; return binary.toString();&#125; Q: 给一个int，只能flip其中一个0变成1，求最长的连续1的长度。 也就是找到夹在两个连续1中间的0使得两边的1长度最长。维护一个prev和curr判断即可。 123456789101112131415int flipBit(int a) &#123; if (~a == 0) return Integer.BYTES * 8; // 已经全是1了 int curr = 0, prev = 0, maxLen = 1; // flip之后至少有一个1 while (a != 0) &#123; if ((a &amp; 1) == 1) &#123; curr++; &#125; else &#123; prev = (a &amp; 2) == 0 ? 0 : curr; // 看看下一位是否为0，连续的0就没法flip了 curr = 0; &#125; maxLen = Math.max(maxLen, curr + prev + 1); a &gt;&gt;&gt;= 1; // visual的右移 &#125; return maxLen;&#125; Q: 给一个正数，返回最小的下一个数和最大的前一个数，这些数含有的1数量必须相同。 对于getNext，就是找到最靠右的非末尾的0，将它变为1后再把右侧的1先统计个数，然后清空后全部放到最右侧。对于getPrev也是类似，找到最靠右的非末尾的1，统计右侧的1后全置为0，然后紧接着拼到原最右侧1的后面。 还可以考虑arithmetic的做法，因为对于getNext其实就类似于10000 - 1 -&gt; 01111的效果，因此就变成了先找011100，根据右侧0的个数加一个1 &lt;&lt; 2变成100000，然后加上一个(1 &lt;&lt; (3 - 1)) - 1 -&gt; 000011，即n + (1 &lt;&lt; count0) + (1 &lt;&lt; (count1 - 1)) - 1. getPrev也是根据右侧0的个数和1的个数，返回n - (1 &lt;&lt; c1) - (1 &lt;&lt; (count0 - 1)) + 1。 Q: 请解释((n &amp; (n - 1)) == 0)的目的。 n和n - 1没有一个bit有相同的1分布，类似于1000 - 1 -&gt; 0111，因此可以用来判断n是否是2的幂。 Q: 给两个int，判断他们之间需要flip多少个bit才能转换成对方。 也就是看异或之后有多少个1，除了老老实实地shift求有多少个1，还可以利用减1的trick加速求有多少个1。 1234567int bitSwapCount(int a, int b) &#123; int count = 0; for (int c = a ^ b; c != 0; c = c &amp; (c - 1)) &#123; // 每次都可以直接将最右的1置0，比一个个shift快得多 count++; &#125; return count;&#125; Q: 用尽可能少的instrction实现奇数位和偶数位的bit互换。 可以先用mask分别把奇数和偶数的部分提取出来，然后分别shift即可（right shift必须是logic的）:(((x &amp; 0xaaaaaaaa) &gt;&gt;&gt; 1) | ((x &amp; 0x55555555) &lt;&lt; 1)) Q: 假设一个黑白屏幕的像素存储在byte数组中，即每8个bit的上色情况存在一个byte中。给定坐标(x1, y)和(x2, y)，实现画线的函数。 可以傻傻地一个bit一个bit地上色，但是更高效的做法是先找到可以完整上色的区间直接赋值0xFF，然后如果头尾还有一点残余，再创建前后两小段的mask。注意edge case，如果x1和x2都在一个byte里面，就不能这样头尾搞来搞去了，直接在区间内自己搞小mask或一蛤。 Math and Logic Puzzles Object-Oriented Design Recursion and Dynamic Programming3 recursion approach Bottom-up: Start with knowing how to solve the problem for a simple case, then build previous case upon it. Top-down: Divide the problem for case N into subproblems(careful: overlap cases) Half-and-half: divide the dataset into halves. like Binary search and merge sort.Problems Q: 爬楼梯，一次只能爬1、2、3级，求到第n级共有多少走法。 利用memo数组记录下从0～n的所有走法数量，每次从前面三个累加即可。注意这种连续加法要考虑overflow的情况，向面试官指出来。 Q: 走grid，每次只能向下走或这向右走，grid值为false的地方是障碍物，求一条从左上角到右下角的路径。 可以从终点往回递归，这样如果找到路径了就只需要在List末尾插入当前坐标即可。为了提升time，需要额外空间记录每个点是否访问过。 Q: 给一个排好序的dinstinct int数组，求其中一个magic index若存在的话. magic index指的是i s.t. A[i] == i 看到排好序就想到是否可以用二分查找？若i &gt; A[i]，而且数组中元素各不相同，说明i之前不可能有magic index，因此可以直接往后找，非常类似二分查找的思想。 12345678910111213141516int getMagicIndex(int[] arr) &#123; return getMagicIndex(arr, 0, arr.length - 1);&#125;int getMaticIndex(int[] arr, int start, int end) &#123; if (end &lt; start) &#123; return -1; &#125; int mid = start + (end - start) / 2; if (arr[mid] == mid) &#123; return mid; &#125; else if (arr[mid] &gt; mid) &#123; return getMagicIndex(arr, start, mid - 1); &#125; else &#123; return getMagicIndex(arr, start + 1, end); &#125;&#125; Follow-up: 如果数组中含有重复元素，如何改进？还是沿用这个思路，区别在于当i &gt; A[i]，不能把整个index &lt; i都放弃，只能说明[A[i], i]这部分是不可能的，还需要保留[start, A[i]]的部分。 12345678910111213141516171819202122int getMagicIndex(int[] arr) &#123; return getMagicIndex(arr, 0, arr.length - 1);&#125;int getMaticIndex(int[] arr, int start, int end) &#123; if (end &lt; start) &#123; return -1; &#125; int midIndex = start + (end - start) / 2; int midValue = arr[midIndex]; if (midValue == midIndex) &#123; return midIndex; &#125; // 搜索左边剩余部分 int leftEnd = Math.min(midIndex - 1, midValue); int left = getMagicIndex(arr, start, leftEnd); if (left &gt;= 0) &#123; return left; &#125; int rightStart = Math.max(midIndex + 1, midValue); int right = getMagicIndex(arr, rightStart, end); return right;&#125; Q: Power set, 求一个set（元素各不相同）的所有subset 经典递归，每一步直接考虑在前一个subset的基础上添加一个元素。 12345678910111213141516171819List&lt;List&lt;Integer&gt;&gt; getSubsets(List&lt;Integer&gt; set, int index) &#123; List&lt;List&lt;Integer&gt;&gt; ans; if (set.size() == index) &#123; ans = new ArrayList&lt;&gt;(); ans.add(new ArrayList&lt;&gt;()); &#125; else &#123; ans = getSubsets(set, index + 1); int curr = set.get(index); List&lt;List&lt;Integer&gt;&gt; moreSet = new ArrayList&lt;&gt;(); for (List&lt;Integer&gt; subset : ans) &#123; List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); temp.addAll(subset); temp.add(curr); moreSet.add(temp); &#125; ans.addAll(moreSet); &#125; return ans;&#125; 还可以考虑用bit，每一个元素取/不取就用1/0来指代。 1234567891011121314151617181920List&lt;List&lt;Integer&gt;&gt; getSubsets(List&lt;Integer&gt; set) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); int max = 1 &lt;&lt; set.size(); for (int i = 0; i &lt; max; i++) &#123; List&lt;Integer&gt; subset = int2Set(k, set); ans.add(subset); &#125; return ans;&#125;List&lt;Integer&gt; int2Set(int num, List&lt;Integer&gt; set) &#123; List&lt;Integer&gt; subset = new ArrayList&lt;&gt;(); int index = 0; for (int i = num; i &gt; 0; i &gt;&gt;= 1) &#123; if ((k &amp; 1) == 1) &#123; subset.add(set.get(index)); &#125; index++; &#125; return subset;&#125; Q: 只使用加、减、shifting实现两个正整数的乘法，要求operations尽量少。 对于一大一小x, y两个数，相当于把大数x加y次，这个y次又可以通过shift进行折半。如果y是偶数折半刚好，如果是奇数就需要递归完成后再加一个x。时间复杂度只需要O(log(smaller)). 12345678910111213141516171819int minProd(int a, int b) &#123; int smaller = a &lt; b ? a : b; int bigger = a &lt; b ? b : a; return minProdHelper(smaller, bigger);&#125;int minProdHelper(int times, int num) &#123; if (times == 0) &#123; return 0; &#125; else if (times == 1) &#123; return num; &#125; int newTimes = times &gt;&gt; 1; int halfProd = minProdHelper(newTimes, num); if (times % 2 == 0) &#123; return halfProd + halfProd; &#125; else &#123; return halfProd + halfProd + num; &#125;&#125; Q: 汉诺塔，一堆从小到大的碟子，有三个柱子分别为起始、中介、终点，要求将这些碟子全部移到终点。 这三个柱子的角色并不是固定的，因此考虑用递归来利用传参确定角色。 12345678910111213141516171819202122232425class Tower &#123; private Stack&lt;Integer&gt; disks; private int index; // getter... public Tower(int index) &#123; disks = new StacK&lt;&gt;(); this.index = index; &#125; public void add(int disk) throws Exception &#123; if (!disks.isEmpty() &amp;&amp; disk &gt;= disks.peek()) &#123; throw new Exception(); &#125; else &#123; disks.push(disk); &#125; &#125; public void moveTop(Tower target) &#123; target.add(disks.pop()); &#125; public void moveDisks(int n, Tower target, Tower buffer) &#123; if (n &gt; 0) &#123; moveDisks(n - 1, buffer, target); // 将buffer作为终点，target作为buffer moveTop(target); buffer.moveDisks(n - 1, target, this); // 将起点作为buffer，终点为target &#125; &#125;&#125; Q: Permutation，重复和无重复元素 Q: 生成所有合法的括号对。]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>algorithm</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[来福软谱]]></title>
    <url>%2F2018%2F02%2F20%2Fliveramp%2F</url>
    <content type="text"><![CDATA[迎难而上，祝我好运。 最小横向刷墙次数 给一个数组A代表糊墙的高度，就是挨在一起的n个矩形，第i个高度为A，宽为1，然后横着刷墙，每一笔高度为1，问最少要多少笔？例如[1,2,2,3,2]-&gt;横着4笔 one-pass，两两比较，如果后面的比前面的矮，说明刷到这里就会断掉，所以要加上delta。123456789private static int minPaint(int[] walls) &#123; int count = walls[0]; for (int i = 1; i &lt; walls.length; i++) &#123; if (walls[i] &gt; walls[i - 1]) &#123; count += (walls[i] - walls[i - 1]); &#125; &#125; return count;&#125; 最少出行天数 给一个数组表示第i天可以去的地点，求去所有出现的地点所需的最短天数。 莉蔻上minmum substring简化版。首先建立一个map，频数都设为1表示我只需要去这个地方至少1天。然后双指针producer-consumer，快指针消耗location直到所有地点都去了（剩余目的地count为0），然后先根据左右慢指针更新minDays，然后开始恢复location计数到map中。12345678910111213141516171819202122232425private static int minDays(int[] locations) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int location : locations) &#123; map.put(location, 1); &#125; int locationCount = map.size(); int left = 0, right = 0, minLen = Integer.MAX_VALUE; while (right &lt; locations.length) &#123; map.put(locations[right], map.get(locations[right]) - 1); if (map.get(locations[right]) == 0) &#123; locationCount--; &#125; while (locationCount == 0) &#123; int currLen = right - left + 1; minLen = Math.min(minLen, currLen); map.put(locations[left], map.get(locations[left]) + 1); if (map.get(locations[left]) &gt; 0) &#123; locationCount++; &#125; left++; &#125; right++; &#125; return minLen;&#125; 分糖果 给一个数组表示糖果的id，其中可能有重复，且糖果数量一定是偶数。要求将其分成两部分，问如果想尝最多的不同的糖果，有多少种。例如[3,2,2,1,3,1]就有三种，[7,3,1,4,3,7,4,3,7]就有四种。要求时间复杂度最差O(N*lgN)，空间复杂度O(N)。 先排序，然后双指针一个从前往后，一个从后往前。left指针负责将糖果存入set，right则是调取后方的糖果往前替换，当left发现当前糖果吃过了，就从right那里swap过来继续判断，直到出现新的糖果或者穷尽。123456789101112131415161718192021private static int maxCandy(int[] candies) &#123; if (candies == null || candies.length == 0) &#123; return 0; &#125; Arrays.sort(candies); Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); int half = candies.length / 2; int left = 0, right = candies.length - 1; while (left &lt; half) &#123; while (set.contains(candies[left]) &amp;&amp; right &gt;= half) &#123; swap(candies, left, right--); &#125; if (right &lt; half) &#123; break; &#125; else &#123; set.add(candies[left++]); &#125; &#125; set.add(candies[left]); return set.size(); &#125; 最小无序区间 给一个int数组，求其中最大和最小值恰好为1的非连续子序列。 给一个部分部分有序的数组，求将其中哪一部分排序之后整个数组就都有序了，求最短的区间的长度。 首先从左往右逆序对，然后从右往左找逆序对。这样就有了一个大致区间，但是还需要找区间内的min和max，分别往前和往后遍历看看是否真的完全符合，否则还需要扩展区间。例如[1,3,6,4,8,2,7,10]在前两步之后找到得失[6,4]和[8,2]实际上前面的3和后面的1都需要加入进来。12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public int findUnsortedSubarray(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; // 找第一个逆序对 int left = 1; while (left &lt; nums.length) &#123; if (nums[left - 1] &gt; nums[left]) &#123; left--; break; &#125; left++; &#125; if (left == nums.length) &#123; // 说明已经有序了 return 0; &#125; int right = nums.length - 1; while (right &gt; 0) &#123; if (nums[right - 1] &gt; nums[right]) &#123; break; &#125; right--; &#125; // 找[left, right]之间的最小、最大 int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE; for (int i = left; i &lt;= right; i++) &#123; min = Math.min(min, nums[i]); max = Math.max(max, nums[i]); &#125; // 前面的必须小于min，后面的必须大于max，否则扩散 while (left &gt; 0 &amp;&amp; nums[left - 1] &gt; min) &#123; left--; &#125; while (right + 1 &lt; nums.length &amp;&amp; nums[right + 1] &lt; max) &#123; right++; &#125; return right - left + 1; &#125;&#125; 最长差值恰好为1的子序列 给一个int数组，求其中最大和最小值恰好为1的非连续子序列。 用Map存每个值出现的次数，然后遍历Map取key相差1都存在的进行更新。123456789101112131415161718class Solution &#123; public int findLHS(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int num : nums) &#123; map.put(num, map.getOrDefault(num, 0) + 1); &#125; int max = 0; for (int num : map.keySet()) &#123; if (map.containsKey(num + 1)) &#123; max = Math.max(max, map.get(num) + map.get(num + 1)); &#125; &#125; return max; &#125;&#125; prefix permutation 给一个规模为N的数组，只包含数字1-N，求其中可以作为permutation的子数组的个数。例如[2,1,3,5,4]就有三个：[2,1], [2,1,3], [2,1,3,5,4]。 方法一是求和，一旦吻合permutation的sum就加一，但又overflow的风险。 方法二是利用规模为N、数字是1-N这个信息，value和index就有一一对应的关系了（虽然相差1）。只有差值为0的时候才是permutation。12345678910private static int prefixPermutation(int[] arr) &#123; int prefixCount = 0, valueIndexDelta = 0; for (int i = 0; i &lt; arr.length; i++) &#123; valueIndexDelta += (arr[i] - i - 1); if (valueIndexDelta == 0) &#123; prefixCount++; &#125; &#125; return prefixCount;&#125; 扑克牌比大小 给两个相同长度的String表示两个人的牌，含有2-9, J, Q, K, A这些面值，判断第一个人赢的次数。 直接暴力比大小，用一个Map存牌和数字的映射关系，然后直接取就行了。123456789private static int getWinTimes(String a, String b) &#123; if (a == null || b == null || a.length() == 0 || b.length() == 0) &#123; return 0; &#125; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 2; i &lt; 10; i++) &#123; map.put() &#125;&#125;]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>algorithm</tag>
        <tag>interview</tag>
        <tag>liveramp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谷入普昂]]></title>
    <url>%2F2018%2F01%2F15%2Fgroupon%2F</url>
    <content type="text"><![CDATA[迎难而上，祝我好运。 LRU Cache(146) 模拟Least Recently Used缓存，当要插入新的entry(key, value)时规模不够，最近最少用到的entry会被清除。要求get和put都是O(1)。 由于有键值对，肯定要有Map。key是整数，而put的时候，value不能真的存给的整数value，而是存双向链表中的一个节点，该节点的val再存给定的整数value。put还需要考虑是否是更新，更新则要把原节点val更新后拖到头部；在get的时候，也要注意拖到链表头部。当需要移除最近最少使用元素的时候，就需要把最后一个节点删掉，同时在map中删掉，所以链表节点中还需要存key才能去map中删。双向链表根据节点来删除是O(1)的，因为可以直接访问前后两个节点（单向链表提供待删除节点和它前一个节点也可以做到constant time）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class LRUCache &#123; private class DoublyListNode &#123; int key; int value; DoublyListNode prev; DoublyListNode next; private DoublyListNode(int key, int value) &#123; this.key = key; this.value = value; &#125; &#125; int capacity; int currSize; DoublyListNode head, tail; HashMap&lt;Integer, DoublyListNode&gt; map; public LRUCache(int capacity) &#123; this.capacity = capacity; map = new HashMap&lt;Integer, DoublyListNode&gt;(); currSize = 0; head = new DoublyListNode(0, 0); // 伪头部 tail = new DoublyListNode(0, 0); // 伪尾部 head.prev = null; head.next = tail; tail.prev = head; tail.next = null; &#125; public int get(int key) &#123; DoublyListNode node = map.get(key); if (node != null) &#123; moveToFirst(node); return node.value; &#125; else &#123; return -1; &#125; &#125; public void put(int key, int value) &#123; DoublyListNode node = map.get(key); if (node == null) &#123; node = new DoublyListNode(key, value); currSize++; if (currSize &gt; capacity) &#123; currSize--; map.remove(popLast().key); // 尾部的 &#125; add(node); map.put(key, node); &#125; else &#123; node.value = value; moveToFirst(node); &#125; &#125; private void add(DoublyListNode node) &#123; DoublyListNode nextOfHead = head.next; head.next = node; // 插入到头部的下一位，需要调整头指针的指向 node.prev = head; nextOfHead.prev = node; node.next = nextOfHead; &#125; private void remove(DoublyListNode node) &#123; DoublyListNode prevOfNode = node.prev; DoublyListNode nextOfNode = node.next; prevOfNode.next = nextOfNode; nextOfNode.prev = prevOfNode; &#125; private DoublyListNode popLast() &#123; DoublyListNode last = tail.prev; remove(last); return last; &#125; // 被get了，就需要挪到头部，先删除再插入到头部即可 private void moveToFirst(DoublyListNode node) &#123; remove(node); add(node); &#125;&#125; follow-up：要求写成Generics的形式，不能认定键和值是int。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class LRUCache&lt;T, U&gt; &#123; class DoublyListNode &#123; T key; U val; DoublyListNode prev; DoublyListNode next; public DoublyListNode() &#123; &#125; public DoublyListNode(T key, U val) &#123; this.key = key; this.val = val; &#125; &#125; int capacity; int currSize; DoublyListNode head, tail; Map&lt;T, DoublyListNode&gt; map; public LRUCache(int capacity) &#123; map = new HashMap&lt;&gt;(); this.capacity = capacity; head = new DoublyListNode(); tail = new DoublyListNode(); head.prev = null; head.next = tail; tail.prev = head; tail.next = null; &#125; public U get(T key) &#123; if (map.containsKey(key)) &#123; moveToFirst(map.get(key)); return map.get(key).val; &#125; else &#123; return null; &#125; &#125; public void put(T key, U value) &#123; if (map.containsKey(key)) &#123; remove(map.get(key)); DoublyListNode node = new DoublyListNode(key, value); map.put(key, node); add(node); &#125; else &#123; DoublyListNode node = new DoublyListNode(key, value); map.put(key, node); add(node); currSize++; if (currSize &gt; capacity) &#123; map.remove(tail.prev.key); remove(tail.prev); currSize--; &#125; &#125; &#125; private void remove(DoublyListNode node) &#123; DoublyListNode prev = node.prev; prev.next = node.next; node.next.prev = prev; &#125; private void add(DoublyListNode node) &#123; DoublyListNode oldFirst = head.next; node.next = oldFirst; oldFirst.prev = node; head.next = node; node.prev = head; &#125; private void moveToFirst(DoublyListNode node) &#123; remove(node); add(node); &#125;&#125; 奇偶归一 对于任何一个数，如果是偶数的话就除以2，是奇数的话乘以3+1，最后这么算经过若干次运算总会变成1.给一个范围[m, n]，求其中所有数字算成1所需要的步数的最大值。 大概考察的是cache提速。从m开始计算，将所有中间过程遇到的数字都存入map。12345678910111213141516171819202122232425262728public class Solution &#123; public int maxStep(int m, int n) &#123; int ans = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = m; i &lt;= n; i++) &#123; ans = Math.max(getStep(map, i), ans); &#125; return ans; &#125; private int getStep(Map&lt;Integer, Integer&gt; map, int num) &#123; Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); while (num != 1 &amp;&amp; !map.containsKey(num)) &#123; q.add(num); if (num % 2 == 1) &#123; num = num * 3 + 1; &#125; else &#123; num /= 2; &#125; &#125; int base = map.get(num); int ret = base + q.size(); while (!q.isEmpty()) &#123; map.put(q.peek(), base + q.size()); q.poll(); &#125; return ret; &#125;&#125; 215. kth-largest-element-in-an-array 求一个无序的int数组，经过排序后的第k个大的元素。 ME：立刻想到了quickSort的应用，写出来是这样。我在这里用的是『以首元素为pivot』，而不是之前一直写的『以中间元素为pivot』的快排，不太熟悉，参考了princeton课件。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Solution &#123; public int findKthLargest(int[] nums, int k) &#123; if (nums == null || nums.length == 0 || k &lt; 1 || k &gt; nums.length) &#123; return 0; &#125; return quickSort(nums, 0, nums.length - 1, k); &#125; private int quickSort(int[] nums, int start, int end, int k) &#123; if (start &gt;= end) &#123; return nums[start]; &#125; int pivot = nums[start], left = start, right = end + 1; while (left &lt; right) &#123; while (nums[++left] &lt; pivot) &#123; if (left == end) &#123; break; &#125; &#125; while (nums[--right] &gt; pivot) &#123; if (right == start) &#123; break; &#125; &#125; if (left &lt; right) &#123; swap(nums, left, right); &#125; &#125; swap(nums, start, right); int currK = end + 1 - right; // 如果是求第k小的就不用这样转一下了 if (currK == k) &#123; return nums[right]; &#125; else if (k &gt; currK) &#123; return quickSort(nums, start, right - 1, k - currK); &#125; else &#123; return quickSort(nums, right + 1, end, k); &#125; &#125; private void swap(int[] nums, int i, int j) &#123; if (i == j) &#123; return; &#125; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125;&#125; TA：这个是一个总结，可以使用Java内置的priorityQueue（其实就是小根堆），将原数组的每个元素插入进去，始终维持规模为K，最后剩下的队首就是了。1234567891011public int findKthLargest(int[] nums, int k) &#123; final PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(); // 第k小就反过来排序就好了 for(int val : nums) &#123; pq.offer(val); if(pq.size() &gt; k) &#123; pq.poll(); &#125; &#125; return pq.peek();&#125; 692. top-k-frequent-words 给一个String数组，求出现频率top k的字符串。 跟347类似。先用Map存每个单词出现的频数，再自定义根据频数minHeap存这些Map.Entry，然后每次都check堆的规模，一旦大于k就直接把最小的poll出来，这样就保证在minHeap中的一定是top k.最后就直接逆序插入结果List。 123456789101112131415161718192021222324252627282930313233class Solution &#123; public List&lt;String&gt; topKFrequent(String[] words, int k) &#123; List&lt;String&gt; ans = new ArrayList&lt;&gt;(); if (words == null || words.length == 0 || k == 0) &#123; return ans; &#125; // 统计每个单词出现的频数 Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); for (String word : words) &#123; if (!map.containsKey(word)) &#123; map.put(word, 1); &#125; else &#123; map.put(word, map.get(word) + 1); &#125; &#125; // 将entry按照频数从小到大插入PQ，若规模&gt;k则直接poll掉最小的 PriorityQueue&lt;Map.Entry&lt;String, Integer&gt;&gt; pq = new PriorityQueue&lt;&gt;((a, b) -&gt; &#123; return a.getValue() != b.getValue()? a.getValue() - b.getValue() : b.getKey().compareTo(a.getKey()); &#125;); for (Map.Entry&lt;String, Integer&gt; e : map.entrySet()) &#123; pq.offer(e); if (pq.size() &gt; k) &#123; pq.poll(); &#125; &#125; // 取PQ元素，逆序插入结果 while (!pq.isEmpty()) &#123; ans.add(0, pq.poll().getKey()); &#125; return ans; &#125;&#125; follow-up：如果给定的输入不是一个完整的数组，而是一个stream，即每次都只能取得一个单词，然后立即返回top k，如何改进？ 关键在于无法在最开始就获得完整的频数统计Map，在插入minHeap的时候就无法知道后续的Entry需不需要覆盖PQ中的值。因此需要一个额外的Map记录具体那些Entry目前被存放在minHeap中；当新的单词出现，就先更新map中的项，然后再看看它是否在PQ中，在则需要更新（我只能想到把k个元素全抖出来再加进去），不在则跟minHeap的peek比较决定是否需要替换。这样时间是O(N)的统计频数、O(logN)的插入minHeap、O(KlogK)的更新(?)和最后O(K)的倒入List。 437. path-sum-iii 给一个二叉树，给一个目标值sum，求有几条从上往下累加的路径之和等于sum。 递归DFS，每次深入之前都先减掉当前节点的值。但这样子的时间复杂度是O(N^2)。 123456789101112131415class Solution &#123; public int pathSum(TreeNode root, int sum) &#123; // calculate path num starting from root if (root == null) &#123; return 0; &#125; return dfs(root, sum) // taking the given node + pathSum(root.left, sum) + pathSum(root.right, sum); // start from left/right child &#125; private int dfs(TreeNode node, int target) &#123; // dig to find path num taking current node if (node == null) &#123; return 0; &#125; return (node.val == target? 1 : 0) + dfs(node.left, target - node.val) + dfs(node.right, target - node.val); &#125;&#125; 更高效的做法是利用Map做cache将中间算出来的结果暂存起来。在每一步DFS过程中，先累积当前节点的val到currSum，然后求(currSum - target)在map中是否有记录。然后就是往左右孩子递归求多少种ways。 12345678910111213141516171819class Solution &#123; public int pathSum(TreeNode root, int sum) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); map.put(0, 1); return getPath(root, 0, sum, map); &#125; private int getPath(TreeNode root, int currSum, int target, Map&lt;Integer, Integer&gt; map) &#123; if (root == null) &#123; return 0; &#125; currSum += root.val; int ways = map.getOrDefault(currSum - target, 0); // 为什么是currSum - target map.put(currSum, map.getOrDefault(currSum, 0) + 1); // ways += getPath(root.left, currSum, target, map) + getPath(root.right, currSum, target, map); map.put(currSum, map.get(currSum) - 1); return ways; &#125;&#125; 322. coin-change 给一个数组表示有哪些面值的硬币，然后给一个目标值，求最少用多少枚硬币能达到的这个目标值。 ME：这个很明显的DP，所以我会做，写出来是这样。思路是从前往后更新DP数组，一开始全部初始化为-1表示不可达，dp[i]表示面值为i需要多少枚硬币，显然dp[0]应为0。对coin面值数组排序保证从小到大排列，然后开始从1更新。若i - coin[j] &gt;= 0说明可以从该状态加一枚coin[j]的硬币到达状态i，更新之，否则就可以直接跳出内层循环了，因为再往后看其他面值的coin只会负得更多。最后取dp[amount]即得。 12345678910111213141516171819202122232425public class Solution &#123; public int coinChange(int[] coins, int amount) &#123; if (coins == null || coins.length == 0) &#123; return 0; &#125; Arrays.sort(coins); // 从小到大取硬币 int[] dp = new int [amount + 1]; Arrays.fill(dp, -1); // 初始化为-1表示无解 dp[0] = 0; for (int i = 1; i &lt; dp.length; i++) &#123; // 从前往后更新每一个可能的值 for (int j = 0; j &lt; coins.length; j++) &#123; // 从小的面值开始更新 int index = i - coins[j]; if (index &gt;= 0) &#123; if (dp[index] &gt;= 0) &#123; dp[i] = dp[i] &lt; 0? dp[index] + 1: Math.min(dp[i], dp[index] + 1); &#125; &#125; else &#123; break; &#125; &#125; &#125; return dp[amount]; &#125;&#125; TA：我的是Bottom-up的DP，从无到有累积到目标值。还有一种Top-down的思路，利用递归来直接从目标值往回减。递归的结束条件有两种，一个是target减完变成了负数，则不存在，返回0；若target恰好是0，那么直接返回0表示不需要额外添加硬币；还有就是如果在之前的结果中已经计算出了DP的值，直接返回即可。否则就逐个取出coin面值，然后用当前target减去这个面值递归到下一层去看需要多少枚硬币，该结果如果存在，则加一即为当前target所需的硬币数。需要尝试所有面值的硬币来找到最小值。模仿出来是这样。 1234567891011121314151617181920212223242526272829public class Solution &#123; public int coinChange(int[] coins, int amount) &#123; if (coins == null || coins.length == 0) &#123; return 0; &#125; return helper(coins, amount, new int [amount]); &#125; private int helper(int[] coins, int target, int[] dp) &#123; if (target &lt; 0) &#123; return -1; // 硬币用过头了，不能继续 &#125; if (target == 0) &#123; return 0; // 不需要新的硬币了，直接返回 &#125; if (dp[target - 1] != 0) &#123; return dp[target - 1]; &#125; // 找到 int min = Integer.MAX_VALUE; for (int coin: coins) &#123; int temp = helper(coins, target - coin, dp); // 当前target减去硬币面额需要多少枚 if (temp &gt;= 0) &#123; min = Math.min(temp + 1, min); &#125; &#125; dp[target - 1] = min == Integer.MAX_VALUE? -1: min; // -1表示凑不出 return dp[target - 1]; &#125;&#125; 238. product-of-array-except-self 给一个数组num[]，求对应长度的数组使得output[i]为所有数的积除了num[i]，要求O(N)且不能用除法。 ME：不给我用除法我整个人是懵逼的，脑子一下转不过来，陷入江局。。。 TA：这个给出了如何从辅助数组到O(1)space的思考过程。首先这个辅助数组的方法我怎么就想不出来呢，left数组从左开始每一格存储的是『除了当前数字的前面数字之积』，right数组从右开始存储的是『除了当前数字的后续数字之积』，然后再来一波对应把left和right乘起来就得到了『除了当前数字前面和后面数字之积』。这怎么能想不到呐？？写出来是这样。 1234567891011121314151617181920212223public class Solution &#123; public int[] productExceptSelf(int[] nums) &#123; if (nums == null || nums.length &lt; 1) &#123; return new int [0]; &#125; int[] ans = new int [nums.length]; int[] left = new int [nums.length]; int[] right = new int [nums.length]; left[0] = 1; for (int i = 1; i &lt; nums.length; i++) &#123; left[i] = left[i - 1] * nums[i - 1]; &#125; right[nums.length - 1] = 1; for (int i = nums.length - 2; i &gt;= 0; i--) &#123; right[i] = right[i + 1] * nums[i + 1]; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; ans[i] = left[i] * right[i]; &#125; return ans; &#125;&#125; 至于从O( N )到O( 1 )的空间复杂度，知道了之后也没啥了，以后再碰到尽量想起来吧。既然每一个地方都需要用到它左边所有项之积和右边所有项之积，而如果只维护left和right两个值，无法在循环到第一位的时候就获得右边所有数的积，怎么办？答主的做法是在一步循环里，对两端进行更新，也就是每个位置会被更新两次，一次是随left更新，一次是随right更新，left和right就分别从左和从右向另一端去乘。妙哉！如果把这个one-pass拆开来写，就是这样的. 123456789101112public int[] productExceptSelf(int[] nums) &#123; int[] result = new int[nums.length]; for (int i = 0, tmp = 1; i &lt; nums.length; i++) &#123; result[i] = tmp; tmp *= nums[i]; &#125; for (int i = nums.length - 1, tmp = 1; i &gt;= 0; i--) &#123; result[i] *= tmp; tmp *= nums[i]; &#125; return result;&#125; 正则 10 输入两个字符串，写个支持.和*的正则表达式判断的method。 目标字符串s和正则字符串p之间相互比较，就需要维护一个boolean的二维数组dp[i][j]，表示s[0~i-1]与p[0~j-1]是否匹配。1234567891011121314151617181920212223242526272829303132class Solution &#123; public boolean isMatch(String s, String p) &#123; if (s == null || p == null || s.equals(p)) &#123; return true; &#125; char[] sChar = s.toCharArray(), pChar = p.toCharArray(); int m = sChar.length, n = pChar.length; boolean[][] dp = new boolean [m + 1][n + 1]; // initial the dp states dp[0][0] = true; for (int j = 2; j &lt;= n; j++) &#123; dp[0][j] = pChar[j - 1] == '*' &amp;&amp; dp[0][j - 2]; &#125; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (pChar[j - 1] == '*') &#123; // check if ignoring curr pattern // OR (the char is matched AND ignoring curr pattern) dp[i][j] = (dp[i][j - 2]) || ((sChar[i - 1] == pChar[j - 2] || pChar[j - 2] == '.') &amp;&amp; dp[i - 1][j]); &#125; else &#123; // check if char is matched for curr pattern dp[i][j] = dp[i - 1][j - 1] &amp;&amp; (sChar[i - 1] == pChar[j - 1] || pChar[j - 1] == '.'); &#125; &#125; &#125; return dp[m][n]; &#125;&#125; 4. Median of 2 sorted arrays 给两个int数组，返回二者合并后的中位数。 朴素的做法，逐个merge，然后分奇数、偶数求中位数。注意这里需要返回的是double。时间复杂度Linear,O((m + n)/2)。 1234567891011121314151617181920212223242526272829303132333435public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int len_total = nums1.length + nums2.length; int len_total_half = len_total &gt;&gt; 1; int[] merged = new int [len_total]; int i = 0, j = 0, len = 0; boolean finished = false; while (!finished &amp;&amp; i &lt; nums1.length &amp;&amp; j &lt; nums2.length) &#123; if (nums1[i] &lt; nums2[j]) &#123; merged[len++] = nums1[i++]; &#125; else &#123; merged[len++] = nums2[j++]; &#125; if (len &gt; len_total_half) &#123; finished = true; &#125; &#125; while (!finished &amp;&amp; i &lt; nums1.length) &#123; merged[len++] = nums1[i++]; if (len &gt; len_total_half) &#123; finished = true; &#125; &#125; while (!finished &amp;&amp; j &lt; nums2.length) &#123; merged[len++] = nums2[j++]; if (len &gt; len_total_half) &#123; finished = true; &#125; &#125; if (len_total % 2 == 1) &#123; return merged[len_total_half]; &#125; else &#123; return (double)((merged[len_total_half] + merged[len_total_half-1])/2.0); &#125; follow-up：要求在O(log(m+n))的时间复杂度以内？ 中位数可以把有序数组分成等长的两部分，因此在数组1取i个元素、数组2取j个元素，使得i + j == 剩余数字个数并且满足大小关系1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; if (nums1 == null || nums2 == null) &#123; return 0; &#125; int m = nums1.length, n = nums2.length; if (nums1.length &gt; nums2.length) &#123; // ensure the len of 1 &lt;= 2 return findMedianSortedArrays(nums2, nums1); &#125; // to ensure equality of the two parts after merged, i + j = m - i + n - j int iLo = 0, iHi = m, allMid = (n + m + 1) / 2; // odd: i = j, even: i = j - 1 // i stands for "how many num taken from nums1 as front part" 0 ~ i-1 | i ~ m-1 // j stands for "how many num taken from nums2 as front part" 0 ~ j-1 | j ~ n-1 while (iLo &lt;= iHi) &#123; int i = (iLo + iHi) / 2, j = allMid - i; // nums1[i-1], nums2[j-1] are the largest element of front part of nums1, nums2 // nums1[i], nums2[j] are the smallest of lag part of nums1, nums2 if (i &lt; m &amp;&amp; nums2[j - 1] &gt; nums1[i]) &#123; // i not big enough iLo = i + 1; &#125; else if (i &gt; 0 &amp;&amp; nums1[i - 1] &gt; nums2[j]) &#123; iHi = i - 1; &#125; else &#123; int maxLeft = 0, minRight = 0; if (i == 0) &#123; maxLeft = nums2[j - 1]; &#125; else if (j == 0) &#123; maxLeft = nums1[i - 1]; &#125; else &#123; maxLeft = Math.max(nums1[i - 1], nums2[j - 1]); &#125; if ((m + n) % 2 == 1) &#123; // I think thats why to make (allMid = (n + m + 1)/2) return maxLeft; // -- to make left part always at least no fewer than right &#125; if (i == m) &#123; minRight = nums2[j]; &#125; else if (j == n) &#123; minRight = nums1[i]; &#125; else &#123; minRight = Math.min(nums1[i], nums2[j]); &#125; return (maxLeft + minRight) / 2.0; &#125; &#125; return 0;&#125; 5. Longest palindromic substring 给一个字符串，返回最长的回文子串（自对称）。 这个似乎也是暴力法，只是用了更优雅的方式——双指针分别扩展，而我的暴力法是双指针向中间合拢，扩展的方式在worst case下复杂度也是O( n^2 )。 123456789101112131415161718192021222324252627class Solution &#123; private int start, maxLen; public String longestPalindrome(String s) &#123; if (s == null || s.length() == 0) &#123; return ""; &#125; char[] sChar = s.toCharArray(); start = 0; maxLen = 1; for (int i = 0; i &lt; sChar.length; i++) &#123; expand(sChar, i, i); // odd expand(sChar, i, i + 1); // even &#125; return s.substring(start, start + maxLen); &#125; private void expand(char[] sChar, int left, int right) &#123; while (left &gt;= 0 &amp;&amp; right &lt; sChar.length &amp;&amp; sChar[left] == sChar[right]) &#123; left--; right++; &#125; if (maxLen &lt; right - left - 1) &#123; // warning start = left + 1; // warning not left maxLen = right - left - 1; // warning &#125; &#125;&#125; 这题也是典型的DP题，dp[i][j]表示字符串的substring[i, j] - inclusive是否自对称。当i、j对应位置的字符相等时，再看看它们所夹的i + 1、j - 1部分是否自对称即可。 1234567891011121314151617181920class Solution &#123; public String longestPalindrome(String s) &#123; if (s == null || s.length() == 0) &#123; return ""; &#125; int len = s.length(); boolean[][] dp = new boolean[len][len]; int maxLen = 1, start = 0; for (int right = 1; right &lt; len; right++) &#123; for (int left = right; left &gt;= 0; left--) &#123; dp[left][right] = s.charAt(left) == s.charAt(right) &amp;&amp; (right - left &lt; 2 || dp[left + 1][right - 1]); if (dp[left][right] &amp;&amp; right - left + 1 &gt; maxLen) &#123; maxLen = right - left + 1; start = left; &#125; &#125; &#125; return s.substring(start, start + maxLen); &#125;&#125; 3 sum 给一个数组，求其中所有的a, b, c使得a + b + c == 0123456789101112131415161718192021222324252627282930313233343536373839public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); if (nums == null || nums.length == 0) &#123; return ans; &#125; Arrays.sort(nums); for (int i = 0; i &lt; nums.length; i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; // 固定nums[i]用双指针找后面两个数b, c，使b + c == 0 - nums[i] int left = i + 1, right = nums.length - 1, target = 0 - nums[i]; while (left &lt; right) &#123; int sum = nums[left] + nums[right]; if (sum == target) &#123; List&lt;Integer&gt; currList = new ArrayList&lt;&gt;(); currList.add(nums[i]); currList.add(nums[left]); currList.add(nums[right]); ans.add(currList); left++; right++; while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) &#123; // 避免重复 left++; &#125; while (right &gt; left &amp;&amp; nums[right] == nums[right + 1]) &#123; // 避免重复 right++; &#125; &#125; else if (sum &lt; target) &#123; left++; &#125; else &#123; right--; &#125; &#125; &#125; return ans; &#125; 202. happy-number 给一个正整数，判断它是否Happy。所谓happy指的是求各位的数字的平方和，得到的是1则是happy，不是1就继续这样算平方和。不是happy的数会陷入循环。 ME：递归加Set标记是否轮回搞定。 12345678910111213141516171819202122232425public class Solution &#123; public boolean isHappy(int n) &#123; if (n &lt; 1) &#123; return false; &#125; HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(); return isHappy(n, set); &#125; private boolean isHappy(int n, HashSet&lt;Integer&gt; set) &#123; if (set.contains(n)) &#123; return false; &#125; set.add(n); int newN = 0; while (n != 0) &#123; int digit = n % 10; newN += digit * digit; n /= 10; &#125; if (newN == 1) &#123; return true; &#125; return isHappy(newN, set); &#125;&#125; TA：这个是Iterative版的set，利用set.add判断是否出现重复。这个借助Floyd Cycle Detection的答案更加妙，来源于快慢指针检测链表中是否有环，这里也是这样，fast是每次往后算两步，slow是一步。当fast到达了1说明是happy，如果fast追上了slow说明成环了。 1234567891011121314151617181920212223public class Solution &#123; public boolean isHappy(int n) &#123; int slow, fast = n; do &#123; slow = next(slow); fast = next(next(fast)); if (slow == 1 || fast == 1) &#123; return true; &#125; &#125; while (slow != fast); return false; &#125; public int next(int n) &#123; int result = 0; while (n &gt; 0) &#123; int remainder = n % 10; result += remainder * remainder; n /= 10; &#125; return result; &#125;&#125; sort array with only 0 and 1 对一个只含有0和1的数组排序。 前后双指针。 木桶排序。 string repetition 给一个String和重复次数N，返回重复这么多次的String。 naive的办法是O(N)，但其实可以O(logN)，就是每次循环时折半，拼接之前将原字符串拼一遍。12345678910111213141516171819public String repeat(String str, int num) &#123; if (num &lt;= 0) &#123; return ""; &#125; StringBuilder result = new StringBuilder(); StringBuilder sb = new StringBuilder(str); while (true) &#123; if ((num &amp; 1) != 0) &#123; result.append(sb); &#125; num /= 2; if (num == 0) &#123; break; &#125; sb.append(sb); &#125; return result.toString();&#125; 366. find-leaves-of-binary-tree 给一个二叉树，求一层层仰视时所能看到的节点，看完后删除这些节点后继续仰视下一层。注意不是层级遍历！ 其实就是利用高度的定义，对于每个节点对应地放到它所属的高度的位置即可。123456789101112131415161718class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; findLeaves(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); height(root, ans); return ans; &#125; private int height(TreeNode node, List&lt;List&lt;Integer&gt;&gt; ans) &#123; if (node == null) &#123; return -1; // 保证叶子节点高度为0 &#125; int h = 1 + Math.max(height(node.left, ans), height(node.right, ans)); // 当前节点的高度 = 左右较大者 + 1 if (ans.size() == h) &#123; // 叶子结点高度为0，索引也为0 ans.add(new ArrayList&lt;&gt;()); &#125; ans.get(h).add(node.val); return h; &#125;&#125; 513. find-bottom-left-tree-value 给一个二叉树，求最下面一层最左边的节点。 方法一：Iterative，从右往左进行层级遍历，最后一个遍历到的节点就是最下层的最左节点。 1234567891011121314151617class Solution &#123; public int findBottomLeftValue(TreeNode root) &#123; Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.offer(root); TreeNode curr = null; while (!q.isEmpty()) &#123; curr = q.poll(); if (curr.right != null) &#123; q.offer(curr.right); &#125; if (curr.left != null) &#123; q.offer(curr.left); &#125; &#125; return curr.val; &#125;&#125; 方法二：Recursive, 正常地从左到右前序遍历，但是会track深度，第一个达到新的深度的节点就一定是最左边的。 12345678910111213141516171819class Solution &#123; int ans = 0, h = 0; public int findBottomLeftValue(TreeNode root) &#123; find(root, 1); return ans; &#125; public void find(TreeNode root, int level) &#123; if (h &lt; level) &#123; ans = root.val; h = level; &#125; if (root.left != null) &#123; find(root.left, level + 1); &#125; if (root.right != null) &#123; find(root.right, level + 1); &#125; &#125;&#125; reverse LinkedList 反转一个链表。 Iterative: 用循环每次两两反转。 1234567891011121314public void reverseList(ListNode head) &#123; if (head == null || head.next == null) &#123; return head; &#125; ListNode prev = null, curr = head; while (curr != null) &#123; ListNode currNext = curr.next; curr.next = prev; prev = curr; curr = currNext; &#125; return prev;&#125; Recursive: 递归往后反转之后，当前节点的下一个节点就会变成最后一个节点，直接把当前节点拼到最后即可。 123456789public ListNode reverseList(ListNode head) &#123; if (head == null || head.next == null) &#123; return head; &#125; ListNode newHead = reverseList(head.next); head.next.next = head; head.next = null; return newHead;&#125; 186. reverse-words-in-a-string-ii 给一个char数组，反转单词出现顺序。I love programming变成programming love I。 先反转全部，再根据空格位置反转每个单词。12345678910111213141516171819202122232425class Solution &#123; public void reverseWords(char[] str) &#123; if (str == null || str.length == 0) &#123; return; &#125; reverse(str, 0, str.length - 1); int start = 0; for (int i = 0; i &lt; str.length; i++) &#123; if (str[i] == ' ') &#123; reverse(str, start, i - 1); start = i + 1; &#125; &#125; reverse(str, start, str.length - 1); &#125; private void reverse(char[] str, int start, int end) &#123; while (start &lt; end) &#123; char temp = str[start]; str[start] = str[end]; str[end] = temp; start++; end--; &#125; &#125;&#125; implement linkedhashmap HashMap：首先讨论普通的HashMap，底层其实就是Entry的数组(bucket)，根据hashCode找到bucket的存放位置，再根据equals判断key是否相等。每个Entry是一个节点，带有next引用，这样就可以形成一个链表了。 LinkedHashMap：与HashMap相比，需要维护put时的顺序，这里是通过加入before和after来构建双向链表，put时就可以进行赋值这样在remove的时候也可以O(1)完成。为了方便删除，也可以用dummy头部的方式简化操作。 implement priority queue priority queue类似于小根堆，需要保证根节点比两个孩子都小就行了。123456789101112131415161718192021222324252627282930313233343536373839404142private int createMinHeap(ListNode[] lists, int end) &#123; // end is inclusive if (end &lt; 0 || end &gt; lists.length) &#123; return -1; &#125; if (lists[0] == null) &#123; swap(lists, 0, end); if (--end &lt;= 0) &#123; return end; &#125; &#125; for (int i = (end - 1)/2; i &gt;= 0; i--) &#123; end = maintainMinHeap(lists, i, end); &#125; return end;&#125;private int maintainMinHeap(ListNode[] lists, int start, int end) &#123; if (lists[0] == null) &#123; swap(lists, 0, end); if (--end &lt;= 0) &#123; return end; &#125; &#125; int fatherIndex = start; while (fatherIndex &lt;= end) &#123; int smallerIndex = 2*fatherIndex + 1; if (smallerIndex &gt; end) &#123; break; &#125; else &#123; if (smallerIndex &lt; end &amp;&amp; lists[smallerIndex+1].val &lt; lists[smallerIndex].val) &#123; smallerIndex ++; &#125; if (lists[smallerIndex].val &lt; lists[fatherIndex].val) &#123; swap(lists, fatherIndex, smallerIndex); fatherIndex = smallerIndex; &#125; else &#123; break; &#125; &#125; &#125; return end;&#125; 572. subtree-of-another-tree 给两棵树，判断后者是不是前者的子树。子树指的是还有一个任意节点为根的子树，结构、数值完全一样。 递归搞定。先判断两个树是否相同，若相同直接就是子树了。若不同则需要到左右子树进行递归，判断t是否是左／右的子树。1234567891011121314151617181920class Solution &#123; public boolean isSubtree(TreeNode s, TreeNode t) &#123; if (s == null &amp;&amp; t == null) &#123; return true; &#125; if (s == null || t == null) &#123; return false; &#125; return isSame(s, t) ? true : isSubtree(s.left, t) || isSubtree(s.right, t); &#125; private boolean isSame(TreeNode s, TreeNode t) &#123; if (s == null &amp;&amp; t == null) &#123; return true; &#125; if (s == null || t == null) &#123; return false; &#125; return s.val == t.val ? isSame(s.left, t.left) &amp;&amp; isSame(s.right, t.right) : false; &#125;&#125; remove-duplicates-from-sorted-array 给一个已排好序的int数组，删除其中的重复项，返回长度。玛德我一开始以为只需要返回一个长度而不用对原数组开刀，还在想这题这么衣洗。题目说的leave beyond length是说该长度之后数组里是什么内容不关心，又不是说besides。。。1234567891011121314class Solution &#123; public int removeDuplicates(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; int len = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[len] != nums[i]) &#123; // lazy move len nums[++len] = nums[i]; // when num[i] is diff from nums[len] &#125; &#125; return ++len; // since last one cannot be compared to next different element &#125;&#125; remove-duplicates-from-sorted-array-ii 给一个排好序的int数组，对它进行操作使得其中任意元素至多出现两次，返回经过修改后的数组长度。至于该长度之后的内容怎样，并不在意。 定义窗口为2，判断当前数字和距离当前末尾往前两格的数字是否相等，不相等才能加入进来。12345678910111213141516public class Solution &#123; public int removeDuplicates(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; int n = nums.length; int i = 0; for (int num: nums) &#123; if (i &lt; 2 || num &gt; nums[i - 2]) &#123; nums[i] = num; i++; &#125; &#125; return i; &#125;&#125; 127. word-ladder 很图论的题，每一个单词看作节点，路径有无根据「能否改一个字母变成它」判断，在BFS过程中可达就直接入queue。 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Solution &#123; public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; if (beginWord == null || endWord == null || beginWord.length() == 0 || endWord.length() == 0 || beginWord.length() != endWord.length() || wordList == null || wordList.size() == 0) &#123; return 0; &#125; Set&lt;String&gt; wordSet = new HashSet&lt;&gt;(wordList); Queue&lt;String&gt; toVisit = new LinkedList&lt;&gt;(); bfs(beginWord, wordSet, toVisit); int dist = 2; while (!toVisit.isEmpty()) &#123; int size = toVisit.size(); for (int i = 0; i &lt; size; i++) &#123; String curr = toVisit.poll(); if (curr.equals(endWord)) &#123; return dist; &#125; else &#123; bfs(curr, wordSet, toVisit); &#125; &#125; dist++; &#125; return 0; &#125; private void bfs(String beginWord, Set&lt;String&gt; wordSet, Queue&lt;String&gt; toVisit) &#123; wordSet.remove(beginWord); StringBuilder sb = new StringBuilder(beginWord); for (int i = 0; i &lt; sb.length(); i++) &#123; char origin = sb.charAt(i); for (int k = 0; k &lt; 26; k++) &#123; char c = (char)('a' + k); sb.setCharAt(i, c); String curr = sb.toString(); if (wordSet.contains(curr)) &#123; toVisit.add(curr); wordSet.remove(curr); &#125; &#125; sb.setCharAt(i, origin); &#125; &#125;&#125; 126. word-ladder-ii 词典中每一个词都是一个node，要从起点到终点，如果要记录这些最短的路径具体是怎么走的，就需要在BFS判断可不可达并构建临街表的基础上再来一个DFS，从起点开始一直往后（不走回头路利用的是后出现的节点的距离一定是先经过的节点的距离+1），如果到了终点就把经过的路径存起来。最后形成的就是路径的列表了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384class Solution &#123; public List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; Set&lt;String&gt; wordSet = new HashSet&lt;&gt;(wordList); wordSet.add(beginWord); Map&lt;String, List&lt;String&gt;&gt; neighborMap = new HashMap&lt;&gt;(); Map&lt;String, Integer&gt; distanceMap = new HashMap&lt;&gt;(); List&lt;List&lt;String&gt;&gt; ans = new ArrayList&lt;&gt;(); bfs(beginWord, endWord, wordSet, neighborMap, distanceMap); dfs(beginWord, endWord, neighborMap, distanceMap, new Arraylist&lt;String&gt;(), ans); return ans; &#125; // 用BFS构建邻接表并维护离起点的距离 private void bfs(String beginWord, String endWord, Set&lt;String&gt; wordSet, Map&lt;String, List&lt;String&gt;&gt; neighborMap, Map&lt;String, Integer&gt; distanceMap) &#123; for (String word: wordSet) &#123; neighborMap.put(word, new ArrayList&lt;String&gt;()); &#125; Queue&lt;String&gt; q = new LinkedList&lt;&gt;(); q.add(beginWord); distanceMap.put(beginWord, 0); while (!q.isEmpty()) &#123; int size = q.size(); boolean reached = false; for (int i = 0; i &lt; size; i++) &#123; String currWord = q.poll(); int currDistance = distanceMap.get(currWord); List&lt;String&gt; neighborList = getNeighborList(currWord, wordSet); for (String neighbor: neighborList) &#123; neighborMap.get(currWord).add(neighbor); if (!distanceMap.containsKey(neighbor)) &#123; distanceMap.put(neighbor, currDistance + 1); if (neighbor.equals(endWord)) &#123; reached = true; &#125; else &#123; q.add(neighbor); &#125; &#125; &#125; &#125; if (reached) &#123; break; &#125; &#125; &#125; // 通过替换字母并判断是否在dict中产生给定词的邻居 private List&lt;String&gt; getNeighborList(String currWord, Set&lt;String&gt; wordSet) &#123; char[] cstr = currWord.toCharArray(); List&lt;String&gt; ret = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; cstr.length; i++) &#123; char origin = cstr[i]; for (char c = 'a'; c &lt;= 'z'; c++) &#123; if (c == origin) &#123; continue; &#125; cstr[i] = c; String temp = new String(cstr); if (wordSet.contains(temp)) &#123; ret.add(temp); &#125; &#125; cstr[i] = origin; &#125; return ret; &#125; // 从起点开始往它的邻居DFS private void dfs(String currWord, String endWord, Map&lt;String, List&lt;String&gt;&gt; neighborMap, Map&lt;String, Integer&gt; distanceMap, List&lt;String&gt; path, List&lt;List&lt;String&gt;&gt; ans) &#123; path.add(currWord); if (currWord.equals(endWord)) &#123; ans.add(new ArrayList&lt;String&gt;(path)); &#125; else &#123; int currDistance = distanceMap.get(currWord); List&lt;String&gt; neighborList = neighborMap.get(currWord); for (String neighbor: neighborList) &#123; if (distanceMap.get(neighbor) == currDistance + 1) &#123; dfs(neighbor, endWord, neighborMap, distanceMap, path, ans); &#125; &#125; &#125; path.remove(path.size() - 1); &#125;&#125; BST验证 常见的错误是直接greedy，只判断当前节点和孩子的大小。但BST的定义是比「所有的左子树都大、比右都小」。 方法一：中序遍历时每次都判断前后两个元素的大小关系。又分为recursive和iterative的。 12345678910111213141516171819202122232425262728293031323334353637 // recursive: 全局的prev记录当前节点前一个是谁，比较大小private TreeNode prev = null;private boolean validateBST1(TreeNode root) &#123; if (root == null) &#123; return true; &#125; if (!validateBST1(root.left)) &#123; return false; &#125; if (prev != null &amp;&amp; prev.val &gt;= root.val) &#123; return false; &#125; prev = root; return validateBST1(root.right);&#125; // iterative: 用stack不断深入左节点，直到空再将栈顶与prev比较，然后进入右子树，继续不断向左。private boolean validateBST2(TreeNode root) &#123; if (root == null) &#123; return true; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode prev = null; while (root != null || !stack.isEmpty()) &#123; while (root != null) &#123; stack.push(root); root = root.left; &#125; root = stack.pop(); if (prev != null &amp;&amp; prev.val &gt;= root.val) &#123; return false; &#125; prev = root; root = root.right; &#125; return true;&#125; 方法二：分治，为左右子树给定范围（min, max），在递归时更新左子树的上界、更新右子树的下界。 12345678910111213private boolean validateBST3(TreeNode root) &#123; return dvcq(root, Long.MIN_VALUE, Long.MAX_VALUE);&#125;private boolean dvcq(TreeNode root, long min, long max) &#123; if (root == null) &#123; return true; &#125; if (root.val &lt;= min || root.val &gt;= max) &#123; return false; &#125; return dvcq(root.left, min, Math.min(root.val, max)) &amp;&amp; dvcq(root.right, Math.max(root.val, min), max);&#125; 22. generate-parentheses 给一个int表示括号的对儿数，输出所有符合括号匹配规则的字符串，存入List中返回。123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; ans = new ArrayList&lt;&gt;(); if (n &lt; 1) &#123; return ans; &#125; dfs(n, 0, 0, "", ans); return ans; &#125; private void dfs(int n, int left, int right, String s, List&lt;String&gt; ans) &#123; if (left == n &amp;&amp; right == n) &#123; ans.add(s); return; &#125; if (left &lt; n) dfs(n, left + 1, right, s + "(", ans); if (right &lt; left) dfs(n, left, right + 1, s + ")", ans); &#125;&#125;class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;List&lt;String&gt;&gt; dp = new ArrayList&lt;&gt;(); if (n &lt; 1) &#123; return new ArrayList&lt;String&gt;(); &#125; dp.add(Arrays.asList("")); for (int i = 1; i &lt;= n; i++) &#123; List&lt;String&gt; curr = new ArrayList&lt;&gt;(); for (int j = 0; j &lt; i; j++) &#123; for (String first: dp.get(j)) &#123; for (String second: dp.get(i - 1 - j)) &#123; curr.add("(" + first + ")" + second); &#125; &#125; &#125; dp.add(curr); &#125; return dp.get(n); &#125;&#125; 袜子匹配 给一个数组表示袜子的编号，匹配到一双之后就输出，未匹配的最后输出。例如1, 3, 2, 1, 1, 2, 4输出1, 2, 3, 1, 4. 用LinkedHashSet维护插入Set的顺序。1234567891011121314public static List&lt;Integer&gt; matchSocks(List&lt;Integer&gt; socks) &#123; Set&lt;Integer&gt; set = new LinkedHashSet&lt;&gt;(); List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for (int sock : socks) &#123; if (set.contains(sock)) &#123; set.remove(sock); ans.add(sock); &#125; else &#123; set.add(sock); &#125; &#125; ans.addAll(set); return ans;&#125; 销售额统计 给一堆每一天的销售情况数据List，统计每一天销售最多货物的销售员，返回Map&lt;String, String&gt;，key是日期的字符串，value是售货员名字. 从List中提取信息，对于每一天维护一个Map&lt;String, Set&lt;Seller&gt;&gt;，每一个Seller中有名字和count，此外还需要维护一个当天的最大值max的Map&lt;String, Integer&gt;，如果插入时发现count比max大就更新一波。 Vending machine 设计自动售货机。用户put required money or more, 给它相应的物品以及显示余额；用户didnt put enough money, 不给物品，显示商品所需实际价格。 不知道具体是什么要求，如果只是判断钱够不够感觉只需要在一个方法里面放一个if就行了啊。1234567891011121314151617181920212223class Item &#123; String id; double price; int count;&#125;class VendingMachine &#123; private Map&lt;String, Item&gt; itemMap; public VendingMachine(Map&lt;String, Item&gt; itemMap) &#123; this.itemMap = itemMap; &#125; public void putMoney(String itemId, double inputPrice) &#123; Item item = itemMap.get(itemId); if (item.count == 0) &#123; // 没了 return; &#125; if (inputPrice &gt; item.price) &#123; // 显示余额 &#125; else &#123; // 钱不够 &#125; &#125;&#125;]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>algorithm</tag>
        <tag>interview</tag>
        <tag>groupon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Note for LeetCode in Java (401~800)]]></title>
    <url>%2F2018%2F01%2F05%2Fjava_leetcode5%2F</url>
    <content type="text"><![CDATA[刷题。祝我好运。 403. frog-jump 给一个数组表示石头所处的x坐标，青蛙每次只能跳上一次跳跃长度的-1,0,1三种可能，判断能否跳到最后一个石头。例如[0,1,3,5,6,8,12,17]是可以的，而[0,1,2,3,4,8,9,11]就不行。 相当于BFS，每个石头处维护一个set存放他可以跳的长度，然后每次都往后跳看看能否有新的石头，有就更新那个石头的可跳长度。12345678910111213141516171819202122232425262728293031323334353637// BFS，从开头出发，不断更新后续可达石头的新步数，若中途更新到了最后一个石头，就可达public boolean canCross(int[] stones) &#123; if (stones == null || stones.length == 0) &#123; return true; &#125; if (stones[0] != 0) &#123; return false; &#125; // 记录每个坐标的石头所能跳的长度 Map&lt;Integer, Set&lt;Integer&gt;&gt; stone2step = new HashMap&lt;&gt;(); for (int i = 0; i &lt; stones.length; i++) &#123; stone2step.put(stones[i], new HashSet&lt;&gt;()); &#125; stone2step.get(0).add(1); // 第一步起码要能往后挪一步 // 从第一个石头开始，往后更新每个石头的能跳步数 for (int i = 0; i &lt; stones.length; i++) &#123; int currStone = stones[i]; Set&lt;Integer&gt; steps = stone2step.get(currStone); for (int step: steps) &#123; int newStone = currStone + step; if (newStone == stones[stones.length - 1]) &#123; return true; &#125; Set&lt;Integer&gt; newStep = stone2step.get(newStone); if (newStep != null) &#123; // 表示有这个新石头的坐标 newStep.add(step + 1); newStep.add(step); if (step - 1 &gt; 0) &#123; newStep.add(step - 1); &#125; &#125; &#125; &#125; return false;&#125; 404. sum-of-left-leaves 给一个数，求所有左叶子的和。 递归求，只有是左孩子且是叶子才返回node.val。1234567891011121314class Solution &#123; public int sumOfLeftLeaves(TreeNode root) &#123; return sumOfLeftLeaves(root, false); &#125; private int sumOfLeftLeaves(TreeNode node, boolean isLeft) &#123; if (node == null) &#123; return 0; &#125; if (node.left == null &amp;&amp; node.right == null) &#123; return isLeft ? node.val : 0; &#125; return sumOfLeftLeaves(node.left, true) + sumOfLeftLeaves(node.right, false); &#125;&#125; 405. convert-a-number-to-hexadecimal 将数字转换为十六进制字符串。 方法一：利用mask每次只取最后四个bit，然后直接map到字符拼接到hexStr的最前面，然后unsigned shift四位。 12345678910111213final private char[] map = &#123;'0', '1', '2', '3','4','5','6','7','8','9','a','b','c','d','e','f'&#125;;final private int mask = 15;public String toHex(int num) &#123; if (num == 0) &#123; return "0"; &#125; String hexStr = ""; while (num != 0) &#123; hexStr = map[(num &amp; mask)] + hexStr; num = (num &gt;&gt;&gt; 4); // 不保留最高位 &#125; return hexStr;&#125; 方法二：更general的做法，可以推广到十进制转任意进制字符串。不过首先需要转成long并且过滤掉long前面填充的一堆符号位，然后取模得到的就是当前位的数值，直接map到字符；然后继续除。 12345678910111213final private char[] map = &#123;'0', '1', '2', '3','4','5','6','7','8','9','a','b','c','d','e','f'&#125;;public String toHex(int num) &#123; if (num == 0) &#123; return "0"; &#125; long longNum = num &amp; 0x00000000ffffffffL; // 不能直接强制转换，不然会保留符号 String hexStr = ""; while (longNum != 0) &#123; hexStr = map[(int)(longNum % 16)] + hexStr; longNum /= 16; &#125; return hexStr;&#125; 410. split-array-largest-sum 给一个只含有非负整数的int数组和一个subArray数目m，将这个数组分成m个连续subarray，求他们的最大值最小是多少。 方法一：在学c++时老师讲过，最大值最小化，经典二分查找问题。一波流求最大值和sum分别作为下界和上界，然后进行二分查找，mid作为targetSum，即如果每个subarray都不超过这个targetSum需要划分成多少个子数组，如果多了说明targetSum太小，需要往前收缩；注意需要尽量biase到尽可能小的targetSum，联想到求first occurance的二分查找。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123; public int splitArray(int[] nums, int m) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; // 最大值为下界、和为上界进行二分查找 long sum = 0; int max = 0; for (int num : nums) &#123; sum += num; max = Math.max(max, num); &#125; long start = max - 1, end = sum + 1; while (end - start &gt; 1) &#123; long mid = start + (end - start) / 2; int count = getSubarrayCount(nums, mid); if (count &lt;= m) &#123; // 当前的targetSum太大导致subarray个数过少 end = mid; // biase to front &#125; else &#123; start = mid; &#125; &#125; return (int)end; &#125; private int getSubarrayCount(int[] nums, long targetSum) &#123; int count = 0; long sum = 0; for (int i = 0; i &lt; nums.length; i++) &#123; long tempSum = sum + nums[i]; if (tempSum &lt; targetSum) &#123; sum = tempSum; &#125; else &#123; if (tempSum == targetSum) &#123; sum = 0; // 恰好相等，则归零 &#125; else &#123; sum = nums[i]; &#125; count++; &#125; &#125; if (sum != 0) &#123; count++; &#125; return count; &#125;&#125; 方法二：DP。。。 412. FizzBuzz 根据是否为3、5的倍数输出指定的字符串。skip。 416. partition-equal-subset-sum 给一个只含有正数的int数组，判断是否可以划分成两个和相等的数组。 和698类似的暴力做法，直接遍历找所有可能的组合。 12345678910111213141516171819202122232425262728293031class Solution &#123; public boolean canPartition(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return false; &#125; int sum = IntStream.of(nums).sum(); Arrays.sort(nums); if (nums[nums.length - 1] &gt; sum / 2) &#123; return false; &#125; return sum % 2 == 0 &amp;&amp; canPartition(nums, new boolean[nums.length], sum / 2, 0); &#125; private boolean canPartition(int[] nums, boolean[] visited, int targetSum, int currSum) &#123; if (currSum &gt; targetSum) &#123; return false; &#125; if (currSum == targetSum) &#123; return true; &#125; for (int i = nums.length - 1; i &gt;= 0; i--) &#123; if (!visited[i]) &#123; visited[i] = true; if (canPartition(nums, visited, targetSum, currSum + nums[i])) &#123; return true; &#125; visited[i] = false; &#125; &#125; return false; &#125;&#125; 其实这题想考察的是DP。dp[i][j]表示i个数组成的和为j，期中这i个数不是全部都取。对于dp[i][j]来说如果不取第i个数（对应索引为i - 1），则直接来自dp[i - 1][j]；如果取了第i个数，则是从dp[i - 1][j - nums[i - 1]]转移过来。 12345678910111213141516171819202122232425class Solution &#123; public boolean canPartition(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return false; &#125; int sum = IntStream.of(nums).sum(); if ((sum &amp; 1) == 1) &#123; return false; &#125; sum /= 2; boolean[][] dp = new boolean[nums.length + 1][sum + 1]; for (int i = 0; i &lt;= nums.length; i++) &#123; dp[i][0] = true; &#125; for (int i = 1; i &lt;= nums.length; i++) &#123; for (int j = 1; j &lt;= sum; j++) &#123; dp[i][j] = dp[i - 1][j]; // 假设不取nums[i - 1]到达当前位置 if (j &gt;= nums[i - 1]) &#123; // 防止数组越界 dp[i][j] = dp[i][j] || dp[i - 1][j - nums[i - 1]]; // 这里只用了前一行，因此其实dp只用一维数组也够了 &#125; &#125; &#125; return dp[nums.length][sum]; &#125;&#125; 419. battleships-in-a-board 给一个二维char数组，其中含有.和X字符，X表示船，船只会横或者竖着放，船之间至少有一个.。求船的个数。 直接算「第一个」出现的X，即左边和上面都不是X的。 424. longest-repeating-character-replacement 给一个仅包含大写字母的字符串，再给一个k，表示假设可以有k次机会将其中的某些字母任意变成另一个字母，返回最长的相同字母的substring的长度。例如ABAB变2次，最长长度为4（AAAA）；AAABAABB变1次，为6. 这个替换是一一对应的吗？（不是，可以任意换成需要的字符。也就是可以多对一） 双指针 + producer/consumer的方法，快指针先往后求各个字母的计数，同时更新一个出现最多的字母的频数maxCount。当前后两指针所夹字母数大于了maxCount + k，说明已经超过了可以替换的数目，此时就需要挪慢指针来consume计数。至于为什么不需要每次都保持最精确的maxCount，因为我们只关心最大的，当前最大的挪出窗口后，计数肯定是减掉的，那么后续再出现的时候，不会错误地产生更大的计数，最大值再大也大不过历史峰值。解释来自这里.1234567891011121314151617181920class Solution &#123; public int characterReplacement(String s, int k) &#123; if (s == null || s.length() == 0) &#123; return 0; &#125; int[] count = new int [26]; char[] sChar = s.toCharArray(); int start = 0, maxCount = 0, maxLen = 0; for (int end = 0; end &lt; sChar.length; end++) &#123; maxCount = Math.max(maxCount, ++count[sChar[end] - 'A']); // 更新最多的字母的频数 while (end - start + 1 &gt; k + maxCount) &#123; // 指针覆盖的字母过多 count[sChar[start] - 'A']--; // 挪动慢指针，并consume掉计数 start++; // 注意并不需要重置maxCount，因为当前这样求出来的就是最大的，只有当新的字符超过了历史最大的maxCount才会有更长的长度需要更新 &#125; maxLen = Math.max(maxLen, end - start + 1); &#125; return maxLen; &#125;&#125; 425. word-squares 给一个wordList，将List中的String放入matrix中使得行、列的单词都来自于这个List。 Trie + DFS，对于每个Trie节点，除了正常的nexts数组、isWord布尔值，额外维护一个List保存以「到达当前TrieNode路径」为prefix的所有word。固定一个word之后，下一个词的prefix可以通过纵向append得到，具体规律见这个discussion.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class Solution &#123; class TrieNode &#123; TrieNode[] nexts; List&lt;String&gt; prefixWords; boolean isWord; public TrieNode() &#123; nexts = new TrieNode[26]; prefixWords = new ArrayList&lt;&gt;(); isWord = false; &#125; &#125; class Trie &#123; TrieNode root; public Trie(String[] words) &#123; root = new TrieNode(); for (String word : words) &#123; TrieNode curr = root; for (int i = 0; i &lt; word.length(); i++) &#123; int index = word.charAt(i) - 'a'; if (curr.nexts[index] == null) &#123; curr.nexts[index] = new TrieNode(); &#125; curr.prefixWords.add(word); curr = curr.nexts[index]; &#125; curr.isWord = true; &#125; &#125; public List&lt;String&gt; getByPrefix(String prefix) &#123; List&lt;String&gt; ans = new ArrayList&lt;&gt;(); TrieNode curr = root; for (int i = 0; i &lt; prefix.length(); i++) &#123; int index = prefix.charAt(i) - 'a'; if (curr.nexts[index] == null) &#123; return ans; &#125; curr = curr.nexts[index]; &#125; ans.addAll(curr.prefixWords); return ans; &#125; &#125; private void dfs(int len, Trie trie, List&lt;List&lt;String&gt;&gt; ans, List&lt;String&gt; curr) &#123; if (curr.size() == len) &#123; ans.add(new ArrayList&lt;&gt;(curr)); return; &#125; int index = curr.size(); StringBuilder prefix = new StringBuilder(); for (String s : curr) &#123; prefix.append(s.charAt(index)); &#125; List&lt;String&gt; candidates = trie.getByPrefix(prefix.toString()); for (String candidate : candidates) &#123; curr.add(candidate); dfs(len, trie, ans, curr); curr.remove(curr.size() - 1); &#125; &#125; public List&lt;List&lt;String&gt;&gt; wordSquares(String[] words) &#123; List&lt;List&lt;String&gt;&gt; ans = new ArrayList&lt;&gt;(); if (words == null || words.length == 0) &#123; return ans; &#125; int len = words[0].length(); Trie root = new Trie(words); List&lt;String&gt; curr = new ArrayList&lt;&gt;(); for (String word : words) &#123; curr.add(word); dfs(len, root, ans, curr); curr.remove(curr.size() - 1); &#125; return ans; &#125;&#125; 426. convert-binary-search-tree-to-sorted-doubly-linked-list 给一个BST，将它转换成排好序的循环双向链表（头尾相接），返回头部。可以把左右孩子就看作是当前节点的前后链表节点，不需要额外搞ListNode类。 BST要维持顺序，那就是用中序遍历。利用全局变量prev来记录每一个子树的结尾节点，先build左子树，然后把当前节点拼到prev的后面，再去继续build右子树即可。 123456789101112131415161718192021222324private Node prev = null;public Node treeToDoublyList(Node root) &#123; if (root == null) &#123; return null; &#125; Node dummy = new Node(); // 伪头部的next就是head prev = dummy; buildDoublyList(root); prev.right = dummy.right; dummy.right.left = prev; dummy.left = dummy.right = null; // 清理dummy return prev.right;&#125;// 执行buildDoublyList后会将node下面的部分都形成双向链表public void buildDoublyList(Node node) &#123; if (node == null) &#123; return; &#125; buildDoublyList(node.left); // 先对左子树build一下，prev会指向最后一个节点 prev.right = node; // 将node拼进去 node.left = prev; prev = node; // 左半部分+当前节点的结尾就是node buildDoublyList(node.right);// 继续build右子树&#125; 方法二：分治法。先把左右子树的循环双向链表build好，再把当前节点塞到中间，同时把新的前后循环连接一下。注意在分别build的时候，需要把root本身设一个自循环，这样就可以重复使用connect方法了。 12345678910111213141516171819202122232425public Node treeToDoublyList(Node root) &#123; if (root == null) &#123; return null; &#125; Node leftHead = treeToDoublyList(root.left); Node rightHead = treeToDoublyList(root.right); root.left = root; root.right = root; return connect(connect(leftHead, root), rightHead);&#125;public Node connect(Node leftHead, Node rightHead) &#123; if (leftHead == null) &#123; return rightHead; &#125; if (rightHead == null) &#123; return leftHead; &#125; Node leftTail = leftHead.left; Node rightTail = rightHead.left; leftTail.right = rightHead; rightHead.left = leftTail; leftHead.left = rightTail; rightTail.right = leftHead; return leftHead;&#125; 437. path-sum-iii 给一个二叉树，给一个目标值sum，求有几条从上往下累加的路径之和等于sum。 递归DFS，每次深入之前都先减掉当前节点的值。123456789101112131415class Solution &#123; public int pathSum(TreeNode root, int sum) &#123; // calculate path num starting from root if (root == null) &#123; return 0; &#125; return dfs(root, sum) // taking the given node + pathSum(root.left, sum) + pathSum(root.right, sum); // start from left/right child &#125; private int dfs(TreeNode node, int target) &#123; // dig to find path num taking current node if (node == null) &#123; return 0; &#125; return (node.val == target? 1 : 0) + dfs(node.left, target - node.val) + dfs(node.right, target - node.val); &#125;&#125; 438. find-all-anagrams-in-a-string 给一个字符串s和一个字符串p，求s中所有p的anagram子串的起始位置的List。 双指针 + producer/consumer的方法，map中存放p中每个字符及其对应出现的次数，快指针负责consume直到没有可用的字符（只需要管map中有的字符），这时看看快慢指针所夹字符的个数是否等于p；之后就挪动慢指针provide补回字符。123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; // O(N)双指针。先一波流统计p中各个字符出现的频数，然后consume掉map中的字符直到没有available的 // 此时判断左右指针之间长度是否等于目标的长度，然后挪动左指针重新往map中加回去，直到出现可选字符 public List&lt;Integer&gt; findAnagrams(String s, String p) &#123; List&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;(); if (s == null || p == null || s.length() == 0 || p.length() == 0) &#123; return ans; &#125; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); char[] pChar = p.toCharArray(); int pLen = pChar.length; for (char c: pChar) &#123; map.put(c, map.getOrDefault(c, 0) + 1); &#125; char[] sChar = s.toCharArray(); int count = map.size(); // 还有count个不同的字符可选 int left = 0, right = 0; while (right &lt; sChar.length) &#123; if (map.containsKey(sChar[right])) &#123; map.put(sChar[right], map.get(sChar[right]) - 1); if (map.get(sChar[right]) == 0) &#123; count--; // 可选字符少了一个 &#125; &#125; while (count == 0) &#123; if (right - left + 1 == pLen) &#123; ans.add(left); &#125; if (map.containsKey(sChar[left])) &#123; map.put(sChar[left], map.get(sChar[left]) + 1); if (map.get(sChar[left]) &gt; 0) &#123; count++; // 恢复可选字符 &#125; &#125; left++; &#125; right++; &#125; return ans; &#125;&#125; 439. ternary-expression-parser 给一个三元运算的? :字符串，布尔表达式直接就是T或者F，其余的都是0-9的一位数字，求最终结果。例如F?1:T?4:5最后就是4. 方法一：Stack。想到了要用Stack，但是没有想出确切的方法。其实就是需要从后往前遍历，确定最终需要保留的是什么数字就好了，在stack中存放两个值以及问号，这样当下一个字符（准确说是前一个）出现时只需要判断栈顶是否是问号就知道当前字符是作为bool还是值。 12345678910111213141516171819202122232425class Solution &#123; public String parseTernary(String expression) &#123; if (expression == null || expression.length() == 0) &#123; return ""; &#125; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); // 存放数值和问号 int len = expression.length(); for (int i = len - 1; i &gt;= 0; i--) &#123; // 从末尾往前遍历 char curr = expression.charAt(i); if (!stack.isEmpty() &amp;&amp; stack.peek() == '?') &#123; stack.pop(); char first = stack.pop(); char second = stack.pop(); if (curr == 'T') &#123; stack.push(first); &#125; else &#123; stack.push(second); &#125; &#125; else if (curr != ':') &#123; stack.push(curr); &#125; &#125; return stack.peek() + ""; &#125;&#125; 方法二：递归DFS。对于每一个问号都进行计数++，每个冒号进行计数–，这样当计数归0的时候就找到了与问号对应的冒号，然后根据T／F递归找前后其中一部分的结果就好。 123456789101112131415161718192021222324252627public class Solution &#123; public String parseTernary(String expression) &#123; if (expression == null || expression.length() == 0) &#123; return expression; &#125; char[] exp = expression.toCharArray(); return DFS(exp, 0, exp.length - 1) + ""; &#125; public char DFS(char[] c, int start, int end)&#123; if (start == end) &#123; return c[start]; &#125; int count = 0, i = start; for (; i &lt;= end; i++) &#123; if (c[i] == '?') &#123; count++; &#125; else if (c[i] == ':') &#123; count--; if (count == 0) &#123; break; &#125; &#125; &#125; return c[start] == 'T'? DFS(c, start + 2, i - 1) : DFS(c, i + 1, end); &#125;&#125; 443. string-compression 给一个字符数组，统计字符出现的个数实现压缩。例如a,a,a,a,a,b,c,c,c,c,c,c,c,c,c,c,c,c,c,c,c,c,c就是a,5,b,c,1,7。要求in-place。 每次从头开始，以第一个为基准往后判断，直到不想等，再根据个数往里塞。1234567891011121314151617181920212223class Solution &#123; public int compress(char[] chars) &#123; if (chars == null || chars.length == 0) &#123; return 0; &#125; int i = 0, len = 0; while (i &lt; chars.length) &#123; char curr = chars[i++]; // 以第一个字符为判断标准 chars[len++] = curr; int count = 1; while (i &lt; chars.length &amp;&amp; curr == chars[i]) &#123; // 统计个数直到不匹配 i++; count++; &#125; if (count != 1) &#123; // 超过一个才拼接上数字 for (char c : Integer.toString(count).toCharArray()) &#123; chars[len++] = c; &#125; &#125; &#125; return len; &#125;&#125; 444. sequence-reconstruction 给一个int数组org，再给一个List of list，这些list是某个original sequence的子序列，问根据这些子序列是否可以唯一地还原成一个完整的序列且正是org. 经典的拓扑排序。用Map&lt;Integer, Set&lt;Integer&gt;&gt;维护邻接关系，用Map&lt;Integer&gt;维护inDegrees关系12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123; public boolean sequenceReconstruction(int[] org, List&lt;List&lt;Integer&gt;&gt; seqs) &#123; if (org == null || org.length == 0 || seqs == null) &#123; return false; &#125; int n = org.length; Map&lt;Integer, Integer&gt; inDegrees = new HashMap&lt;&gt;(); Map&lt;Integer, Set&lt;Integer&gt;&gt; graph = new HashMap&lt;&gt;(); for (List&lt;Integer&gt; seq : seqs) &#123; if (seq.size() == 1) &#123; // 可能存在只有一个节点的seq graph.putIfAbsent(seq.get(0), new HashSet&lt;&gt;()); inDegrees.putIfAbsent(seq.get(0), 0); &#125; else &#123; for (int i = 1; i &lt; seq.size();i++) &#123; // 依次取每条seq的节点形成graph graph.putIfAbsent(seq.get(i - 1), new HashSet&lt;Integer&gt;()); graph.putIfAbsent(seq.get(i), new HashSet&lt;Integer&gt;()); if (i == 1) &#123; inDegrees.put(seq.get(i - 1), inDegrees.getOrDefault(seq.get(i - 1), 0)); &#125; if (graph.get(seq.get(i - 1)).add(seq.get(i))) &#123; inDegrees.put(seq.get(i), inDegrees.getOrDefault(seq.get(i), 0) + 1); &#125; &#125; &#125; &#125; Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); for (int key : inDegrees.keySet()) &#123; if (inDegrees.get(key) == 0) &#123; q.offer(key); &#125; &#125; int index = 0; while (q.size() == 1) &#123; // 必须保证每次只有一个入度为0的节点 int startIndex = q.poll(); if (startIndex != org[index]) &#123; return false; &#125; if (++index == n) &#123; break; &#125; Set&lt;Integer&gt; neighbors = graph.get(startIndex); if (neighbors == null) &#123; // 没有后续节点可以判断 break; &#125; for (int neighbor : neighbors) &#123; inDegrees.put(neighbor, inDegrees.get(neighbor) - 1); if (inDegrees.get(neighbor) == 0) &#123; q.offer(neighbor); &#125; &#125; &#125; return index == n &amp;&amp; index == graph.size(); &#125;&#125; 449. serialize-and-deserialize-bst 给一个BST，实现序列化和反序列化，即和String互相转换。 如果只是一个普通的二叉树，直接暴力写preorder和StringBuilder拼接没问题。但对于BST这个条件要怎么用呢？root一定比所有左边节点大、比所有右边节点小，那么在反序列化的时候直接通过val找到属于左边那半部分subtree去build即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Codec &#123; // Encodes a tree to a single string. public String serialize(TreeNode root) &#123; StringBuilder sb = new StringBuilder(); preorder(root, sb); return sb.toString(); &#125; private void preorder(TreeNode root, StringBuilder sb) &#123; if (root == null) &#123; return; &#125; sb.append(root.val); sb.append(","); preorder(root.left, sb); preorder(root.right, sb); &#125; // Decodes your encoded data to tree. public TreeNode deserialize(String data) &#123; if (data == null || data.length() == 0) &#123; return null; &#125; String[] vals = data.split(","); Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); for (String val : vals) &#123; q.offer(Integer.parseInt(val)); &#125; return deserialize(q); &#125; private TreeNode deserialize(Queue&lt;Integer&gt; q) &#123; if (q.isEmpty()) &#123; return null; &#125; TreeNode root = new TreeNode(q.poll()); Queue&lt;Integer&gt; smallerQueue = new LinkedList&lt;&gt;(); while (!q.isEmpty() &amp;&amp; q.peek() &lt; root.val) &#123; smallerQueue.offer(q.poll()); &#125; root.left = deserialize(smallerQueue); root.right = deserialize(q); return root; &#125;&#125; 450. delete-node-in-a-bst 给一个BST和一个key，如果存在这个key就删除这个值，返回root（可能会更新）。 经典。首先是搜索这个key，然后就是删除节点。如果这个节点是叶子，直接返回null；如果是单边，返回非空child；如果是双边children，则需要取中序遍历的下一个节点来替换掉当前节点。一种做法是去右子树的最左节点的值放到当前节点，再把该最左节点删除。另一种是真正的替换1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public TreeNode deleteNode(TreeNode root, int key) &#123; if (root == null) &#123; return root; &#125; if (key &lt; root.val) &#123; root.left = deleteNode(root.left, key); &#125; else if (key &gt; root.val) &#123; root.right = deleteNode(root.right, key); &#125; else &#123; if (root.left == null &amp;&amp; root.right == null) &#123; return null; &#125; if (root.left == null) &#123; return root.right; &#125; if (root.right == null) &#123; return root.left; &#125; TreeNode minNode = getMinNode(root.right); // 方法一：覆盖value // root.val = minNode.val; // root.right = deleteNode(root.right, minNode.val); // 方法二：真正的替换 minNode.right = deleteNode(root.right, minNode.val); minNode.left = root.left; root = minNode; &#125; return root; &#125; private TreeNode getMinNode(TreeNode root) &#123; while (root.left != null) &#123; root = root.left; &#125; return root; &#125;&#125; 453. minimum-moves-to-equal-array-elements 给一个int数组，返回move几次能够让每个元素相等。move指的是对某位置以外的所有元素加1. 这题其实是个math problem，推导在此，假设所有数之和为sum，最小值为minNum，加了m次达到x，则有sum + m * (n - 1) = x * n以及minNum + m = x，代入抵消一下就得到sum + mn - m = minNum * n + mn，所求的m为sum - minNum * n = SUM(num_i - minNum)。直接根据公式来，先求一波最小值，然后累加即可。12345678910111213141516class Solution &#123; public int minMoves(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; int min = nums[0]; for (int i = 1; i &lt; nums.length; i++) &#123; min = Math.min(min, nums[i]); &#125; int minMove = 0; for (int num: nums) &#123; minMove += (num - min); &#125; return minMove; &#125;&#125; 454. 4sum-ii 给四个数组，求其中有多少个组合使得A[i] + B[j] + C[k] + D[l] = 0. Map统计A和B的所有和出现的次数，然后遍历C+D的组合，到map中找对应项。skip。 457. circular-array-loop 给一个int数组，从任意一点出发，跳动步数就是数组的值，判断是否存在一个单一方向的、含有多于一个element的loop。数组中不含0.尝试不实用额外空间。 如果可以使用extra space，可以直接用Set记录到过的index以及某个path的index。如果不用额外空间呢？联想LinkedList找loop用快慢指针，这里也是一样。slow每次往后一步、fast每次两步，若全程能保持同一个方向移动且slow和fast相遇，则有loop.注意这里需要filter掉self-loop的元素。为了标记是否访问过而不使用Set，可以利用条件「原数组不含有0元素」，将访问过的元素改成0。保证一个方向的loop则是通过每一步经过的元素是否符号相同来判定的，也就是相乘大于0.1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public boolean circularArrayLoop(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return false; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] == 0) &#123; continue; &#125; int n = nums.length, slow = i, fast = getNextIndex(i, nums[i], n); while (nums[fast] * nums[i] &gt; 0 &amp;&amp; nums[getNextIndex(fast, nums[fast], n)] * nums[i] &gt; 0) &#123; if (slow == fast) &#123; if (slow == getNextIndex(slow, nums[slow], n)) &#123; // 排除只含有一个element的cycle break; &#125; return true; &#125; slow = getNextIndex(slow, nums[slow], n); // 慢快指针分别移动一步两步 fast = getNextIndex(fast, nums[fast], n); fast = getNextIndex(fast, nums[fast], n); &#125; int j = i, val = nums[i]; while (nums[j] * val &gt; 0) &#123; int nextIndex = getNextIndex(j, nums[j], n); nums[j] = 0; j = nextIndex; &#125; &#125; return false; &#125; private int getNextIndex(int index, int step, int len) &#123; int nextIndex = index + step; return nextIndex &gt;= 0 ? nextIndex % len : nextIndex % len + len; // java的%求的是余数而不是真正的modulo &#125;&#125; 460. Least Frequently Used Cache 实现最近最频繁使用的有限容量缓存，到达容量上限时evict最不频繁使用的key，若频繁情况相同则evict掉最早插入的。 方法一：优先队列，自定义Cache类，其中包含freq和timestamp，自定义Comparator来维护顺序。cacheMap用于维护正常的键值对缓存，freqMap用于快速获得给定key的freq。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class LFUCache &#123; // naive做法：通过自定义Cache维护一个优先队列，排序就是根据freq和timestamp来的，freq小在前、相等则时间戳小的在前。注意需要重载equals和hashCode，才能正常remove。 // put：把键值对放入cacheMap，还要新建这个key的freq（第一次为1）并插入freqMap // get: 直接从cacheMap中拿 // 在put和get过程中，若key是现有的，则需要更新freq，并存入pq // 当到达容量上限，直接从pq头部poll出来的key对应从map里删掉即可 // pq的remove是O(N)的，所以总体是O(capacity)的 class Cache &#123; int key, freq, timestamp; public Cache(int key, int freq, int timestamp) &#123; this.key = key; this.freq = freq; this.timestamp = timestamp; &#125; @Override public boolean equals(Object obj) &#123; return key == ((Cache)(obj)).key; &#125; @Override public int hashCode() &#123; return key; &#125; &#125; int capacity, globalTime; Map&lt;Integer, Integer&gt; cacheMap = null; Map&lt;Integer, Integer&gt; freqMap = null; PriorityQueue&lt;Cache&gt; pq = null; public LFUCache(int capacity) &#123; this.capacity = capacity; globalTime = 0; cacheMap = new HashMap&lt;&gt;(); freqMap = new HashMap&lt;&gt;(); pq = new PriorityQueue&lt;&gt;((c1, c2) -&gt; &#123; return c1.freq == c2.freq? c1.timestamp - c2.timestamp: c1.freq - c2.freq; &#125;); &#125; public int get(int key) &#123; globalTime++; if (cacheMap.containsKey(key)) &#123; update(key); return cacheMap.get(key); &#125; return -1; &#125; public void put(int key, int value) &#123; if (capacity == 0) &#123; return ; &#125; globalTime++; if (cacheMap.containsKey(key)) &#123; update(key); cacheMap.put(key, value); return; &#125; if (cacheMap.size() == capacity) &#123; Cache evict = pq.poll(); cacheMap.remove(evict.key); freqMap.remove(evict.key); &#125; cacheMap.put(key, value); freqMap.put(key, 1); pq.add(new Cache(key, 1, globalTime)); &#125; public void update(int key) &#123; int freq = freqMap.get(key); freqMap.put(key, freq + 1); Cache c = new Cache(key, freq + 1, globalTime); pq.remove(c); pq.add(c); &#125;&#125; 方法二：使用LRU中的双向链表，可以使得remove也O(1)。自定义Node，每个位置的Node代表了某个freq值的所有key。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128class LFUCache &#123; // 自定义双向链表节点Node用于按照freq从大到小存放key // 通过key对应到Node（nodeMap），Node中存放该key的freq。 // 若相同的freq对应多个key，则用一个Set存放，为了维持Recent特性，需要保证插入顺序，故用LinkedHashSet // get：从cacheMap中正常取数值，并从nodeMap中拿到这个节点，更新freq并插入到后续位置。 // put：有可能是更新原有key的数值，更新cacheMap中value。 // put：若是插入新的key，则先看看head是否维护的是freq为0，不是则新建head并插入到最前。 // put完之后要统一更新freq. class Node &#123; public int freq = 0; public Set&lt;Integer&gt; keySet = null; public Node prev = null, next = null; public Node(int freq) &#123; this.freq = freq; keySet = new LinkedHashSet&lt;&gt;(); prev = null; next = null; &#125; &#125; private Node head = null; private int capacity = 0; private Map&lt;Integer, Integer&gt; cacheMap = null; private Map&lt;Integer, Node&gt; nodeMap = null; public LFUCache(int capacity) &#123; this.capacity = capacity; cacheMap = new HashMap&lt;&gt;(); nodeMap = new HashMap&lt;&gt;(); &#125; public int get(int key) &#123; if (cacheMap.containsKey(key)) &#123; updateFreq(key); return cacheMap.get(key); &#125; return -1; &#125; public void put(int key, int value) &#123; if (capacity == 0) &#123; return; &#125; if (cacheMap.containsKey(key)) &#123; cacheMap.put(key, value); &#125; else &#123; if (cacheMap.size() &lt; capacity) &#123; cacheMap.put(key, value); &#125; else &#123; deleteOldest(); cacheMap.put(key, value); &#125; addToHead(key); &#125; updateFreq(key); &#125; // 更新key的freq并加入相应的node中 private void updateFreq(int key) &#123; Node node = nodeMap.get(key); node.keySet.remove(key); // 从当前freq的node中移除然后加入后续node if (node.next == null) &#123; node.next = new Node(node.freq + 1); node.next.prev = node; node.next.keySet.add(key); // 相同freq的key，维持插入顺序 &#125; else if (node.next.freq == node.freq + 1) &#123; node.next.keySet.add(key); &#125; else &#123; Node newFreqNode = new Node(node.freq + 1); newFreqNode.keySet.add(key); newFreqNode.prev = node; newFreqNode.next = node.next; node.next.prev = newFreqNode; node.next = newFreqNode; &#125; nodeMap.put(key, node.next); // 更新后续node if (node.keySet.size() == 0) &#123; deleteNode(node); &#125; &#125; // O(1)删除双向链表的节点 private void deleteNode(Node node) &#123; if (node.prev == null) &#123; head = node.next; &#125; else &#123; node.prev.next = node.next; &#125; if (node.next != null) &#123; node.next.prev = node.prev; &#125; &#125; // 新插入的key要新建freq=0的Node（或原本就有），并作为head private void addToHead(int key) &#123; if (head == null) &#123; head = new Node(0); head.keySet.add(key); &#125; else if (head.freq &gt; 0) &#123; Node newHead = new Node(0); newHead.keySet.add(key); newHead.next = head; head.prev = newHead; head = newHead; &#125; else &#123; head.keySet.add(key); &#125; nodeMap.put(key, head); &#125; private void deleteOldest() &#123; // 双向链表头就是freq最小的key们 if (head == null) &#123; return; &#125; Iterator it = head.keySet.iterator(); // keys中靠前的就是较早插入的 Integer oldestKey = null; if (it.hasNext()) &#123; oldestKey = (Integer)it.next(); head.keySet.remove(oldestKey); &#125; if (head.keySet.size() == 0) &#123; deleteNode(head); &#125; if (oldestKey != null) &#123; cacheMap.remove(oldestKey); nodeMap.remove(oldestKey); &#125; &#125;&#125; 461. hamming-distance 给两个int，求hamming distance. hamming distance指的是两个数不同的bit的个数，例如1001和0011就有两位不同。 异或之后看多少个bit。12345678910111213class Solution &#123; public int hammingDistance(int x, int y) &#123; int n = x ^ y; int ans = 0; for (int i = 0; i &lt; 32; i++) &#123; int mask = (1 &lt;&lt; i); if ((n &amp; mask) != 0) &#123; ans++; &#125; &#125; return ans; &#125;&#125; 463. island-perimeter 给一个0/1二维矩阵，求其中为1的island的周长。 方法一：BFS，每个1都先算它有四条边，然后根据邻接情况减掉不是边的即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public int islandPerimeter(int[][] grid) &#123; if (grid == null || grid.length == 0) &#123; return 0; &#125; boolean[][] visited = new boolean[grid.length][grid[0].length]; int perimeter = 0; for (int i = 0; i &lt; grid.length; i++) &#123; for (int j = 0; j &lt; grid[0].length; j++) &#123; if (grid[i][j] == 1 &amp;&amp; !visited[i][j]) &#123; perimeter += bfs(grid, i, j, visited); &#125; &#125; &#125; return perimeter; &#125; private int[][] dirs = new int[][] &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;; private int bfs(int[][] grid, int i, int j, boolean[][] visited) &#123; Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;(); q.add(new int[] &#123;i, j&#125;); visited[i][j] = true; int perimeter = 0; while (!q.isEmpty()) &#123; int[] curr = q.poll(); perimeter += 4; for (int[] dir : dirs) &#123; int row = curr[0] + dir[0], col = curr[1] + dir[1]; if (isIsland(grid, row, col)) &#123; perimeter--; if (!visited[row][col]) &#123; q.add(new int[] &#123;row, col&#125;); visited[row][col] = true; &#125; &#125; &#125; &#125; return perimeter; &#125; private boolean isIsland(int[][] grid, int i, int j) &#123; return i &gt;= 0 &amp;&amp; i &lt; grid.length &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; grid[0].length &amp;&amp; grid[i][j] == 1; &#125;&#125; 方法二：找规律。对于每一个1的cell，看它的下方和右方neighbor是不是1，记录neighbor数，最后周长就是islands 4 - neighbours 2。 1234567891011121314public int islandPerimeter(int[][] grid) &#123; int islands = 0, neighbours = 0; for (int i = 0; i &lt; grid.length; i++) &#123; for (int j = 0; j &lt; grid[i].length; j++) &#123; if (grid[i][j] == 1) &#123; islands++; // count islands if (i &lt; grid.length - 1 &amp;&amp; grid[i + 1][j] == 1) neighbours++; // count down neighbours if (j &lt; grid[i].length - 1 &amp;&amp; grid[i][j + 1] == 1) neighbours++; // count right neighbours &#125; &#125; &#125; return islands * 4 - neighbours * 2;&#125; 464. can-i-win 给定一个最大可取的int，再给个目标值target，两个人轮流从[1, int]之间取值，用过的值就不能再用了，两个人取的值不断累加，恰好达到或超过target的人就赢了。问是否能稳赢。 经典的DFS递归。有两个状态需要维护，一个是可选的数字需要用map或者数组bucket存起来，一个是剩余的target。同样为了避免DFS重复计算，需要用一个map将中间结果存起来。如果不加memorize的话时间复杂度O(N!)，相当于从1到N每一步都有N, N-1, N-2…个选择。如果加了memorize，则提升到O(2^N)，相当于1到N每个数字都有取或不取两种状态，可以保证访问过的状态不会重复heo访问，那么就是2^N。12345678910111213141516171819202122232425262728293031class Solution &#123; public boolean canIWin(int maxChoosableInteger, int desiredTotal) &#123; if (desiredTotal &lt;= 0) &#123; return true; &#125; int maxTotal = (1 + maxChoosableInteger) * maxChoosableInteger / 2; if (maxTotal &lt; desiredTotal) &#123; return false; &#125; return checkWin(desiredTotal, new boolean [maxChoosableInteger], new HashMap&lt;String, Boolean&gt;()); &#125; private boolean checkWin(int total, boolean[] bucket, Map&lt;String, Boolean&gt; map) &#123; String state = Arrays.toString(bucket); if (map.containsKey(state)) &#123; return map.get(state); &#125; for (int i = 0; i &lt; bucket.length; i++) &#123; if (!bucket[i]) &#123; bucket[i] = true; if (i + 1 &gt;= total || !checkWin(total - (i + 1), bucket, map)) &#123; // 超过或者对方必输，我就赢了 map.put(state, true); bucket[i] = false; return true; &#125; bucket[i] = false; &#125; &#125; map.put(state, false); // 遍历了所有可能值都不行，必输 return false; &#125;&#125; 477. total-hamming-distance 给一个int数组，求这些数两两之间的hamming distance之和。hamming distance指的是两个数不同的bit的个数，例如1001和0011就有两位不同。 直接用mask每一个bit地看有多少个数x该位为1，然后x乘一下(N - x)就得到该位不同的数的个数了。12345678910111213141516171819class Solution &#123; public int totalHammingDistance(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; int ans = 0; for (int i = 0; i &lt; 32; i++) &#123; int mask = (1 &lt;&lt; i); int count = 0; for (int j = 0; j &lt; nums.length; j++) &#123; if ((nums[j] &amp; mask) != 0) &#123; count++; &#125; &#125; ans += (count * (nums.length - count)); &#125; return ans; &#125;&#125; 480. sliding-window-median 给一个数组，给一个窗口size = k，从前往后滑动窗口，求每一个范围的median。 用两个PriorityQueue分别维护大根堆（存的是较小的值）和小根堆（存的是较大的值），在往里存元素的时候先尝试往minHeap中存比堆顶大的值，不行就直接存入maxHeap。两个堆加起来存够k个元素之后，还需要根据两个堆的size进行调整，因为不一定刚好一半一半。匀完了之后，每次从两个堆中取最大、最小值，再根据size = k决定中位数是直接取中间还是求平均。当窗口往后挪了之后，需要从两个堆的其中一个中删除，PriorityQueue的offer, poll, remove是O(logN)的，contains是O(N)的，retreive peek是O(1)的。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123; // 和前面的slidingWindowMax单调队列有点像 // 用一个单调队列可以求一个最大值/最小值，那么用两个单调队列维护大根堆和小根堆 // 分别取一个元素出来，看看是否需要求平均 public double[] medianSlidingWindow(int[] nums, int k) &#123; if (nums == null || nums.length == 0) &#123; return new double[0]; &#125; Queue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;(k, Collections.reverseOrder()); Queue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;(k); double[] ans = new double[nums.length - k + 1]; for (int i = 0; i &lt; nums.length; i++) &#123; if (i &gt;= k) &#123; if (minHeap.contains(nums[i - k])) &#123; minHeap.remove(nums[i - k]); &#125; else &#123; maxHeap.remove(nums[i - k]); &#125; &#125; if (minHeap.size() &gt; 0 &amp;&amp; nums[i] &gt; minHeap.peek()) &#123; minHeap.add(nums[i]); &#125; else &#123; maxHeap.add(nums[i]); &#125; adjustHeaps(maxHeap, minHeap); if (i &gt;= k - 1) &#123; ans[i - (k - 1)] = getMedian(maxHeap, minHeap); &#125; &#125; return ans; &#125; private double getMedian(Queue&lt;Integer&gt; minHeap, Queue&lt;Integer&gt; maxHeap) &#123; return minHeap.size() == maxHeap.size() ? ((double)minHeap.peek() + (double)maxHeap.peek()) / 2.0 : minHeap.size() &gt; maxHeap.size() ? minHeap.peek() : maxHeap.peek(); &#125; private void adjustHeaps(Queue&lt;Integer&gt; maxHeap, Queue&lt;Integer&gt; minHeap) &#123; while (Math.abs(maxHeap.size() - minHeap.size()) &gt; 1) &#123; if (maxHeap.size() &gt; minHeap.size()) &#123; minHeap.add(maxHeap.poll()); &#125; else &#123; maxHeap.add(minHeap.poll()); &#125; &#125; &#125;&#125; 482. license-key-formatting 给一个字符串，只含有数字和字母，再给一个K，将字符以K个为一组组成licenseKey。skip. 484. find-permutation 给一个只有D和I的字符串，表示相邻两个数的大小关系下降和上升。求lexicographical最小的、符合这个升降关系的1~n+1的数组。 贪心做法，先一波升序填进去，然后再对应遍历字符串，对于D就一直往后找连续的D，将这一段reverse即可。123456789101112131415161718192021public int[] findPermutation(String s) &#123; int n = s.length(), arr[] = new int[n + 1]; for (int i = 0; i &lt;= n; i++) arr[i] = i + 1; // sorted for (int h = 0; h &lt; n; h++) &#123; if (s.charAt(h) == 'D') &#123; int l = h; while (h &lt; n &amp;&amp; s.charAt(h) == 'D') h++; reverse(arr, l, h); &#125; &#125; return arr;&#125; void reverse(int[] arr, int l, int h) &#123; while (l &lt; h) &#123; arr[l] ^= arr[h]; // 酷炫的异或swap整数 arr[h] ^= arr[l]; arr[l] ^= arr[h]; l++; h--; &#125; &#125; 485. max-consecutive-ones 给一个只含有0和1的数组，求最多连续出现1的个数。 用一个lastIndex记录上一个出现的1的位置，然后不断往后遍历数组，如果是1就更新count、否则就把lastIndex更新过来。12345678910111213141516171819class Solution &#123; public int findMaxConsecutiveOnes(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; int max = 0, lastIndex = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] == 1) &#123; if (nums[lastIndex] == 0) &#123; lastIndex = i; &#125; max = Math.max(i - lastIndex + 1, max); &#125; else &#123; lastIndex = i; &#125; &#125; return max; &#125;&#125; 486. predict-the-winner 给一个int数组，两个玩家每次可以从两端任取一个数，轮流取完后比较取出数字之和，谁大谁赢（相等则player 1赢）。判断先选数字的player 1是否稳赢(两个玩家都会走最优) DP。是否赢需要依赖之前选数字的状态，最终胜负并不在意具体的sum是多少，而是比较两个玩家的sum，因此dp[i][j]存储nums[i...j]中此时选择的玩家会比另一个玩家多多少分。相比上一步，当前玩家可以在两端分别选nums[i]或者nums[j]，每次会选让自己分更多的，即Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]（注意上一步存的是另一个玩家比自己多多少分，因此需要取负）.注意到dp每次只会用到左侧和下侧相邻的cell，可以优化成只用一维数组的dp-space-complexity.)。12345678910111213141516171819class Solution &#123; public boolean PredictTheWinner(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return false; &#125; int n = nums.length; int[][] dp = new int[n][n]; for (int i = 0; i &lt; n; i++) &#123; dp[i][i] = nums[i]; &#125; for (int len = 1; len &lt; n; len++) &#123; for (int i = 0; i &lt; n - len; i++) &#123; int j = i + len; dp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]); &#125; &#125; return dp[0][n - 1] &gt;= 0; &#125;&#125; 487. max-consecutive-ones-ii 给一个只含有0和1的数组，至多可以将一个0 flip成1，求最长连续出现1的个数。 利用双指针维护一个至多含有一个0的window，当0过多就移动左指针直到恢复。 123456789101112131415161718192021class Solution &#123; public int findMaxConsecutiveOnes(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; int max = 0, zeroCount = 0; for (int left = 0, right = 0; right &lt; nums.length; right++) &#123; if (nums[right] == 0) &#123; zeroCount++; &#125; while (zeroCount &gt; 1) &#123; // 将1改为k即可处理flip k个零的情况 if (nums[left] == 0) &#123; zeroCount--; &#125; left++; &#125; max = Math.max(max, right - left + 1); &#125; return max; &#125;&#125; follow-up: 如果输入的数组无法全部存入内存？输入将以stream的形式传入，这样的话就不能直接存放整个数组，可以将零出现的index存入queue，当queue的size超过k的时候就说明window中零的个数过多，此时就将left移到q.poll() + 1即可。 490. the-maze 给一个grid，0表示空地1表示障碍物，一颗球在里面滚动，只有碰到障碍物或者边缘才会停下，给起点和终点坐标判断能否到达。BFS. skip. 494. target-sum 给一个只含有非负数的int数组和一个target，给这些int加正号或负号进行求和，求共有多少中加符号的方式使得sum等于target。其中所有数的sum不会超过1000，且数组长度不超过20. 注意到了限制“所有数的sum不会超过1000”，就联想到了木桶法。每个bucket[index]表示和为index有多少种方式，那么读入新的数x时将当前index的数加到[index+x]和[index-x]处即可。注意不可对原数组直接操作。12345678910111213141516171819202122232425262728293031class Solution &#123; public int findTargetSumWays(int[] nums, int S) &#123; if (nums == null || nums.length == 0 || Math.abs(S) &gt; 1000) &#123; return 0; &#125; int[] bucket = new int [2001]; // 全部平移1000 int[] bucketTemp = new int [2001]; bucket[1000] = 1; // sum = 0初始有一种情况，即空的输入 for (int i = 0; i &lt; nums.length; i++) &#123; for (int j = 0; j &lt; bucket.length; j++) &#123; if (bucket[j] &gt; 0) &#123; if (nums[i] != 0) &#123; bucketTemp[j - nums[i]] += bucket[j]; // 以当前值为中心点往两边拓展 bucketTemp[j + nums[i]] += bucket[j]; &#125; else &#123; bucketTemp[j] = bucket[j] * 2; // 当前值为0则直接翻倍（+0 / -0） &#125; bucket[j] = 0; &#125; &#125; for (int j = 0; j &lt; bucketTemp.length; j++) &#123; if (bucketTemp[j] != 0) &#123; bucket[j] = bucketTemp[j]; bucketTemp[j] = 0; &#125; &#125; &#125; return bucket[S + 1000]; &#125;&#125; 496. next-greater-element-i 给两个int数组，都不含重复元素，求nums1中元素在nums2中的next greater.不存在则设为-1. 首先处理一波nums2，从前往后入栈，每次入栈之前需要判断是否小于栈顶，如果大于了栈顶，说明栈中元素的next greater就是当前元素，用一个map存起来（不含重复元素就可以这样搞），最后遍历nums1的时候直接从map中取就可以了。1234567891011121314151617181920class Solution &#123; public int[] nextGreaterElement(int[] nums1, int[] nums2) &#123; if (nums1 == null || nums2 == null) &#123; return new int [0]; &#125; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for (int num: nums2) &#123; while (!stack.isEmpty() &amp;&amp; stack.peek() &lt; num) &#123; map.put(stack.pop(), num); &#125; stack.push(num); &#125; int[] ans = new int [nums1.length]; for (int i = 0; i &lt; nums1.length; i++) &#123; ans[i] = map.getOrDefault(nums1[i], -1); &#125; return ans; &#125;&#125; 499. the-maze-iii 给一个grid，0表示空地1表示障碍物，一颗球在里面滚动，只有碰到障碍物或者边缘才会停下，给起点和终点（和另两题的区别是这是一个洞，球滚到这里就会掉进去）坐标，求最短滚过的格子的路径（用u, d, l, r代替走过的上下左右），若有多个最短路径则取lexicographical更小的那个路径，若无法到达则返回impossible. 和前面第二题相比又需要存多一个path的信息，同时PriorityQueue的比较函数也需要更新当滚过的路程一样长时需要比较String。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class Solution &#123; class Point implements Comparable&lt;Point&gt; &#123; int row, col, step; String path; public Point(int row, int col, int step, String path) &#123; this.row = row; this.col = col; this.step = step; this.path = path; &#125; @Override public int compareTo(Point that) &#123; return this.step == that.step ? this.path.compareTo(that.path) : this.step - that.step; &#125; &#125; private final String IMP = "impossible"; public String findShortestWay(int[][] maze, int[] ball, int[] hole) &#123; if (maze == null || maze.length == 0 || maze[0].length == 0 || ball == null || ball.length != 2 || hole == null || hole.length != 2) &#123; return IMP; &#125; int rows = maze.length, cols = maze[0].length; boolean[][] visited = new boolean[rows][cols]; PriorityQueue&lt;Point&gt; q = new PriorityQueue&lt;&gt;(); q.offer(new Point(ball[0], ball[1], 0, "")); while (!q.isEmpty()) &#123; Point curr = q.poll(); if (curr.row == hole[0] &amp;&amp; curr.col == hole[1]) &#123; return curr.path; &#125; visited[curr.row][curr.col] = true; Point up = getNext(curr, -1, 0, maze, hole); if (!visited[up.row][up.col]) &#123; up.path += "u"; q.offer(up); &#125; Point down = getNext(curr, 1, 0, maze, hole); if (!visited[down.row][down.col]) &#123; down.path += "d"; q.offer(down); &#125; Point left = getNext(curr, 0, -1, maze, hole); if (!visited[left.row][left.col]) &#123; left.path += "l"; q.offer(left); &#125; Point right = getNext(curr, 0, 1, maze, hole); if (!visited[right.row][right.col]) &#123; right.path += "r"; q.offer(right); &#125; &#125; return IMP; &#125; private Point getNext(Point curr, int rowShift, int colShift, int[][] maze, int[] hole) &#123; Point next = new Point(curr.row, curr.col, curr.step, curr.path); while (next.row + rowShift &gt;= 0 &amp;&amp; next.row + rowShift &lt; maze.length &amp;&amp; next.col + colShift &gt;= 0 &amp;&amp; next.col + colShift &lt; maze[0].length &amp;&amp; maze[next.row + rowShift][next.col + colShift] == 0) &#123; next.row += rowShift; next.col += colShift; next.step++; if (next.row == hole[0] &amp;&amp; next.col == hole[1]) &#123; break; &#125; &#125; return next; &#125;&#125; 503. next-greater-element-ii 给一个circular数组，求每一个元素的下一个更大的元素的索引，如果不存在则设为-1。例如[1,2,1]返回[2,-1,2]。 这种circular性质的，容易想到直接拼接一段重复的元素到后方，转换成普通数组找后续更大值，时间O(N^2)。此外还能利用stack存放索引，首先从后往前把所有元素都丢进去，然后i还是从后往前遍历原数组并与栈顶索引对应的元素比较，直到小于栈顶时才将栈顶存入结果数组。此时还需要将当前索引push到栈中，因为循环的下一步是往前一个，所以需要将当前的元素存入stack作为最接近的next candidate.123456789101112131415161718192021222324class Solution &#123; public int[] nextGreaterElements(int[] nums) &#123; if (nums == null) &#123; return new int [0]; &#125; int[] ans = new int [nums.length]; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for (int i = nums.length - 1; i &gt;= 0; i--) &#123; // 从后往前将元素入栈 stack.push(nums[i]); ans[i] = -1; &#125; for (int i = nums.length - 1; i &gt;= 0; i--) &#123; // 从后往前找greater while (!stack.isEmpty() &amp;&amp; nums[i] &gt;= stack.peek()) &#123; stack.pop(); &#125; if (!stack.isEmpty()) &#123; ans[i] = stack.peek(); &#125; stack.push(nums[i]); // 因为下一个要遍历i - 1，所以就直接把i给入栈 &#125; return ans; &#125;&#125; 505. the-maze-ii 给一个grid，0表示空地1表示障碍物，一颗球在里面滚动，只有碰到障碍物或者边缘才会停下，给起点和终点坐标，求最短滚过的格子数，若无法到达则返回-1. 仍然是BFS，只不过此时需要利用PriorityQueue代替传统BFS的Queue，这个PQ的比较函数是将从起点滚过距离最短的放在前面，这样率先到达终点的就一定是最短路径。 508. most-frequent-subtree-sum 给一个二叉树，求所有subtree sum中出现最频繁的，tie则全都输出。 递归求sum过程中直接用map统计出现次数，最后导出来存入数组返回即可。skip。 513. find-bottom-left-tree-value 给一个二叉树，求最下面一层最左边的节点。 方法一：Iterative，从右往左进行层级遍历，最后一个遍历到的节点就是最下层的最左节点。 1234567891011121314151617class Solution &#123; public int findBottomLeftValue(TreeNode root) &#123; Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.offer(root); TreeNode curr = null; while (!q.isEmpty()) &#123; curr = q.poll(); if (curr.right != null) &#123; q.offer(curr.right); &#125; if (curr.left != null) &#123; q.offer(curr.left); &#125; &#125; return curr.val; &#125;&#125; 方法二：Recursive, 正常地从左到右前序遍历，但是会track深度，第一个达到新的深度的节点就一定是最左边的。 12345678910111213141516171819class Solution &#123; int ans = 0, h = 0; public int findBottomLeftValue(TreeNode root) &#123; find(root, 1); return ans; &#125; public void find(TreeNode root, int level) &#123; if (h &lt; level) &#123; ans = root.val; h = level; &#125; if (root.left != null) &#123; find(root.left, level + 1); &#125; if (root.right != null) &#123; find(root.right, level + 1); &#125; &#125;&#125; 515. find-largest-value-in-each-tree-row 给一个树，返回它每一个level节点的最大值。 层级遍历嘛。DFS和BFS。12345678910111213141516171819202122232425class Solution &#123; List&lt;Integer&gt; levelMax; public List&lt;Integer&gt; largestValues(TreeNode root) &#123; levelMax = new ArrayList&lt;&gt;(); dfsLevelMax(root, 0); return levelMax; &#125; private void dfsLevelMax(TreeNode node, int level) &#123; if (node == null) &#123; return; &#125; updateLevelMax(node.val, level); dfsLevelMax(node.left, level + 1); dfsLevelMax(node.right, level + 1); &#125; private void updateLevelMax(int val, int level) &#123; if (levelMax.size() == level) &#123; levelMax.add(val); &#125; else &#123; levelMax.set(level, Math.max(val, levelMax.get(level))); &#125; &#125;&#125; 516. longest-palindromic-subsequence 给一个字符串，求其中最长的自对称的subsequence（顺序与原字符串一样但不一定是连续的）的长度。例如bbbab最长为4（bbbb）。 DP。和647一样也是从后往前更新DP数组，dp[i][j]表示从i到j（inclusive）的最长长度。12345678910111213141516171819202122class Solution &#123; public int longestPalindromeSubseq(String s) &#123; if (s == null || s.length() == 0) &#123; return 0; &#125; char[] sChar = s.toCharArray(); int[][] dp = new int [sChar.length][sChar.length]; for (int row = sChar.length - 1; row &gt;= 0; row--) &#123; // 从最后一个字符往前更新 dp[row][row] = 1; for (int col = row + 1; col &lt; sChar.length; col++) &#123; if (sChar[row] == sChar[col]) &#123; dp[row][col] = 2 + dp[row + 1][col - 1]; // 取中间夹的部分的最长长度加上头尾两个 // compare prev or adding curr palindrome. no worry about exceeding boundary &#125; else &#123; // 不取当前字符 dp[row][col] = Math.max(dp[row][col - 1], dp[row + 1][col]); // keep at previous one &#125; &#125; &#125; return dp[0][sChar.length - 1]; &#125;&#125; 518. coin-change-2 给一个数组表示有哪些面额的硬币，每个面额的硬币有无限多个可以任取。给定一个目标值，求总共有多少种组合方式。 DP。和前面的那个硬币题类似，这里dp[i]表示达到i这个值有多少组合方式。如果当前硬币的面额是x，则dp[i] = dp[i] + dp[i - x].12345678910111213141516171819202122class Solution &#123; public int change(int amount, int[] coins) &#123; if (amount == 0) &#123; return 1; &#125; if (coins == null || coins.length == 0) &#123; return 0; &#125; // dp[amount]表示凑成amount有几种ways // 对于每个dp[i + coin] = dp[i + coin] + dp[i] int[] dp = new int [amount + 1]; dp[0] = 1; for (int i = 0; i &lt; coins.length; i++) &#123; // 固定coin值遍历所有可能值 for (int j = 0; j &lt; dp.length; j++) &#123; if (j &gt;= coins[i]) &#123; dp[j] += dp[j - coins[i]]; // 从j - coins[i]增加到j &#125; &#125; &#125; return dp[amount]; &#125;&#125; 523. continuous-subarray-sum 给一个非负int数组和一个非负整数k，判断是否含有长度大于等于2的连续subarray whose sum是k的multiple。可以保证将原数组所有数加起来不会爆int。 方法一：暴力法，求膜的方式O(N^2)两重循环求sum。 方法二：求是否含有一部分使得sum是n*k，那么如果利用Map记录sum对应的索引，一路往后加x%k，当出现前面已经存在的sum的时候，说明这一路加的x刚好膜k得到0，即为k的倍数。注意需要特殊处理0，不可以膜0.12345678910111213141516171819202122232425class Solution &#123; public boolean checkSubarraySum(int[] nums, int k) &#123; if (nums == null || nums.length == 0) &#123; return true; &#125; // 记录得到当前sum对应的索引 Map&lt;Integer, Integer&gt; sum2Index = new HashMap&lt;&gt;(); sum2Index.put(0, -1); int sum = 0; for (int i = 0; i &lt; nums.length; i++) &#123; sum += nums[i]; if (k != 0) &#123; sum %= k; // 膜来处理倍数问题 &#125; if (sum2Index.containsKey(sum)) &#123; // 说明膜了一波等于0，中间可能有k的倍数 if (i - sum2Index.get(sum) &gt; 1) &#123; // 注意需要长度大于等于2 return true; &#125; &#125; else &#123; sum2Index.put(sum, i); &#125; &#125; return false; &#125;&#125; 524. longest-word-in-dictionary-through-deleting 给一个字符串s，给一个单词List，求将s中部分字母删除后能得到的最长的在List中的单词，若长度相等则取lexicographical更短的。 遍历List中的单词，与s比较看是否是subsequence。基本是暴力做法，只不过prune掉了一些情况，只有当candidate比之前的结果更长或者lexicographical order更前才会计算。还有一种做法是先对List进行排序，长度长的在前、字典序小的在前，然后再直接遍历List，第一个subsequence即为所求。 525. contiguous-array 给一个只含0,1的int数组，求最长subarray的长度使得其中的0,1个数相等。 方法一：暴力破解，固定start和end依次看当前窗口的0,1个数。O(N^2)超时。 方法二：既然需要的是0,1相等的个数而不关心具体位置／顺序，也就是如果经过一波操作之后0和1的个数差回到原点，说明一波操作没有造成什么后果，也就是0，1个数相等。或者更近一步，将0先一波流替换成-1，这样只要sum为0就意味着相等，而且如果当前的sum在之前出现过，说明经过一波操作又回到原点，那么-1,1的个数也是相等的。因此想到用map记录sum出现的各个位置，只记录最早出现的位置，这样一旦后面出现了这个sum就可以求得最长长度了。123456789101112131415161718192021222324class Solution &#123; public int findMaxLength(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] == 0) &#123; nums[i] = -1; &#125; &#125; Map&lt;Integer, Integer&gt; sum2Index = new HashMap&lt;&gt;(); sum2Index.put(0, -1); int sum = 0, maxLen = 0; for (int i = 0; i &lt; nums.length; i++) &#123; sum += nums[i]; if (sum2Index.containsKey(sum)) &#123; maxLen = Math.max(maxLen, i - sum2Index.get(sum)); &#125; else &#123; sum2Index.put(sum, i); &#125; &#125; return maxLen; &#125;&#125; 529. minesweeper 点击一个位置，根据是否有雷更新棋盘。如果是雷，直接改成叉叉并返回；如果没有点开并且周围八个相邻格子有雷，则改成雷的数目并返回；如果周围都没有雷，就扩散到相邻格子继续更新。 方法一：根据描述本身就蕴含了递归，所以自然想到DFS。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123; public char[][] updateBoard(char[][] board, int[] click) &#123; if (board == null || board.length == 0 || board[0].length == 0 || click == null || click.length &lt; 2) &#123; return new char [0][0]; &#125; int rowCount = board.length, colCount = board[0].length; int row = click[0], col = click[1]; if (board[row][col] == 'B') &#123; // 已经点开了就直接返回 return board; &#125; if (board[row][col] == 'M') &#123; // 是雷就gg board[row][col] = 'X'; &#125; else &#123; int count = 0; // 计算雷的个数 for (int i = -1; i &lt; 2; i++) &#123; int tempRow = row + i; if (tempRow &lt; 0 || tempRow &gt;= rowCount) &#123; continue; &#125; for (int j = -1; j &lt; 2; j++) &#123; int tempCol = col + j; if (tempCol &lt; 0 || tempCol &gt;= colCount) &#123; continue; &#125; if (board[tempRow][tempCol] == 'M') &#123; count++; &#125; &#125; &#125; if (count &gt; 0) &#123; board[row][col] = (char)('0' + count); &#125; else &#123; board[row][col] = 'B'; // 改为已经reveal，并扩散到周围unreveal的邻居 for (int i = -1; i &lt; 2; i++) &#123; int tempRow = row + i; if (tempRow &lt; 0 || tempRow &gt;= rowCount) &#123; continue; &#125; for (int j = -1; j &lt; 2; j++) &#123; int tempCol = col + j; if (tempCol &lt; 0 || tempCol &gt;= colCount) &#123; continue; &#125; if (board[tempRow][tempCol] == 'E') &#123; // DFS the unrevealed updateBoard(board, new int[]&#123;tempRow, tempCol&#125;); &#125; &#125; &#125; &#125; &#125; return board; &#125;&#125; 方法二：BFS，Queue中存放点击之后扩散的点（如果有的话），一直扩散直到Queue为空。但是和DFS需要区别的是，由于BFS会将相邻的所有E的格子都入队，很可能会出现重复，所以就直接在更新时就赋值为B，防止重复入队。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution &#123; public char[][] updateBoard(char[][] board, int[] click) &#123; if (board == null || board.length == 0 || board[0].length == 0 || click == null || click.length &lt; 2) &#123; return new char [0][0]; &#125; Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;(); int rowCount = board.length, colCount = board[0].length; q.add(click); while (!q.isEmpty()) &#123; int[] curr = q.poll(); int row = curr[0], col = curr[1]; // 和DFS相比少了判断为B的步骤 if (board[row][col] == 'M') &#123; board[row][col] = 'X'; &#125; else &#123; int count = 0; for (int i = -1; i &lt; 2; i++) &#123; int tempRow = row + i; if (tempRow &lt; 0 || tempRow &gt;= rowCount) &#123; continue; &#125; for (int j = -1; j &lt; 2; j++) &#123; int tempCol = col + j; if (tempCol &lt; 0 || tempCol &gt;= colCount) &#123; continue; &#125; if (board[tempRow][tempCol] == 'M') &#123; count++; &#125; &#125; &#125; if (count &gt; 0) &#123; board[row][col] = (char)('0' + count); &#125; else &#123; board[row][col] = 'B'; for (int i = -1; i &lt; 2; i++) &#123; int tempRow = row + i; if (tempRow &lt; 0 || tempRow &gt;= rowCount) &#123; continue; &#125; for (int j = -1; j &lt; 2; j++) &#123; int tempCol = col + j; if (tempCol &lt; 0 || tempCol &gt;= colCount) &#123; continue; &#125; if (board[tempRow][tempCol] == 'E') &#123; // BFS the unrevealed q.add(new int[]&#123;tempRow, tempCol&#125;); board[tempRow][tempCol] = 'B'; // IMPORTANT!!! &#125; &#125; &#125; &#125; &#125; &#125; return board; &#125;&#125; 535. encode-and-decode-tinyurl 实现一个含有encode和decode方法的类，能够转码和解码tinyURL。 这种映射关系必定需要Map，关键是如何建立这种从长到短的映射？利用随机数随机从一长串字符串中取字符，取够6个即形成了短码。如果这个短码已经存在，就需要再来一次生成新的短码，直到出现新的。12345678910111213141516171819202122232425262728293031323334353637public class Codec &#123; private static final String HOST = "http://tinyurl.com/"; private static final String CHAR = "abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"; private static final int LIMIT = CHAR.length(); Map&lt;String, String&gt; url2tiny = new HashMap&lt;&gt;(); Map&lt;String, String&gt; tiny2url = new HashMap&lt;&gt;(); // Encodes a URL to a shortened URL. public String encode(String longUrl) &#123; if (url2tiny.containsKey(longUrl)) &#123; return HOST + url2tiny.get(longUrl); &#125; String ret = null; do &#123; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; 6; i++) &#123; int index = (int) (Math.random() * LIMIT); sb.append(CHAR.charAt(index)); &#125; ret = sb.toString(); &#125; while (tiny2url.containsKey(ret)); url2tiny.put(longUrl, ret); tiny2url.put(ret, longUrl); return HOST + ret; &#125; // Decodes a shortened URL to its original URL. public String decode(String shortUrl) &#123; return tiny2url.get(shortUrl.replace(HOST, "")); &#125;&#125;// Your Codec object will be instantiated and called as such:// Codec codec = new Codec();// codec.decode(codec.encode(url)); 540. single-element-in-a-sorted-array 给一个排好序的数组，每个数字都出现了两次except其中一个，求这个毒瘤。要求时间复杂度O(logN)，空间(1). 二分查找，利用pair的特性，以偶数index与下一个元素为判断依据，若元素相等说明毒瘤出现在后半部分，若不想等说明出现在前面。edge case需要考虑单独元素出现在数组首位和末尾的情况。1234567891011121314151617181920class Solution &#123; public int singleNonDuplicate(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; int left = 0, right = nums.length - 1; while (right &gt; left) &#123; int mid = left + (right - left) / 2; if (mid % 2 == 1) &#123; mid--; &#125; if (nums[mid] == nums[mid + 1]) &#123; left = mid + 2; &#125; else &#123; right = mid; &#125; &#125; return nums[left]; &#125;&#125; 543. diameter-of-binary-tree Zillow面试题刻骨铭心。给一个二叉树，求其中任意两个节点的path距离中最长长度。例如下面的树就有4-2-1-3和5-2-1-3两个最长路径，都是3. 对于当前节点有取和不取两种情况（但），取根则等于左深度加右深度，不取则在往下求深度的时候就可以顺便用一个全局变量去更新，时间复杂度就为O(N)了。1234567891011121314151617class Solution &#123; private int max = 0; public int diameterOfBinaryTree(TreeNode root) &#123; getMaxDepth(root); return max; &#125; private int getMaxDepth(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; int left = getMaxDepth(root.left); int right = getMaxDepth(root.right); max = Math.max(max, left + right); // 取根的情况 return Math.max(left, right) + 1; // 求深度 &#125;&#125; 545. boundary-of-binary-tree 给一个二叉树，求它从左到下方到右的所有boundary的元素。 方法一：根据定义来写，则是老老实实先把所有左边界找出来、再把叶子节点找出来、再把右边界节点找出来。需要注意的是在遍历左边界时遵循preorder，当所有的左侧叶子节点都遍历完了再重新潜入一次找所有最下方节点（叶子节点），找完所有叶子结点之后再开始遍历右边界节点，遵循postorder. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123; private List&lt;Integer&gt; nodes; public List&lt;Integer&gt; boundaryOfBinaryTree(TreeNode root) &#123; nodes = new ArrayList&lt;&gt;(); if (root == null) &#123; return nodes; &#125; nodes.add(root.val); traverseLeftBoundary(root.left); traverseLeaves(root.left); traverseLeaves(root.right); traverseRightBoundary(root.right); return nodes; &#125; private void traverseLeftBoundary(TreeNode root) &#123; if (root == null || root.left == null &amp;&amp; root.right == null) &#123; return; &#125; nodes.add(root.val); if (root.left != null) &#123; traverseLeftBoundary(root.left); &#125; else &#123; traverseLeftBoundary(root.right); &#125; &#125; private void traverseRightBoundary(TreeNode root) &#123; if (root == null || root.left == null &amp;&amp; root.right == null) &#123; return; &#125; if (root.right != null) &#123; traverseRightBoundary(root.right); &#125; else &#123; traverseRightBoundary(root.left); &#125; nodes.add(root.val); &#125; private void traverseLeaves(TreeNode root) &#123; if (root == null) &#123; return; &#125; if (root.left == null &amp;&amp; root.right == null) &#123; nodes.add(root.val); return; &#125; else &#123; traverseLeaves(root.left); traverseLeaves(root.right); &#125; &#125;&#125; 方法二：如何one-pass只遍历一次呢？在潜入的时候其实就已经知道节点的身份了：若当前节点是左边界，潜入左child时肯定还是左边界；右边界亦然。若当前节点是左边界，潜入右child时，若左child是null，则当前继续是左边界，也就是一个AND的关系。若当前节点是右边界，潜入左child时，若右child为null，则继续时右边界。 12345678910111213141516171819202122232425262728class Solution &#123; public List&lt;Integer&gt; boundaryOfBinaryTree(TreeNode root) &#123; List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); if (root == null) &#123; return ans; &#125; ans.add(root.val); dfs(root.left, true, false, ans); dfs(root.right, false, true, ans); return ans; &#125; private void dfs(TreeNode root, boolean isLeft, boolean isRight, List&lt;Integer&gt; ans) &#123; if (root == null) &#123; return; &#125; if (isLeft) &#123; ans.add(root.val); &#125; dfs(root.left, isLeft, isRight &amp;&amp; root.right == null, ans); if (!isLeft &amp;&amp; !isRight &amp;&amp; root.left == null &amp;&amp; root.right == null) &#123; ans.add(root.val); &#125; dfs(root.right, isLeft &amp;&amp; root.left == null, isRight, ans); if (isRight) &#123; ans.add(root.val); &#125; &#125;&#125; 548. split-array-with-equal-sum 给一个int数组，判断是否存在三个分割点i, j, k使得被这三个点分割出来的四个部分（不包含分割点）的sum相等。 方法一：类似于4sum，利用Set存储在之前出现过的相等的sum，然后固定中间点j，遍历可能的i，将前面两部分相等的sum存入set，然后遍历后半部分k，若也存在两部分相等的和且set中存在，则说明确实可以分成四个相等的部分。 123456789101112131415161718192021222324252627282930class Solution &#123; public boolean splitArray(int[] nums) &#123; if (nums == null || nums.length &lt; 7) &#123; return false; &#125; int[] sum = new int[nums.length]; sum[0] = nums[0]; for (int i = 1; i &lt; nums.length; i++) &#123; sum[i] = sum[i - 1] + nums[i]; &#125; for (int j = 3; j + 3 &lt; nums.length; j++) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int i = 1; i + 1 &lt; j; i++) &#123; int sumBeforeI = sum[i - 1]; int sumItoJ = sum[j - 1] - sum[i]; if (sumBeforeI == sumItoJ) &#123; set.add(sumBeforeI); &#125; &#125; for (int k = j + 1; k + 1 &lt; nums.length; k++) &#123; int sumJtoK = sum[k - 1] - sum[j]; int sumAfterK = sum[nums.length - 1] - sum[k]; if (sumJtoK == sumAfterK &amp;&amp; set.contains(sumJtoK)) &#123; return true; &#125; &#125; &#125; return false; &#125;&#125; DFS也可破。枚举所有可能的part sum，然后dfs到后续部分判断是否可以根据这个part sum恰好得到四个部分。注意为了避免无效DFS，需要ignore连续出现的0。 1234567891011121314151617181920212223242526272829class Solution &#123; public boolean splitArray(int[] nums) &#123; if (nums == null || nums.length &lt; 7) &#123; return false; &#125; int sum = IntStream.of(nums).sum(); return dfs(nums, 0, 0, sum, 0); &#125; private boolean dfs(int[] nums, int start, int target, int sumRemain, int depth) &#123; if (depth == 3) &#123; if (target == sumRemain) return true; else return false; &#125; int currSum = 0; for (int i = start + 1; i + 5 - (2 * depth) &lt; nums.length; i++) &#123; if (i != 1 &amp;&amp; nums[i - 1] == 0 &amp;&amp; nums[i] == 0) &#123; // 忽略连续出现的0 continue; &#125; currSum += nums[i - 1]; if ((depth == 0 || currSum == target) &amp;&amp; dfs(nums, i + 1, currSum, sumRemain - currSum - nums[i], depth + 1)) &#123; return true; &#125; &#125; return false; &#125;&#125; 549. binary-tree-longest-consecutive-sequence-ii 给一个二叉树，求其中路径最长的连续increasing或decreasing的长度，这个路径不一定是parent-child的，怎么上下左右都行，只要是连续即可。 不论怎么弯折，对于每一个节点来说其实就是看和孩子能否形成increase和decrease，可以则加一下就是一个弯折的路径了。1234567891011121314151617181920212223242526272829303132333435class Solution &#123; int max = 0; public int longestConsecutive(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; helper(root); return max; &#125; private int[] helper(TreeNode root) &#123; if (root == null) &#123; return new int[] &#123;0, 0&#125;; &#125; int[] left = helper(root.left), right = helper(root.right); int inc = 1, dec = 1; if (root.left != null) &#123; if (root.left.val == root.val + 1) &#123; // 确认是否能和孩子形成升序/降序列 inc = left[0] + 1; &#125; if (root.left.val == root.val - 1) &#123; dec = left[1] + 1; &#125; &#125; if (root.right != null) &#123; if (root.right.val == root.val + 1) &#123; inc = Math.max(inc, right[0] + 1); // 取左右中最大的 &#125; if (root.right.val == root.val - 1) &#123; dec = Math.max(dec, right[1] + 1); &#125; &#125; max = Math.max(inc + dec - 1, max); return new int[] &#123;inc, dec&#125;; &#125;&#125; 554. brick-wall 给一个二维List表示每一行每一块砖各自的长度。求纵向切下来最少穿过的墙的个数。 最少的穿过的个数也就是求穿过最多缝隙的个数，也就事给定一个结束长度，最多的那个即为所求。用Map记录每一行的累加的结尾长度，不断更新最多的那个长度，最后wall的行数减去count即可。123456789101112131415161718192021class Solution &#123; public int leastBricks(List&lt;List&lt;Integer&gt;&gt; wall) &#123; if (wall == null || wall.size() == 0) &#123; return 0; &#125; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int count = 0; for (List&lt;Integer&gt; list : wall) &#123; int len = 0; for (int i = 0; i &lt; list.size() - 1; i++) &#123; len += list.get(i); map.put(len, map.getOrDefault(len, 0) + 1); // 求对应长度结尾的墙有多少 count = Math.max(count, map.get(len)); // 更新以len结尾的最多的 if (count == wall.size()) &#123; return 0; &#125; &#125; &#125; return wall.size() - count; // 减一下就是穿过墙最少的 &#125;&#125; 556. next-greater-element-iii 给一个32bit的正整数，求十进制中相同数字组成的下一个更大值。例如12的下一个就是21，1342则是1423。 若已经是最大的可能值？（返回-1） 对输入的数字从后往前遍历，找到连续的两个数字使得前面的（i - 1）小于后面的（i），然后再从i + 1开始往后找最小的大于i - 1的数字，互换他俩，最后从i开始往后从小到大排个序即可。1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public int nextGreaterElement(int n) &#123; if (n &lt; 1) &#123; return -1; &#125; String s = String.valueOf(n); char[] sChar = s.toCharArray(); int i = sChar.length - 1; // 从后往前 while (i &gt; 0) &#123; if (sChar[i - 1] &lt; sChar[i]) &#123; // 找到第一个连续的顺序对 break; &#125; i--; &#125; if (i == 0) &#123; // 到最后都没找到 return -1; &#125; int j = i + 1, minIndex = i; char first = sChar[i - 1]; while (j &lt; sChar.length) &#123; // 从i + 1开始从前往后不断更新最小的大于i - 1的元素 if (sChar[j] &lt;= sChar[minIndex] &amp;&amp; sChar[j] &gt; first) &#123; minIndex = j; &#125; j++; &#125; sChar[i - 1] = sChar[minIndex]; // 交换该ceiling值和i - 1 sChar[minIndex] = first; Arrays.sort(sChar, i, sChar.length); // 从i开始拍个序 long ans = Long.valueOf(new String(sChar)); return ans &gt; Integer.MAX_VALUE? -1: (int)ans; &#125;&#125; 560. subarray-sum-equals-k 给一个int数组和一个k，问有多少连续的subarray之和等于k。这些int都在[-1000, 1000]，数组长度最多20000。 一开始想用双指针，但有正有负，更新条件不好搞。正解是使用Map，在计算sum的时候顺便看看之前是否出现过sum - k。这其实和path sum III 很像，都是利用prefix sum.123456789101112131415161718class Solution &#123; public int subarraySum(int[] nums, int k) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); map.put(0, 1); int count = 0, sum = 0; for (int i = 0; i &lt; nums.length; i++) &#123; sum += nums[i]; if (map.containsKey(sum - k)) &#123; // 看之前是否已经出现了 count += map.get(sum - k); &#125; map.put(sum, map.getOrDefault(sum, 0) + 1); &#125; return count; &#125;&#125; 562. longest-line-of-consecutive-one-in-matrix 给一个只含有0和1的二维数组，求横、竖、两个斜对角的连续出现1的最长长度。 方法一：O(N^2)从每个点出发往四个方向分别遍历，求最长长度。 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; // O(N^3)：矩阵遍历每个点是N^2，对每个点在扫四个方向是4N public int longestLine(int[][] M) &#123; if (M == null || M.length == 0 || M[0].length == 0) &#123; return 0; &#125; int longest = 0; for (int i = 0; i &lt; M.length; i++) &#123; for (int j = 0; j &lt; M[0].length; j++) &#123; if (M[i][j] == 1) &#123; longest = Math.max(longest, getLongest(M, i, j)); &#125; &#125; &#125; return longest; &#125; // 右、下、右下、左下 final private int[][] directions = new int[][] &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;1, 1&#125;, &#123;1, -1&#125;&#125;; private int getLongest(int[][] M, int row, int col) &#123; int maxLen = 1; for (int[] direction: directions) &#123; int len = 1; int newRow = row + direction[0]; int newCol = col + direction[1]; // 持续在一个方向上继续走 while (isValidPosition(M, newRow, newCol) &amp;&amp; M[newRow][newCol] == 1) &#123; len++; newRow += direction[0]; newCol += direction[1]; &#125; maxLen = Math.max(maxLen, len); &#125; return maxLen; &#125; private boolean isValidPosition(int[][] M, int row, int col) &#123; return row &gt;= 0 &amp;&amp; col &gt;= 0 &amp;&amp; row &lt; M.length &amp;&amp; col &lt; M[0].length; &#125;&#125; 方法二：类似于DP，记录下四个方向各自的最大长度。参考这个被lz和N皇后问题很像。 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; // O(N^2)时间，O(M+N)空间 public int longestLine(int[][] M) &#123; // validation if (M == null || M.length == 0 || M[0].length == 0) &#123; return 0; &#125; int rows = M.length, cols = M[0].length; int longest = 0; int[] bucketCol = new int [cols]; int[] bucketDiag1 = new int [rows + cols]; int[] bucketDiag2 = new int [rows + cols]; for (int i = 0; i &lt; rows; i++) &#123; int row = 0; // 新行初始化为0 for (int j = 0; j &lt; cols; j++) &#123; if (M[i][j] == 1) &#123; // 当前为1，对应更新bucket row++; bucketCol[j]++; bucketDiag1[j + i]++; bucketDiag2[j - i + M.length]++; longest = Math.max(longest, row); longest = Math.max(longest, bucketCol[j]); longest = Math.max(longest, bucketDiag1[j + i]); longest = Math.max(longest, bucketDiag2[j - i + M.length]); &#125; else &#123; row = 0; bucketCol[j] = 0; bucketDiag1[j + i] = 0; bucketDiag2[j - i + M.length] = 0; &#125; &#125; &#125; return longest; &#125;&#125; 567. permutation-in-string 给两个字符串，判断s1的permutation是否包含在s2中，例如s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;返回true，因为s2包含了ba。 其实这个s1的permutation并不用真的一个个求出来，在意的只是s1的每个字符及其出现次数，因此用一个map O(N)扫一波就好了。然后就对s2进行双指针 + producer/consumer操作，如果消耗完map中所有字符的时候恰好前后指针间距等于s1的长度，说明就是permutation的一种了，返回true。123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public boolean checkInclusion(String s1, String s2) &#123; if (s1 == null || s2 == null || s1.length() == 0 || s2.length() == 0 ) &#123; return false; &#125; char[] s1Char = s1.toCharArray(); Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); int len1 = s1Char.length; for (int i = 0; i &lt; len1; i++) &#123; // 统计s1中每个字母出现个数，作为producer map.put(s1Char[i], map.getOrDefault(s1Char[i], 0) + 1); &#125; char[] s2Char = s2.toCharArray(); int count = map.size(); int left = 0, right = 0; while (right &lt; s2Char.length) &#123; // 遍历s2作为consumer消耗字符，直到map中所有字符消耗完 if (map.containsKey(s2Char[right])) &#123; map.put(s2Char[right], map.get(s2Char[right]) - 1); if (map.get(s2Char[right]) == 0) &#123; count--; &#125; &#125; while (count == 0) &#123; // 左指针补回来，直到map中出现available的字符 if (right - left + 1 == len1) &#123; return true; &#125; if (map.containsKey(s2Char[left])) &#123; map.put(s2Char[left], map.get(s2Char[left]) + 1); if (map.get(s2Char[left]) &gt; 0) &#123; count++; &#125; &#125; left++; &#125; right++; &#125; return false; &#125;&#125; 572. subtree-of-another-tree 给两棵树，判断后者是不是前者的子树。子树指的是还有一个任意节点为根的子树，结构、数值完全一样。 递归搞定。先判断两个树是否相同，若相同直接就是子树了。若不同则需要到左右子树进行递归，判断t是否是左／右的子树。1234567891011121314151617181920class Solution &#123; public boolean isSubtree(TreeNode s, TreeNode t) &#123; if (s == null &amp;&amp; t == null) &#123; return true; &#125; if (s == null || t == null) &#123; return false; &#125; return isSame(s, t) ? true : isSubtree(s.left, t) || isSubtree(s.right, t); &#125; private boolean isSame(TreeNode s, TreeNode t) &#123; if (s == null &amp;&amp; t == null) &#123; return true; &#125; if (s == null || t == null) &#123; return false; &#125; return s.val == t.val ? isSame(s.left, t.left) &amp;&amp; isSame(s.right, t.right) : false; &#125;&#125; 575. distribute-candies 给一个数组表示糖果的id，其中可能有重复，且糖果数量一定是偶数。要求将其分成两部分，问如果想尝最多的不同的糖果，有多少种。例如[3,2,2,1,3,1]就有三种，[7,3,1,4,3,7,4,3,7]就有四种。要求时间复杂度最差O(N*lgN)，空间复杂度O(N)。 先排序，然后双指针一个从前往后，一个从后往前。left指针负责将糖果存入set，right则是调取后方的糖果往前替换，当left发现当前糖果吃过了，就从right那里swap过来继续判断，直到出现新的糖果或者穷尽。123456789101112131415161718192021private static int maxCandy(int[] candies) &#123; if (candies == null || candies.length == 0) &#123; return 0; &#125; Arrays.sort(candies); Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); int half = candies.length / 2; int left = 0, right = candies.length - 1; while (left &lt; half) &#123; while (set.contains(candies[left]) &amp;&amp; right &gt;= half) &#123; swap(candies, left, right--); &#125; if (right &lt; half) &#123; break; &#125; else &#123; set.add(candies[left++]); &#125; &#125; set.add(candies[left]); return set.size(); &#125; 581. shortest-unsorted-continuous-subarray 给一个部分部分有序的数组，求将其中哪一部分排序之后整个数组就都有序了，求最短的区间的长度。 首先从左往右逆序对，然后从右往左找逆序对。这样就有了一个大致区间，但是还需要找区间内的min和max，分别往前和往后遍历看看是否真的完全符合，否则还需要扩展区间。例如[1,3,6,4,8,2,7,10]在前两步之后找到得失[6,4]和[8,2]实际上前面的3和后面的1都需要加入进来。12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public int findUnsortedSubarray(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; // 找第一个逆序对 int left = 1; while (left &lt; nums.length) &#123; if (nums[left - 1] &gt; nums[left]) &#123; left--; break; &#125; left++; &#125; if (left == nums.length) &#123; // 说明已经有序了 return 0; &#125; int right = nums.length - 1; while (right &gt; 0) &#123; if (nums[right - 1] &gt; nums[right]) &#123; break; &#125; right--; &#125; // 找[left, right]之间的最小、最大 int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE; for (int i = left; i &lt;= right; i++) &#123; min = Math.min(min, nums[i]); max = Math.max(max, nums[i]); &#125; // 前面的必须小于min，后面的必须大于max，否则扩散 while (left &gt; 0 &amp;&amp; nums[left - 1] &gt; min) &#123; left--; &#125; while (right + 1 &lt; nums.length &amp;&amp; nums[right + 1] &lt; max) &#123; right++; &#125; return right - left + 1; &#125;&#125; 594. longest-harmonious-subsequence 给一个int数组，求其中最大和最小值恰好为1的非连续子序列。 用Map存每个值出现的次数，然后遍历Map取key相差1都存在的进行更新。123456789101112131415161718class Solution &#123; public int findLHS(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int num : nums) &#123; map.put(num, map.getOrDefault(num, 0) + 1); &#125; int max = 0; for (int num : map.keySet()) &#123; if (map.containsKey(num + 1)) &#123; max = Math.max(max, map.get(num) + map.get(num + 1)); &#125; &#125; return max; &#125;&#125; 598. range-addition-ii 给一个二维数组的规模m和n，初始值为0，再给一个ops二维数组，每个op表示前x行和前y列都加1.求最终最大值的个数。例如m = 3, n = 3, operations = [[2,2],[3,3]]，那么就是先给左上方2*2加1，再给3*3加1，最后就有4个最大值（2）。 直接找行和列的最小值，相乘即可。m和n甚至都没啥用。123456789101112131415class Solution &#123; // 直接找最小的行和列数，相乘即得 public int maxCount(int m, int n, int[][] ops) &#123; if (ops == null || ops.length == 0) &#123; return m * n; &#125; int rowMin = Integer.MAX_VALUE, colMin = Integer.MAX_VALUE; for (int[] op : ops) &#123; rowMin = Math.min(op[0], rowMin); colMin = Math.min(op[1], colMin); &#125; return rowMin * colMin; &#125;&#125; 600. non-negative-integers-without-consecutive-ones 给一个正数num，求[0, num]之间的bitString不含连续1的数字的个数。 方法一：DP。对于bitString有两种可能，以1结尾或以0结尾。为了不出现连续的1，对于0结尾的数字可以拼上0或1，而对于1结尾的数字就只能拼上0.Geeks4Geeks上面给的是bitString的长度，这里也可以用类似的方法。不过由于这里num的存在可能需要砍掉一部分结果，因此在最后需要多一步判断。如果num中出现了连续的xx00xxx（注意是从右往左遍历），而如果没有这个限制xx10xxx, xx01xxx等都可能算进去，因此需要减去前一个0到最前面的数字位数所保存的endWithOne的值。 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; // 对于一个二进制数字，最后一位可能为1也可能为0.后者可以append数字0或1，而前者只能append数字0了。牵涉到DP了。 // end0表示不含连续1的、bit长度为i + 1的、以0结尾的数字个数，end1表示不含连续1的、bit长度为i + 1的、以1结尾的数字的个数 // 初始状态为end0[0] = 1, end1[0] = 1. // end0只在最后拼0，因此上一步来自0或1都可以；而end1只拼1，因此上一步只能来自0. // 状态转换为end0[i] = end0[i - 1] + end1[i - 1], end1[i] = end0[i - 1] // 但这是根据bitString长度来的，而题目给的是num，因此最后还需要过滤看看有没有多算 // 如果在i, i+1处出现连续的0，说明i往前的部分就多算了，因此根据0～i-1的长度找endWithOne减掉即可。 public int findIntegers(int num) &#123; if (num &lt;= 0) &#123; return 0; &#125; StringBuilder sb = new StringBuilder(Integer.toBinaryString(num)); int n = sb.length(); int[] endWithZero = new int [n]; int[] endWithOne = new int [n]; endWithZero[0] = 1; endWithOne[0] = 1; for (int i = 1; i &lt; n; i++) &#123; endWithZero[i] = endWithZero[i - 1] + endWithOne[i - 1]; endWithOne[i] = endWithZero[i - 1]; &#125; int count = endWithZero[n - 1] + endWithOne[n - 1]; for (int i = 1; i &lt; n; i++) &#123; if (sb.charAt(i) == '1' &amp;&amp; sb.charAt(i - 1) == '1') &#123; // x11xx说明已经是最大了，后面都不可能多算了 break; &#125; else if (sb.charAt(i) == '0' &amp;&amp; sb.charAt(i - 1) == '0') &#123; // x00xx说明前一个0处不应该含有endWithOne count -= endWithOne[n - 1 - i]; &#125; &#125; return count; &#125;&#125; 方法二：constant space的DP。 604. design-compressed-string-iterator 给一个字符加数字组成的字符串，实现next、hasNext函数遍历这个字符串。例如L20J3B8这样。 一开始直接根据频数全部存入queue，后来发现如果某个数频数特别大，而实际用不到那么多项就很不划算。因此就自定义类来搞了。写出来是这样. 605. can-place-flowers 给一个只含有0和1的数组，1表示该处被种了花，0表示可以种，同时相邻的位置不能同时种花。给一个花数n，判断能否种到所给的花池中。 方法一：想到了greedy的方法，每次判断0前后是否都为0，可以就直接设为1. 123456789101112131415161718class Solution &#123; public boolean canPlaceFlowers(int[] flowerbed, int n) &#123; if (flowerbed == null || flowerbed.length == 0 || n == 0) &#123; return true; &#125; for (int i = 0; i &lt; flowerbed.length; i++) &#123; if (flowerbed[i] == 0 &amp;&amp; (i == flowerbed.length - 1 || flowerbed[i + 1] != 1) // 后一个为0 &amp;&amp; (i == 0 || flowerbed[i - 1] != 1)) &#123; // 前一个为0 flowerbed[i] = 1; if (--n == 0) &#123; return true; &#125; &#125; &#125; return false; &#125;&#125; 方法二：计算0的个数，碰到1就计算前面最多可以放多少0，同时重置计数。注意初始化count = 1，比如0 0 1在碰到1的时候需要保证slot为1，如果count初始化为0就无法得到了。 123456789101112131415161718class Solution &#123; public boolean canPlaceFlowers(int[] flowerbed, int n) &#123; if (flowerbed == null || flowerbed.length == 0 || n == 0) &#123; return true; &#125; int count = 1, slot = 0; for (int i = 0; i &lt; flowerbed.length; i++) &#123; if (flowerbed[i] == 0) &#123; count++; &#125; else &#123; slot += (count - 1) / 2; count = 0; &#125; &#125; slot += count / 2; return slot &gt;= n; &#125;&#125; 606. construct-string-from-binary-tree 给一个二叉树，encode成括号分割的字符串。 递归拼接。注意左子树和右子树为空时加不加括号需要加判断。12345678910111213141516171819202122class Solution &#123; public String tree2str(TreeNode t) &#123; if (t == null) &#123; return ""; &#125; StringBuilder sb = new StringBuilder(); sb.append(t.val); String left = tree2str(t.left); String right = tree2str(t.right); if (left.length() &gt; 0 || right.length() &gt; 0) &#123; sb.append("("); sb.append(left); sb.append(")"); &#125; if (right.length() &gt; 0) &#123; sb.append("("); sb.append(right); sb.append(")"); &#125; return sb.toString(); &#125;&#125; 609. find-duplicate-file-in-system 给一个字符串数组，每个字符串中表示某路径下的所有文件以及内容，求相同文件内容的文件路径并存入List。比较有意思的是follow-up，解答参考这里：在真实的文件系统中你会选择BFS还是DFS?(BFS。虽然会消耗更多空间，但是可以利用locality提速)如果每个文件内容非常巨大怎么办？（不直接hash文件内容，而是首先根据文件大小判断是否是同一个文件，然后再取文件其中一部分进行hash） 直接以内容为key、路径&amp;文件名为value存入map。最坏时间复杂度是O(N^2 * k)，N是文件个数，k是文件大小。123456789101112131415161718192021222324252627282930313233class Solution &#123; public List&lt;List&lt;String&gt;&gt; findDuplicate(String[] paths) &#123; List&lt;List&lt;String&gt;&gt; ans = new ArrayList&lt;&gt;(); if (paths == null || paths.length == 0) &#123; return ans; &#125; Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); // 以文件内容为key、路径+文件名为value for (String path : paths) &#123; String[] arr = path.split("\\s+"); // 不可以直接用空格，要正则表达式!!!!!! String dir = arr[0]; for (int i = 1; i &lt; arr.length; i++) &#123; int start = arr[i].indexOf("("); String file = arr[i].substring(0, start); String content = arr[i].substring(start, arr[i].length() - 1); List&lt;String&gt; temp = map.get(content); if (temp == null) &#123; temp = new ArrayList&lt;String&gt;(); &#125; temp.add(dir + "/" + file); map.put(content, temp); &#125; &#125; for (String content : map.keySet()) &#123; List&lt;String&gt; temp = map.get(content); if (temp.size() &gt; 1) &#123; ans.add(temp); &#125; &#125; return ans; &#125;&#125; 611. valid-triangle-number 给一个int数组表示边长，问这些边可以组成多少个三角形。（这些边可能重复，但是算作不同的边） 三角形任意两边之和大于第三边，这个任意其实指的是起码较小的两边之和大于最大边。12345678910111213141516171819202122class Solution &#123; // 两边之和大于第三边，那么每次都取最小都两个边相加大于最大边即可 public int triangleNumber(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; Arrays.sort(nums); // 排序 int count = 0; for (int i = nums.length - 1; i &gt;= 2; i--) &#123; int left = 0, right = i - 1; // 双指针取比当前指针小的两条边 while (left &lt; right) &#123; if (nums[left] + nums[right] &gt; nums[i]) &#123; count += (right - left); // 相当于固定right取left开始的边 right --; &#125; else &#123; left ++; &#125; &#125; &#125; return count; &#125;&#125; 621. task-scheduler 给一个char数组，每个char表示一个task的名字；然后给一个interval表示相同的task必须经过这么多时间之后才能再次执行。求执行完所有任务所需要的时间。 greedy可解，即以所给的interval作为周期，每次按频数从多到少地放task，如果周期没有用完而后续还有任务则需要把idle的时间也加进去。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123; class Task &#123; char name; int freq; public Task(char name, int freq) &#123; this.name = name; this.freq = freq; &#125; &#125; public int leastInterval(char[] tasks, int n) &#123; if (tasks == null || tasks.length == 0) &#123; return 0; &#125; // 统计每个任务的频数 Map&lt;Character, Task&gt; map = new HashMap&lt;&gt;(); for (char c : tasks) &#123; if (!map.containsKey(c)) &#123; map.put(c, new Task(c, 1)); &#125; else &#123; Task t = map.get(c); t.freq++; map.put(c, t); &#125; &#125; // 根据频数维护优先队列 PriorityQueue&lt;Task&gt; q = new PriorityQueue&lt;&gt;((a, b) -&gt; &#123; return b.freq == a.freq? a.name - b.name : b.freq - a.freq; // freq大的在前 &#125;); for (Character c : map.keySet()) &#123; q.add(map.get(c)); &#125; // 以n+1为周期，从pq中根据freq从高到低取task int totalTime = 0; while (!q.isEmpty()) &#123; List&lt;Task&gt; temp = new ArrayList&lt;&gt;(); int period = n + 1; while (period &gt; 0 &amp;&amp; !q.isEmpty()) &#123; Task t = q.poll(); t.freq--; temp.add(t); period--; totalTime++; &#125; for (Task t : temp) &#123; if (t.freq &gt; 0) &#123; q.add(t); &#125; &#125; if (!q.isEmpty()) &#123; // 后面还有task，确实需要隔多这么多时间 totalTime += period; &#125; &#125; return totalTime; &#125;&#125; 628. maximum-product-of-three-numbers 给一个int数组，求其中任意三个数的最大乘积（不用考虑越界问题）。 naive的想法是排序后取三个max，但实际上只需要用到三个max以及两个可能为负数的min。12345678910111213141516171819202122232425262728class Solution &#123; public int maximumProduct(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; int max1 = Integer.MIN_VALUE, max2 = Integer.MIN_VALUE, max3 = Integer.MIN_VALUE, min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE; for (int num : nums) &#123; if (num &lt;= min1) &#123; min2 = min1; min1 = num; &#125; else if (num &lt;= min2) &#123; min2 = num; &#125; if (num &gt;= max1) &#123; max3 = max2; max2 = max1; max1 = num; &#125; else if (num &gt;= max2) &#123; max3 = max2; max2 = num; &#125; else if (num &gt;= max3) &#123; max3 = num; &#125; &#125; return Math.max(max1 * max2 * max3, max1 * min1 * min2); &#125;&#125; 632. smallest-range 给一个List&lt;List&lt;Integer&gt;&gt;，每行List内部是排好序的，求一个区间使其包括每一行的某个元素。例如[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]，返回[20,24]. 类似于merge k sorted list，自定义一个Node类存放值、所属的行数、所处的列数信息，每次从每个List中取值存入PriorityQueue，然后每次从pq中poll掉元素的下一个作为新的元素存入pq。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; class Node &#123; int val; int row; int index; public Node(int val, int row, int index) &#123; this.val = val; this.row = row; this.index = index; &#125; &#125; public int[] smallestRange(List&lt;List&lt;Integer&gt;&gt; nums) &#123; if (nums == null || nums.size() == 0 || nums.get(0).size() == 0) &#123; return new int [0]; &#125; int[] ans = new int [] &#123;0, Integer.MAX_VALUE&#125;; // warning: need to be max at first int k = nums.size(); PriorityQueue&lt;Node&gt; pq = new PriorityQueue&lt;&gt;((a, b) -&gt; a.val - b.val); // new PriorityQueue&lt;Node&gt;(new Comparator() &#123; // public int compare(Node a, Node b) &#123; // return a.val - b.val; // &#125; // &#125;); int max = Integer.MIN_VALUE; for (int i = 0; i &lt; k; i++) &#123; int currVal = nums.get(i).get(0); max = Math.max(max, currVal); pq.offer(new Node(currVal, i, 0)); &#125; while (pq.size() == nums.size()) &#123; // 已经没有新的元素了加进来说明能跨所有行的间距已经遍历完成 Node node = pq.poll(); if (max - node.val &lt; ans[1] - ans[0]) &#123; // 发现间距更小的window就更新 ans[1] = max; ans[0] = node.val; &#125; if (node.index + 1 &lt; nums.get(node.row).size()) &#123; Node nextNode = new Node(nums.get(node.row).get(node.index + 1), node.row, node.index + 1); if (nextNode.val &gt; max) &#123; max = nextNode.val; &#125; pq.offer(nextNode); &#125; &#125; return ans; &#125;&#125; 633. sum-of-square-numbers 给一个非负数，判断它是否是两个整数的平方和。 方法一：类似two sum，把每个整数的平方和存入set，判断set中是否有target - curr即可。 12345678910111213141516class Solution &#123; public boolean judgeSquareSum(int c) &#123; if (c &lt; 0) &#123; return false; &#125; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); int sqrtC = (int) Math.sqrt(c); for (int i = 0; i &lt;= sqrtC; i++) &#123; set.add(i * i); if (set.contains(c - i * i)) &#123; return true; &#125; &#125; return false; &#125;&#125; 方法二：双指针，同时从0和sqrt(num)出发往中间逼近，若平方和大了则左移右指针、若小了则右移左指针。但 1234567891011121314151617public boolean judgeSquareSum(int c) &#123; if (c &lt; 0) &#123; return false; &#125; int left = 0, right = (int) Math.sqrt(c); while (left &lt;= right) &#123; int curr = left * left + right * right; if (curr &gt; c) &#123; right--; &#125; else if (curr &lt; c) &#123; left++; &#125; else &#123; return true; &#125; &#125; return false;&#125; 636. exclusive-time-of-functions 给一个log数组，每个log包含function_id:start_or_end:timestamp形式的字符串，求每个function执行时间长度。注意这些function的执行可能嵌套、也可能递归调用。 经典的Stack题，需要用Stack记录function_id，这样在后续log来的时候，如果是start，说明栈顶函数暂停执行了，需要先把它的时间存起来（当前时间戳减去之前的时间戳）；如果是end，说明栈顶函数彻底执行完了，此时的时间计算需要加上end的这个时间戳。1234567891011121314151617181920212223242526class Solution &#123; public int[] exclusiveTime(int n, List&lt;String&gt; logs) &#123; int[] ans = new int [n]; if (logs == null) &#123; return ans; &#125; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int prev = 0; // 记录上一次log的时间戳 for (int i = 0; i &lt; logs.size(); i++) &#123; String[] log = logs.get(i).split(":"); if (log[1].equals("start")) &#123; int curr = Integer.valueOf(log[2]); if (!stack.isEmpty()) &#123; ans[stack.peek()] += (curr - prev); &#125; prev = curr; stack.push(Integer.valueOf(log[0])); &#125; else &#123; int curr = Integer.valueOf(log[2]); ans[stack.pop()] += (curr - prev + 1); // end包含当前这个时间点，因此要加1 prev = curr + 1; &#125; &#125; return ans; &#125;&#125; 637. average-of-levels-in-binary-tree 给一个二叉树，求每一层的平均数。 还是层级遍历的变形，主要是防止求平均值的时候越界，用了double，这样求平均值的时候也方便很多。写出来是这样。 646. maximum-length-of-pair-chain 给一个pair的数组，每个pair可以作为chain的节点。节点[c, d]能够连到[a, b]后面的条件是b &lt; c。求最长的链长度。 DP。len[i]表示以pair[i]结尾的链的长度，那么在双重循环时，就需要找到pairs[j]使得pairs[j][1] &lt; pairs[i][0]。12345678910111213141516171819202122class Solution &#123; public int findLongestChain(int[][] pairs) &#123; if (pairs == null || pairs.length == 0) &#123; return 0; &#125; Arrays.sort(pairs, (a, b) -&gt; &#123; return a[0] - b[0]; &#125;); int[] len = new int [pairs.length]; // len[i]表示以pairs[i]结尾的链的长度 Arrays.fill(len, 1); int maxLen = 1; for (int i = 1; i &lt; pairs.length; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (pairs[i][0] &gt; pairs[j][1]) &#123; len[i] = Math.max(len[i], len[j] + 1); // 上一个节点为pairs[j] &#125; &#125; maxLen = Math.max(maxLen, len[i]); &#125; return maxLen; &#125;&#125; 647. palindromic-substrings 给一个字符串，求其中自对称的子串的个数。例如aaa就有6个，aba就有4个。 DP。dp[i][j]表示从第i个字符到第j个字符是否对称，当判断第i和第j个字符的时候，如果相等则需要用到i + 1到j - 1之间的结果（若也对称则当前这个也是对称的），因此需要从后往前递推更新DP数组才行。1234567891011121314151617181920212223class Solution &#123; public int countSubstrings(String s) &#123; if (s == null) &#123; return 0; &#125; int count = 0; char[] sChar = s.toCharArray(); boolean[][] dp = new boolean [sChar.length][sChar.length]; // dp[i][j] means take substr from i to j for (int row = dp.length - 1; row &gt;= 0; row--) &#123; // 从最后一行开始往前 dp[row][row] = true; // 最后一列设为true count++; // 每个字符本身是自对称的 for (int col = row + 1; col &lt; dp.length; col++) &#123; // 只更新对角线之后的元素 if (sChar[col] == sChar[row]) &#123; dp[row][col] = row + 1 &gt; col - 1 || dp[row + 1][col - 1]; &#125; if (dp[row][col]) &#123; count++; &#125; &#125; &#125; return count; &#125;&#125; 648. replace-words 给一个List的dict表示词根，然后给一个sentence String，将其中以词根开头的单词替换成词根，返回修改后的String。 方法一：直接用Set存放这些词根，然后split之后暴力取每一个单词，再逐一取字符append判断是否在Set中，有就替换过去。 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public String replaceWords(List&lt;String&gt; dict, String sentence) &#123; if (dict == null || dict.size() == 0 || sentence == null || sentence.length() == 0) &#123; return sentence; &#125; Set&lt;String&gt; set = new HashSet&lt;&gt;(); int minLen = Integer.MAX_VALUE; for (String str : dict) &#123; set.add(str); minLen = Math.min(str.length(), minLen); &#125; String[] words = sentence.split("\\s+"); for (int i = 0; i &lt; words.length; i++) &#123; int wordLen = words[i].length(); if (wordLen &lt; minLen) &#123; continue; &#125; StringBuilder temp = new StringBuilder(words[i].substring(0, minLen)); if (set.contains(temp.toString())) &#123; words[i] = temp.toString(); continue; &#125; for (int j = minLen; j &lt; wordLen; j++) &#123; temp.append(words[i].charAt(j)); if (set.contains(temp.toString())) &#123; words[i] = temp.toString(); break; &#125; &#125; &#125; StringBuilder sb = new StringBuilder(); for (String word : words) &#123; sb.append(word); sb.append(" "); &#125; sb.setLength(sb.length() - 1); return sb.toString(); &#125;&#125; 方法二：使用Trie，将dict中的所有词根都存入Trie，然后还是取出来判断这些word是否有前缀出现在Trie中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution &#123; class TrieNode &#123; boolean isWord; TrieNode[] next; public TrieNode() &#123; next = new TrieNode[26]; Arrays.fill(next, null); isWord = false; &#125; &#125; public String replaceWords(List&lt;String&gt; dict, String sentence) &#123; if (dict == null || dict.size() == 0 || sentence == null || sentence.length() == 0) &#123; return sentence; &#125; TrieNode root = buildTrie(dict); String[] words = sentence.split("\\s+"); StringBuilder ans = new StringBuilder(); for (int i = 0; i &lt; words.length; i++) &#123; String prefix = getPrefix(root, words[i]); ans.append(prefix == null ? words[i] : prefix); ans.append(' '); &#125; ans.setLength(ans.length() - 1); return ans.toString(); &#125; private TrieNode buildTrie(List&lt;String&gt; dict) &#123; TrieNode root = new TrieNode(); for (String str : dict) &#123; insert(root, str); &#125; return root; &#125; private void insert(TrieNode root, String word) &#123; for (char c : word.toCharArray()) &#123; if (root.next[c - 'a'] == null) &#123; root.next[c - 'a'] = new TrieNode(); &#125; root = root.next[c - 'a']; &#125; root.isWord = true; &#125; // return the prefix in trie if exist, or null if not. private String getPrefix(TrieNode root, String word) &#123; StringBuilder sb = new StringBuilder(); for (char c : word.toCharArray()) &#123; if (root.next[c - 'a'] == null) &#123; return null; &#125; sb.append(c); if (root.next[c - 'a'].isWord) &#123; return sb.toString(); &#125; root = root.next[c - 'a']; &#125; return root.isWord ? word : null; &#125;&#125; 652. find-duplicate-subtrees 给一个二叉树，返回一个包含所有duplicate的子树根节点的List。例如下面的树就有2-4和4两个duplicate的子树。 1234567 1 / \ 2 3 / / \4 2 4 / 4 利用encoding tree的思路，对于每一个节点为root的树都进行一波类似前序遍历点操作，将遍历结果encode成字符串作为key、计数作为value存入map。一旦出现了两次就加入结果List。 123456789101112131415161718192021class Solution &#123; public List&lt;TreeNode&gt; findDuplicateSubtrees(TreeNode root) &#123; List&lt;TreeNode&gt; ans = new ArrayList&lt;&gt;(); Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); check(root, map, ans); return ans; &#125; private String check(TreeNode node, Map&lt;String, Integer&gt; map, List&lt;TreeNode&gt; ans) &#123; if (node == null) &#123; return ""; &#125; // 通过前序遍历拼接出pattern并存入map String pattern = node.val + "," + check(node.left, map, ans) + "," + check(node.right, map, ans); int count = map.getOrDefault(pattern, 0) + 1; if (count == 2) &#123; // the second one ans.add(node); &#125; map.put(pattern, count); return pattern; &#125;&#125; 653. two-sum-iv-input-is-a-bst 给一个二叉搜索树和一个sum值，判断树中是否存在两个node之和等于sum。 朴素想法，对于每个可能的值进行O(logN)的搜索，因此总的时间复杂度就是O(NlogN)，而空间复杂度如果考虑递归栈的话就是O(TreeHeight)。 12345678910111213141516171819202122232425262728class Solution &#123; public boolean findTarget(TreeNode root, int k) &#123; return dfs(root, root, k); &#125; private boolean dfs(TreeNode node, TreeNode root, int k) &#123; if (node == null) &#123; return false; &#125; int target = k - node.val; if (target != node.val &amp;&amp; search(root, target)) &#123; return true; &#125; else &#123; return dfs(node.left, root, k) || dfs(node.right, root, k); &#125; &#125; private boolean search(TreeNode root, int val) &#123; if (root == null) &#123; return false; &#125; if (root.val == val) &#123; return true; &#125; else if (val &lt; root.val) &#123; return search(root.left, val); &#125; else &#123; return search(root.right, val); &#125; &#125;&#125; 方法二：用BST中序遍历转换成有序数组，再用双指针分别从头和尾往中间找。时间O(N)，空间O(N). 1234567891011121314151617181920212223242526class Solution &#123; public boolean findTarget(TreeNode root, int k) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); inorder(root, list); int left = 0, right = list.size() - 1; while (left &lt; right) &#123; // 双指针查找有序数组中的pair int sum = list.get(left) + list.get(right); if (sum &lt; k) &#123; left++; &#125; else if (sum &gt; k) &#123; right--; &#125; else &#123; return true; &#125; &#125; return false; &#125; private void inorder(TreeNode root, List&lt;Integer&gt; list) &#123; if (root == null) &#123; return; &#125; inorder(root.left, list); list.add(root.val); inorder(root.right, list); &#125;&#125; 657. judge-route-circle 给一个字符串表示一个移动的seq，判断最终是否回到远点。skip. 658. find-k-closest-elements 在一个排好序的数组中，找距离x最近的k个元素，若有tie则尽量取更小的值。 二分查找找到x所在位置/若x存在则应该处在的index，然后取它左边的元素作为left、本身作为right，双指针前后取即可。为了提高insert效率，使用linkedlist的addfirst。123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public List&lt;Integer&gt; findClosestElements(int[] arr, int k, int x) &#123; LinkedList&lt;Integer&gt; ans = new LinkedList&lt;&gt;(); if (arr == null || arr.length == 0) &#123; return ans; &#125; int pos = binarySearch(arr, x); int left = pos - 1, right = pos; while (ans.size() &lt; k &amp;&amp; left &gt;= 0 &amp;&amp; right &lt; arr.length) &#123; if (x - arr[left] &lt;= arr[right] - x) &#123; // delta相等时尽量取小的 ans.addFirst(arr[left--]); &#125; else &#123; ans.add(arr[right++]); &#125; &#125; while (ans.size() &lt; k &amp;&amp; left &gt;= 0) &#123; ans.addFirst(arr[left--]); &#125; while (ans.size() &lt; k &amp;&amp; right &lt; arr.length) &#123; ans.add(arr[right++]); &#125; return ans; &#125; private int binarySearch(int[] arr, int target) &#123; int left = -1, right = arr.length; while (right - left &gt; 1) &#123; int mid = left + (right - left) / 2; if (target &lt;= arr[mid]) &#123; right = mid; &#125; else &#123; left = mid; &#125; &#125; return right; &#125;&#125; 662. maximum-width-of-binary-tree 给一个二叉树，求最大宽度，即最左节点和最右节点之间的间隔。 在dfs过程中记录最左节点的id（类似于数组存储二叉树的形式），然后在遍历过程中根据level和当前id求间隔。1234567891011121314151617class Solution &#123; public int widthOfBinaryTree(TreeNode root) &#123; List&lt;Integer&gt; leftMostIds = new ArrayList&lt;&gt;(); return dfs(root, 1, 0, leftMostIds); &#125; private int dfs(TreeNode node, int nodeId, int level, List&lt;Integer&gt; leftMostIds) &#123; if (node == null) &#123; return 0; &#125; if (level &gt;= leftMostIds.size()) &#123; // 每一个level最左的node id leftMostIds.add(nodeId); &#125; return Math.max(nodeId - leftMostIds.get(level) + 1, Math.max(dfs(node.left, 2 * nodeId, level + 1, leftMostIds), dfs(node.right, 2 * nodeId + 1, level + 1, leftMostIds))); &#125;&#125; 669. trim-a-binary-search-tree 给一个BST和一个值域[L, R]，只保留BST中属于该值域的节点。递归搞定，skip。 670. maximum-swap 给一个非负数，求至多将其中两个digit互换位置之后所能得到的最大数。例如9987就是本身，9978是9987，958469是998465. 暗中观察规律就是找其中一个小的数字并找在它右侧的最大数，交换。因此首先需要记录每个数字最后出现的位置，然后从原数字第一位开始遍历，从最大的数字开始比较，一旦找到比自己大且排在自己后面的数字就可以直接交换位置了。12345678910111213141516171819202122232425class Solution &#123; public int maximumSwap(int num) &#123; if (num &lt;= 0) &#123; return 0; &#125; char[] numStr = Integer.toString(num).toCharArray(); int[] bucket = new int [10]; for (int i = 0; i &lt; numStr.length; i++) &#123; bucket[numStr[i] - '0'] = i; // 每个数字最后出现的位置 &#125; // 找到最靠右的、比当前数字大的数字，交换位置即可 for (int i = 0; i &lt; numStr.length; i++) &#123; for (int index = 9; index &gt; numStr[i] - '0'; index--) &#123; // 注意只跟比当前数字大的比位置 if (bucket[index] &gt; i) &#123; // 在当前位置之后 char temp = numStr[bucket[index]]; numStr[bucket[index]] = numStr[i]; numStr[i] = temp; return Integer.valueOf(new String(numStr)); &#125; &#125; &#125; return num; &#125;&#125; 671. second-minimum-node-in-a-binary-tree 给一个特殊的二叉树，每一个节点只有0或2个children，且值是两个子节点的较小值。求树中第二小的值，若没有，返回-1. 既然找的是比最小值大的最小的值，就用递归的方法在左右两边分别找比最小值的大的最小值，然后比较一下即可。12345678910111213141516171819202122232425262728class Solution &#123; public int findSecondMinimumValue(TreeNode root) &#123; if (root == null || root.left == null || root.right == null) &#123; return -1; &#125; int leftLeastGreater = getLeastGreater(root.left, root.val); int rightLeastGreater = getLeastGreater(root.right, root.val); int min = Math.min(leftLeastGreater, rightLeastGreater); if (leftLeastGreater &gt; root.val &amp;&amp; rightLeastGreater &gt; root.val) &#123; return min; &#125; return leftLeastGreater == root.val ? (rightLeastGreater == root.val ? -1 : rightLeastGreater) : leftLeastGreater; &#125; private int getLeastGreater(TreeNode root, int val) &#123; if (root.left == null &amp;&amp; root.right == null) &#123; return root.val; &#125; int leftLeastGreater = getLeastGreater(root.left, val); int rightLeastGreater = getLeastGreater(root.right, val); if (leftLeastGreater &gt; val &amp;&amp; rightLeastGreater &gt; val) &#123; return Math.min(leftLeastGreater, rightLeastGreater); &#125; else if (leftLeastGreater &gt; val) &#123; return leftLeastGreater; &#125; else &#123; return rightLeastGreater; &#125; &#125;&#125; 673. number-of-longest-increasing-subsequence 给一个数组，求其中最长递增的subsequence的个数。如[1,3,5,4,7]中有两个长度为4的subsequence。 DP。用一个len[k]数组记录以k结尾的字符处的最长长度，count[k]记录对应的计数。双重循环时，当nums[i] &gt; nums[j]，若len[j] + 1 &gt; len[i]则需要更新i处的长度，同时count也直接更新；若len[j] + 1 == len[i]，则说明刚好从j过来可以形成递增sequence，直接累加就行了（一开始以为是lc300求长度，就用stack做了，然而stack这个greedy做法也是错误的，还是需要上DP。。1234567891011121314151617181920212223242526272829303132class Solution &#123; public int findNumberOfLIS(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; int[] len = new int [nums.length]; int[] count = new int [nums.length]; int maxLen = 1, ans = 0; Arrays.fill(len, 1); Arrays.fill(count, 1); for (int i = 1; i &lt; nums.length; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (nums[i] &gt; nums[j]) &#123; // 保证递增关系 int tempLen = len[j] + 1; // 递增后的长度 if (tempLen &gt; len[i]) &#123; len[i] = tempLen; count[i] = count[j]; &#125; else if (tempLen == len[i]) &#123; // 从j跳过来的递增 count[i] += count[j]; &#125; &#125; &#125; maxLen = Math.max(len[i], maxLen); // 记录最大长度，后续用于对比并累计count &#125; for (int i = 0; i &lt; nums.length; i++) &#123; if (len[i] == maxLen) &#123; ans += count[i]; &#125; &#125; return ans; &#125;&#125; 674. longest-continuous-increasing-subsequence 给一个数组，求其中最长递增的连续subarray的长度。如[1,2,3,4,5,6,5,4,3,4,5]就是6，[2,2,2,2,2]就是1. 贪心法，只有大于前面元素才更新，一旦小于就更新到总的里面。注意最后返回之前还要取一次max。1234567891011121314151617class Solution &#123; public int findLengthOfLCIS(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; int ans = 1, curr = 1; for (int i = 1; i &lt; nums.length; i++) &#123; if (nums[i] &gt; nums[i - 1]) &#123; curr++; &#125; else &#123; ans = Math.max(ans, curr); curr = 1; &#125; &#125; return Math.max(ans, curr); &#125;&#125; 676. implement-magic-dictionary 实现buildDict和search方法，search时判断能否通过「替换一个字符」的方式使得修改后的字符串包含在dict中，返回boolean。例如给[&quot;hello&quot;, &quot;leetcode&quot;]，搜索hhllo就返回true、搜索hello返回false。 方法一：dict就想到选择map，在build时对于每个字符串，将其中每个字符替换成特殊字符如*，将替换后的字符串作为key、被替换的字符作为value存入map。如果出现相同的key，则说明这个位置可以放任何字符（例如hello, hallo的第二位）；在搜索时也是对每个字符替换，然后看map中有没有，判断一下当前字符是否是value的字符（防止indentical）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class MagicDictionary &#123; // 将每个单词的每个字符都替换成*之后，插入map，key是替换后的字符串，value是被替换掉的那个字符 // 如果出现替换过后的key一样，则该位可以放任意字符，因为例如hello和hallo只有在第二位不同，如果替换后是h*llo可以任选一个，一定是true。 Map&lt;String, Character&gt; map = null; /** Initialize your data structure here. */ public MagicDictionary() &#123; map = new HashMap&lt;String, Character&gt;(); &#125; /** Build a dictionary through a list of words */ public void buildDict(String[] dict) &#123; if (dict == null || dict.length == 0) &#123; return; &#125; for (String word : dict) &#123; StringBuilder sb = new StringBuilder(word); int len = word.length(); for (int i = 0; i &lt; len; i++) &#123; sb.setCharAt(i, '*'); Character c = map.get(sb.toString()); if (c == null) &#123; map.put(sb.toString(), word.charAt(i)); &#125; else &#123; map.put(sb.toString(), '*'); // 表示可以放任何字符 &#125; sb.setCharAt(i, word.charAt(i)); &#125; &#125; &#125; /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */ public boolean search(String word) &#123; if (word == null || word.length() == 0) &#123; return false; &#125; int len = word.length(); StringBuilder sb = new StringBuilder(word); for (int i = 0; i &lt; len; i++) &#123; sb.setCharAt(i, '*'); Character c = map.get(sb.toString()); if (c != null &amp;&amp; (c == '*' || c != word.charAt(i))) &#123; return true; &#125; sb.setCharAt(i, word.charAt(i)); &#125; return false; &#125;&#125; 方法二：使用Trie。build的时候就正常地创建Trie，然后在search的时候逐个位置替换26个字符，每换一次就在Trie中搜索。Trie的效率感觉不高啊，感觉有square级别。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class MagicDictionary &#123; class TrieNode &#123; TrieNode[] children = new TrieNode[26]; boolean isWord; public TrieNode() &#123;&#125; &#125; TrieNode root; /** Initialize your data structure here. */ public MagicDictionary() &#123; root = new TrieNode(); &#125; /** Build a dictionary through a list of words */ public void buildDict(String[] dict) &#123; for (String s : dict) &#123; TrieNode node = root; for (char c : s.toCharArray()) &#123; if (node.children[c - 'a'] == null) &#123; node.children[c - 'a'] = new TrieNode(); &#125; node = node.children[c - 'a']; &#125; node.isWord = true; &#125; &#125; /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */ public boolean search(String word) &#123; char[] arr = word.toCharArray(); for (int i = 0; i &lt; word.length(); i++) &#123; for (char c = 'a'; c &lt;= 'z'; c++) &#123; if (arr[i] == c) &#123; continue; &#125; char org = arr[i]; arr[i] = c; if (checkTrie(new String(arr), root)) &#123; return true; &#125; arr[i] = org; &#125; &#125; return false; &#125; public boolean checkTrie(String s, TrieNode root) &#123; TrieNode node = root; for (char c : s.toCharArray()) &#123; if (node.children[c - 'a'] == null) &#123; return false; &#125; node = node.children[c - 'a']; &#125; return node.isWord; &#125;&#125; 680. valid-palindrome-ii 给一个字符串，判断能否通过“最多删掉一个字符”形成自对称字符串。例如aba本身就是，abca可以通过删掉b或c变成自对称。 直接前后指针往中间并拢，一旦发现不同的字符就把不同的两个字符分别遮住继续判断，如果还不行那就一定不能自对称了。123456789101112131415161718192021222324class Solution &#123; public boolean validPalindrome(String s) &#123; if (s == null || s.length() == 0) &#123; return false; &#125; int left = 0, right = s.length() - 1; while (left &lt; right) &#123; if (s.charAt(left) != s.charAt(right)) &#123; // 发现对应位置不匹配，尝试遮掉其中一个继续判断 return isPalin(s, left + 1, right) || isPalin(s, left, right - 1); &#125; left++; right--; &#125; return true; &#125; private boolean isPalin(String s, int left, int right) &#123; while (left &lt; right) &#123; if (s.charAt(left++) != s.charAt(right--)) &#123; return false; &#125; &#125; return true; &#125;&#125; 681. next-closest-time 给一个字符串表示时间，求由这些数组组成的、下一个最近的时间（数字可无限使用）。 greedy方法，从末尾开始替换，如果有恰好比他大的数字，替换之后直接就返回了。否则就替换成这些数字中最小的数字。注意每一个位置的限制都不同，例如第二位就需要根据第一位是否为2来决定最大值是3还是9.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123; public String nextClosestTime(String time) &#123; if (time == null || time.length() == 0) &#123; return null; &#125; char[] digits = getDigits(time.split(":")); char[] digitsOrigin = Arrays.copyOf(digits, digits.length); char[] ans = new char[5]; ans[0] = digitsOrigin[0]; ans[1] = digitsOrigin[1]; ans[2] = ':'; ans[3] = digitsOrigin[2]; ans[4] = digitsOrigin[3]; Arrays.sort(digits); ans[4] = getNextGreater(digitsOrigin[3], '9', digits); if (ans[4] &gt; digitsOrigin[3]) &#123; return String.valueOf(ans); &#125; ans[3] = getNextGreater(digitsOrigin[2], '5', digits); if (ans[3] &gt; digitsOrigin[2]) &#123; return String.valueOf(ans); &#125; ans[1] = getNextGreater(digitsOrigin[1], digitsOrigin[0] == '2' ? '3' : '9', digits); if (ans[1] &gt; digitsOrigin[1]) &#123; return String.valueOf(ans); &#125; ans[0] = getNextGreater(digitsOrigin[0], '2', digits); return String.valueOf(ans); &#125; private char[] getDigits(String[] timeSplitted) &#123; char[] digits = new char[4]; digits[0] = (char)('0' + Integer.parseInt(timeSplitted[0]) / 10); digits[1] = (char)('0' + Integer.parseInt(timeSplitted[0]) % 10); digits[2] = (char)('0' + Integer.parseInt(timeSplitted[1]) / 10); digits[3] = (char)('0' + Integer.parseInt(timeSplitted[1]) % 10); return digits; &#125; private char getNextGreater(char curr, char limit, char[] digits) &#123; int pos = Arrays.binarySearch(digits, curr) + 1; while (pos &lt; 4 &amp;&amp; digits[pos] &lt;= limit &amp;&amp; digits[pos] == curr) &#123; pos++; &#125; return pos &lt; 4 &amp;&amp; digits[pos] &lt;= limit ? digits[pos] : digits[0]; &#125;&#125; 682. baseball-game 定义一个积分规则，没有什么好说的，用List即可。 683. k-empty-slots 给一个flowers数组表示第i + 1天，开花的索引是flowers[i]。再给一个k，问是否存在某一天使得存在连续k个花未开且左右两边都已经开放，返回这个天数，若不存在则返回-1。 方法一：维护一个days数组表示该index的花在第days[index]天开。需要求得一个子序列left, left+1, left+2, ..., left+k, right使得days[left]和days[right]开放时间比中间任何一个都要早。从左往右遍历days数组，一旦发现中间某天开花时间早于left或者right就说明这个子序列中断了，更新left为i即可。时间空间都是O(N). 1234567891011121314151617181920212223class Solution &#123; public int kEmptySlots(int[] flowers, int k) &#123; if (flowers == null || flowers.length &lt;= k) &#123; return -1; &#125; int[] days = new int[flowers.length]; for (int i = 0; i &lt; flowers.length; i++) &#123; days[flowers[i] - 1] = i + 1; &#125; int left = 0, right = k + 1, ans = Integer.MAX_VALUE; // 从左开始往右遍历 for (int i = 0; right &lt; days.length; i++) &#123; if (days[i] &lt; days[left] || days[i] &lt;= days[right]) &#123; // 若其中某个i开花时刻早于左或者右侧window，就以该处为新的起点 if (i == right) &#123; // 若遍历到right都没有问题，就是一个新的ans ans = Math.min(ans, Math.max(days[left], days[right])); &#125; left = i; right = i + k + 1; &#125; &#125; return ans == Integer.MAX_VALUE ? -1 : ans; &#125;&#125; 方法二：利用TreeSet存储flowers，随着天数增加，利用TreeSet的lower找小于该索引处的最大值、利用higher找大于该索引的最小值，这样求出来就能碰到完美等于k的子序列了。 123456789101112131415161718class Solution &#123; public int kEmptySlots(int[] flowers, int k) &#123; if (flowers == null || flowers.length &lt;= k) &#123; return -1; &#125; TreeSet&lt;Integer&gt; bloomIndex = new TreeSet&lt;&gt;(); for (int day = 0; day &lt; flowers.length; day++) &#123; bloomIndex.add(flowers[day]); Integer left = bloomIndex.lower(flowers[day]); Integer right = bloomIndex.higher(flowers[day]); if ((left != null &amp;&amp; flowers[day] - left == k + 1) || (right != null &amp;&amp; right - flowers[day] == k + 1)) &#123; return day + 1; &#125; &#125; return -1; &#125;&#125; 684. redundant-connection 给一系列边组成无向图，其中恰好多了一个边使图无法形成树，求多出来的这个边即最后出现的这个边。例如[[1,2], [2,3], [3,4], [1,4], [1,5]]，返回[1,4]。 并查集，维护每个节点的祖先，首次出现时默认以自己为祖先，然后就判断edge中的两个节点祖先是否一样，一样就说明成环了，否则就把前者的祖先指向后者的祖先。123456789101112131415161718192021222324252627282930313233343536class Solution &#123; // 并查集：维护一个Map，表示每个编号的点的祖先 // 一旦找到两个点的祖先一样，就说明这个边就是让前面成环的，直接返回 // 若祖先不同，则直接将前者的祖先归位后者祖先的后代，这样就把两个部分直接合并了，后面判断成环就可以直接判断 public int[] findRedundantConnection(int[][] edges) &#123; if (edges == null || edges.length == 0 || edges[0].length == 0) &#123; return null; &#125; Map&lt;Integer, Integer&gt; parentMap = new HashMap&lt;&gt;(); for (int[] edge: edges) &#123; int from = edge[0]; int to = edge[1]; if (!parentMap.containsKey(from)) &#123; parentMap.put(from, from); // 刚开始设为本身 &#125; if (!parentMap.containsKey(to)) &#123; parentMap.put(to, to); &#125; int fromParent = findParent(parentMap, from); int toParent = findParent(parentMap, to); if (fromParent == toParent) &#123; // 二者的祖先是一样的说明成环了 return edge; &#125; else &#123; parentMap.put(fromParent, toParent); &#125; &#125; return new int [2]; &#125; private int findParent(Map&lt;Integer, Integer&gt; parentMap, int node) &#123; int parent = parentMap.get(node); if (parent != node) &#123; parentMap.put(node, findParent(parentMap, parent)); &#125; return parentMap.get(node); &#125;&#125; 685. redundant-connection-ii 给一系列边组成有向图，其中恰好多了一个边使图无法形成rooted tree，求多出来的这个边即最后出现的这个边。例如[[2,1],[3,1],[4,2],[1,4]]，返回[2,1]。 与684相比这里的边都是有向的了，有两种情况来判别边invalid：形成了环，或者一个节点同时有两个parent节点。做法分为两步：首先check看是否有节点有两个parent，有的话就设为candidate A和B，并把B设置为invalid（设一个节点为0即可）；然后进行union-find，如果此时树已经是valid的了，就直接返回candidate B（因为是后出现的）。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123; public int[] findRedundantDirectedConnection(int[][] edges) &#123; if (edges == null || edges.length == 0 || edges[0].length == 0) &#123; return null; &#125; int[] candidate1 = new int [2]; int[] candidate2 = new int [2]; // 后出现的 int[] parent = new int [edges.length + 1]; // 先找有没有节点有两个parent for (int i = 0; i &lt; edges.length; i++) &#123; if (parent[edges[i][1]] == 0) &#123; // 设置每个孩子节点的parent parent[edges[i][1]] = edges[i][0]; &#125; else &#123; // 发现有重复设置的情况 candidate2[0] = edges[i][0]; candidate2[1] = edges[i][1]; candidate1[0] = parent[edges[i][1]]; // 原本存的parent是谁 candidate1[1] = edges[i][1]; edges[i][1] = 0; // 这个孩子节点暂时设为无效的节点值，比如0 &#125; &#125; // 重新初始化parent，设为本身 for (int i = 0; i &lt; edges.length; i++) &#123; parent[i] = i; &#125; for (int[] edge : edges) &#123; if (edge[1] == 0) &#123; continue; &#125; int father = edge[0], child = edge[1]; // 前-&gt;后 if (root(parent, father) == child) &#123; // 判断两个节点是不是连到一起了，注意这里是直接判断是否以child作为parent，而不像上一题两个节点都要求parent if (candidate1[0] == 0) &#123; // 没有多parent的情况 return edge; &#125; else &#123; return candidate1; &#125; &#125; parent[child] = father; &#125; return candidate2; &#125; private int root(int[] parent, int i) &#123; while (parent[i] != i) &#123; parent[i] = parent[parent[i]]; i = parent[i]; &#125; return i; &#125;&#125; 686. repeated-string-match 给两个字符串A和B，求A需要重复几次才能让B成为它的substring. 狗家实习的OA，自己想的方法。先看看起始字符都出现在哪些索引，统统入queue；然后先拼一波使得A的长度不小于B；然后从queue中取起始索引，比较看B是否包含其中；如果queue还没用完则还需要拼多一次。 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; public int repeatedStringMatch(String A, String B) &#123; if (A == null || B == null) &#123; return -1; &#125; String AOld = A; Queue&lt;Integer&gt; startIndexQueue = new LinkedList&lt;&gt;(); char[] AChar = A.toCharArray(), BChar = B.toCharArray(); char startChar = BChar[0]; // O(N) get start position for (int i = 0; i &lt; AChar.length; i++) &#123; if (AChar[i] == startChar) &#123; startIndexQueue.add(i); &#125; &#125; int repeatCount = 1; while (!startIndexQueue.isEmpty() &amp;&amp; A.length() - startIndexQueue.peek() &lt; BChar.length) &#123; A += AOld; // append if not long enough repeatCount++; &#125; while (!startIndexQueue.isEmpty() &amp;&amp; startIndexQueue.peek() + BChar.length &lt;= A.length()) &#123; int startIndex = startIndexQueue.poll(); if (B.equals(A.substring(startIndex, startIndex + BChar.length))) &#123; return repeatCount; &#125; &#125; // if there is still startIndex in queue, need to repeat and check more if (!startIndexQueue.isEmpty()) &#123; A += AOld; repeatCount++; while (!startIndexQueue.isEmpty()) &#123; if (B.equals(A.substring(startIndexQueue.peek(), startIndexQueue.peek() + BChar.length))) &#123; return repeatCount; &#125; else &#123; startIndexQueue.poll(); &#125; &#125; &#125; return -1; &#125;&#125; 或者直接用拼接的方式，一直拼接A直到超过B的长度，然后看是否包含。如果不包含还需要额外的一次拼接再看。 1234567891011public int repeatedStringMatch(String A, String B) &#123; int count = 0; StringBuilder sb = new StringBuilder(); while (sb.length() &lt; B.length()) &#123; sb.append(A); count++; &#125; if (sb.toString().contains(B)) return count; if (sb.append(A).toString().contains(B)) return ++count; return -1;&#125; 687. longest-univalue-path 给一个二叉树，求其中最长的连续边数使得经过的节点值都一样。不一定是完全笔直的路径。 对于左子树和右子树递归调用求最长路径（不取当前节点的情况），然后根据当前节点的值进行DFS（也就是取当前节点的情况）。最后取最大。 123456789101112131415class Solution &#123; public int longestUnivaluePath(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; int child = Math.max(longestUnivaluePath(root.left), longestUnivaluePath(root.right)); return Math.max(child, dfs(root.left, root.val) + dfs(root.right, root.val)); &#125; private int dfs(TreeNode node, int val) &#123; if (node == null || node.val != val) &#123; return 0; &#125; return 1 + Math.max(dfs(node.left, val), dfs(node.right, val)); // two nodes forms one edge &#125;&#125; 但是上面的这个方法存在大量重复访问节点，时间复杂度O(N^2)。因此考虑和之前diameter题一样，使用全局变量求最大path，同时在dfs每步直接将两侧中较大深度返回给上一层。 12345678910111213141516171819class Solution &#123; int maxLen = 0; public int longestUnivaluePath(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; dfs(root, root.val); return maxLen; &#125; private int dfs(TreeNode node, int val) &#123; if (node == null) &#123; return 0; &#125; int left = dfs(node.left, node.val); int right = dfs(node.right, node.val); maxLen = Math.max(maxLen, left + right); // 取当前node为转折点 return node.val == val ? Math.max(left, right) + 1 : 0; &#125;&#125; 689. maximum-sum-of-3-non-overlapping-subarrays 给一个正整数数组，找出三个互不重叠的、size为k的子数组，使得总和最大。返回的形式是每个subarray的起始索引。例如[1,2,1,2,6,7,5,1], k=2则返回[0, 3, 5]。 有唯一解吗？（可能有多个，只需返回最先出现索引）k本身会不会很大？（不会，不大于len/3） 首先是如何快速求某个区间内的和？如果数值都不大的话，可以通过累加把sum都给缓存下来，用的时候直接减一下就行了。然后是如何求subarray的结果？可以用二位dp数组，行表示划分成row个subarray，列表示从0到col处为止能得到的最大的总sum。此外还需要一个二维index数组记录第row个subarray对应的起始位置。从第一个subarray开始循环，固定求size为k的subarray使之和最大，其实就是贪心的思想，只要过程中求的每个subarray的和都最大那么最终的总和就是最大的。在循环过程中就可以不断求总和，为了防止重叠求和时必须求往前k个元素为end的dp结果。123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public int[] maxSumOfThreeSubarrays(int[] nums, int k) &#123; // 动态规划 if (nums == null || nums.length == 0) &#123; return new int [0]; &#125; // 缓存到i为止到所有项之和 int[] sumArray = new int [nums.length]; sumArray[0] = nums[0]; for (int i = 1; i &lt; nums.length; i++) &#123; sumArray[i] = sumArray[i - 1] + nums[i]; &#125; // dp[i][j]表示求i个non-overlap sum的时候从0~j能得到的最大总sum int[][] dp = new int [4][nums.length]; // index[i][j]表示求第i个non-overlap sum的时候的starting index int[][] index = new int [4][nums.length]; for (int i = 1; i &lt; 4; i++) &#123; // 从求第1个最大的k-size subarray开始直到第3个 for (int j = k - 1; j &lt; nums.length; j++) &#123; int tempMax = j == k - 1? sumArray[j] : // 快速求区间内的和 sumArray[j] - sumArray[j - k] + dp[i - 1][j - k]; // 加上上一行前一个block为止的最大和 if (j &gt; k - 1) &#123; // 先直接沿用同一行的前面的结果 dp[i][j] = dp[i][j - 1]; index[i][j] = index[i][j - 1]; &#125; if (j &gt; 0 &amp;&amp; tempMax &gt; dp[i][j - 1]) &#123; // 若发现有更大的就更新当前最大和到dp dp[i][j] = tempMax; index[i][j] = j - k + 1; // 同时更新最大和出现的下标 &#125; &#125; &#125; int[] ans = new int [3]; ans[2] = index[3][nums.length - 1]; // 最后一行的最后一位就是第三个block的index ans[1] = index[2][ans[2] - 1]; // 倒数第二行的index[3]之前的存的就是第二行的 ans[0] = index[1][ans[1] - 1]; return ans; &#125;&#125; 690. employee-importance 给一个List of Employee，包含id、importance、下属List等属性。给定id，求这个id对应员工及其所有下属（不一定是直接下属）的imp之和。 DFS。用一个Map先存储id-Employee的键值对，然后可以给定一个id快速访问到该Employee的信息，然后DFS递归搞定。1234567891011121314151617181920212223242526272829303132333435/*// Employee infoclass Employee &#123; // It's the unique id of each node; // unique id of this employee public int id; // the importance value of this employee public int importance; // the id of direct subordinates public List&lt;Integer&gt; subordinates;&#125;;*/class Solution &#123; public int getImportance(List&lt;Employee&gt; employees, int id) &#123; if (employees == null || employees.size() == 0) &#123; return 0; &#125; Map&lt;Integer, Employee&gt; map = new HashMap&lt;&gt;(); for (Employee e : employees) &#123; map.put(e.id, e); &#125; return getImp(map, id); &#125; private int getImp(Map&lt;Integer, Employee&gt; map, int id) &#123; if (!map.containsKey(id)) &#123; return 0; &#125; Employee e = map.get(id); int imp = e.importance; for (Integer i : e.subordinates) &#123; imp += getImp(map, i); &#125; return imp; &#125;&#125; 692. top-k-frequent-words 给一个String数组，求出现频率top k的字符串。 跟347类似。先用Map存每个单词出现的频数，再自定义根据频数minHeap存这些Map.Entry，然后每次都check堆的规模，一旦大于k就直接把最小的poll出来，这样就保证在minHeap中的一定是top k.最后就直接逆序插入结果List。 123456789101112131415161718192021222324252627282930313233class Solution &#123; public List&lt;String&gt; topKFrequent(String[] words, int k) &#123; List&lt;String&gt; ans = new ArrayList&lt;&gt;(); if (words == null || words.length == 0 || k == 0) &#123; return ans; &#125; // 统计每个单词出现的频数 Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); for (String word : words) &#123; if (!map.containsKey(word)) &#123; map.put(word, 1); &#125; else &#123; map.put(word, map.get(word) + 1); &#125; &#125; // 将entry按照频数从小到大插入PQ，若规模&gt;k则直接poll掉最小的 PriorityQueue&lt;Map.Entry&lt;String, Integer&gt;&gt; pq = new PriorityQueue&lt;&gt;((a, b) -&gt; &#123; return a.getValue() != b.getValue()? a.getValue() - b.getValue() : b.getKey().compareTo(a.getKey()); &#125;); for (Map.Entry&lt;String, Integer&gt; e : map.entrySet()) &#123; pq.offer(e); if (pq.size() &gt; k) &#123; pq.poll(); &#125; &#125; // 取PQ元素，逆序插入结果 while (!pq.isEmpty()) &#123; ans.add(0, pq.poll().getKey()); &#125; return ans; &#125;&#125; follow-up：如果给定的输入不是一个完整的数组，而是一个stream，即每次都只能取得一个单词，然后立即返回top k，如何改进？ 关键在于无法在最开始就获得完整的频数统计Map，在插入minHeap的时候就无法知道后续的Entry需不需要覆盖PQ中的值。因此需要一个额外的Map记录具体哪些Entry目前被存放在minHeap中；当新的单词出现，就先更新map中的项，然后再看看它是否在PQ中，在则需要更新（我只能想到把k个元素全抖出来再加进去），不在则跟minHeap的peek比较决定是否需要替换。这样时间是O(N)的统计频数、O(logN)的插入minHeap、O(KlogK)的更新(?)和最后O(K)的倒入List。 694. number-of-distinct-islands 给一个grid，其中含有0和1，求所有distinct的连续1的团簇的个数，distinct指的是通过位移无法完全匹配的连续的1的区域。 与统计number of island的区别在于这里的island需要通过某种方式辨别该形状是否出现过，联想到encode方法，利用上下左右标记走过的路程。对于DFS，需要额外标出回溯的字母。对于BFS，也需要在结束当前节点的邻接点enqueue后加上标记符。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123; private final int[][] directions = new int[][] &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; private final char[] directionsChar = new char[] &#123;'u', 'd', 'l', 'r'&#125;; public int numDistinctIslands(int[][] grid) &#123; if (grid == null || grid.length == 0 || grid[0].length == 0) &#123; return 0; &#125; int rowTotal = grid.length, colTotal = grid[0].length; Set&lt;String&gt; set = new HashSet&lt;&gt;(); for (int i = 0; i &lt; rowTotal; i++) &#123; for (int j = 0; j &lt; colTotal; j++) &#123; if (grid[i][j] == 1) &#123; StringBuilder sb = new StringBuilder(); // dfs(grid, i, j, sb, 'o'); bfs(grid, i, j, sb); set.add(sb.toString()); &#125; &#125; &#125; return set.size(); &#125; private void bfs(int[][] grid, int row, int col, StringBuilder sb) &#123; Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;(); q.offer(new int[] &#123;row, col&#125;); grid[row][col] = 0; // BFS在加入queue的时候就要将grid标记为已访问了 while (!q.isEmpty()) &#123; int[] curr = q.poll(); for (int i = 0; i &lt; directions.length; i++) &#123; int rowNeighbor = curr[0] + directions[i][0]; int colNeighbor = curr[1] + directions[i][1]; if (validatePos(grid, rowNeighbor, colNeighbor)) &#123; grid[rowNeighbor][colNeighbor] = 0; q.offer(new int[] &#123;rowNeighbor, colNeighbor&#125;); sb.append(directionsChar[i]); &#125; &#125; sb.append(','); // 表示将当前的所有neighbor都enqueue了 &#125; &#125; private void dfs(int[][] grid, int row, int col, StringBuilder sb, char dir) &#123; grid[row][col] = 0; sb.append(dir); for (int i = 0; i &lt; directions.length; i++) &#123; int rowNeighbor = row + directions[i][0]; int colNeighbor = col + directions[i][1]; if (validatePos(grid, rowNeighbor, colNeighbor)) &#123; dfs(grid, rowNeighbor, colNeighbor, sb, directionsChar[i]); &#125; &#125; sb.append('b'); // Trick!!! DFS回溯的时候需要标出来，不然无法区分是否回溯之后的位移 &#125; private boolean validatePos(int[][] grid, int row, int col) &#123; return row &gt;= 0 &amp;&amp; row &lt; grid.length &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; grid[0].length &amp;&amp; grid[row][col] == 1; &#125;&#125; 695. max-area-of-island 给一个grid，表示水和小岛，求最大的岛的面积。DFS搞定，skip。 696. count-binary-substrings 给一个只含有0和1的字符串，求其中有多少个子字符串使得0和1分别连续出现且个数相等，例如01, 1100就满足要求。 从头到尾遍历，然后双指针扩散判断。123456789101112131415161718192021222324class Solution &#123; public int countBinarySubstrings(String s) &#123; if (s == null || s.length() &lt; 2) &#123; return 0; &#125; int left = 0, right = 1, ans = 0; // 同时比较相邻两个字符 while (right &lt; s.length()) &#123; if (s.charAt(left) != s.charAt(right)) &#123; // 往左和右分别扩展 char charLeft = s.charAt(left), charRight = s.charAt(right); int i = left - 1, j = right + 1, count = 1; while (i &gt;= 0 &amp;&amp; s.charAt(i) == charLeft &amp;&amp; j &lt; s.length() &amp;&amp; s.charAt(j) == charRight) &#123; i--; j++; count++; &#125; ans += count; &#125; left++; right++; &#125; return ans; &#125;&#125; 698. partition-to-k-equal-sum-subsets 给一个只含有(0, 10000)的int数组和一个k，判断是否可以将该数组划分为k个相等sum的partition。 似乎是个NP-hard的问题。只能用暴力办法，DFS+标记数组，每次累加过后进入下一层看看是否达到了targetSum，达到了就清空继续往后找新的一组subset.最后如果只剩下一组了，直接返回true，因为此时其他k - 1个组都已经达到targetSum了，当前的sum = k * targetSum - (k - 1) * targetSum = targetSum. 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public boolean canPartitionKSubsets(int[] nums, int k) &#123; if (nums == null || nums.length == 0 || k &gt; nums.length || k &lt; 1) &#123; return false; &#125; if (k == 1) &#123; return true; &#125; int sum = IntStream.of(nums).sum(); // Java8的stream! if (sum % k != 0) &#123; return false; &#125; int targetSum = sum / k; boolean[] visited = new boolean[nums.length]; return checkPartition(nums, visited, 0, targetSum, 0, k); &#125; public boolean checkPartition(int[] nums, boolean[] visited, int startIndex, int targetSum, int currSum, int k) &#123; if (k == 1) &#123; // 提前break return true; &#125; if (currSum == targetSum) &#123; return checkPartition(nums, visited, 0, targetSum, 0, k - 1); &#125; for (int i = startIndex; i &lt; nums.length; i++) &#123; if (!visited[i]) &#123; visited[i] = true; if (checkPartition(nums, visited, i + 1, targetSum, currSum + nums[i], k)) &#123; return true; &#125; visited[i] = false; &#125; &#125; return false; &#125;&#125; 方法二：更快的做法是先对数组排序，然后存k个bucket，每个bucket从后往前取元素不断累加. 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public boolean canPartitionKSubsets(int[] nums, int k) &#123; if (nums == null || nums.length == 0 || k &gt; nums.length || k &lt; 1) &#123; return false; &#125; if (k == 1) &#123; return true; &#125; int sum = 0; for (int num : nums) &#123; sum += num; &#125; if (sum % k != 0) &#123; return false; &#125; int targetSum = sum / k; Arrays.sort(nums); return checkPartition(nums, targetSum, new int[k], nums.length - 1); &#125; public boolean checkPartition(int[] nums, int targetSum, int[] buckets, int numsIndex) &#123; if (numsIndex &lt; 0) &#123; for (int bucket : buckets) &#123; if (bucket != targetSum) &#123; return false; &#125; &#125; return true; &#125; for (int i = 0; i &lt; buckets.length; i++) &#123; if (buckets[i] + nums[numsIndex] &lt;= targetSum) &#123; buckets[i] += nums[numsIndex]; if (checkPartition(nums, targetSum, buckets, numsIndex - 1)) &#123; return true; &#125; buckets[i] -= nums[numsIndex]; &#125; &#125; return false; &#125;&#125; follow-up: 如果去掉正数的限制，允许出现负数和0？ 上面的方法只考虑了直接累积叠加，无法解决负数问题。因此需要引入一个elementCount来统计当前这一波存入了多少element，当达到targetSum的时候需要判断当前这一波是否真的存入了元素。1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public boolean canPartitionKSubsets(int[] nums, int k) &#123; if (nums == null || nums.length == 0 || k &gt; nums.length || k &lt; 1) &#123; return false; &#125; if (k == 1) &#123; return true; &#125; int sum = IntStream.of(nums).sum(); if (sum % k != 0) &#123; return false; &#125; int targetSum = sum / k; boolean[] visited = new boolean[nums.length]; return checkPartition(nums, visited, 0, targetSum, 0, k, 0); &#125; public boolean checkPartition(int[] nums, boolean[] visited, int startIndex, int targetSum, int currSum, int k, int elementCount) &#123; if (k == 0) &#123; // 必须算完才行 return true; &#125; if (currSum == targetSum &amp;&amp; elementCount &gt; 0) &#123; return checkPartition(nums, visited, 0, targetSum, 0, k - 1, 0); &#125; for (int i = startIndex; i &lt; nums.length; i++) &#123; if (!visited[i]) &#123; visited[i] = true; if (checkPartition(nums, visited, i + 1, targetSum, currSum + nums[i], k, elementCount + 1)) &#123; return true; &#125; visited[i] = false; &#125; &#125; return false; &#125;&#125; 699. falling-squares 给一个二维数组，每一行表示一个方块的起始坐标和边长。方块按照数组的顺序下落，方块底部可以粘在下面的方块上，无限堆叠，求一个List表示当前已下落的所有方块中的最大高度。 方法一：naive的O(N^2)暴力遍历法。对于每个方块都往前遍历所有的方块求当前方块的高度，然后和List的前一个元素比较，获取最大高度。 12345678910111213141516171819202122232425262728293031323334class Solution &#123; class Square &#123; int left, right, height; public Square(int left, int right, int height) &#123; this.left = left; this.right = right; this.height = height; &#125; &#125; public List&lt;Integer&gt; fallingSquares(int[][] positions) &#123; List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); if (positions == null || positions.length == 0 || positions[0].length &lt; 2) &#123; return ans; &#125; Square[] squares = new Square[positions.length]; for (int i = 0; i &lt; positions.length; i++) &#123; squares[i] = new Square(positions[i][0], positions[i][0] + positions[i][1], positions[i][1]); int currHeight = getHeight(squares, i); squares[i].height = currHeight; ans.add(Math.max(i &gt; 0 ? ans.get(i - 1) : 0, currHeight)); &#125; return ans; &#125; private int getHeight(Square[] squares, int i) &#123; int maxHeight = squares[i].height; for (int j = 0; j &lt; i; j++) &#123; if (squares[i].left &gt;= squares[j].right || squares[i].right &lt;= squares[j].left) &#123; continue; &#125; maxHeight = Math.max(maxHeight, squares[i].height + squares[j].height); &#125; return maxHeight; &#125;&#125; 方法二：TreeMap 方法三：Segment Tree 703. kth-largest-element-in-a-stream 实现一个能handle stream of int的类，调用add时能返回第k大的数。 和求top k element一个道理，PriorityQueue搞定。skip. 711. number-of-distinct-islands-ii 给一个二维grid表示小岛，求其中形状distinct的小岛数量。这些形状可以任意平移、轴对称、翻转。 暴力方法，遍历完一个小岛的时候就将所有的轴对称、翻转形式统统列出来，然后根据某个统一标准取一个root form来代表所有这些形状，这里就直接使用encode之后字典序最小的作为key。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution &#123; final private int[][] directions = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; final private int[][] transitions = &#123;&#123;1, 1&#125;, &#123;1, -1&#125;, &#123;-1, 1&#125;, &#123;-1, -1&#125;&#125;; public int numDistinctIslands2(int[][] grid) &#123; if (grid == null || grid.length == 0 || grid[0].length == 0) &#123; return 0; &#125; int rowTotal = grid.length, colTotal = grid[0].length; Set&lt;String&gt; islandSet = new HashSet&lt;&gt;(); for (int i = 0; i &lt; rowTotal; i++) &#123; for (int j = 0; j &lt; colTotal; j++) &#123; if (grid[i][j] == 1) &#123; List&lt;int[]&gt; island = new ArrayList&lt;&gt;(); dfs(grid, i, j, island); islandSet.add(getRootShape(island)); &#125; &#125; &#125; return islandSet.size(); &#125; private void dfs(int[][] grid, int row, int col, List&lt;int[]&gt; island) &#123; island.add(new int[] &#123;row, col&#125;); grid[row][col] = 0; for (int[] direction : directions) &#123; int rowNeighbor = row + direction[0]; int colNeighbor = col + direction[1]; if (validatePos(grid, rowNeighbor, colNeighbor)) &#123; dfs(grid, rowNeighbor, colNeighbor, island); &#125; &#125; &#125; private boolean validatePos(int[][] grid, int row, int col) &#123; return row &gt;= 0 &amp;&amp; row &lt; grid.length &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; grid[0].length &amp;&amp; grid[row][col] == 1; &#125; private String getRootShape(List&lt;int[]&gt; island) &#123; List&lt;String&gt; shapes = new ArrayList&lt;&gt;(); // 对于shape中的一个点，总共有八种形式 // (x, y), (x, -y), (-x, y), (-x, -y) // (y, x), (-y, x), (y, -x), (-y, -x) for (int[] transition : transitions) &#123; List&lt;int[]&gt; list1 = new ArrayList&lt;&gt;(); List&lt;int[]&gt; list2 = new ArrayList&lt;&gt;(); for (int[] point : island) &#123; list1.add(new int[] &#123;point[0] * transition[0], point[1] * transition[1]&#125;); list2.add(new int[] &#123;point[1] * transition[1], point[0] * transition[0]&#125;); &#125; shapes.add(getKey(list1)); // 获取每个方向上的root encode形式 shapes.add(getKey(list2)); &#125; Collections.sort(shapes); // 用最小的代表所有这些shape return shapes.get(0); &#125; private String getKey(List&lt;int[]&gt; points) &#123; Collections.sort(points, (a, b) -&gt; a[0] != b[0] ? a[0] - b[0] : a[1] - b[1]); StringBuilder sb = new StringBuilder(); int row = points.get(0)[0], col = points.get(0)[1]; for (int[] point : points) &#123; // 注意是与最小的那个点的delta作为坐标，即相对坐标 sb.append(point[0] - row).append(',').append(point[1] - col).append(';'); &#125; return sb.toString(); &#125;&#125; 714. best-time-to-buy-and-sell-stock-with-transaction-fee 给一个数组表示股票价格，每次交易（买卖完成算一次）都会收取手续费。求最大收益。 （思路来自覃超说算法）DP。profit[i][0]表示第i天不持有股票手头的资金，profit[i][1]表示第i天持有股票手头的资金.初始化时第一天如果不持有股票则手头为0，若持有股票则需要消耗资金，因此是-price[0]。之后的状态转换为profit[i][0] = profit[i - 1][0]（前一天也没有买入）和profit[i - 1][1] + prices[i]（前一天是持有的，今天卖出）的较大者。类似地，profit[i][1] = profit[i - 1][1]（前一天也持有）和profit[i - 1][0] - prices[i]（前一天没有，今天买入）的较大者。最后返回最后一天不持有股票的profit即可。123456789101112131415class Solution &#123; public int maxProfit(int[] prices, int fee) &#123; if (prices == null || prices.length == 0) &#123; return 0; &#125; int[][] profit = new int [prices.length][2]; profit[0][0] = 0; profit[0][1] = -prices[0]; for (int i = 1; i &lt; profit.length; i++) &#123; profit[i][0] = Math.max(profit[i - 1][0], profit[i - 1][1] + prices[i] - fee); profit[i][1] = Math.max(profit[i - 1][1], profit[i - 1][0] - prices[i]); &#125; return profit[prices.length - 1][0]; &#125;&#125; 719. find-k-th-smallest-pair-distance 给一个int数组，求每两个数之差中第k小的值。例如[1,3,8,4,5,45]，当k = 1，返回1，当k = 3，返回2. 先对所有元素从小到大排序，那么间距最小值为0、最大值为最右减最左。用二分查找的思想，假设mid为第k小的值，然后O(N^2)遍历求有多少对儿数之差小于mid；若对儿数小于k，说明猜的值太小了排太前了；大于k则说明猜太大了。12345678910111213141516171819202122232425class Solution &#123; public int smallestDistancePair(int[] nums, int k) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; Arrays.sort(nums); int lo = 0, hi = nums[nums.length - 1] - nums[0]; while (lo &lt; hi) &#123; int mid = lo + (hi - lo) / 2; // 猜一个距离 int count = 0, left = 0; for (int right = 1; right &lt; nums.length; right++) &#123; while (nums[right] - nums[left] &gt; mid) &#123; left++; &#125; count += right - left; &#125; if (count &lt; k) &#123; // 说明猜的不够大 lo = mid + 1; &#125; else &#123; hi = mid; &#125; &#125; return lo; &#125;&#125; 720. longest-word-in-dictionary 给一个string数组，只含有小写字母，这些word可能形成链式如a, ap, app, appl, apple，求能形成链式的最长的单词，若有多个则取lexicographical最小的。 用sort + Set的方式比较trivial。还有一种Trie + DFS/BFS的更考察基本功，构建trie之后从root节点开始尝试从后往前遍历邻接点并更新最长word，这样就可以保证是lexicograpchical最小的了。 721. accounts-merge 给一堆字符串List，每个List中首先是名字，然后是这个人的各种邮箱。最后放回经过merge的姓名、邮箱List，并且要求将邮箱从小到大排序。 这种多对一的关系查找，特别适合用并查集。首先将每个邮箱的parent设为自己，然后将每个List靠后面的邮箱统一把parent设成第一个邮箱。然后利用TreeSet实现邮箱的排序，最后导出到List返回。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123; public List&lt;List&lt;String&gt;&gt; accountsMerge(List&lt;List&lt;String&gt;&gt; accounts) &#123; List&lt;List&lt;String&gt;&gt; ans = new ArrayList&lt;&gt;(); if (accounts == null || accounts.size() == 0) &#123; return ans; &#125; // 初始化并查集，并存放每个email的主人 Map&lt;String, String&gt; parent = new HashMap&lt;&gt;(); Map&lt;String, String&gt; emailOwner = new HashMap&lt;&gt;(); for (List&lt;String&gt; account : accounts) &#123; for (int i = 1; i &lt; account.size(); i++) &#123; parent.put(account.get(i), account.get(i)); // 老大初始化为自己 emailOwner.put(account.get(i), account.get(0)); &#125; &#125; // 将同一个人的邮箱存入并查集map for (List&lt;String&gt; account : accounts) &#123; String root = find(parent, account.get(1)); for (int i = 2; i &lt; account.size(); i++) &#123; parent.put(find(parent, account.get(i)), root); &#125; &#125; // 将同属一个老大的email存入TreeSet以排序 Map&lt;String, Set&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); for (List&lt;String&gt; account : accounts) &#123; String root = find(parent, account.get(1)); if (!map.containsKey(root)) &#123; map.put(root, new TreeSet&lt;String&gt;()); &#125; for (int i = 1; i &lt; account.size(); i++) &#123; map.get(root).add(account.get(i)); &#125; &#125; // 最后导出到List中返回 for (String email : map.keySet()) &#123; String owner = emailOwner.get(email); List&lt;String&gt; list = new ArrayList&lt;&gt;(map.get(email)); list.add(0, owner); ans.add(list); &#125; return ans; &#125; private String find(Map&lt;String, String&gt; parent, String s) &#123; while (!parent.get(s).equals(s)) &#123; parent.put(s, parent.get(parent.get(s))); // 将当前的parent设为"parent的parent" s = parent.get(s); &#125; return s; &#125;&#125; 其实更直白的看，这题就是个图论题，整理出图的联通部分。首先是构建graph，每个邮箱都是节点，用Set存每一行所给邮箱组成的subgraph，每个邮箱都用Set存放可达邻居（需要双向添加）。然后开始DFS或BFS搜索图，将每一行的第一个邮箱作为起点，把所有可达的邮箱都加进来，在这个过程中需要标记visited。之后如果再遇到visited的邮箱就说明已经在之前“可达”掉了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123; public List&lt;List&lt;String&gt;&gt; accountsMerge(List&lt;List&lt;String&gt;&gt; accounts) &#123; // build the graph Map&lt;String,Set&lt;String&gt;&gt; graph = new HashMap&lt;&gt;(); for (List&lt;String&gt; ls : accounts) &#123; for (int i = 1; i &lt; ls.size();i ++) &#123; if (!graph.containsKey(ls.get(i))) graph.put(ls.get(i), new HashSet&lt;String&gt;()); graph.get(ls.get(i)).add(ls.get(1)); graph.get(ls.get(1)).add(ls.get(i)); &#125; &#125; // traverse the graph, find out all the connected subgraph Set&lt;String&gt; visited = new HashSet&lt;&gt;(); List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;(); for (List&lt;String&gt; ls : accounts) &#123; if (!visited.contains(ls.get(1))) &#123; List&lt;String&gt; ans = new ArrayList&lt;&gt;(); bfs(graph, visited, ls.get(1), ans); // or dfs(graph,visited,ls.get(1),ans) Collections.sort(ans); ans.add(0,ls.get(0)); result.add(ans); &#125; &#125; return result; &#125; public void dfs(Map&lt;String, Set&lt;String&gt;&gt; graph, Set&lt;String&gt; visited, String s, List&lt;String&gt; ans) &#123; ans.add(s); visited.add(s); for (String str : graph.get(s)) &#123; if (!visited.contains(str)) &#123; dfs(graph, visited, str, ans); &#125; &#125; &#125; public void bfs(Map&lt;String, Set&lt;String&gt;&gt; graph, Set&lt;String&gt; visited, String s, List&lt;String&gt; ans) &#123; Queue&lt;String&gt; q = new LinkedList&lt;&gt;(); q.add(s); visited.add(s); while (!q.isEmpty()) &#123; String t = q.poll(); ans.add(t); for (String str : graph.get(t)) &#123; if (!visited.contains(str)) &#123; q.add(str); visited.add(str); &#125; &#125; &#125; &#125;&#125; 722. remove-comments 给一个string数组，每一个string代表一行C++代码，要求将其中的comment清除。可以保证这些comment不会存在于字符串中。 没什么意思。用一个inComment布尔值存放当前是否在注释块中。遍历每行代码的时候若仍在注释块中则关注*/；正常状态下则先关注是否是//，这样后续就不用继续append了，否则关注/*。 724. find-pivot-index 给一个int数组，求其中一个index使得左侧数字之和与右侧数字之和相等。zillow面试原题，维护leftSum和rightSum即可。 726. number-of-atoms 给一个字符串表示化学物质，统计其中的元素及出现次数，按字典序输出。例如H2(O(Mn)2)3输出H2Mn6O3. 只有1个元素是输出1还是不输出？（不输出数字，只输出元素） 由于含有括号，联想运算符算式就知道要用Stack进行吞吐来处理括号嵌套的情况。如果是字母，就一直找到小写的为止作为元素名字，之后跟着的数字就是count，存入map。若出现左括号，则当前的这个map（保存了括号之前的元素及count）直接入栈，然后用新的map继续统计，一旦遇到右括号，说明当前部分结束(注意需要检查右括号之后还有没有数字)，则与栈顶弹出的map合并一下就好了。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Solution &#123; public String countOfAtoms(String formula) &#123; if (formula == null || formula.length() == 0) &#123; return ""; &#125; Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); Stack&lt;Map&gt; stack = new Stack&lt;&gt;(); char[] fChar = formula.toCharArray(); int i = 0, fLen = fChar.length; while (i &lt; fLen) &#123; if (fChar[i] == '(') &#123; // 将之前的map压栈 stack.push(map); map = new HashMap&lt;&gt;(); i++; &#125; else if (fChar[i] == ')') &#123; // 将当前的合并入之前的map int count = 0; i++; // 取括号后的数值 while (i &lt; fLen &amp;&amp; Character.isDigit(fChar[i])) &#123; count = (10 * count) + fChar[i++] - '0'; &#125; if (count == 0) &#123; count = 1; &#125; if (!stack.isEmpty()) &#123; Map&lt;String, Integer&gt; prevMap = stack.pop(); for (String atom: map.keySet()) &#123; // 取当前map中的atom放入之前的 prevMap.put(atom, prevMap.getOrDefault(atom, 0) + map.get(atom) * count); &#125; map = prevMap; // 用回原来的map &#125; &#125; else &#123; // 以字母开头，直到非小写字母为一个原子 int end = i + 1; while (end &lt; fLen &amp;&amp; Character.isLowerCase(fChar[end])) &#123; end++; &#125; String atom = formula.substring(i, end); // 看看字母之后是否跟着数字 int count = 0; while (end &lt; fLen &amp;&amp; Character.isDigit(fChar[end])) &#123; count = 10 * count + fChar[end++] - '0'; &#125; if (count == 0) &#123; count = 1; &#125; // 更新原子数值 map.put(atom, map.getOrDefault(atom, 0) + count); i = end; &#125; &#125; StringBuilder sb = new StringBuilder(); List&lt;String&gt; atoms = new ArrayList&lt;&gt;(map.keySet()); Collections.sort(atoms); // 字母顺序 for (String atom: atoms) &#123; sb.append(atom); if (map.get(atom) &gt; 1) &#123; sb.append(map.get(atom)); &#125; &#125; return sb.toString(); &#125;&#125; 727. minimum-window-subsequence 给一个source字符串和一个target字符串，求在source的最短子串使得包含target的所有字符（个数和出现顺序都必须一致）。 DP（感觉是野路子，不太好想）。。。纵向行为target，横向列为source，第一行全部初始化为0,1,2....sLen表示从第几位开始取，之后所有值初始化为-1表示无解。然后O(M*N)逐个字符遍历两个字符串，若匹配上了则从左上方取起始位置（看前一个字符的情况），若匹配不上则默认继续取source（直接取左侧的值）。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123; public String minWindow(String S, String T) &#123; // 动态规划, 行为tLen + 1, 列为sLen + 1, dp[][]表示从dp[i][j]到j到这部分字符串是所求， // 即T[0, j)是S[0, i)的subsequence with substring S[dp[i][j], j). // 初始状态为 // 状态转换为，若当前字符不匹配，则根据左侧（即S前一个字符）情况决定起始位置（保证最短） // 若匹配，则依赖于左上方的结果，即T前一个字符的起始位置。 if (S == null || T == null || S.length() == 0 || T.length() == 0) &#123; return ""; &#125; char[] sChar = S.toCharArray(); char[] tChar = T.toCharArray(); int sLen = sChar.length, tLen = tChar.length; int[][] startFrom = new int [tLen + 1][sLen + 1]; for (int i = 0; i &lt;= tLen; i++) &#123; for (int j = 0; j &lt;= sLen; j++) &#123; if (i == 0) &#123; startFrom[i][j] = j; &#125; else &#123; startFrom[i][j] = -1; // -1表示无解 &#125; &#125; &#125; for (int i = 1; i &lt;= tLen; i++) &#123; for (int j = 1; j &lt;= sLen; j++) &#123; if (sChar[j - 1] == tChar[i - 1]) &#123; startFrom[i][j] = startFrom[i - 1][j - 1]; &#125; else &#123; startFrom[i][j] = startFrom[i][j - 1]; &#125; &#125; &#125; int start = 0, end = sLen, minLen = Integer.MAX_VALUE; for (int j = 1; j &lt;= sLen; j++) &#123; System.out.print(startFrom[tLen][j] + " "); if (startFrom[tLen][j] != -1) &#123; int currLen = j - startFrom[tLen][j]; if (currLen &lt; minLen) &#123; start = startFrom[tLen][j]; end = j; minLen = currLen; &#125; &#125; &#125; return minLen == Integer.MAX_VALUE? "" : S.substring(start, end); &#125;&#125; 729. my-calendar-i 给若干开始时间+结束时间pair，实现book函数判断能否成功添加事件，不能有时间重叠。 方法一：暴力法，从头到尾遍历链表，无冲突就插入。效率O(N)。 123456789101112131415161718192021222324252627282930313233343536373839404142class MyCalendar &#123; // 定义一个链表，每次遍历所有节点判断有没有重合，没有就插入到末尾 class Node &#123; int start; int end; Node next; public Node(int start, int end) &#123; this.start = start; this.end = end; next = null; &#125; &#125; Node head = null; public MyCalendar() &#123; head = null; &#125; public boolean book(int start, int end) &#123; if (head == null) &#123; head = new Node(start, end); return true; &#125; else &#123; return checkAndAdd(new Node(start, end)); &#125; &#125; // brute force: check with every existing intervals and insert at the end private boolean checkAndAdd(Node node) &#123; Node curr = head; Node prev = null; while (curr != null) &#123; if (node.end &gt; curr.start &amp;&amp; node.start &lt; curr.end) &#123; return false; &#125; else &#123; prev = curr; curr = curr.next; &#125; &#125; prev.next = node; return true; &#125;&#125; 方法二：利用TreeMap，对于每个[start, end]对，从TreeMap中找start的floor，取出它对应的end。一旦这个end大于start，就说明有重叠了。同理，也要从TreeMap中找start的ceiling，如果这个ceiling小于end，说明与后面有重叠。 1234567891011121314151617181920212223242526class MyCalendar &#123; // 维护start-end的TreeMap，每次尝试取输入的start的在TreeeMap中的下界和上界 // 分别判断输入的start是否在最大的不大于start的floorStart对应的end之间， // 再判断最小的不小于start的ceilingStart会不会落在end之前 TreeMap&lt;Integer, Integer&gt; calendar; public MyCalendar() &#123; calendar = new TreeMap&lt;&gt;(); &#125; public boolean book(int start, int end) &#123; // floorStart, start, floorStart'sEnd Integer floorStart = calendar.floorKey(start); if (floorStart != null &amp;&amp; calendar.get(floorStart) &gt; start) &#123; return false; &#125; // start, ceilingStart, end Integer ceilingStart = calendar.ceilingKey(start); if (ceilingStart != null &amp;&amp; ceilingStart &lt; end) &#123; return false; &#125; calendar.put(start, end); return true; &#125;&#125; 731. my-calendar-ii 与729相比变成了不能出现triple的重叠就算是可以book。 注意不能简单地理解为一个interval同时与两个interval重叠，因为[2,6]和[1,3]&amp;[5,7]同时重叠，但没有形成triplet. 同样是维护TreeMap，对于每个新加入的interval，遍历已有的interval并把重叠的部分插入treemap。如果插入时发现有重叠，说明“重叠部分之间也有重叠”，这样就是triple了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class MyCalendarTwo &#123; // 原本一位和之前相比就只是多了一个map，这个存不了就尝试另一个map，都不行就说明triple了。 // 但题目给的样例都不行，例如最后一个25~55，因为这个overlap分别和两个map里都interval重叠，但是没有形成triple； // 正解应该是用一个list维护所有的interval，然后用treemap只维护当前重叠的部分，如果后续又出现了和list里的重叠， // 就再去treemap中看看有没有第三次重叠。 // 注意每次遍历都需要清空TreeMap，因为我在遍历List的时候只关心新加入的这个会不会和别的重叠。 List&lt;int[]&gt; intervals; TreeMap&lt;Integer, Integer&gt; overlap; public MyCalendarTwo() &#123; intervals = new ArrayList&lt;&gt;(); overlap = new TreeMap&lt;&gt;(); &#125; public boolean book(int start, int end) &#123; overlap.clear(); // 遍历所有interval看看有没有重叠 for (int[] interval: intervals) &#123; if (start &gt;= interval[0] &amp;&amp; start &lt; interval[1]) &#123; // interval: ________ // newInter: _____... if (!addOverlap(start, Math.min(end, interval[1]))) &#123; return false; &#125; &#125; else if (end &gt; interval[0] &amp;&amp; start &lt; interval[0]) &#123; // interval: ________ // newInter: ______... if (!addOverlap(interval[0], Math.min(end, interval[1]))) &#123; return false; &#125; &#125; &#125; intervals.add(new int[] &#123;start, end&#125;); return true; &#125; private boolean addOverlap(int start, int end) &#123; Integer floorStart = overlap.floorKey(start); if (floorStart != null &amp;&amp; overlap.get(floorStart) &gt; start) &#123; return false; &#125; Integer ceilingStart = overlap.ceilingKey(start); if (ceilingStart != null &amp;&amp; ceilingStart &lt; end) &#123; return false; &#125; overlap.put(start, end); return true; &#125;&#125; 733. flood-fill 给一个二维int数组，其中包含0-65535的值。给定坐标i，j，和一个newColor，将该cell周围和它值相等的cell都赋值为newColor. DFS，直接赋值。需要注意如果原色和newColor相等就直接返回了，否则会stack overflow。12345678910111213141516171819202122class Solution &#123; public int[][] floodFill(int[][] image, int sr, int sc, int newColor) &#123; if (image == null || image.length == 0 || image[0].length == 0 || image[sr][sc] == newColor) &#123; // warning!! return image; &#125; dfs(image, sr, sc, image[sr][sc], newColor); return image; &#125; private int getValue(int[][] image, int i, int j) &#123; return i &lt; 0 || i &gt;= image.length || j &lt; 0 || j &gt;= image[0].length ? -1 : image[i][j]; &#125; private void dfs(int[][] image, int i, int j, int oldColor, int newColor) &#123; if (getValue(image, i, j) != oldColor) &#123; return; &#125; image[i][j] = newColor; dfs(image, i - 1, j, oldColor, newColor); dfs(image, i + 1, j, oldColor, newColor); dfs(image, i, j - 1, oldColor, newColor); dfs(image, i, j + 1, oldColor, newColor); &#125;&#125; 734. sentence-similarity 给一堆同义词[(&quot;restaurant&quot;, &quot;cafe&quot;), (&quot;ratings&quot;, &quot;reviews&quot;), ...]，再给一些queries[(&quot;restaurant ratings&quot;, &quot;cafe reviews&quot;), ...]，要求返回每个query里的对应词是否都是synonym。同义词没有传递性。 直接把字符串作为key、对应的所有同义词的set作为value存入map，正反都放一次，比如map.get(&quot;restaurant&quot;).add(&quot;cafe&quot;)), map.get(&quot;restaurant&quot;).add(&quot;cafe&quot;)，这样在query的时候就可以直接调用了。123456789101112131415161718192021222324252627282930// 维护一个总的map，每个单词作为key，对等的单词塞入它维护的Set中// 有对称性所以需要正反都加public boolean areSentencesSimilar(String[] words1, String[] words2, String[][] pairs) &#123; if (words1 == null || words2 == null || pairs == null || words1.length != words2.length) &#123; return false; &#125; Map&lt;String, Set&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; pairs.length; i++) &#123; if (!map.containsKey(pairs[i][0])) &#123; map.put(pairs[i][0], new HashSet&lt;&gt;()); &#125; if (!map.containsKey(pairs[i][1])) &#123; map.put(pairs[i][1], new HashSet&lt;&gt;()); &#125; map.get(pairs[i][0]).add(pairs[i][1]); // 构建a-&gt;b map.get(pairs[i][1]).add(pairs[i][0]); // 构建b-&gt;a &#125; for (int i = 0; i &lt; words1.length; i++) &#123; if (words1[i].equals(words2[i])) &#123; continue; &#125; if (map.get(words1[i]) == null || !map.get(words1[i]).contains(words2[i])) &#123; return false; &#125; &#125; return true;&#125; 735. asteroid-collision 给一个int数组，表示原子。正数向右移动，负数向左移动，可能会发生碰撞，如果绝对值相等则会抵消，否则绝对值更大的会把小的给干掉。求碰撞完后的数组。 直接用一个List，正数直接存，负数就需要与list中末尾的元素比较，如果是负就直接push，是正就需要比较看看谁更大。 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public int[] asteroidCollision(int[] asteroids) &#123; if (asteroids == null || asteroids.length == 0) &#123; return asteroids; &#125; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int asteroid : asteroids) &#123; if (asteroid &lt; 0) &#123; boolean needAdd = true; while (!list.isEmpty()) &#123; if (list.get(list.size() - 1) &lt; 0) &#123; break; &#125; if (-asteroid &gt; list.get(list.size() - 1)) &#123; list.remove(list.size() - 1); &#125; else if (-asteroid == list.get(list.size() - 1)) &#123; list.remove(list.size() - 1); needAdd = false; break; // cancelled with each other &#125; else &#123; needAdd = false; break; &#125; &#125; if (needAdd) &#123; list.add(asteroid); &#125; &#125; else &#123; list.add(asteroid); &#125; &#125; int[] ret = new int[list.size()]; for (int i = 0; i &lt; ret.length; i++) &#123; ret[i] = list.get(i); &#125; return ret; &#125;&#125; 更巧妙的做法是直接用一个数组模拟stack，然后用加法判断是否抵消。每次都强行取栈顶元素出来，如果没有被干掉就再放回去。 12345678910111213141516171819202122232425class Solution &#123; public int[] asteroidCollision(int[] asteroids) &#123; if (asteroids == null || asteroids.length == 0) &#123; return asteroids; &#125; int[] stack = new int[asteroids.length + 1]; int size = 1; stack[0] = -1; // 第一个放负数placeholder让pop终止 for (int asteroid : asteroids) &#123; while (stack[size - 1] &gt; 0 &amp;&amp; asteroid &lt; 0) &#123; int sum = asteroid + stack[size - 1]; if (sum &gt; 0) &#123; // 负数被干掉了 asteroid = stack[size - 1]; &#125; else if (sum == 0) &#123; asteroid = 0; &#125; size--; // 始终pop栈顶 &#125; if (asteroid != 0) &#123; stack[size++] = asteroid; &#125; &#125; return Arrays.copyOfRange(stack, 1, size); &#125;&#125; 737. sentence-similarity-ii 给一堆同义词[(&quot;restaurant&quot;, &quot;cafe&quot;), (&quot;ratings&quot;, &quot;reviews&quot;), ...]，再给一些queries[(&quot;restaurant ratings&quot;, &quot;cafe reviews&quot;), ...]，要求返回每个query里的对应词是否都是synonym。注意这些同义词具有传递性，a=b, b=c -&gt; a=c。 方法一：图论题，每个词都是一个节点，对于每个节点维护一个Set，通过DFS遍历所有可达的节点。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 和前一个版本的区别是这个可以无限传递a=b=c=d...// 还是map维护每个单词等价的单词，但匹配不上的话还得看它的set里所有单词对应的单词是否能匹配到public boolean areSentencesSimilarTwo(String[] words1, String[] words2, String[][] pairs) &#123; if (words1 == null || words2 == null || pairs == null || words1.length != words2.length) &#123; return false; &#125; // 表示每个单词直接相连的同义词 Map&lt;String, Set&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; pairs.length; i++) &#123; // O(N) if (!map.containsKey(pairs[i][0])) &#123; map.put(pairs[i][0], new HashSet&lt;&gt;()); &#125; if (!map.containsKey(pairs[i][1])) &#123; map.put(pairs[i][1], new HashSet&lt;&gt;()); &#125; map.get(pairs[i][0]).add(pairs[i][1]); // 构建a-&gt;b map.get(pairs[i][1]).add(pairs[i][0]); // 构建b-&gt;a &#125; for (int i = 0; i &lt; words1.length; i++) &#123; // O(N*N) if (words1[i].equals(words2[i])) &#123; continue; &#125; if (!map.containsKey(words1[i])) &#123; return false; &#125; if (!dfs(words1[i], words2[i], map, new HashSet&lt;String&gt;())) &#123; return false; &#125; &#125; return true;&#125;private boolean dfs(String start, String end, Map&lt;String, Set&lt;String&gt;&gt; map, Set&lt;String&gt; visited) &#123; if (map.get(start).contains(end)) &#123; // 终止条件：start连接着end return true; &#125; visited.add(start); Set&lt;String&gt; neighbors = map.get(start); if (neighbors == null) &#123; return false; &#125; for (String neighbor : neighbors) &#123; if (!visited.contains(neighbor) &amp;&amp; dfs(neighbor, end, map, visited)) &#123; return true; &#125; &#125; return false;&#125; 方法二：并查集，初始化时每个单词都是自己的root；然后根据同义词关系将前者的老大设为后者。判断句子是否同义时就找两个单词的老大是否相等即可。 123456789101112131415161718192021222324252627282930313233343536373839// 并查集。初始化时每个单词都是自己的root；然后根据同义词关系将前者的老大设为后者。// 判断句子是否同义时就找两个单词的老大是否相等即可public boolean areSentencesSimilarTwo(String[] words1, String[] words2, String[][] pairs) &#123; if (words1.length != words2.length) &#123; return false; &#125; Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); for (String[] pair : pairs) &#123; // 开始时每个老大都是自己 map.put(pair[0], pair[0]); map.put(pair[1], pair[1]); &#125; for (String[] pair : pairs) &#123; String par1 = findParent(pair[0], map); String par2 = findParent(pair[1], map); if (!par1.equals(par2)) &#123; map.put(par1, par2); // par1的老大设为par2 &#125; &#125; for (int i = 0; i &lt; words1.length; i++) &#123; if (words1[i].equals(words2[i])) &#123; continue; &#125; if (!map.containsKey(words1[i]) || !map.containsKey(words2[i])) &#123; return false; &#125; String par1 = findParent(words1[i], map); String par2 = findParent(words2[i], map); if (!par1.equals(par2)) &#123; return false; &#125; &#125; return true;&#125;public String findParent(String str, Map&lt;String,String&gt; map)&#123; while (!str.equals(map.get(str))) &#123; // 追溯str的老大 str = map.get(str); &#125; return str;&#125; 739. daily-temperatures 给一个int数组表示气温，返回一个数组表示该日最短需要多少天才会有更温暖的日子。例如[73, 74, 75, 71, 69, 72, 76, 73]输出[1, 1, 4, 2, 1, 1, 0, 0]。 解法：维护一个Stack存放索引，每次读入新的温度时就和栈顶对应的温度比较，如果更高，就弹出并设置该索引处的天数。12345678910111213141516171819202122class Solution &#123; public int[] dailyTemperatures(int[] temperatures) &#123; if (temperatures == null || temperatures.length == 0) &#123; return new int [0]; &#125; int[] nextWarmer = new int [temperatures.length]; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for (int i = 0; i &lt; temperatures.length; i++) &#123; // 比较当前温度和栈顶索引对应温度 while (!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) &#123; int index = stack.pop(); nextWarmer[index] = i - index; &#125; stack.push(i); // 栈剩下的都比当前大 &#125; while (!stack.isEmpty()) &#123; nextWarmer[stack.pop()] = 0; // 其实Java数组原本就是0 &#125; return nextWarmer; &#125;&#125; 742. closest-leaf-in-a-binary-tree 给一个二叉树和一个其中必定存在的值k，求这个节点到最近的leaf节点的距离。注意不是BST。 纯粹用Tree来思考有点困难，需要抽象成graph来思考：给定一个target点，怎么找最近的满足一定条件的neighbor？BFS。因此先dfs一波找到target节点，同时记录target节点怎么往parent走。然后从target节点开始BFS找最近的leaf节点即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123; public int findClosestLeaf(TreeNode root, int k) &#123; if (root == null) &#123; return 0; &#125; Map&lt;TreeNode, TreeNode&gt; prevNodeMap = new HashMap&lt;&gt;(); Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); Set&lt;TreeNode&gt; visited = new HashSet&lt;&gt;(); TreeNode targetNode = dfs(root, k, prevNodeMap); q.offer(targetNode); while (!q.isEmpty()) &#123; TreeNode curr = q.poll(); visited.add(curr); if (curr.left == null &amp;&amp; curr.right == null) &#123; return curr.val; &#125; if (curr.left != null &amp;&amp; !visited.contains(curr.left)) &#123; q.offer(curr.left); &#125; if (curr.right != null &amp;&amp; !visited.contains(curr.right)) &#123; q.offer(curr.right); &#125; if (prevNodeMap.containsKey(curr) &amp;&amp; !visited.contains(prevNodeMap.get(curr))) &#123; q.offer(prevNodeMap.get(curr)); &#125; &#125; return 0; &#125; private TreeNode dfs(TreeNode root, int k, Map&lt;TreeNode, TreeNode&gt; prevNodeMap) &#123; if (root.val == k) &#123; return root; &#125; if (root.left != null) &#123; prevNodeMap.put(root.left, root); TreeNode left = dfs(root.left, k, prevNodeMap); if (left != null) &#123; return left; &#125; &#125; if (root.right != null) &#123; prevNodeMap.put(root.right, root); TreeNode right = dfs(root.right, k, prevNodeMap); if (right != null) &#123; return right; &#125; &#125; return null; &#125;&#125; 743. network-delay-time 总共有1、2、3、…、N个节点，给一个times数组表示从node A到node B需要传播的时间，给定起始点K，求最长需要消耗的时间。类似于求最短路，BFS搞定。注意需要更新到达节点所需要的时间。 744. find-smallest-letter-greater-than-target 给一个排好序的a-z的char数组，给一个target，求比他大的字符，若是最后一个则wrap到前面如比z大的就是最前面的字符。 二分查找，找last occurence，直接返回「下一个」字符。123456789101112131415161718class Solution &#123; public char nextGreatestLetter(char[] letters, char target) &#123; if (letters == null || letters.length == 0) &#123; return target; &#125; int start = -1, end = letters.length; while (end - start &gt; 1) &#123; int mid = start + (end - start) / 2; if (letters[mid] &lt;= target) &#123; // 相等也要把start往后推，找到最后一个occurence start = mid; &#125; else &#123; end = mid; &#125; &#125; // 不论start处是不是target，直接返回下一位即可 return start &lt; letters.length - 1 ? letters[start + 1] : letters[0]; &#125;&#125; 745. prefix-and-suffix-search 给一个字符串数组，之后给一些query，这些query含有前缀和后缀（0～10个字符），求符合前缀的单词的索引。 有多个答案怎么办？返回最后一个出现的。 方法一：encode的方式将每个单词所有可能的前缀后缀组合作为key存入map，索引作为value，这样在query的时候直接再encode一下就可以直接get了。初始化时间复杂度O(N wordLen^2)，query时间复杂度O(1)，空间占用O(N wordLen^2). 1234567891011121314151617181920class WordFilter &#123; Map&lt;String, Integer&gt; map; public WordFilter(String[] words) &#123; map = new HashMap&lt;&gt;(); for (int index = 0; index &lt; words.length; index++) &#123; int wordLen = words[index].length(); for (int i = 0; i &lt;= 10 &amp;&amp; i &lt;= wordLen; i++) &#123; String front = words[index].substring(0, i); for (int j = 0; j &lt;= 10 &amp;&amp; j &lt;= wordLen; j++) &#123; String back = words[index].substring(wordLen - j); // 组成"a...#p.."的key map.put(front + "#" + back, index); &#125; &#125; &#125; &#125; public int f(String prefix, String suffix) &#123; String key = prefix + "#" + suffix; return map.containsKey(key)? map.get(key) : -1; &#125;&#125; 方法二：拆分成两个map，一个专门维护前缀、一个专门维护后缀，value都是索引的List。在query的时候需要把两个List取出来，然后O(N)扫描看看有没有交点。初始化时间复杂度O(N wordLen)，query时间复杂度O(N)，空间占用O(N wordLen). 123456789101112131415161718192021222324252627282930313233343536373839404142class WordFilter &#123; Map&lt;String, List&lt;Integer&gt;&gt; mapPrefix; Map&lt;String, List&lt;Integer&gt;&gt; mapSuffix; public WordFilter(String[] words) &#123; mapPrefix = new HashMap&lt;&gt;(); mapSuffix = new HashMap&lt;&gt;(); for (int index = 0; index &lt; words.length; index++) &#123; int wordLen = words[index].length(); for (int i = 0; i &lt;= 10 &amp;&amp; i &lt;= wordLen; i++) &#123; String front = words[index].substring(0, i); if (!mapPrefix.containsKey(front)) &#123; mapPrefix.put(front, new ArrayList&lt;Integer&gt;()); &#125; mapPrefix.get(front).add(index); String back = words[index].substring(wordLen - i); if (!mapSuffix.containsKey(back)) &#123; mapSuffix.put(back, new ArrayList&lt;Integer&gt;()); &#125; mapSuffix.get(back).add(index); &#125; &#125; &#125; public int f(String prefix, String suffix) &#123; List&lt;Integer&gt; listPrefix = mapPrefix.get(prefix); List&lt;Integer&gt; listSuffix = mapSuffix.get(suffix); if (listPrefix == null || listSuffix == null) &#123; return -1; &#125; int i = listPrefix.size() - 1, j = listSuffix.size() - 1; while (i &gt;= 0 &amp;&amp; j &gt;= 0) &#123; // 因为要返回最后一个，所以要从后往前找交点 if (listPrefix.get(i) &gt; listSuffix.get(j)) &#123; i--; &#125; else if (listPrefix.get(i) &lt; listSuffix.get(j)) &#123; j--; &#125; else &#123; return listPrefix.get(i); // 注意不能直接对Integer用==判断相等！ &#125; &#125; return -1; &#125;&#125; 方法三：直接使用内建函数startsWith和endsWith。初始化时间复杂度O(1)，query时间复杂度O(N * wordLen)，空间占用O(1). 123456789101112131415class WordFilter &#123; String[] words; public WordFilter(String[] words) &#123; this.words = words; &#125; public int f(String prefix, String suffix) &#123; for (int i = words.length - 1; i &gt;= 0; i--) &#123; if (words[i].startsWith(prefix) &amp;&amp; words[i].endsWith(suffix)) &#123; return i; &#125; &#125; return -1; &#125;&#125; 748. shortest-completing-word 给一个licensePlate，再给一个words数组，求其中最短的字符串使得licensePlate出现过的字母都有。例如licensePlate = &quot;1s3 PSt&quot;中只用关注S P S T, words = [&quot;step&quot;, &quot;steps&quot;, &quot;stripe&quot;, &quot;stepple&quot;]，输出steps。 licensePlate有哪些字符、确定只关注字母？（-是的）字母大小写？（-忽略大小写） 解法：先统计licensePlate中字母出现次数，然后O(N)遍历字符串数组，对于每一个单词判断是否包含licensePlate的所有字母（O(26)），再找最短的返回。12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; final private int LETTER_NUM = 26; public String shortestCompletingWord(String licensePlate, String[] words) &#123; if (licensePlate == null || words == null) &#123; return ""; &#125; // 统计licensePlate里字母的出现次数 char[] letterCount = new char [LETTER_NUM]; char[] lChar = licensePlate.toLowerCase().toCharArray(); for (int i = 0; i &lt; lChar.length; i++) &#123; if (Character.isLetter(lChar[i])) &#123; letterCount[lChar[i] - 'a']++; &#125; &#125; // 对于每个单词判断是否complete，然后找最短的 String ans = null; int minLen = Integer.MAX_VALUE; for (String word: words) &#123; if (checkComplete(word, letterCount)) &#123; if (word.length() &lt; minLen) &#123; minLen = word.length(); ans = word; &#125; &#125; &#125; return ans; &#125; // 统计当前单词的字母出现次数，然后再一波O（26）和licensePlate的字母Count比较 private boolean checkComplete(String word, char[] letterCount) &#123; char[] wChar = word.toCharArray(); char[] thisCount = new char [LETTER_NUM]; for (int i = 0; i &lt; wChar.length; i++) &#123; thisCount[wChar[i] - 'a']++; &#125; for (int i = 0; i &lt; LETTER_NUM; i++) &#123; if (letterCount[i] &gt; 0 &amp;&amp; thisCount[i] &lt; letterCount[i]) &#123; return false; &#125; &#125; return true; &#125;&#125; 750. number-of-corner-rectangles 给一个只含有0和1的二维数组，求其中四个1所能组成矩形的个数。矩形的边必须横、竖两个方向。 扫描线的思路，取两个行，同时扫竖线，统计同时出现1的pair数作为竖线，然后把这些竖线组合一下即可。123456789101112131415161718192021class Solution &#123; // 两行一起往右挪找是否有同时为1的，然后根据该平行线的pair数简单排列组合就可以了 public int countCornerRectangles(int[][] grid) &#123; if (grid == null || grid.length == 0 || grid[0].length == 0) &#123; return 0; &#125; int ans = 0; for (int i = 0; i &lt; grid.length - 1; i++) &#123; for (int j = i + 1; j &lt; grid.length; j++) &#123; int count = 0; for (int k = 0; k &lt; grid[0].length; k++) &#123; if (grid[i][k] == 1 &amp;&amp; grid[j][k] == 1) &#123; // 两平行线同一列同为1 count++; &#125; &#125; ans += count * (count - 1) / 2; // combination &#125; &#125; return ans; &#125;&#125; 752. open-the-lock 假如有一个锁头从0000开始转，每次只能只能转四位中的一位，给一个String数组表示这些数字不可以转到，给一个target表示最终开锁的密码。求最短需要多少次才能开锁，不可能打开则返回-1。 这种最短路径问题就想到了BFS，不过需要小心的是target本身不可达以及起始点就不可达的情况。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123; public int openLock(String[] deadends, String target) &#123; if (deadends == null || deadends.length == 0) &#123; return 0; &#125; Set&lt;String&gt; visited = new HashSet&lt;&gt;(); for (String deadend : deadends) &#123; visited.add(deadend); &#125; if (visited.contains(target)) &#123; return -1; &#125; Queue&lt;StringBuilder&gt; q = new LinkedList&lt;&gt;(); StringBuilder start = new StringBuilder("0000"); if (visited.contains(start.toString())) &#123; return -1; &#125; q.offer(start); visited.add(start.toString()); int count = 0; while (!q.isEmpty()) &#123; int size = q.size(); count++; while (size-- &gt; 0) &#123; StringBuilder curr = q.poll(); for (int i = 0; i &lt; 4; i++) &#123; char c = curr.charAt(i); for (int j = -1; j &lt;= 1; j += 2) &#123; if (c == '0' &amp;&amp; j == -1) &#123; curr.setCharAt(i, '9'); &#125; else if (c == '9' &amp;&amp; j == 1) &#123; curr.setCharAt(i, '0'); &#125; else &#123; curr.setCharAt(i, (char)(c + j)); &#125; String currStr = curr.toString(); if (!visited.contains(currStr)) &#123; if (currStr.equals(target)) &#123; return count; &#125; q.offer(new StringBuilder(currStr)); visited.add(currStr); &#125; &#125; curr.setCharAt(i, c); &#125; &#125; &#125; return -1; &#125;&#125; 以上是basic的BFS，如果要提速，可以进行双向的BFS，也就是维护两个Set，一个begin作为开始、一个end作为结束，每次switch角色，搞完begin就将end补过来、将当前begin的邻居点作为新的end。 759. employee-free-time 给一个List of List，每一个子List存放每个employee的工作时间，求所有employee的共同空闲时间。没有则返回空List。 直接将List flatten，然后按照工作开始时间从小到大排序，再往后依次取工作时间，若当前开始时间比之前的结束时间长，说明出现了空闲时间；否则需要更新prev的end，保证prev的结束时间cover到所有结束时间，即取max。12345678910111213141516171819public List&lt;Interval&gt; employeeFreeTime(List&lt;List&lt;Interval&gt;&gt; schedule) &#123; List&lt;Interval&gt; ans = new ArrayList&lt;&gt;(); if (schedule == null || schedule.size() == 0) &#123; return ans; &#125; List&lt;Interval&gt; workingTimes = new ArrayList&lt;&gt;(); schedule.forEach(e -&gt; workingTimes.addAll(e)); Collections.sort(workingTimes, (a, b) -&gt; a.start - b.start); Interval prev = workingTimes.get(0); for (int i = 1; i &lt; workingTimes.size(); i++) &#123; if (workingTimes.get(i).start &gt; prev.end) &#123; ans.add(new Interval(prev.end, workingTimes.get(i).start)); prev = workingTimes.get(i); &#125; else &#123; prev.end = Math.max(prev.end, workingTimes.get(i).end); &#125; &#125; return ans;&#125; 760. find-anagram-mappings 给两个数组，求对应出现的位置。skip. 763. partition-labels 给一个字符串，尝试将它进行partition使得每个字符至多只出现在一个partition，划分处尽量多的partition，求每个partition的长度。 方法一：LinkedHashMap搞定。统计每个字符出现的初始位置和最后一次出现的位置，然后遍历，当前后无法相连则说明这是一个新的partition。 方法二：不需要对每一个字母同时存放start和end，而是对于一个partition维护start和end。遍历字符串时若当前索引正是当前字符的最后一次出现的索引，且到达了当前partition的end，说明partition结束；否则需要适当更新end。1234567891011121314151617181920212223242526272829class Solution &#123; public List&lt;Integer&gt; partitionLabels(String S) &#123; List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); if (S == null || S.length() == 0) &#123; return ans; &#125; int[] lastOccurance = new int[26]; for (int i = 0; i &lt; S.length(); i++) &#123; lastOccurance[S.charAt(i) - 'a'] = i; &#125; int start = 0, end = 0; for (int i = 0; i &lt; S.length(); i++) &#123; int index = S.charAt(i) - 'a'; if (lastOccurance[index] != i) &#123; if (lastOccurance[index] &gt; end) &#123; end = lastOccurance[index]; // 若有更靠后的索引则更新end &#125; &#125; else &#123; if (i == end) &#123; ans.add(end - start + 1); end = i + 1; start = i + 1; // start只在每个partition开始时更新一次 &#125; &#125; &#125; return ans; &#125;&#125; 764. largest-plus-sign 给定N表示棋盘的长和宽，默认棋盘中每个cell都是1，再给一些坐标表示该处是0。求棋盘中最大的加号的长度。 可以利用grid本身记录上下左右四个方向最长延伸出去多长。最原始的想法是每个方向都维护一个二维数组专门记录到该cell的最长长度是多少，不过经过改进可以将所有的计算都合并到一个grid中完成。开始时初始化每个cell的长度都为N，然后直接从前、后、上、下同时更新，不过每一步循环中更新的其实是四个不同的cell，最后循环结束时每个cell都会被更新四次。时间复杂度O(N^2)。123456789101112131415161718192021222324252627282930313233class Solution &#123; public int orderOfLargestPlusSign(int N, int[][] mines) &#123; if (N &lt; 1) &#123; return 0; &#125; int[][] grid = new int [N][N]; for (int i = 0; i &lt; N; i++) &#123; Arrays.fill(grid[i], N); &#125; for (int[] mine : mines) &#123; grid[mine[0]][mine[1]] = 0; &#125; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0, k = N - 1, l = 0, r = 0, t = 0, b = 0; j &lt; N; j++, k--) &#123; // 分别统计左右、上下有多少延伸出去的长度，每个cell会被访问到4次，每次都取min grid[i][j] = Math.min(grid[i][j], l = grid[i][j] == 0 ? 0 : l + 1); grid[i][k] = Math.min(grid[i][k], r = grid[i][k] == 0 ? 0 : r + 1); grid[j][i] = Math.min(grid[j][i], t = grid[j][i] == 0 ? 0 : t + 1); grid[k][i] = Math.min(grid[k][i], b = grid[k][i] == 0 ? 0 : b + 1); &#125; &#125; int ans = 0; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; N; j++) &#123; ans = Math.max(grid[i][j], ans); &#125; &#125; return ans; &#125;&#125; 765. couples-holding-hands 给一个int数组表示每个位置坐的人，假设0-1, 2-3, 4-5…是一对，问最少通过几次交换座位可以让没对情侣都相邻而坐。 可以用greedy的办法，每发现一个坐错位置的人，就让他和应该在这个位置的人swap一次。123456789101112131415161718192021class Solution &#123; public int minSwapsCouples(int[] row) &#123; if (row == null || row.length == 0 || row.length % 2 != 0) &#123; return 0; &#125; int[] pos = new int[row.length]; for (int i = 0; i &lt; row.length; i++) &#123; pos[row[i]] = i; &#125; int count = 0; for (int i = 0; i &lt; row.length; i += 2) &#123; int expected = row[i] % 2 == 0 ? row[i] + 1 : row[i] - 1; if (row[i + 1] != expected) &#123; pos[row[i + 1]] = pos[expected]; row[pos[expected]] = row[i + 1]; count++; &#125; &#125; return count; &#125;&#125; 767. reorganize-string 给一个只含有小写字母的字符串，将这些字符重新排列使得相邻字母不同，若不存在则返回””; greedy，先统计每一个字符出现的次数，存入priorityqueue使得次数多的先取，取后若仍有剩余则需要更新次数并重新放回pq。注意若当前取出的次数最多的字母是上一次append的，则需要取第二多的字符，若没有后续字符说明没法这么存，返回””即可。 768. max-chunks-to-make-sorted-ii 给一个int数组，将这个数组分成若干个chunk后在每个chunk内部排序之后拼接能得到sorted的数组，求最多划分成多少个这样的chunk。 形成chunk的条件是「chunk中最大值小于等于右侧所有数的最小值」。因此维护两个数组存放当前位置的左侧最大值和右侧最小值即可。123456789101112131415161718192021222324252627class Solution &#123; public int maxChunksToSorted(int[] arr) &#123; if (arr == null || arr.length == 0) &#123; return 0; &#125; int[] maxOfLeft = new int[arr.length]; // 左侧的最大值 maxOfLeft[0] = arr[0]; for (int i = 1; i &lt; arr.length; i++) &#123; maxOfLeft[i] = Math.max(maxOfLeft[i - 1], arr[i]); &#125; int[] minOfRight = new int[arr.length]; // 右侧的最小值 minOfRight[arr.length - 1] = arr[arr.length - 1]; for (int i = arr.length - 2; i &gt;= 0; i--) &#123; minOfRight[i] = Math.min(minOfRight[i + 1], arr[i]); &#125; int count = 0; for (int i = 0; i &lt; arr.length - 1; i++) &#123;// 当左侧最大值都小于右侧最小值，说明当前位之前都可以自己排个序了 if (maxOfLeft[i] &lt;= minOfRight[i + 1]) &#123; count++; &#125; &#125; return count + 1; &#125;&#125; 769. max-chunks-to-make-sorted 给一个int数组，其中含有元素[0, 1, ..., arr.length - 1]（顺序不一定是这样的，是一个permutation），将这个数组分成若干个chunk后在每个chunk内部排序之后拼接能得到sorted的数组，求最多划分成多少个这样的chunk。如[4,3,2,1,0]必须整个作为一个chunk排序，[1,0,2,3,4]则分成[1, 0], [2], [3], [4]来排序。 既然元素和index是能对应填充的，考虑他们之间的关系。要想形成chunk，必须chunk的最大值在最右侧index的左侧，维护一个max即可。123456789101112131415class Solution &#123; public int maxChunksToSorted(int[] arr) &#123; if (arr == null || arr.length == 0) &#123; return 0; &#125; int count = 0, max = 0; for (int i = 0; i &lt; arr.length; i++) &#123; max = Math.max(max, arr[i]); if (i == max) &#123; count++; &#125; &#125; return count; &#125;&#125; 776. split-bst 给一个BST和一个value，这个value不一定存在于BST中，要求以这个value为临界点将BST分成小于等于&amp;大于两部分。 在split的时候比较节点与value，若value更大则split点会出现在右子树且split后会得到两个split之后的子树，需要将小于等于的那个子树拼接到当前节点的右侧。若value不大于当前节点，则需要到左子树去搜索split点，同样需要将split之后较大的那个子树拼接到当前子树的左侧。12345678910111213141516public TreeNode[] splitBST(TreeNode root, int V) &#123; if (root == null) &#123; return new TreeNode[] &#123;null, null&#125;; &#125; if (root.val &lt;= V) &#123; TreeNode[] splitted = splitBST(root.right, V); root.right = splitted[0]; splitted[0] = root; return splitted; &#125; else &#123; TreeNode[] splitted = splitBST(root.left, V); root.left = splitted[1]; splitted[1] = root; return splitted; &#125;&#125; 785. is-graph-bipartite 给一个数组，每个index对应着该node的所有邻接点。问这个graph能否只用两个颜色给node上色使得相邻两个点的颜色都不一样。 方法一：DFS。对于每一个点都一波直接深度搜索上色，用一个数组存储上色状态，0表示未访问过，-1和1分别表示两个颜色，在dfs时对于当前的点若已经访问过就判断是否符合当前给定的颜色，若未访问则直接上色并DFS到它所有邻接点。需要注意可能有若干独立的cluster，因此不能一次DFS搜索就结束了，而是需要一个循环保证对所有未访问过的点都进行一次DFS。 1234567891011121314151617181920212223242526class Solution &#123; public boolean isBipartite(int[][] graph) &#123; if (graph == null || graph.length == 0) &#123; return true; &#125; int[] colors = new int[graph.length]; for (int i = 0; i &lt; graph.length; i++) &#123; if (colors[i] == 0 &amp;&amp; !checkColor(graph, colors, -1, i)) &#123; return false; &#125; &#125; return true; &#125; private boolean checkColor(int[][] graph, int[] colors, int currColor, int currNode) &#123; if (colors[currNode] != 0) &#123; return colors[currNode] == currColor; &#125; colors[currNode] = currColor; for (int neighbor : graph[currNode]) &#123; if (!checkColor(graph, colors, -currColor, neighbor)) &#123; return false; &#125; &#125; return true; &#125;&#125; 方法二：BFS，还是用queue存放所有邻接点然后逐一上色。 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public boolean isBipartite(int[][] graph) &#123; if (graph == null || graph.length == 0) &#123; return true; &#125; int[] colors = new int[graph.length]; for (int i = 0; i &lt; graph.length; i++) &#123; // 只check没有访问过的点，即各个独立的cluster if (colors[i] == 0 &amp;&amp; !checkColor(graph, colors, -1, i)) &#123; return false; &#125; &#125; return true; &#125; private boolean checkColor(int[][] graph, int[] colors, int currColor, int currNode) &#123; if (colors[currNode] != 0) &#123; return colors[currNode] == currColor; &#125; Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); int color = currColor; q.offer(currNode); while (!q.isEmpty()) &#123; int size = q.size(); while (size-- &gt; 0) &#123; int node = q.poll(); if (colors[node] != 0) &#123; if (colors[node] != color) return false; &#125; else &#123; colors[node] = color; &#125; for (int neighbor : graph[node]) &#123; if (colors[neighbor] == 0) q.offer(neighbor); // 避免回头路 &#125; &#125; color = -color; &#125; return true; &#125;&#125; 787. cheapest-flights-within-k-stops 给一组city和航班信息，在最多stop k次的情况下求从src到dst最便宜的航班价格。 经典grpah最短路问题，首先用Map记录每一个city的邻居city航班，然后从src出发BFS，维护一个minPrice数组，发现更低价格时就更新对应city的到达所需价格。在BFS过程中，每扩散一轮就算作stop一次，利用一个flightCount保证最多停k次。123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) &#123; if (flights == null || flights.length == 0) &#123; return 0; &#125; Map&lt;Integer, List&lt;int[]&gt;&gt; flightMap = getGraph(flights); int[] minPrices = new int[n]; Arrays.fill(minPrices, Integer.MAX_VALUE); Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;(); int flightCount = K + 1; q.offer(new int[] &#123;src, 0&#125;); while (!q.isEmpty() &amp;&amp; flightCount-- &gt; 0) &#123; int size = q.size(); while (size-- &gt; 0) &#123; int[] currCity = q.poll(); List&lt;int[]&gt; neighbors = flightMap.get(currCity[0]); if (neighbors == null) &#123; continue; &#125; for (int[] neighbor : neighbors) &#123; int price = currCity[1] + neighbor[2]; if (price &lt; minPrices[neighbor[1]]) &#123; minPrices[neighbor[1]] = price; q.offer(new int[] &#123;neighbor[1], price&#125;); &#125; &#125; &#125; &#125; return minPrices[dst] == Integer.MAX_VALUE ? -1 : minPrices[dst]; &#125; private Map&lt;Integer, List&lt;int[]&gt;&gt; getGraph(int[][] flights) &#123; Map&lt;Integer, List&lt;int[]&gt;&gt; flightMap = new HashMap&lt;&gt;(); for (int[] flight : flights) &#123; flightMap.putIfAbsent(flight[0], new ArrayList&lt;int[]&gt;()); flightMap.get(flight[0]).add(flight); &#125; return flightMap; &#125;&#125; 791. custom-sort-string 给两个String，S只含有不重复的小写字母表示custom定义的顺序，需要将T按照这个给定顺序进行排序，对于没有出现过的字母随便放哪里都可以。 方法一：遍历S，在循环内层遍历T，遇到当前字符就往前swap，时间复杂度O(N^2). 方法二：木桶排序，既然只会出现小写字母，就用26个木桶统计出现个数，然后遍历S取处相应的append即可，最后再把S中没有的字母拼接到最后即可。时间O(N). 795. number-of-subarrays-with-bounded-maximum 给一个数组和一个范围[L, R]，求该数组有多少个子数组，使得子数组的最大值落在[L, R]中。 首先想到DP，dp[i][j]表示从i到j的子数组的最大值，O(N^2)遍历的时候就可以顺便判断。 1234567891011121314151617181920212223class Solution &#123; public int numSubarrayBoundedMax(int[] A, int L, int R) &#123; if (A == null || A.length == 0) &#123; return 0; &#125; int len = A.length, ans = 0; int[][] dp = new int[len][len]; for (int i = 0; i &lt; len; i++) &#123; for (int j = i; j &lt; len; j++) &#123; if (i == j) &#123; dp[i][j] = A[j]; &#125; else &#123; dp[i][j] = Math.max(dp[i][j - 1], A[j]); &#125; if (dp[i][j] &gt;= L &amp;&amp; dp[i][j] &lt;= R) &#123; ans++; &#125; &#125; &#125; return ans; &#125;&#125; follow-up：进一步优化，不使用额外的空间，同时时间复杂度降到O(N). 子数组的总量是一定的，既然求的是range，那首先求所有数都不超过max的子数组数量，然后求所有数都不超过(min - 1)的子数组的数量，两个一减就得到了在[min, max]之间的子数组的数量。12345678910111213141516class Solution &#123; public int numSubarrayBoundedMax(int[] A, int L, int R) &#123; if (A == null || A.length == 0) &#123; return 0; &#125; return countSubarray(A, R) - countSubarray(A, L - 1); &#125; private int countSubarray(int[] nums, int max) &#123; int curr = 0, total = 0; for (int num : nums) &#123; curr = num &lt;= max ? curr + 1 : 0; total += curr; &#125; return total; &#125;&#125; 796. rotate-string 给两个String，判断A能否通过shift变成B。 经典。观察可以得出A拼接上自身之后必须包含B才能保证shift得到B。123public boolean rotateString(String A, String B) &#123; return A != null &amp;&amp; B != null &amp;&amp; A.length() == B.length() &amp;&amp; (A + A).contains(B); &#125;]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>algorithm</tag>
        <tag>interview</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Note for LeetCode in Java (800+)]]></title>
    <url>%2F2018%2F01%2F05%2Fjava_leetcode6%2F</url>
    <content type="text"><![CDATA[刷题。祝我好运。 802. find-eventual-safe-states 给一个2D array，每一个行数组表示该index的邻居，所有的点和边可以形成directed graph。求所有最终能稳定的点（所有的邻居点都不会陷入一个无限循环的path）。 DFS过程中记录当前path的visited情况，一旦回头了就说明当前节点是有环（无限）的。利用memo来提升DFS性能，防止重复DFS。事实上可以利用bucket代替visited的功能，例如赋一个特殊值表示on path。12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public List&lt;Integer&gt; eventualSafeNodes(int[][] graph) &#123; List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); if (graph == null || graph.length == 0) &#123; return ans; &#125; int[] bucket = new int[graph.length]; boolean[] visited = new boolean[graph.length]; for (int i = 0; i &lt; graph.length; i++) &#123; if (dfs(graph, i, bucket, visited)) &#123; ans.add(i); &#125; &#125; return ans; &#125; private boolean dfs(int[][] graph, int index, int[] bucket, boolean[] visited) &#123; if (bucket[index] &gt; 0) &#123; return true; &#125; else if (bucket[index] &lt; 0) &#123; return false; &#125; visited[index] = true; for (int neighbor : graph[index]) &#123; if (visited[neighbor] || !dfs(graph, neighbor, bucket, visited)) &#123; bucket[index] = -1; visited[index] = false; return false; &#125; &#125; visited[index] = false; bucket[index] = 1; return true; &#125;&#125; 804. unique-morse-code-words 摩斯电码转换，记录总共出现了几种不同的组合。skip. 806. number-of-lines-to-write-string 输出字母求需要占用多少宽度。skip. 807. max-increase-to-keep-city-skyline 给一个二维数组表示各个摩天大楼的高度，从左右两侧和前后两侧看的skyline相同的情况下，最多共可以升高多少。skip. 817. linked-list-components 给一个链表表示int之间的链接关系，给一个数组，求数组中在链表中连续出现的团簇数。 将数组的元素放入Set后开始遍历链表，Set中存在该元素就remove掉，不存在则结束统计前一个团簇，开始找下一个团簇，最后return之前还需要判断是否已经找到了团簇。 819. most-common-word 给一段String文本，给一个banned数组作为stopword，求最频繁出现的词。split之后统计频数即可，skip。 827. making-a-large-island 给一个只含有0和1的grid，求将其中某一个0替换成1后形成island的最大面积。如果没有0则是整个棋盘的面积。 对于每一个1进行连通上色，同时维护一个colorMap表示每种颜色对应的island有多少。最后再遍历每一个0看看它周围四个方向分别是什么颜色，然后对应取个数即可。用一个getValue的wrapper函数专门用于访问matrix中的值，让代码简洁了不少。BFS和DFS都差不多。BFS需要注意上色时机，在加入queue的时候就需要上色，否则上下左右的时候可能会重复上色。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class Solution &#123; public int largestIsland(int[][] grid) &#123; if (grid == null || grid.length == 0 || grid[0].length == 0) &#123; return 0; &#125; int rows = grid.length, cols = grid[0].length; List&lt;Integer&gt; colorSize = new ArrayList&lt;&gt;(); // force color starts with 2 colorSize.add(0); colorSize.add(0); for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; cols; j++) &#123; if (grid[i][j] == 1) &#123; // colorSize.add(dfs(grid, i, j, colorSize.size())); colorSize.add(bfs(grid, i, j, colorSize.size())); &#125; &#125; &#125; int max = 0; for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; cols; j++) &#123; if (grid[i][j] == 0) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); set.add(getValue(grid, i - 1, j)); set.add(getValue(grid, i + 1, j)); set.add(getValue(grid, i, j - 1)); set.add(getValue(grid, i, j + 1)); int curr = 0; for (Integer color : set) &#123; curr += colorSize.get(color); &#125; max = Math.max(curr + 1, max); &#125; &#125; &#125; return max == 0 ? rows * cols : max; &#125; // wrap到一个函数中去访问cell，省去很多判断 private int getValue(int[][] grid, int i, int j) &#123; return (i &lt; 0 || i &gt;= grid.length || j &lt; 0 || j &gt;= grid[0].length) ? 0 : grid[i][j]; &#125; private int dfs(int[][] grid, int i, int j, int color) &#123; if (getValue(grid, i, j) != 1) &#123; return 0; &#125; grid[i][j] = color; return 1 + dfs(grid, i - 1, j, color) + dfs(grid, i + 1, j, color) + dfs(grid, i, j - 1, color) + dfs(grid, i, j + 1, color); &#125; private int bfs(int[][] grid, int i, int j, int color) &#123; Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;(); q.offer(new int[] &#123;i, j&#125;); grid[i][j] = color; int size = 0; while (!q.isEmpty()) &#123; int currSize = q.size(); size += currSize; while (currSize-- &gt; 0) &#123; int[] temp = q.poll(); int row = temp[0], col = temp[1]; if (getValue(grid, row - 1, col) == 1) &#123; q.offer(new int[] &#123;row - 1, col&#125;); grid[row - 1][col] = color; &#125; if (getValue(grid, row + 1, col) == 1) &#123; q.offer(new int[] &#123;row + 1, col&#125;); grid[row + 1][col] = color; &#125; if (getValue(grid, row, col - 1) == 1) &#123; q.offer(new int[] &#123;row, col - 1&#125;); grid[row][col - 1] = color; &#125; if (getValue(grid, row, col + 1) == 1) &#123; q.offer(new int[] &#123;row, col + 1&#125;); grid[row][col + 1] = color; &#125; &#125; &#125; return size; &#125;&#125; 833. find-and-replace-in-string 给一个原字符串S，给indexes索引数组和两个字符串数组sources和targets，对于indexes中每一个索引判断是否由sources中对应的字符串startsWith，是则替换撑targets。 由于target替换后对原字符串的长度可能有影响，因此不能直接用index来替换。使用一个indexDelta记录每次成功替换之后后续的index需要平移多少。注意需要保证index是从小到大进行替换的，否则后面的平移不应该影响到前面的平移。 835. image-overlap 给两个binary square matrix，只有0和1两个数值，将两个矩阵上下左右移动，问重叠的1最多有多少个。 将二维问题flatten成一维，然后在一维List中遍历每一个cell与另一个矩阵的每一个cell重叠后是否都是1，然后将结果存入map。如何判定是否是相同的平移之后的结果呢？利用一维List的索引之差即可。123456789101112131415161718192021222324252627282930class Solution &#123; public int largestOverlap(int[][] A, int[][] B) &#123; if (A == null || B == null) &#123; return 0; &#125; int N = A.length; List&lt;Integer&gt; listA = new ArrayList&lt;&gt;(); List&lt;Integer&gt; listB = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; N * N; i++) &#123; if (A[i / N][i % N] == 1) &#123; listA.add(i / N * 100 + i % N); &#125; if (B[i / N][i % N] == 1) &#123; listB.add(i / N * 100 + i % N); &#125; &#125; Map&lt;Integer, Integer&gt; count = new HashMap&lt;&gt;(); for (int i : listA) &#123; for (int j : listB) &#123; count.put(i - j, count.getOrDefault(i - j, 0) + 1); &#125; &#125; int max = 0; for (int val : count.values()) &#123; max = Math.max(max, val); &#125; return max; &#125;&#125; 836. rectangle-overlap 给两个数组表示二维平面中矩形左下角的定点和右上角的定点。判断是否overlap。 转换成一维线段来判断，两个线段有overlap的充分必要条件是left1 &lt; right2 &amp;&amp; left2 &lt; right1，那么推广到2D中就是x方向上用一次、y方向上用一次，都满足就一定有overlap了。123public boolean isRectangleOverlap(int[] rec1, int[] rec2) &#123; return rec1[0] &lt; rec2[2] &amp;&amp; rec2[0] &lt; rec1[2] &amp;&amp; rec1[1] &lt; rec2[3] &amp;&amp; rec2[1] &lt; rec1[3];&#125; 839. similar-string-groups 给一个长度相同且互为anagram的String数组，求总共有多少组similar的词。similar指的是A只swap一对儿字符能够equal B。 DFS/BFS均可，访问每个word时往后搜只有两位字符不同的标记为visited，这样当前dfs完成后就是一个similar group.12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public int numSimilarGroups(String[] A) &#123; if (A == null || A.length == 0) &#123; return 0; &#125; int count = 0; boolean[] visited = new boolean[A.length]; for (int i = 0; i &lt; A.length; i++) &#123; if (!visited[i]) &#123; visited[i] = true; dfs(A, A[i], visited); count++; &#125; &#125; return count; &#125; public void dfs(String[] A, String str, boolean[] visited) &#123; for (int i = 0; i &lt; A.length; i++) &#123; if (!visited[i] &amp;&amp; isDiffBy2(str, A[i])) &#123; visited[i] = true; dfs(A, A[i], visited); &#125; &#125; &#125; private boolean isDiffBy2(String str1, String str2) &#123; int diff = 0; for (int i = 0; i &lt; str1.length(); i++) &#123; if (str1.charAt(i) != str2.charAt(i)) &#123; diff++; &#125; if (diff &gt; 2) &#123; return false; &#125; &#125; return true; &#125;&#125; 841. keys-and-rooms 给一个rooms nested list，每一个row list表示该room存放的所有key list，一开始只有room 0可以进入，其余房间都必须有对应钥匙才能进入。判断能否进所有的房间。BFS和DFS都可以搞定。 843. guess-the-word 给一个String数组，每一个词都是6个字符，通过调用给定的API猜其中的一个secret word，每次调用API时都会返回所给词和secret词的match字符数。 通过random的办法，随机选取一个String猜，然后根据返回的字符匹配数，将原List中所有和所给字符串匹配数相等的字符保留下来，然后继续随机取字符串去猜。 12345678910111213141516171819202122232425262728class Solution &#123; public void findSecretWord(String[] wordlist, Master master) &#123; if (wordlist == null || wordlist.length == 0) &#123; return; &#125; List&lt;String&gt; wordList = Arrays.asList(wordlist); for (int i = 0, ret = 0; i &lt; 10 &amp;&amp; ret &lt; 6; i++) &#123; String input = wordList.get(new Random().nextInt(wordList.size())); ret = master.guess(input); List&lt;String&gt; wordListNew = new ArrayList&lt;&gt;(); for (String word : wordList) &#123; if (getMatchCount(word, input) == ret) &#123; wordListNew.add(word); &#125; &#125; wordList = wordListNew; &#125; &#125; private int getMatchCount(String str1, String str2) &#123; int count = 0; for (int i = 0; i &lt; str1.length(); i++) &#123; if (str1.charAt(i) == str2.charAt(i)) &#123; count++; &#125; &#125; return count++; &#125;&#125; 纯粹的随机并不是一个最优策略，可以先在给定的String数组内部找到「与其他字符串完全不match最少的」字符串来猜。 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public void findSecretWord(String[] wordlist, Master master) &#123; if (wordlist == null || wordlist.length == 0) &#123; return; &#125; List&lt;String&gt; wordList = Arrays.asList(wordlist); for (int i = 0, ret = 0; i &lt; 10 &amp;&amp; ret &lt; 6; i++) &#123; Map&lt;String, Integer&gt; zeroMatchCount = new HashMap&lt;&gt;(); for (String str1 : wordList) &#123; for (String str2 : wordList) &#123; if (getMatchCount(str1, str2) == 0) &#123; zeroMatchCount.put(str1, zeroMatchCount.getOrDefault(str1, 0) + 1); &#125; &#125; &#125; int minZeroCount = Integer.MAX_VALUE; String input = ""; for (String str : wordList) &#123; if (zeroMatchCount.getOrDefault(str, 0) &lt; minZeroCount) &#123; input = str; minZeroCount = zeroMatchCount.getOrDefault(str, 0); &#125; &#125; ret = master.guess(input); List&lt;String&gt; wordListNew = new ArrayList&lt;&gt;(); for (String word : wordList) &#123; if (getMatchCount(word, input) == ret) &#123; wordListNew.add(word); &#125; &#125; wordList = wordListNew; &#125; &#125;&#125; 844. backspace-string-compare 给两个字符串，含有#表示backspace回删符号，判断这两个字符串是否相等。 面试原题，从后往前判断即可达到O(1)空间。123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public boolean backspaceCompare(String S, String T) &#123; if (S == null || T == null) &#123; return false; &#125; int indexS = S.length() - 1, indexT = T.length() - 1; while (true) &#123; indexS = getPrevIndex(S, indexS); indexT = getPrevIndex(T, indexT); if (indexS &lt; 0 &amp;&amp; indexT &lt; 0) &#123; return true; &#125; if (indexS &lt; 0 || indexT &lt; 0 || S.charAt(indexS) != T.charAt(indexT)) &#123; return false; &#125; indexS--; indexT--; &#125; &#125; private int getPrevIndex(String str, int currIndex) &#123; int delCount = 0; while (currIndex &gt;= 0) &#123; if (str.charAt(currIndex) == '#') &#123; delCount++; &#125; else &#123; if (delCount &gt; 0) &#123; delCount--; &#125; else &#123; break; // 直到找到新的可供对比的字符 &#125; &#125; currIndex--; &#125; return currIndex; &#125;&#125; 846. hand-of-straights 给一个int数组表示一手牌，给一个整数W表示每一组牌的个数，判断是否可以重新整理形成顺子，每组顺子size都是W。 对于每一个顺子，每一个数的总出现次数必须比最小的数的出现次数大，才能保证顺子的形成。因此考虑使用一个TreeMap将每个value和count存起来，然后从最小值开始遍历，将顺子中需要的value的count都对应消耗掉与最小值相等的量，一旦不符合就说明顺子断了。1234567891011121314151617181920212223242526class Solution &#123; public boolean isNStraightHand(int[] hand, int W) &#123; if (hand == null || hand.length == 0) &#123; return true; &#125; if (W == 0 || hand.length % W != 0) &#123; return false; &#125; Map&lt;Integer, Integer&gt; map = new TreeMap&lt;&gt;(); for (int num : hand) &#123; map.put(num, map.getOrDefault(num, 0) + 1); &#125; for (int num : map.keySet()) &#123; if (map.get(num) &gt; 0) &#123; for (int i = W - 1; i &gt;= 0; i--) &#123; // 遍历顺子中每个值 if (map.getOrDefault(num + i, 0) &lt; map.get(num)) &#123; return false; &#125; map.put(num + i, map.get(num + i) - map.get(num)); // 必须消耗掉与最小值对应的数量 &#125; &#125; &#125; return true; &#125;&#125; 849. maximize-distance-to-closest-person 给一个只含有0和1的数组，0表示没人坐，1表示有人坐，求某一个0使得离最近的人最远，返回最远距离。 分情况讨论，如果最远出现在两侧以及出现在两个1之间。skip。 853. car-fleet 若干辆车朝着target开，给一个position数组表示开始时车的位置，给一个speed数组表示每台车的速度。若后续车辆追上前面车则融合成一个以前面车的速度继续开。求到达终点的共有几台车。初识时每台车都在不同位置。 利用TreeMap，每台车的剩余距离作为key、每台车的到达终点所需时间作为value，在TreeMap中按照剩余距离从小到大排序后从头遍历剩余时间，若后续车辆剩余时间比前面的短或相等，就说明会追上；若后续车辆所需时间比前面大，必定赶不上，因此它就作为后续集团的leading car。本质就是求有多少个leading car.1234567891011121314151617181920212223class Solution &#123; public int carFleet(int target, int[] position, int[] speed) &#123; if (position == null || position.length == 0 || speed == null || speed.length == 0 || position.length != speed.length) &#123; return 0; &#125; TreeMap&lt;Integer, Double&gt; map = new TreeMap&lt;&gt;(); for (int i = 0; i &lt; position.length; i++) &#123; int distanceRemain = target - position[i]; map.put(distanceRemain, (double)(distanceRemain) / speed[i]); &#125; int count = 0; double prevTime = 0; for (double time : map.values()) &#123; // values按照distanceRemain从小到大排列 if (time &gt; prevTime) &#123; // 若当前所需时间大于前面的时间 prevTime = time; // 则形成新的fleet count++; &#125; &#125; return count; &#125;&#125; 854. k-similar-strings 给A和B两个字符串，求最少需要swap多少次A中的字符使得最终能得到B。如果不可能则返回Integer.MAX_VALUE。 从头开始遍历两个字符串，一旦遇到不同的字符，就在A中往后寻找B中该位的字符，尝试swap，然后从该位继续往后dfs一路搜下去。利用Map作为memo减少重复计算。123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public int kSimilarity(String A, String B) &#123; if (A == null || B == null || A.length() != B.length()) &#123; return 0; &#125; return dfs(A.toCharArray(), B, 0, new HashMap&lt;String, Integer&gt;()); &#125; private int dfs(char[] charA, String B, int index, Map&lt;String, Integer&gt; memo) &#123; String A = new String(charA); if (A.equals(B)) &#123; return 0; &#125; if (memo.containsKey(A)) &#123; return memo.get(A); &#125; int i = index; while (i &lt; charA.length &amp;&amp; charA[i] == B.charAt(i)) &#123; i++; &#125; int min = Integer.MAX_VALUE; for (int j = i + 1; j &lt; charA.length; j++) &#123; if (charA[j] == B.charAt(i)) &#123; // 往后找对应字符出现的位置，一个个比较 swap(charA, i, j); int nextMin = dfs(charA, B, i + 1, memo); if (nextMin != Integer.MAX_VALUE &amp;&amp; nextMin + 1 &lt; min) &#123; min = nextMin + 1; &#125; swap(charA, i, j); &#125; &#125; memo.put(A, min); return min; &#125; private void swap(char[] arr, int i, int j) &#123; char temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125; 858. mirror-reflection 给整数p和q，p表示正方形空间的边长，q表示初始激光从左下射出的高度，在右下、右上、左上各右一个receptor标号为0、1、2，可以保证一定可以接收到，求接收到的receptor的id。 激光射出后纵向移动达到q时，横向移动一定为p。假设把天花板去掉，无限往上反射x次，最终射到某个corner的时候，纵向上移动的距离恰好是p的某个倍数q*x == y*p，因此问题转换为求p和q的最小公倍数lcm，而lcm = p * q / gcd，用最大公约数可破。若lcm / p % 2 == 0，说明反射到了下面这个receptor，即0；否则再判断lcm / q % 2 == 0看看是否回到了左侧的recptor，即2。123456789101112131415// lcm / p % 2 + 1 - lcm / q % 2 // = p * q / gcd / p % 2 + 1 - p * q / gcd / q % 2// = 1 + q / gcd % 2 - p / gcd % 2class Solution &#123; public int mirrorReflection(int p, int q) &#123; if (p &lt; 1 || q &gt; p) &#123; return 0; &#125; int gcd = getGCD(p, q); return 1 + q / gcd % 2 - p / gcd % 2; &#125; private int getGCD(int p, int q) &#123; return q != 0 ? getGCD(q, p % q) : p; &#125;&#125; 860. lemonade-change 给一个数组表示买柠檬汁的顾客的钱，只有5、10、20三种面额，每个顾客只买一杯柠檬汁，一开始手头没钱，判断按照顺序这样收银能否保证每个顾客都能找到钱。skip。 863. all-nodes-distance-k-in-binary-tree 给一个二叉树和其中的一个节点target，求二叉树中距离target为K的所有节点。 先一波DFS从root到target的backward path，然后从target开始沿三个方向开始BFS。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution &#123; public List&lt;Integer&gt; distanceK(TreeNode root, TreeNode target, int K) &#123; List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); if (root == null || target == null) &#123; return ans; &#125; Map&lt;TreeNode, TreeNode&gt; prevNodeMap = new HashMap&lt;&gt;(); Set&lt;TreeNode&gt; visited = new HashSet&lt;&gt;(); if (!buildBackPath(target, root, null, prevNodeMap)) &#123; return ans; &#125; Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.offer(target); visited.add(target); int distance = 0; while (!q.isEmpty() &amp;&amp; distance &lt; K) &#123; int size = q.size(); while (size-- &gt; 0) &#123; TreeNode curr = q.poll(); if (prevNodeMap.containsKey(curr) &amp;&amp; !visited.contains(prevNodeMap.get(curr))) &#123; visited.add(prevNodeMap.get(curr)); q.offer(prevNodeMap.get(curr)); &#125; if (curr.left != null &amp;&amp; !visited.contains(curr.left)) &#123; visited.add(curr.left); q.offer(curr.left); &#125; if (curr.right != null &amp;&amp; !visited.contains(curr.right)) &#123; visited.add(curr.right); q.offer(curr.right); &#125; &#125; distance++; &#125; while (!q.isEmpty()) &#123; ans.add(q.poll().val); &#125; return ans; &#125; private boolean buildBackPath(TreeNode target, TreeNode node, TreeNode prev, Map&lt;TreeNode, TreeNode&gt; prevNodeMap) &#123; if (node == null) &#123; return false; &#125; if (prev != null) &#123; prevNodeMap.put(node, prev); &#125; if (node == target) &#123; return true; &#125; if (buildBackPath(target, node.left, node, prevNodeMap) || buildBackPath(target, node.right, node, prevNodeMap)) &#123; return true; &#125; return false; &#125;&#125; 864. shortest-path-to-get-all-keys 给一个二维的grid，.表示空地、@表示起点（也可以看作空地）、a~f表示锁、A~F表示对应的门，要想到对应的门必须先有对应的钥匙。求从起点最少需要走几步拿到所有钥匙。 这种求graph中最短路径的问题通常用BFS就可以。问题在于这个锁和钥匙的问题，拿到钥匙之后可能需要原路返回，这和通常BFS不走回头路的做法不同。但注意现在的状态区别就是持有钥匙的不同，而且只需要统计每一种钥匙是否出现，可以直接用一个int的bit来表示。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788class Solution &#123; class Point &#123; int row, col, keyBits; public Point(int row, int col, int keyBits) &#123; this.row = row; this.col = col; this.keyBits = keyBits; &#125; &#125; public int shortestPathAllKeys(String[] grid) &#123; if (grid == null || grid.length == 0) &#123; return 0; &#125; int rowCount = grid.length, colCount = grid[0].length(); int rowStart = -1, colStart = -1, keyTotal = 0; for (int i = 0; i &lt; rowCount; i++) &#123; for (int j = 0; j &lt; colCount; j++) &#123; if (grid[i].charAt(j) == '@') &#123; rowStart = i; colStart = j; &#125; else if (grid[i].charAt(j) &gt;= 'a' &amp;&amp; grid[i].charAt(j) &lt;= 'f') &#123; keyTotal++; &#125; &#125; &#125; if (rowStart == -1 || keyTotal == 0) &#123; return 0; &#125; int steps = -1, keyTotalBits = (1 &lt;&lt; keyTotal) - 1; Set&lt;String&gt; visited = new HashSet&lt;&gt;(); Queue&lt;Point&gt; q = new LinkedList&lt;&gt;(); q.offer(new Point (rowStart, colStart, 0)); visited.add(getStateString(rowStart, colStart, 0)); while (!q.isEmpty()) &#123; int size = q.size(); steps++; while (size-- &gt; 0) &#123; Point curr = q.poll(); char currChar = grid[curr.row].charAt(curr.col); if (currChar &gt;= 'a' &amp;&amp; currChar &lt;= 'f') &#123; curr.keyBits |= (1 &lt;&lt; (currChar - 'a')); &#125; if (curr.keyBits == keyTotalBits) &#123; return steps; &#125; if (validatePos(grid, curr.row - 1, curr.col, visited, curr.keyBits)) &#123; q.offer(new Point(curr.row - 1, curr.col, curr.keyBits)); visited.add(getStateString(curr.row - 1, curr.col, curr.keyBits)); &#125; if (validatePos(grid, curr.row + 1, curr.col, visited, curr.keyBits)) &#123; q.offer(new Point(curr.row + 1, curr.col, curr.keyBits)); visited.add(getStateString(curr.row + 1, curr.col, curr.keyBits)); &#125; if (validatePos(grid, curr.row, curr.col - 1, visited, curr.keyBits)) &#123; q.offer(new Point(curr.row, curr.col - 1, curr.keyBits)); visited.add(getStateString(curr.row, curr.col - 1, curr.keyBits)); &#125; if (validatePos(grid, curr.row, curr.col + 1, visited, curr.keyBits)) &#123; q.offer(new Point(curr.row, curr.col + 1, curr.keyBits)); visited.add(getStateString(curr.row, curr.col + 1, curr.keyBits)); &#125; &#125; &#125; return -1; &#125; private char getChar(String[] grid, int row, int col) &#123; if (row &gt;= 0 &amp;&amp; row &lt; grid.length &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; grid[row].length()) &#123; return grid[row].charAt(col); &#125; else &#123; return '#'; &#125; &#125; private String getStateString(int row, int col, int keyCount) &#123; return row + "," + col + ":" + keyCount; &#125; private boolean validatePos(String[] grid, int row, int col, Set&lt;String&gt; visited, int keyBits) &#123; char currChar = getChar(grid, row, col); return ((currChar == '.' || currChar == '@' || currChar &gt;= 'a' &amp;&amp; currChar &lt;= 'f' || currChar &gt;= 'A' &amp;&amp; currChar &lt;= 'F' &amp;&amp; ((keyBits &amp; (1 &lt;&lt; (currChar - 'A'))) != 0)) &amp;&amp; !visited.contains(getStateString(row, col, keyBits))); &#125;&#125; 872. leaf-similar-trees 给两个二叉树的root节点，判断他们的叶子节点组成的sequence是否相同。DFS搞定，skip。]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>algorithm</tag>
        <tag>interview</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有代西滴]]></title>
    <url>%2F2017%2F11%2F28%2Fudacity%2F</url>
    <content type="text"><![CDATA[迎难而上，祝我好运。 Anagram (49) 给一个数组，将所有“由相同字母组合而成的字符串”group起来返回。 group就要找共同点，这里就是各字母出现的个数，可以排序一下作为key，维护一个Map映射到对应的index，存到的List进去。1234567891011121314151617181920212223242526class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; List&lt;List&lt;String&gt;&gt; ans = new ArrayList&lt;&gt;(); if (strs == null || strs.length == 0) &#123; return ans; &#125; Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); for (String str: strs) &#123; char[] sChar = str.toCharArray(); // sort str Arrays.sort(sChar); String newStr = new String(sChar); // the key to get the index in ans if (map.containsKey(newStr)) &#123; int index = map.get(newStr); ans.get(index).add(str); &#125; else &#123; map.put(newStr, ans.size()); List&lt;String&gt; temp = new ArrayList&lt;&gt;(); temp.add(str); ans.add(temp); &#125; &#125; return ans; &#125;&#125; Least Frequently Used 460 实现最近最频繁使用的有限容量缓存，到达容量上限时evict最不频繁使用的key，若频繁情况相同则evict掉最早插入的。 方法一：优先队列，自定义Cache类，其中包含freq和timestamp，自定义Comparator来维护顺序。cacheMap用于维护正常的键值对缓存，freqMap用于快速获得给定key的freq。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182class LFUCache &#123; // naive做法：通过自定义Cache维护一个优先队列，排序就是根据freq和timestamp来的，freq小在前、相等则时间戳小的在前 // put：把键值对放入cacheMap，还要新建这个key的freq（第一次为1）并插入freqMap // get: 直接从cacheMap中拿 // 在put和get过程中，若key是现有的，则需要更新freq，并存入pq // 当到达容量上限，直接从pq头部poll出来的key对应从map里删掉即可 // pq的remove是O(N)的，所以总体是O(capacity)的 class Cache &#123; int key, freq, timestamp; public Cache(int key, int freq, int timestamp) &#123; this.key = key; this.freq = freq; this.timestamp = timestamp; &#125; @Override public boolean equals(Object obj) &#123; return key == ((Cache)(obj)).key; &#125; @Override public int hashCode() &#123; return key; &#125; &#125; int capacity, globalTime; Map&lt;Integer, Integer&gt; cacheMap = null; Map&lt;Integer, Integer&gt; freqMap = null; PriorityQueue&lt;Cache&gt; pq = null; public LFUCache(int capacity) &#123; this.capacity = capacity; globalTime = 0; cacheMap = new HashMap&lt;&gt;(); freqMap = new HashMap&lt;&gt;(); pq = new PriorityQueue&lt;&gt;((c1, c2) -&gt; &#123; return c1.freq == c2.freq? c1.timestamp - c2.timestamp: c1.freq - c2.freq; &#125;); &#125; public int get(int key) &#123; globalTime++; if (cacheMap.containsKey(key)) &#123; update(key); return cacheMap.get(key); &#125; return -1; &#125; public void put(int key, int value) &#123; if (capacity == 0) &#123; return ; &#125; globalTime++; if (cacheMap.containsKey(key)) &#123; update(key); cacheMap.put(key, value); return; &#125; if (cacheMap.size() == capacity) &#123; Cache evict = pq.poll(); cacheMap.remove(evict.key); freqMap.remove(evict.key); &#125; cacheMap.put(key, value); freqMap.put(key, 1); pq.add(new Cache(key, 1, globalTime)); &#125; public void update(int key) &#123; int freq = freqMap.get(key); freqMap.put(key, freq + 1); Cache c = new Cache(key, freq + 1, globalTime); pq.remove(c); pq.add(c); &#125;&#125;/** * Your LFUCache object will be instantiated and called as such: * LFUCache obj = new LFUCache(capacity); * int param_1 = obj.get(key); * obj.put(key,value); */ 方法二：使用LRU中的双向链表，可以使得remove也O(1)。自定义Node，每个位置的Node代表了某个freq值的所有key。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128class LFUCache &#123; // 自定义双向链表节点Node用于按照freq从大到小存放key // 通过key对应到Node（nodeMap），Node中存放该key的freq。 // 若相同的freq对应多个key，则用一个Set存放，为了维持Recent特性，需要保证插入顺序，故用LinkedHashSet // get：从cacheMap中正常取数值，并从nodeMap中拿到这个节点，更新freq并插入到后续位置。 // put：有可能是更新原有key的数值，更新cacheMap中value。 // put：若是插入新的key，则先看看head是否维护的是freq为0，不是则新建head并插入到最前。 // put完之后要统一更新freq. class Node &#123; public int freq = 0; public Set&lt;Integer&gt; keySet = null; public Node prev = null, next = null; public Node(int freq) &#123; this.freq = freq; keySet = new LinkedHashSet&lt;&gt;(); prev = null; next = null; &#125; &#125; private Node head = null; private int capacity = 0; private Map&lt;Integer, Integer&gt; cacheMap = null; private Map&lt;Integer, Node&gt; nodeMap = null; public LFUCache(int capacity) &#123; this.capacity = capacity; cacheMap = new HashMap&lt;&gt;(); nodeMap = new HashMap&lt;&gt;(); &#125; public int get(int key) &#123; if (cacheMap.containsKey(key)) &#123; updateFreq(key); return cacheMap.get(key); &#125; return -1; &#125; public void put(int key, int value) &#123; if (capacity == 0) &#123; return; &#125; if (cacheMap.containsKey(key)) &#123; cacheMap.put(key, value); &#125; else &#123; if (cacheMap.size() &lt; capacity) &#123; cacheMap.put(key, value); &#125; else &#123; deleteOldest(); cacheMap.put(key, value); &#125; addToHead(key); &#125; updateFreq(key); &#125; // 更新key的freq并加入相应的node中 private void updateFreq(int key) &#123; Node node = nodeMap.get(key); node.keySet.remove(key); // 从当前freq的node中移除然后加入后续node if (node.next == null) &#123; node.next = new Node(node.freq + 1); node.next.prev = node; node.next.keySet.add(key); // 相同freq的key，维持插入顺序 &#125; else if (node.next.freq == node.freq + 1) &#123; node.next.keySet.add(key); &#125; else &#123; Node newFreqNode = new Node(node.freq + 1); newFreqNode.keySet.add(key); newFreqNode.prev = node; newFreqNode.next = node.next; node.next.prev = newFreqNode; node.next = newFreqNode; &#125; nodeMap.put(key, node.next); // 更新后续node if (node.keySet.size() == 0) &#123; deleteNode(node); &#125; &#125; // O(1)删除双向链表的节点 private void deleteNode(Node node) &#123; if (node.prev == null) &#123; head = node.next; &#125; else &#123; node.prev.next = node.next; &#125; if (node.next != null) &#123; node.next.prev = node.prev; &#125; &#125; // 新插入的key要新建freq=0的Node（或原本就有），并作为head private void addToHead(int key) &#123; if (head == null) &#123; head = new Node(0); head.keySet.add(key); &#125; else if (head.freq &gt; 0) &#123; Node newHead = new Node(0); newHead.keySet.add(key); newHead.next = head; head.prev = newHead; head = newHead; &#125; else &#123; head.keySet.add(key); &#125; nodeMap.put(key, head); &#125; private void deleteOldest() &#123; // 双向链表头就是freq最小的key们 if (head == null) &#123; return; &#125; Iterator it = head.keySet.iterator(); // keys中靠前的就是较早插入的 Integer oldestKey = null; if (it.hasNext()) &#123; oldestKey = (Integer)it.next(); head.keySet.remove(oldestKey); &#125; if (head.keySet.size() == 0) &#123; deleteNode(head); &#125; if (oldestKey != null) &#123; cacheMap.remove(oldestKey); nodeMap.remove(oldestKey); &#125; &#125;&#125; 求平均时间 给一堆GET request，其中包含时间信息，求这些请求的平均时间。比如 12345GET /course/html5-game-development--cs255 200 [72.80 27.47 28.51] 86.231.22.202 2017-04-07T18:02:35+00:00 &#123;&quot;id&quot;: &quot;html5-game-development--cs255&quot;&#125;GET /public-api/v1/degrees/nd803 200 [83.31 32.66 25.50] 160.153.51.93 2017-04-07T18:02:35+00:00 &#123;&quot;format&quot;: &quot;json&quot;, &quot;key&quot;: &quot;nd803&quot;&#125;GET /course/android-development-for-beginners--ud837 200 [68.02 29.44 21.22] 205.102.123.51 2017-04-07T18:02:36+00:00 &#123;&quot;id&quot;: &quot;android-development-for-beginners--ud837&quot;&#125;GET /ai 302 [32.47 21.71 4.39] 209.151.195.193 2017-04-07T18:02:37+00:00 &#123;&quot;id&quot;: &quot;ai&quot;&#125;GET /course/artificial-intelligence-nanodegree--nd889 200 [52.65 41.78 4.50] 209.151.195.193 2017-04-07T18:02:37+00:00 &#123;&quot;id&quot;: &quot;artificial-intelligence-nanodegree--nd889&quot;&#125; 它们都格式都是固定的，通过split提取出时间，然后从Date转换成long，求平均值，最后再new一个Date即得。 12345678910111213141516171819202122232425public static String getAvgTime(String[] requests) &#123; if (requests == null || requests.length == 0) &#123; return null; &#125; long timeVal = 0; SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"); format.setTimeZone(TimeZone.getTimeZone("UTC")); for (int i = 0; i &lt; requests.length; i++) &#123; String[] requestParts = requests[i].split(" "); long currVal = 0; try &#123; currVal = format.parse(requestParts[7]).getTime(); &#125; catch (ParseException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; if (i &gt; 0) &#123; timeVal = (long)(timeVal / 2.0 + currVal / 2.0); &#125; else &#123; timeVal = currVal; &#125; &#125; Date avgTime = new Date(timeVal); return avgTime.toString();&#125;]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>algorithm</tag>
        <tag>interview</tag>
        <tag>udacity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[诶叵]]></title>
    <url>%2F2017%2F11%2F26%2Fapple%2F</url>
    <content type="text"><![CDATA[请多多指教！ 403. frog-jump 给一个数组表示石头所处的x坐标，青蛙每次只能跳上一次跳跃长度的-1,0,1三种可能，判断能否跳到最后一个石头。 相当于BFS，每个石头处维护一个set存放他可以跳的长度，然后每次都往后跳看看能否有新的石头，有就更新那个石头的可跳长度。 12345678910111213141516171819202122232425262728293031323334353637// BFS，从开头出发，不断更新后续可达石头的新步数，若中途更新到了最后一个石头，就可达public boolean canCross(int[] stones) &#123; if (stones == null || stones.length == 0) &#123; return true; &#125; if (stones[0] != 0) &#123; return false; &#125; // 记录每个坐标的石头所能跳的长度 Map&lt;Integer, Set&lt;Integer&gt;&gt; stone2step = new HashMap&lt;&gt;(); for (int i = 0; i &lt; stones.length; i++) &#123; stone2step.put(stones[i], new HashSet&lt;&gt;()); &#125; stone2step.get(0).add(1); // 第一步起码要能往后挪一步 // 从第一个石头开始，往后更新每个石头的能跳步数 for (int i = 0; i &lt; stones.length; i++) &#123; int currStone = stones[i]; Set&lt;Integer&gt; steps = stone2step.get(currStone); for (int step: steps) &#123; int newStone = currStone + step; if (newStone == stones[stones.length - 1]) &#123; return true; &#125; Set&lt;Integer&gt; newStep = stone2step.get(newStone); if (newStep != null) &#123; // 表示有这个新石头的坐标 newStep.add(step + 1); newStep.add(step); if (step - 1 &gt; 0) &#123; newStep.add(step - 1); &#125; &#125; &#125; &#125; return false;&#125; 249. group-shifted-strings 给一个String的数组，要求将其中能通过平移相同offset后相同的字符串group在一起. 先根据第一个字母算出与a的offset，然后将后续所有字母都根据这个offset来挪，拼接成key存入map。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; // group xxx的题，八成就是要找到同一组的共同点并定义好key // 这里的key就是长度相同的字符串每个字母挪动一定的offset可以相等 // 根据首字母与'a'的offset来定义key，往key对应的List里add就好了 public List&lt;List&lt;String&gt;&gt; groupStrings(String[] strings) &#123; List&lt;List&lt;String&gt;&gt; ans = new ArrayList&lt;&gt;(); if (strings == null || strings.length == 0) &#123; return ans; &#125; Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); for (String s: strings) &#123; if (s.length() == 0) &#123; if (!map.containsKey("")) &#123; map.put("", new ArrayList&lt;&gt;()); &#125; map.get("").add(s); continue; &#125; char[] sChar = s.toCharArray(); int offset = sChar[0] - 'a'; // 只有小写字母 StringBuilder key = new StringBuilder(); for (int i = 0; i &lt; sChar.length; i++) &#123; char c = (char)(sChar[i] - offset); if (c &lt; 'a') &#123; c += 26; &#125; key.append(c); &#125; if (!map.containsKey(key.toString())) &#123; map.put(key.toString(), new ArrayList&lt;String&gt;()); &#125; map.get(key.toString()).add(s); &#125; // 每个List内部需要排序 for (String key: map.keySet()) &#123; List&lt;String&gt; list = map.get(key); Collections.sort(list); ans.add(list); &#125; return ans; &#125;&#125; 108. convert-sorted-array-to-binary-search-tree 取中间的为根节点，然后前后两半递归继续build。 123456789101112131415161718192021class Solution &#123; public TreeNode sortedArrayToBST(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return null; &#125; return buildTree(nums, 0, nums.length - 1); &#125; private TreeNode buildTree(int[] nums, int start, int end) &#123; if (start &gt; end) return null; if (start == end) return new TreeNode(nums[start]); int mid = start + (end - start) / 2; TreeNode node = new TreeNode(nums[mid]); node.left = buildTree(nums, start, mid - 1); node.right = buildTree(nums, mid + 1, end); return node; &#125;&#125; 127. word-ladder 很图论的题，每一个单词看作节点，路径有无根据「能否改一个字母变成它」判断，在BFS过程中可达就直接入queue。 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Solution &#123; public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; if (beginWord == null || endWord == null || beginWord.length() == 0 || endWord.length() == 0 || beginWord.length() != endWord.length() || wordList == null || wordList.size() == 0) &#123; return 0; &#125; Set&lt;String&gt; wordSet = new HashSet&lt;&gt;(wordList); Queue&lt;String&gt; toVisit = new LinkedList&lt;&gt;(); bfs(beginWord, wordSet, toVisit); int dist = 2; while (!toVisit.isEmpty()) &#123; int size = toVisit.size(); for (int i = 0; i &lt; size; i++) &#123; String curr = toVisit.poll(); if (curr.equals(endWord)) &#123; return dist; &#125; else &#123; bfs(curr, wordSet, toVisit); &#125; &#125; dist++; &#125; return 0; &#125; private void bfs(String beginWord, Set&lt;String&gt; wordSet, Queue&lt;String&gt; toVisit) &#123; wordSet.remove(beginWord); StringBuilder sb = new StringBuilder(beginWord); for (int i = 0; i &lt; sb.length(); i++) &#123; char origin = sb.charAt(i); for (int k = 0; k &lt; 26; k++) &#123; char c = (char)('a' + k); sb.setCharAt(i, c); String curr = sb.toString(); if (wordSet.contains(curr)) &#123; toVisit.add(curr); wordSet.remove(curr); &#125; &#125; sb.setCharAt(i, origin); &#125; &#125;&#125; 126. word-ladder-ii 词典中每一个词都是一个node，要从起点到终点，如果要记录这些最短的路径具体是怎么走的，就需要在BFS判断可不可达并构建临街表的基础上再来一个DFS，从起点开始一直往后（不走回头路利用的是后出现的节点的距离一定是先经过的节点的距离+1），如果到了终点就把经过的路径存起来。最后形成的就是路径的列表了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384class Solution &#123; public List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; Set&lt;String&gt; wordSet = new HashSet&lt;&gt;(wordList); wordSet.add(beginWord); Map&lt;String, List&lt;String&gt;&gt; neighborMap = new HashMap&lt;&gt;(); Map&lt;String, Integer&gt; distanceMap = new HashMap&lt;&gt;(); List&lt;List&lt;String&gt;&gt; ans = new ArrayList&lt;&gt;(); bfs(beginWord, endWord, wordSet, neighborMap, distanceMap); dfs(beginWord, endWord, neighborMap, distanceMap, new Arraylist&lt;String&gt;(), ans); return ans; &#125; // 用BFS构建邻接表并维护离起点的距离 private void bfs(String beginWord, String endWord, Set&lt;String&gt; wordSet, Map&lt;String, List&lt;String&gt;&gt; neighborMap, Map&lt;String, Integer&gt; distanceMap) &#123; for (String word: wordSet) &#123; neighborMap.put(word, new ArrayList&lt;String&gt;()); &#125; Queue&lt;String&gt; q = new LinkedList&lt;&gt;(); q.add(beginWord); distanceMap.put(beginWord, 0); while (!q.isEmpty()) &#123; int size = q.size(); boolean reached = false; for (int i = 0; i &lt; size; i++) &#123; String currWord = q.poll(); int currDistance = distanceMap.get(currWord); List&lt;String&gt; neighborList = getNeighborList(currWord, wordSet); for (String neighbor: neighborList) &#123; neighborMap.get(currWord).add(neighbor); if (!distanceMap.containsKey(neighbor)) &#123; distanceMap.put(neighbor, currDistance + 1); if (neighbor.equals(endWord)) &#123; reached = true; &#125; else &#123; q.add(neighbor); &#125; &#125; &#125; &#125; if (reached) &#123; break; &#125; &#125; &#125; // 通过替换字母并判断是否在dict中产生给定词的邻居 private List&lt;String&gt; getNeighborList(String currWord, Set&lt;String&gt; wordSet) &#123; char[] cstr = currWord.toCharArray(); List&lt;String&gt; ret = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; cstr.length; i++) &#123; char origin = cstr[i]; for (char c = 'a'; c &lt;= 'z'; c++) &#123; if (c == origin) &#123; continue; &#125; cstr[i] = c; String temp = new String(cstr); if (wordSet.contains(temp)) &#123; ret.add(temp); &#125; &#125; cstr[i] = origin; &#125; return ret; &#125; // 从起点开始往它的邻居DFS private void dfs(String currWord, String endWord, Map&lt;String, List&lt;String&gt;&gt; neighborMap, Map&lt;String, Integer&gt; distanceMap, List&lt;String&gt; path, List&lt;List&lt;String&gt;&gt; ans) &#123; path.add(currWord); if (currWord.equals(endWord)) &#123; ans.add(new ArrayList&lt;String&gt;(path)); &#125; else &#123; int currDistance = distanceMap.get(currWord); List&lt;String&gt; neighborList = neighborMap.get(currWord); for (String neighbor: neighborList) &#123; if (distanceMap.get(neighbor) == currDistance + 1) &#123; dfs(neighbor, endWord, neighborMap, distanceMap, path, ans); &#125; &#125; &#125; path.remove(path.size() - 1); &#125;&#125; [Extra][path between 2 nodes in tree] 给一个二叉树，和两个节点A，B，找出从A到B的路径，返回结果要求顺序存到一个链表中。 找到A和B的共同祖先，然后倒序输出到A的路径，再输出到B的路径。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public class Apple &#123; // 共同祖先：递归左边，递归右边，两边都有则root为LCA，否则就是左右二者其中之一 private static TreeNode getLCA(TreeNode root, TreeNode n1, TreeNode n2) &#123; if (root == null) &#123; return null; &#125; if (root == n1 || root == n2) &#123; return root; &#125; TreeNode left = getLCA(root.left, n1, n2); TreeNode right = getLCA(root.right, n1, n2); if (left != null &amp;&amp; right != null) &#123; return root; &#125; if (left == null &amp;&amp; right == null) &#123; return null; &#125; return left == null? right: left; &#125; private static String findPathBetween(TreeNode root, TreeNode start, TreeNode end) &#123; if (root == null) &#123; return ""; &#125; TreeNode lca = getLCA(root, start, end); List&lt;TreeNode&gt; pathToStart = new ArrayList&lt;TreeNode&gt;(); findPathTo(lca, start, pathToStart); List&lt;TreeNode&gt; pathToEnd = new ArrayList&lt;TreeNode&gt;(); findPathTo(lca, end, pathToEnd); StringBuilder sb = new StringBuilder(); for (int i = pathToStart.size() - 1; i &gt; 0; i--) &#123; if (sb.length() == 0) &#123; sb.append(pathToStart.get(i).val); &#125; else &#123; sb.append("-&gt;"); sb.append(pathToStart.get(i).val); &#125; &#125; for (TreeNode node : pathToEnd) &#123; sb.append("-&gt;"); sb.append(node.val); &#125; return sb.toString(); &#125; private static boolean findPathTo(TreeNode start, TreeNode end, List&lt;TreeNode&gt; curr) &#123; curr.add(start); if (start == end) &#123; return true; &#125; else &#123; if (start.left != null) &#123; if (findPathTo(start.left, end, curr)) &#123; return true; &#125; &#125; if (start.right != null) &#123; if (findPathTo(start.right, end, curr)) &#123; return true; &#125; &#125; &#125; curr.remove(curr.size() - 1); return false; &#125; public static class TreeNode &#123; int val; TreeNode left; TreeNode right; public TreeNode(int val) &#123; this.val = val; &#125; &#125; public static void main(String[] args) &#123; TreeNode root = new TreeNode(0); TreeNode n1 = new TreeNode(1); TreeNode n2 = new TreeNode(2); TreeNode n3 = new TreeNode(3); TreeNode n4 = new TreeNode(4); TreeNode n5 = new TreeNode(5); TreeNode n6 = new TreeNode(6); TreeNode n7 = new TreeNode(7); root.left = n1; root.right = n2; n1.left = n5; n1.right = n6; n2.left = n3; n2.right = n4; n3.left = n7; System.out.println(findPathBetween(root, n2, n5)); &#125;&#125; [extra][overlap interval] 给两个interval的数组，求二者overlap的部分. 定义一个endCurr表示当前的结尾，然后取两个数组中start较小的与它比较，如果重合就将start为起点、endCurr为结尾new一个新的interval存入结果，然后更新endCurr（如果比该start处对应的end小了的话） 123456789101112131415161718192021222324public List&lt;Interval&gt; findOverlapping(Interval[] i1, Interval[] i2) &#123; List&lt;Interval&gt; res = new ArrayList&lt;Interval&gt;(); int i = 0; int j = 0; int endCurr = i1[0].start &gt; i2[0].start ? i2[0].start : i1[0].start; while (i &lt; i1.length &amp;&amp; j &lt; i2.length) &#123; if (i1[i].start &gt; i2[j].start) &#123; if (i2[j].start &lt; endCurr) &#123; Interval temp = new Interval(i2[j].start, endCurr); res.add(temp); &#125; endCurr = Math.max(i2[j].end, endCurr); j++; &#125; else &#123; if (i1[i].start &lt; endCurr) &#123; Interval temp = new Interval(i1[i].start, endCurr); res.add(temp); &#125; endCurr = Math.max(i1[i].end, endCurr); i++; &#125; &#125; return res;&#125; [extra][inplace convert binary tree to BST] 给一个普通的二叉树，转换成二分查找树BST。 方法一：直接中序遍历并将结果存起来，排序后直接赋值回去，可以维持原有的树的形状。 方法二；如果要求in-place，就先将二叉树建成一个双向链表，然后排序（归并O(NlgN)），然后再将双向链表恢复成二分查找树（经过了平衡，没法维持原本的了）。将链表恢复成BST除了取中间值为根然后递归两边，还有一个tricky的方法是从叶开始往根build，复杂度O(N). 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class Apple &#123; public TreeNode binaryTree2BST(TreeNode root) &#123; if (root == null || (root.left == null &amp;&amp; root.right == null)) &#123; return root; &#125; binaryTree2DLL(root); // 转换成双链表 O(N) head = mergeSortDLL(head); // 归并排序 O(N*logN) return DLL2BST(); // 双链表转BST O(N) &#125; TreeNode prev = null, head = null; private void binaryTree2DLL(TreeNode root) &#123; if (root == null) &#123; return; &#125; binaryTree2DLL(root.left); if (prev == null) &#123; head = root; // 最左边的那个为头节点，一次性赋值 &#125; else &#123; root.left = prev; prev.right = root; &#125; prev = root; binaryTree2DLL(root.right); &#125; private TreeNode mergeSortDLL(TreeNode head) &#123; if (head == null || head.right == null) &#123; return head; &#125; TreeNode halfHead = partition(head); head = mergeSortDLL(head); halfHead = mergeSortDLL(halfHead); return merge(head, halfHead); &#125; private TreeNode partition(TreeNode head) &#123; TreeNode fast = head, slow = head; while (fast.right != null &amp;&amp; fast.right.right != null) &#123; fast = fast.right.right; slow = slow.right; &#125; TreeNode mid = slow.right; slow.right = null; return mid; &#125; private TreeNode merge(TreeNode first, TreeNode second) &#123; if (first == null) &#123; return second; &#125; if (second == null) &#123; return first; &#125; if (first.val &lt; second.val) &#123; first.right = merge(first.right, second); first.right.left = first; first.left = null; return first; &#125; else &#123; second.right = merge(first, second.right); second.right.left = second; second.left = null; return second; &#125; &#125; private TreeNode DLL2BST() &#123; int n = countNodes(head); return DLL2BST(n); &#125; private TreeNode DLL2BST(int n) &#123; if (n &lt;= 0) &#123; return null; &#125; TreeNode left = DLL2BST(n / 2); // 左子树的根节点 TreeNode root = head; // root.left = left; head = head.right; // 挪到下一个节点为起点 root.right = DLL2BST(n - n / 2 - 1); // 减去左边和root节点的剩余数 return root; &#125; private int countNodes(TreeNode head) &#123; int count = 0; while (head != null) &#123; count++; head = head.right; &#125; return count; &#125;&#125; [extra][product between indices] 给一个正数数组，给两个索引x和y，求数组从x到y（inclusive）的积。 12345678910111213141516public class Apple &#123; public int getProduct(int[] nums, int x, int y) &#123; if (nums == null || nums.length == 0 || y &lt; x || y &gt;= nums.length || x &lt; 0) &#123; return 0; &#125; // 缓存cache[i]表示从0到i - 1的积 int[] cache = new int [nums.length + 1]; cache[0] = 1; for (int i = 1; i &lt;= nums.length; i++) &#123; cache[i] = nums[i] * cache[i - 1]; &#125; // 从x到y的积就是"到y的积"除以"到x - 1的积" return cache[y + 1] / cache[x]; &#125;&#125; 数组中含有0呢？ 前面的方法不能直接用，难道要用一个n*n的数组穷举出所有情况？其实前面的方法加多个标记0的即可。 123456789101112131415161718192021public class Apple &#123; public int getProduct2(int[] nums, int x, int y) &#123; if (nums == null || nums.length == 0 || y &lt; x || y &gt;= nums.length || x &lt; 0) &#123; return 0; &#125; int[] cache = new int [nums.length + 1]; int[] zeroCount = new int [nums.length + 1]; cache[0] = 1; for (int i = 1; i &lt;= nums.length; i++) &#123; if (nums[i] = 0) &#123; cache[i] = 1; zeroCount[i] = zeroCount[i - 1] + 1; &#125; else &#123; cache[i] = nums[i] * cache[i - 1]; zeroCount[i] = zeroCount[i - 1]; &#125; &#125; return zeroCount[y + 1] != zeroCount[x]? 0: cache[y + 1] / cache[x]; &#125;&#125; 362. design-hit-counter 实现一个计数器，返回给定时间点之前300秒内的hit数。 12345678910111213141516171819202122232425262728293031323334class HitCounter &#123; private int[] hits; private int[] time; final private int TIMEWINDOW = 300; /** Initialize your data structure here. */ public HitCounter() &#123; hits = new int [TIMEWINDOW]; time = new int [TIMEWINDOW]; &#125; /** Record a hit. @param timestamp - The current timestamp (in seconds granularity). */ public void hit(int timestamp) &#123; int index = timestamp % TIMEWINDOW; if (time[index] != timestamp) &#123; time[index] = timestamp; hits[index] = 1; &#125; else &#123; hits[index]++; &#125; &#125; /** Return the number of hits in the past 5 minutes. @param timestamp - The current timestamp (in seconds granularity). */ public int getHits(int timestamp) &#123; int count = 0; for (int i = 0; i &lt; TIMEWINDOW; i++) &#123; if (timestamp - time[i] &lt; TIMEWINDOW) &#123; count += hits[i]; &#125; &#125; return count; &#125;&#125; [extra][subarray sum] 求所有等于target的subarray,有点类似209. minimum-size-subarray-sum. 双指针，一前一后，一旦前面挪动后所得的sum太大，就开始挪后面的。 123456789101112131415161718192021222324public class Solution &#123; public List&lt;int[]&gt; minSubArrayLen(int s, int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; int slow = 0, fast = 0, currSum = 0; while (fast &lt; nums.length) &#123; if (nums[fast] &gt;= s) &#123; return 1; &#125; if (currSum &gt;= s || fast - slow &gt; minLen) &#123; minLen = Math.min(minLen, fast - slow); currSum -= nums[slow++]; &#125; else &#123; currSum += nums[fast++]; &#125; &#125; while (currSum &gt;= s) &#123; minLen = Math.min(minLen, fast - slow); currSum -= nums[slow++]; &#125; return slow == 0? 0: minLen; &#125;&#125; anagrams group问题，定义key：这里就是string按照字母顺序排好序之后的新String。 123456789101112131415161718192021222324class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; List&lt;List&lt;String&gt;&gt; ans = new ArrayList&lt;&gt;(); if (strs == null || strs.length == 0) &#123; return ans; &#125; Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); for (String str: strs) &#123; char[] sChar = str.toCharArray(); // sort str Arrays.sort(sChar); String newStr = new String(sChar); // the key to get the index in ans if (map.containsKey(newStr)) &#123; int index = map.get(newStr); ans.get(index).add(str); &#125; else &#123; map.put(newStr, ans.size()); List&lt;String&gt; temp = new ArrayList&lt;&gt;(); temp.add(str); ans.add(temp); &#125; &#125; return ans; &#125;&#125; 70. climbing-stairs 爬楼梯，每次只能爬1或2步，求共有多少种到达顶楼的方式。 DP，当前这一层的方式数取决于前一层的方式数加上前两层的方式数。用不着数组。 123456789101112131415161718192021222324252627public class Solution &#123; public int climbStairs(int n) &#123; int[] dp = new int [n + 1]; dp[0] = 1; if (n &gt; 0) &#123; dp[1] = 1; &#125; for (int i = 2; i &lt;= n; i++) &#123; dp[i] = dp[i - 1] + dp[i - 2]; &#125; return dp[n]; &#125;&#125;class Solution &#123; public int climbStairs(int n) &#123; if (n &lt; 2) &#123; return 1; &#125; int prev2 = 1, prev1 = 1, ans = prev2 + prev1; for (int i = 2; i &lt;= n; i++) &#123; ans = prev2 + prev1; prev2 = prev1; prev1 = ans; &#125; return ans; &#125;&#125; 43. multiply-strings 解析在此 123456789101112131415161718192021222324252627282930313233class Solution &#123; public String multiply(String num1, String num2) &#123; if (num1 == null || num2 == null || num1.length() == 0 || num2.length() == 0) &#123; return ""; &#125; int m = num1.length(), n = num2.length(); int[] result = new int [m + n]; char[] cnum1 = num1.toCharArray(), cnum2 = num2.toCharArray(); // from least significant bit for (int i = m - 1; i &gt;= 0; i--) &#123; for (int j = n - 1; j &gt;= 0; j--) &#123; int mult = (cnum1[i] - '0') * (cnum2[j] - '0'); int first = i + j, second = i + j + 1; int sum = mult + result[second]; // add carry from prev steps result[first] += sum / 10; // accumulate result[second] = sum % 10; // overwrite &#125; &#125; StringBuilder sb = new StringBuilder(); int i = 0; // find the first non-zero item while (i &lt; result.length &amp;&amp; sb.length() == 0 &amp;&amp; result[i] == 0) &#123; i++; &#125; while (i &lt; result.length) &#123; sb.append(result[i++]); &#125; return sb.length() == 0? "0": sb.toString(); &#125;&#125; [extra][even space] 给一个句子，再给一个宽度，要求均匀分配空格。 12345678910111213141516171819202122232425262728293031323334public class Apple &#123; private String evenSpace(String input, int width) &#123; if (input.length() &gt; width) &#123; return input; &#125; String[] words = input.split(" "); int wordLenSum = 0; for (int i = 0; i &lt; words.length; i++) &#123; wordLenSum += words[i].length(); &#125; return putLine(words, width, wordLenSum); &#125; private String putLine(String[] words, int maxWidth, int wordSum) &#123; StringBuilder sb = new StringBuilder(words[start]); int spaceSum = maxWidth - wordSum; int spaceCount = words.length; int mod = spaceSum % spaceCount, quo = spaceSum / spaceCount; for (int i = 0; i &lt; words.length; i++) &#123; if (mod != 0) &#123; int useCount = quo + 1; appendSpace(sb, useCount); spaceSum -= useCount; spaceCount--; mod = spaceSum % spaceCount; quo = spaceSum / spaceCount; &#125; else &#123; appendSpace(sb, quo); &#125; sb.append(words[i]); &#125; return sb.toString(); &#125;&#125; 32. longest-valid-parentheses 给一个只包含了(和)的字符串，求其中合法匹配的最大子字符串长度。 动态规划，dp[i]表示到i索引为止的最长长度。12345678910111213141516171819202122232425262728class Solution &#123; public int longestValidParentheses(String s) &#123; if (s == null || s.length() == 0) &#123; return 0; &#125; int[] dp = new int [s.length()]; // maxLen till curr char (only for valid ')') char[] sChar = s.toCharArray(); int ans = 0; for (int i = 0; i &lt; sChar.length; i++) &#123; // only ) is count as valid bit if (sChar[i] == ')') &#123; // "xxx)" if (i &gt; 0) &#123; if (sChar[i - 1] == '(') &#123; // prev is (, simply add 2 to prevprev dp[i] = 2 + (i &gt; 1? dp[i - 2]: 0); &#125; else &#123; // prev is ( int prev = i - dp[i - 1] - 1; // move to the very front of prev slot if (prev &gt;= 0 &amp;&amp; sChar[prev] == '(') &#123; // only ( can match curr ) dp[i] = (prev &gt; 0? dp[prev - 1]: 0) + 2 + dp[i - 1]; // check ('s prev &#125; &#125; ans = Math.max(ans, dp[i]); &#125; &#125; &#125; return ans; &#125;&#125; 543. diameter-of-binary-tree 可以普通O(N^2)的DFS或者优化后的O(N)。1234567891011121314151617class Solution &#123; private int max = 0; public int diameterOfBinaryTree(TreeNode root) &#123; getMaxDepth(root); return max; &#125; private int getMaxDepth(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; int left = getMaxDepth(root.left); // 左深度 int right = getMaxDepth(root.right);// 右深度 max = Math.max(max, left + right); // 形成^的diameter return Math.max(left, right) + 1; // 返回新的深度 &#125;&#125; 472. concatenated-words 给一个String的数组，求其中能由其他String拼接而成的字符串。和wordbreak很像。 先根据长度排序，然后从字符串前面（维护一个Set）取字符串，然后就变成了wordbreak了。 123456789101112131415161718192021222324252627282930313233public class Solution &#123; public static List&lt;String&gt; findAllConcatenatedWordsInADict(String[] words) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); Set&lt;String&gt; preWords = new HashSet&lt;&gt;(); Arrays.sort(words, new Comparator&lt;String&gt;() &#123; public int compare (String s1, String s2) &#123; return s1.length() - s2.length(); &#125; &#125;); for (int i = 0; i &lt; words.length; i++) &#123; if (canForm(words[i], preWords)) &#123; result.add(words[i]); &#125; preWords.add(words[i]); &#125; return result; &#125; private static boolean canForm(String word, Set&lt;String&gt; dict) &#123; if (dict.isEmpty()) return false; boolean[] dp = new boolean[word.length() + 1]; dp[0] = true; for (int i = 1; i &lt;= word.length(); i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (dp[j] &amp;&amp; dict.contains(word.substring(j, i))) &#123; dp[i] = true; break; &#125; &#125; &#125; return dp[word.length()]; &#125;&#125; 138. copy-list-with-random-pointer 一个链表，每个节点除了含有label和next以外还含有一个指向任意节点的random引用。深复制这个链表。 方法一：用HashMap存放各个链表节点和它对应的复制品。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 /** * Definition for singly-linked list with a random pointer. * class RandomListNode &#123; * int label; * RandomListNode next, random; * RandomListNode(int x) &#123; this.label = x; &#125; * &#125;; */public class Solution &#123; HashMap&lt;RandomListNode, RandomListNode&gt; map; public RandomListNode copyRandomList(RandomListNode head) &#123; map = new HashMap&lt;RandomListNode, RandomListNode&gt;(); if (head == null) &#123; return null; &#125; RandomListNode prev = null, curr = head, newHead = null; while (curr != null) &#123; RandomListNode newNode = null; if (map.containsKey(curr)) &#123; newNode = map.get(curr); &#125; else &#123; newNode = new RandomListNode(curr.label); map.put(curr, newNode); &#125; if (prev != null) &#123; prev.next = newNode; &#125; else &#123; newHead = newNode; &#125; if (curr.random != null) &#123; if (map.containsKey(curr.random)) &#123; newNode.random = map.get(curr.random); &#125; else &#123; RandomListNode temp = new RandomListNode(curr.random.label); newNode.random = temp; map.put(curr.random, temp); &#125; &#125; prev = newNode; curr = curr.next; &#125; return newHead; &#125;&#125; 把每一个拷贝的节点拼接到原节点的后面，这样一轮循环过后所有节点都有了一份拷贝；第二轮循环就是为random赋值了，既然知道原节点之后就是对应的拷贝节点，那random的引用也就可以直接获得了。最后一轮循环则是把拷贝的节点正确地拼接起来，最后返回。 123456789101112131415161718192021222324252627282930313233343536373839404142public class Solution &#123; public RandomListNode copyRandomList(RandomListNode head) &#123; if (head == null) &#123; return null; &#125; RandomListNode curr = head, currNext = null, currCopy = null; while (curr != null) &#123; currNext = curr.next; // 先暂存原节点的next currCopy = new RandomListNode(curr.label); curr.next = currCopy; // 原节点next指向复制品 currCopy.next = currNext; // 复制品next指向原节点的next curr = currNext; &#125; curr = head; // 从原链表头开始遍历 while (curr != null) &#123; if (curr.random != null) &#123; // 节点的next就是它的复制品 curr.next.random = curr.random.next; &#125; curr = curr.next.next; &#125; RandomListNode fakeHead = new RandomListNode(0); curr = head; currCopy = fakeHead; // 恢复原链表同时产生复制品链表 while (curr != null) &#123; currNext = curr.next.next; currCopy.next = curr.next; currCopy = curr.next; curr.next = currNext; curr = currNext; &#125; return fakeHead.next; &#125;&#125; 139. word-break 给一个字符串，判断能否由给定dict中的单词组成。 当前是否可以取决于”以当前字符结尾、前面某处开头的单词来自于dict”且”该起点往前也是可以的”。 1234567891011121314151617181920212223public class Apple &#123; public boolean workBreak(String s, List&lt;String&gt; wordDict) &#123; if (s == null || s.length() == 0 || wordDict == null || wordDict.size() == 0) &#123; return false; &#125; Set&lt;String&gt; wordSet = new HashSet&lt;&gt;(); int maxLen = 0; for (String word: wordDict) &#123; wordSet.add(word); maxLen = Math.max(maxLen, word.length()); &#125; boolean[] dp = new boolean [s.length() + 1]; for (int i = 1; i &lt;= s.length(); i++) &#123; for (int j = i - 1; j &gt;= 0 &amp;&amp; i - j &lt;= maxLen; j--) &#123; if (dp[j] &amp;&amp; wordSet.contains(s.substring(j, i))) &#123; dp[i] = true; break; &#125; &#125; &#125; return dp[s.length()]; &#125;&#125; 98. validate-binary-search-tree 验证二叉树是否是BST。 递归检查左节点，然后当前节点与prev比较大小保证从小到达，然后更新prev再潜入右边。 或者用Stack迭代，中序遍历。 或者分而治之，给定节点的范围，判断当前节点是否符合，然后更新两侧的范围再潜入下去。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Apple &#123; // 一直往左边潜下去，找到第一个元素，然后设置prev private TreeNode prev1 = null; private boolean validateBST1(TreeNode root) &#123; if (root == null) &#123; return true; &#125; if (!validateBST1(root.left)) &#123; return false; &#125; if (prev1 != null &amp;&amp; prev1.val &gt;= root.val) &#123; return false; &#125; prev1 = root; return validateBST1(root.right); &#125; private boolean validateBST2(TreeNode root) &#123; if (root == null) &#123; return true; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode prev = null; while (root != null || !stack.isEmpty()) &#123; while (root != null) &#123; stack.push(root); root = root.left; &#125; root = stack.pop(); if (prev != null &amp;&amp; prev.val &gt;= root.val) &#123; return false; &#125; prev = root; root = root.right; &#125; return true; &#125; private boolean validateBST3(TreeNode root) &#123; return dvcq(root, Long.MIN_VALUE, Long.MAX_VALUE); &#125; private boolean dvcq(TreeNode root, long min, long max) &#123; if (root == null) &#123; return true; &#125; if (root.val &lt;= min || root.val &gt;= max) &#123; return false; &#125; return dvcq(root.left, min, Math.min(root.val, max)) &amp;&amp; dvcq(root.right, Math.max(root.val, min), max); &#125;&#125;]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>algorithm</tag>
        <tag>interview</tag>
        <tag>apple</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[覃超视频课]]></title>
    <url>%2F2017%2F10%2F26%2Fqin_chao_algorithm_note%2F</url>
    <content type="text"><![CDATA[迎难而上，祝我好运。 Live 2Big-O Big-O: asymptotic behavior of a function，渐近线逼近描述快慢。 非正式定义：忽略lower-order items. O(1): 不根据输入值规模变化。 O(logN): O(N^1/2): O(N): O(NlogN): O(2^N): two to the power of N. 切题四件套 clarification possible solutions: compare（时间和空间复杂度）、optimization（加强）。 coding test cases Live 3Queue and Stack 先入先出v.s.后入先出 例题 lc125 lc20 lc32 Live 6DFS 题中无图／树，心中有图/树。例如字符串最少多少次变换后到达另一个字符串其实就是最短路径问题。 基于状态迁移的一种遍历；为了判重需要二维布尔数组/Set标记是否访问。 吞吐使用Stack。BFS 与DFS类似，只是吞吐变成了Queue. 注意在graph中也需要一个visited数组来保证每次都是首次访问。例题 merge two sorted lists; lc23 merge k sorted lists; lc239 sliding window max lc480 sliding window median Live 7DFS/BFS 例题 lc22 generate parentheses lc515 largest in BT row lc102 level traversal Live 8Dyanamic Programming 递推（从前往后推导，而不能仅仅理解为递归里加个cache） 状态的定义（状态实在定义不了的话，就考虑是否可以增加一个维度） 最优子结构（实现getOptimizedState） 状态转移方程DP与分治法区别 适合于动态规划求解的问题，经分解后的字问题往往不是相互独立的。下一个阶段子问题的求解需要建立在上一阶段解的基础之上。三大属性 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，则该问题具有最优子结构。 无后效性：某阶段的状态一旦确定，就不受后续状态/决策的影响，不会出现回溯。 有重叠字问题：子问题之间不独立，一个子问题可能在后续阶段决策中被多次用到。例题 lc300：状态就是以当前元素为结尾的子序列长度，只要比前面任意一个元素大就可以从该元素转移过来。 lc64：可以BFS/DFS上下左右搞一波，也可以DP。 Live 9DP例题 lc70：有很多follow-up.如果可以走1…k步，就需要不断累加dp[i - 1]...dp[i - k]。如果限制「上一步走了x，这一步就不能走x」，则需要增加一个维度来保存该处走的是多少步到达的；如果限制「上一步走x、上上步走y，这一步不能走x或y」，就再增加一个维度。 lc91：DP在字符串处理中经常用到，状态就是当前长度为止有多少种decode方式。 股票系列题：]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[孤狗]]></title>
    <url>%2F2017%2F10%2F21%2Fgoogle%2F</url>
    <content type="text"><![CDATA[迎难而上，祝我好运。 10. regular-expression-matching 输入两个字符串，写个支持.和*的正则表达式判断的method。例如s = &quot;ab&quot;, p = &quot;a*&quot;, 为True。 目标字符串s和正则字符串p之间相互比较，就需要维护一个boolean的二维数组dp[i][j]，表示s[0~i-1]与p[0~j-1]是否匹配。1234567891011121314151617181920212223242526272829303132class Solution &#123; public boolean isMatch(String s, String p) &#123; if (s == null || p == null || s.equals(p)) &#123; return true; &#125; char[] sChar = s.toCharArray(), pChar = p.toCharArray(); int m = sChar.length, n = pChar.length; boolean[][] dp = new boolean [m + 1][n + 1]; // initial the dp states dp[0][0] = true; for (int j = 2; j &lt;= n; j++) &#123; dp[0][j] = pChar[j - 1] == '*' &amp;&amp; dp[0][j - 2]; &#125; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (pChar[j - 1] == '*') &#123; // check if ignoring curr pattern // OR (the char is matched AND ignoring curr pattern) dp[i][j] = (dp[i][j - 2]) // 不取pattern || ((sChar[i - 1] == pChar[j - 2] || pChar[j - 2] == '.') &amp;&amp; dp[i - 1][j]); &#125; else &#123; // check if char is matched for curr pattern dp[i][j] = dp[i - 1][j - 1] &amp;&amp; (sChar[i - 1] == pChar[j - 1] || pChar[j - 1] == '.'); &#125; &#125; &#125; return dp[m][n]; &#125;&#125; 36. valid-sudoku 给一个二维char数组，里面是一个未完成的数独9x9棋盘，要求每一行、每一列、每个3x3方块中数字1-9有且仅有出现一次。判断这个棋盘是否符合数独规则，返回布尔值。 方法一：直接双重循环遍历，注意可以利用index的变换同时判断行、列和box的情况 123456789101112131415161718192021222324public boolean isValidSudoku(char[][] board) &#123; if (board == null || board.length == 0 || board[0].length == 0) &#123; return false; &#125; for (int i = 0; i &lt; board.length; i++) &#123; Set&lt;Character&gt; rowSet = new HashSet&lt;&gt;(); Set&lt;Character&gt; colSet = new HashSet&lt;&gt;(); Set&lt;Character&gt; boxSet = new HashSet&lt;&gt;(); int rowIndex = 3 * (i / 3), colIndex = 3 * (i % 3); for (int j = 0; j &lt; board[0].length; j++) &#123; if (board[i][j] != '.' &amp;&amp; !rowSet.add(board[i][j])) &#123; return false; &#125; if (board[j][i] != '.' &amp;&amp; !colSet.add(board[j][i])) &#123; return false; &#125; if (board[rowIndex + j / 3][colIndex + j % 3] != '.' &amp;&amp; !boxSet.add(board[rowIndex + j / 3][colIndex + j % 3])) &#123; return false; &#125; &#125; &#125; return true;&#125; 方法二：利用String encoding，直接将每个数字出现的行、列、box情况encode成String存入set。 123456789101112131415161718public boolean isValidSudoku(char[][] board) &#123; if (board == null || board.length == 0 || board[0].length == 0) &#123; return false; &#125; Set&lt;String&gt; set = new HashSet&lt;&gt;(); for (int i = 0; i &lt; board.length; i++) &#123; for (int j = 0; j &lt; board[0].length; j++) &#123; if (board[i][j] != '.') &#123; if (!set.add(board[i][j] + " in row " + i) || !set.add(board[i][j] + " in col " + j) || !set.add(board[i][j] + " in block " + (i / 3) + '-' + (j / 3))) &#123; return false; &#125; &#125; &#125; &#125; return true;&#125; 37. sudoku-solver 给一个二位char数组，里面是一个未完成的数独9x9棋盘，要求每一行、每一列、每个3x3方块中数字1-9有且仅有出现一次。解出数独，解有且仅有一种，直接在原二维数组中将.改为数字的char。 暴力dfs，确定一个位置后就进入下一层DFS去判断。时间复杂度为O(9^m)，m为可填的空位数。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950final String inRow = " in row ";final String inCol = " in col ";final String inBlk = " in blk ";public void solveSudoku(char[][] board) &#123; if (board == null || board.length != 9 || board[0].length != 9) &#123; return; &#125; Set&lt;String&gt; set = new HashSet&lt;&gt;(); for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; if (board[i][j] != '.') &#123; set.add(board[i][j] + inRow + i); set.add(board[i][j] + inCol + j); set.add(board[i][j] + inBlk + i/3 + "-" + j/3); &#125; &#125; &#125; dfs(board, set);&#125;private boolean dfs(char[][] board, Set&lt;String&gt; set) &#123; for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; if (board[i][j] == '.') &#123; for (int c = 0; c &lt; 9; c++) &#123; char temp = (char)(c + '1'); String row = temp + inRow + i; String col = temp + inCol + j; String blk = temp + inBlk + i/3 + "-" + j/3; if (!set.contains(row) &amp;&amp; !set.contains(col) &amp;&amp; !set.contains(blk)) &#123; set.add(row); set.add(col); set.add(blk); board[i][j] = temp; if (dfs(board, set)) &#123; return true; &#125; else &#123; set.remove(row); set.remove(col); set.remove(blk); board[i][j] = '.'; &#125; &#125; &#125; return false; &#125; &#125; &#125; return true;&#125; 41. first-missing-positive 给一个乱序整数数组，要求返回所缺正整数中的最小值。要求constant space，O(n).例如[3,4,-1,1]，返回2. 尝试将在合理范围内的正数[1, nums.length]放入对应的位置，即与它的值对应的索引进行swap，注意执行swap之前需要判断该对应处的元素是否已经处在正确的位置，已经是正确位置就不能swap。最后从头遍历一波，第一个放错位置的即为所求。123456789101112131415161718192021222324252627public int firstMissingPositive(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 1; &#125; int i = 0; while (i &lt; nums.length) &#123; if (nums[i] == i + 1 || nums[i] &lt;= 0 || nums[i] &gt; nums.length) &#123; i++; &#125; else if (nums[nums[i] - 1] != nums[i]) &#123; // warning: not nums[i] != i + 1 // critical: avoid re-overwriting that correct spot swap(nums, i, nums[i] - 1); // i is curr index, nums[i] - 1 is where it should be &#125; else &#123; i++; &#125; &#125; i = 0; while (i &lt; nums.length &amp;&amp; nums[i] == i + 1) &#123; i++; &#125; return i + 1;&#125;private void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp;&#125; 42. trapping-rain-water 给一个int数组，其中包含每个索引处墙的高度。求装满水时的横截面的积水的面积。 利用双指针，left向后更新maxLeft，right往前更新maxRight。每次在left处和right处的高度中取较小值与maxLeft和maxRight进行比较，如果是凹的就直接累加高度差即可。12345678910111213141516171819202122232425public int trap(int[] height) &#123; if (height == null || height.length == 0) &#123; return 0; &#125; int area = 0, maxLeft = 0, maxRight = 0; int left = 0, right = height.length - 1; while (left &lt;= right) &#123; if (height[left] &lt;= height[right]) &#123; // curr value less than some right value if (maxLeft &lt;= height[left]) &#123; maxLeft = height[left]; &#125; else &#123; // curr value is also less than left value area += maxLeft - height[left]; // means it is concave &#125; left++; &#125; else &#123; if (maxRight &lt;= height[right]) &#123; maxRight = height[right]; &#125; else &#123; area += maxRight - height[right]; &#125; right--; &#125; &#125; return area;&#125; 43. multiply-strings 给两个字符串形式的int，模拟乘法求他们的积，返回字符串。 观察index的关系，num1的第i个数字乘以num2的第j个数字得到的两位数将出现在结果数的第i + j和第i + j + 1位。因此就从最低位开始，双重循环相乘，不断更新结果数组即可。注意数组中保存的是一位数，有进位需要存到前一个位置。12345678910111213141516171819202122232425262728293031public String multiply(String num1, String num2) &#123; if (num1 == null || num2 == null || num1.length() == 0 || num2.length() == 0) &#123; return ""; &#125; int m = num1.length(), n = num2.length(); int[] result = new int [m + n]; char[] cnum1 = num1.toCharArray(), cnum2 = num2.toCharArray(); // from least significant bit for (int i = m - 1; i &gt;= 0; i--) &#123; for (int j = n - 1; j &gt;= 0; j--) &#123; int mult = (cnum1[i] - '0') * (cnum2[j] - '0'); int first = i + j, second = i + j + 1; int sum = mult + result[second]; // add carry from prev steps result[first] += sum / 10; // accumulate result[second] = sum % 10; // overwrite &#125; &#125; StringBuilder sb = new StringBuilder(); int i = 0; // find the first non-zero item while (i &lt; result.length &amp;&amp; sb.length() == 0 &amp;&amp; result[i] == 0) &#123; i++; &#125; while (i &lt; result.length) &#123; sb.append(result[i++]); &#125; return sb.length() == 0? "0": sb.toString();&#125; 44. wildcard-matching 和前面的regular-expression-matching很像，但这里用?代表任意一个字符、用*代表任意长度的任意字符而不依赖它前面的字符（而且不只能匹配单一个字符，直接匹配任意长度的任意字符组合）。总的来说比上一题简单，要讨论的情况少了。 维护一个二维boolean数组，dp[i][j]表示s[0~i-1]和p[0~j-1]是否匹配。初始化方面，对于空的p，dp[i][0]仍是除dp[0][0]外全部false，不可能用空的p去匹配非空的s；对于空的s，dp[0][j]就要看当前是否是&#39;*&#39;且考虑dp[0][j-1]。接着双重循环更新dp-&gt; 若当前字符p[j-1]是&#39;*&#39;，则考虑取p的*但不匹配s当前字符时，s[0~i-1]和p[0~j-2]的匹配情况，即dp[i][j-1]；或将&#39;*&#39;假设为s[i-1]那个字符，看看s[0~i-2]与p[0~i-1]的匹配情况，即dp[i-1][j]；或者不取*也不匹配s当前字符，s[0~i-2]和p[0~j-2]的匹配情况，即dp[i-1][j-1].-&gt; 若当前字符p[j-1]不是&#39;*&#39;，就直接看s[i-1]和p[j-1]的匹配情况再结合dp[i-1][j-1]了。除了DP，这个题目似乎还可以用贪心给两个字符串分别用一个指针一直向后挪。1234567891011121314151617181920212223242526272829303132public boolean isMatch(String s, String p) &#123; if (s == null || p == null || s.equals(p)) &#123; return true; &#125; int m = s.length(), n = p.length(); char[] sChar = s.toCharArray(), pChar = p.toCharArray(); boolean[][] dp = new boolean [m + 1][n + 1]; dp[0][0] = true; // "" fits "" for (int j = 1; j &lt;= n; j++) &#123; // only "x*" can fit "" if (pChar[j - 1] == '*') &#123; dp[0][j] = dp[0][j - 1]; &#125; else &#123; dp[0][j] = false; &#125; &#125; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (pChar[j - 1] == '*') &#123; // don't take * or view * as one char or just // get rid of the char in sChar dp[i][j] = dp[i][j - 1] || dp[i - 1][j] || dp[i - 1][j - 1]; &#125; else &#123; if (pChar[j - 1] == sChar[i - 1] || pChar[j - 1] == '?') &#123; dp[i][j] = dp[i - 1][j - 1]; &#125; else &#123; dp[i][j] = false; &#125; &#125; &#125; &#125; return dp[m][n];&#125; 56. merge-intervals 给一个Interval类的list，将重叠部分进行合并，返回合并之后的list。 方法一：使用自定义排序，按照start再按照end排序，然后入栈，每次与栈顶比较。 123456789101112131415161718192021222324public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; if (intervals == null) &#123; return new ArrayList&lt;Interval&gt;(); &#125; Collections.sort(intervals, (a, b) -&gt; a.start != b.start ？ a.start - b.start : a.end - b.end; ); Stack&lt;Interval&gt; stack = new Stack&lt;&gt;(); for (Interval itv: intervals) &#123; if (stack.isEmpty()) &#123; stack.push(itv); &#125; else &#123; Interval curr = stack.peek(); if (itv.start &gt; curr.end) &#123; stack.push(itv); &#125; else &#123; stack.peek().end = Math.max(itv.end, curr.end); &#125; &#125; &#125; // directly get List from stack with constructor return new ArrayList&lt;Interval&gt;(stack); &#125; 方法二：将左、右boundary分别排序，然后快慢指针遍历。当left[fast + 1] &gt; right[fast]，说明slow~fast可以组成一个独立的interval，存入list后将慢指针放到fast + 1即可。 1234567891011121314151617181920212223242526public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; List&lt;Interval&gt; ans = new ArrayList&lt;Interval&gt;(); if (intervals == null) &#123; return ans; &#125; int len = intervals.size(); int[] left = new int [len]; // all left boundary int[] right = new int [len]; // all right boundary for (int i = 0; i &lt; len; i++) &#123; left[i] = intervals.get(i).start; right[i] = intervals.get(i).end; &#125; Arrays.sort(left); Arrays.sort(right); // fast will select right bound and fast+1 is the candidate for next left bound // when candidate is valid, store curr interval (slow, fast) and move slow to candidate // for next left bound for (int fast = 0, slow = 0; fast &lt; len; fast++) &#123; if (fast == len - 1 || left[fast + 1] &gt; right[fast]) &#123; ans.add(new Interval(left[slow], right[fast])); slow = fast + 1; &#125; &#125; return ans;&#125; 59. spiral-matrix-ii 给一个整数n，生成一个n*n的二维数组方阵，使得螺旋式遍历的结果为1,2,3,…,n^2。 直接用循环搞。123456789101112131415161718192021222324252627282930313233343536373839404142public int[][] generateMatrix(int n) &#123; // Declaration int[][] matrix = new int[n][n]; // Edge Case if (n == 0) &#123; return matrix; &#125; // Normal Case int rowStart = 0; int rowEnd = n - 1; int colStart = 0; int colEnd = n - 1; int num = 1; //change while (rowStart &lt;= rowEnd &amp;&amp; colStart &lt;= colEnd) &#123; for (int i = colStart; i &lt;= colEnd; i++) &#123; matrix[rowStart][i] = num++; //change &#125; rowStart++; for (int i = rowStart; i &lt;= rowEnd; i++) &#123; matrix[i][colEnd] = num++; //change &#125; colEnd--; for (int i = colEnd; i &gt;= colStart; i--) &#123; if (rowStart &lt;= rowEnd) matrix[rowEnd][i] = num++; //change &#125; rowEnd--; for (int i = rowEnd; i &gt;= rowStart; i--) &#123; if (colStart &lt;= colEnd) matrix[i][colStart] = num++; //change &#125; colStart++; &#125; return matrix;&#125; 72. edit-distance 给两个字符串word1, word2，求使用addition, replacement, removement三种操作的情况下最少多少步可以从word1转换成word2。 dp[i][j]表示当前长度i的子字符串1转换成长度j的子字符串2最少需要的操作数。初始条件显然是dp[0][x] = dp[x][0] = x。对于任意一个dp[i][j]，需要由上、左上、左三个方格的计算结果决定，往上dp[i-1][j]表示一个deletion，往左dp[i][j-1]表示一个addition，左上dp[i-1][j-1]表示一个replacement。每次选取三者中最小的，加上1就是当前的最小操作数了。12345678910111213141516171819202122232425262728public int minDistance(String word1, String word2) &#123; if (word1 == null || word2 == null) &#123; return 0; &#125; int len1 = word1.length(), len2 = word2.length(); int[][] dp = new int [len1 + 1][len2 + s1]; for (int i = 0; i &lt;= len1; i++) &#123; for (int j = 0; j &lt;= len2; j++) &#123; if (i == 0) &#123; dp[i][j] = j; &#125; else if (j == 0) &#123; dp[i][j] = i; &#125; else &#123; // s1取i-1、s2取j-1个字符的情况，然后s1和s2都取，不需要增加操作数 if (word1.charAt(i - 1) == word2.charAt(j - 1)) &#123; dp[i][j] = dp[i - 1][j - 1]; &#125; else &#123; // left: s1取i、s2取j-1个字符的操作数，现在相当于需要往s1中加s2对应位置的字符才能匹配上 // up: s1取i-1、s2取j个字符的操作数，相当于要从s1中删除字符才能匹配上 // left-up: s1取i-1、s2取j-1个字符的操作数，现在相当于要进行替换才能匹配上 int left = dp[i][j - 1], up = dp[i - 1][j], upLeft = dp[i - 1][j - 1]; dp[i][j] = Math.min(Math.min(left, up), upLeft) + 1; &#125; &#125; &#125; &#125; return dp[len1][len2];&#125; 91. decode-ways 给一个纯数字的字符串，看有多少中方式解析成对应的字母A-Z。如12可解析为AB或L两种，返回2。 联想到“跳楼梯的方式”那题，每次可以选择1位数或者2位数，dp[i]表示取i个字符总共有多少decode的方式，那么当前的方式数就取决于前一位或者前两位的方式数。注意如果取两位digit，需要判断是否在10~26范围之内。1234567891011121314151617181920public int numDecodings(String s) &#123; if (s == null || s.length() == 0) &#123; return 0; &#125; int n = s.length(); int[] dp = new int[ n+ 1]; dp[0] = 1; dp[1] = s.charAt(0) != '0' ? 1 : 0; for (int i = 2; i &lt;= n; i++) &#123; int first = Integer.valueOf(s.substring(i - 1, i)); int second = Integer.valueOf(s.substring(i - 2, i)); if (first &gt;= 1 &amp;&amp; first &lt;= 9) &#123; dp[i] += dp[i - 1]; &#125; if (second &gt;= 10 &amp;&amp; second &lt;= 26) &#123; dp[i] += dp[i - 2]; &#125; &#125; return dp[n];&#125; 95. unique-binary-search-trees-ii 只给一个整数n表示二分查找树的节点数，返回所有结构不同的树。而上一问（96）则只是输出不同树的个数，只是个小DP。 方法一：DP。dp[i]表示节点数为i的时候后所有可能的unique BST根节点。 123456789101112131415161718192021222324252627282930313233343536public List&lt;TreeNode&gt; generateTrees(int n) &#123; List&lt;TreeNode&gt;[] dp = new List[n + 1]; dp[0] = new ArrayList&lt;TreeNode&gt;(); if (n &lt; 1) &#123; return dp[0]; &#125; dp[0].add(null); // 空BST // BST: left children all smaller, right all larger. // each time fix the root, take prev as left subtree, and prev with offset as right subtree. // 固定跟节点，左子树节点数从0到n for (int nodeNum = 1; nodeNum &lt;= n; nodeNum++) &#123; dp[nodeNum] = new ArrayList&lt;TreeNode&gt;(); for (int leftNum = 0; leftNum &lt; nodeNum; leftNum++) &#123; for (TreeNode leftNode: dp[leftNum]) &#123; for (TreeNode rightNode: dp[nodeNum - leftNum - 1]) &#123; TreeNode curr = new TreeNode(leftNum + 1); curr.left = leftNode; curr.right = addOffset(rightNode, leftNum + 1); dp[nodeNum].add(curr); &#125; &#125; &#125; &#125; return dp[n];&#125;// its kinda tricky to come up with this offsetprivate TreeNode addOffset(TreeNode node, int offset) &#123; if (node == null) &#123; return null; &#125; TreeNode newNode = new TreeNode(node.val + offset); newNode.left = addOffset(node.left, offset); newNode.right = addOffset(node.right, offset); return newNode;&#125; 方法二：分治法，分别build左右两边的子树。 123456789101112131415161718192021222324252627public List&lt;TreeNode&gt; generateTrees(int n) &#123; if (n &lt; 1) &#123; return new ArrayList&lt;TreeNode&gt;(); &#125; return generate(1, n);&#125;private List&lt;TreeNode&gt; generate(int start, int end) &#123; List&lt;TreeNode&gt; result = new ArrayList&lt;&gt;(); if (start &gt; end) &#123; // recursion end condition result.add(null); return result; &#125; // take i as root val for (int i = start; i &lt;= end; i++) &#123; List&lt;TreeNode&gt; left = generate(start, i - 1); // generate all possible left subtree List&lt;TreeNode&gt; right = generate(i + 1, end); // gennerate all possible right subtree for (TreeNode l: left) &#123; for (TreeNode r: right) &#123; TreeNode node = new TreeNode(i); // set root val node.left = l; node.right = r; result.add(node); &#125; &#125; &#125; return result;&#125; OA: Email地址处理 给String数组包含email地址，如name@domain，其中name需要将(1)dots(‘.’) between some characters去除 (2)如果有’+’，’+’和后面的全去除。将处理完的email地址归类，统计每个email出现个数，返回里面&gt;1个email兄弟的个数。12345678910111213141516171819202122232425public int getEmailCount(String[] emails) &#123; if (emails == null || emails.length == 0) &#123; return 0; &#125; Map&lt;String, Set&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); int count = 0; for (String email : emails) &#123; int atIndex = email.indexOf("@"); if (atIndex == -1) &#123; continue; &#125; String simplifiedEmail = simplify(email.substring(0, atIndex)) + email.substring(atIndex); map.putIfAbsent(simplifiedEmail, new HashSet&lt;String&gt;()); map.get(simplifiedEmail).add(email); &#125; for (Map.Entry&lt;String, Set&lt;String&gt;&gt; e : map.entrySet()) &#123; if (e.getValue().size() &gt; 1) &#123; count++; &#125; &#125; return count;&#125;private String simplify(String local) &#123; return local.replaceAll("(?&lt;=[a-zA-Z]+)\\.+(?=[a-zA-Z]+)|(\\+.*)", "");&#125; OA: 两个篮子取水果 lc 159变种。只有两个篮子可以放水果，每个篮子只能放一样水果，但可以放无数个相同的水果。从任意一个位置开始往右取，求最多取多少水果。 滑动窗口。 OA: 上一个最接近时间 类似于lc 681. 给一个时间string如hh:mm，求前一个最近的时间，可以重复使用已有的数字。 将所有出现过的数字存入TreeSet，从最低位开始尝试将当前数字替换成比他小的最大的数，若存在这样的数就是previou closest time了，若没有这样的数则需要替换成最大值，注意需要validate。1234567891011121314151617181920212223242526272829303132333435363738public static String prevClosestTime(String time) &#123; if (time == null || time.length() != 5) &#123; return null; &#125; TreeSet&lt;Integer&gt; digitSet = new TreeSet&lt;&gt;(); char maxChar = '0'; for (char c : time.toCharArray()) &#123; if (c != ':') &#123; digitSet.add(c - '0'); maxChar = (char) Math.max(maxChar, c); &#125; &#125; char[] ans = time.toCharArray(); for (int i = 4; i &gt;= 0; i--) &#123; if (i != 2) &#123; int currDigit = ans[i] - '0'; Integer temp = digitSet.lower(currDigit); if (temp != null) &#123; ans[i] = (char) (temp + '0'); return String.valueOf(ans); &#125; else &#123; updateDigitToMax(ans, i, maxChar, digitSet); &#125; &#125; &#125; return String.valueOf(ans);&#125;private static void updateDigitToMax(char[] ans, int i, char maxChar, TreeSet&lt;Integer&gt; digitSet) &#123; if (i == 3 &amp;&amp; maxChar &gt; '5') &#123; ans[i] = (char) (digitSet.floor(5) + '0'); &#125; else if (i == 1 &amp;&amp; ans[i - 1] == '2' &amp;&amp; maxChar &gt; '3') &#123; ans[i] = (char) (digitSet.floor(3) + '0'); &#125; else if (i == 0 &amp;&amp; maxChar &gt; '2') &#123; ans[i] = (char) (digitSet.floor(2) + '0'); &#125; else &#123; ans[i] = maxChar; &#125;&#125; OA: 开花时间 给一个数组，index表示开花时间，element表示开花的位置，第i天arr[i]位置的花会开，为了维持M个group，问最晚的天数k。 考虑逆向处理，这样就可以保证先找到是最晚天数。在最后一天所有的花都开了，使用TreeSet存放没有开的花的index，往前找最大的天数、往后找最小的天数，若前后都间隔了&gt;= k，说明前后都满足连续&gt;= k朵花开放的条件，这样clusterCount++。但是若当前没有开导致前后的小于k，就需要减少clusterCount。当clusterCount == m时就是最晚的、有m个至少k朵花开放的天数。1234567891011121314151617181920212223242526272829public static int getDay(int[] flowers, int k, int m) &#123; if (flowers == null || flowers.length == 0) &#123; return 0; &#125; TreeSet&lt;Integer&gt; posSet = new TreeSet&lt;&gt;(); int count = 1; for (int day = flowers.length - 1; day &gt;= 0; day--) &#123; Integer prevPos = posSet.lower(flowers[day]); if (prevPos == null) &#123; prevPos = 0; &#125; Integer nextPos = posSet.higher(flowers[day]); if (nextPos == null) &#123; nextPos = flowers.length + 1; &#125; int prevBloomLen = flowers[day] - prevPos - 1; int nextBloomLen = nextPos - flowers[day] - 1; if (prevBloomLen &gt;= k &amp;&amp; nextBloomLen &gt;= k) &#123; count++; &#125; else if (prevBloomLen &lt; k &amp;&amp; nextBloomLen &lt; k) &#123; count--; &#125; if (count &gt;= m) &#123; return day; &#125; posSet.add(flowers[day]); &#125; return -1;&#125; 以下是实习面经 求有序数组的平方数 给一个有序数组，求其中各项平方后的结果并排好序。 方法一：双指针，一个从0开始往后，一个从最后一个元素往前，比较大小然后从后往前地存入结果数组。O(N)。 方法二：从前往后，找到第一个非负数开始，往前后两个方向merge，搜索部分复杂度O(N)，merge部分复杂度O(N)。 方法三：既然是有序，那么查找的时候就用二分查找，找『0插入的地方』，然后往两边merge。搜索部分复杂度O(logN)，merge部分复杂度O(N)。再来复习一遍二分查找找第一个出现／插入的位置： 12345678910111213private int binarySearch(int[] nums, int target) &#123; int start = -1, end = nums.length; while (end - start &gt; 1) &#123; int mid = start + (end - start) / 2; // invariant relation: nums[start] &lt; target &lt;= nums[end] if (nums[mid] &gt;= target) &#123; end = mid; &#125; else &#123; start = mid; &#125; &#125; return end;&#125; follow-up：这次是求x ^ 2 + a * x而不单单是平方了。 思路也是类似，找到函数的最小值，往两边merge，这里对称轴出现在-a/2，所以找到这个值之后往两边merge即可。 String字符交换 给两个字符，问能否交换str1的两个字符得到str2. 需要考虑两个字符串本身是否相等？长度小于2？ 方法一：从前往后遍历两个数组，把不同的位置拼到List里，然后判断不同的是否恰好两位且可以互换。 1234567891011121314151617181920private boolean convert(String s1, String s2) &#123; if (s1.length() != s2.length()) &#123; return false; &#125; List&lt;Integer&gt; arr = new ArrayList&lt;&gt;(); char[] sChar1 = s1.toCharArray(); char[] sChar2 = s2.toCharArray(); for (int i = 0; i &lt; sChar1.length; i++) &#123; if (sChar1[i] != sChar2[i]) &#123; arr.add(i); &#125; &#125; if (arr.size() != 2) &#123; return false; &#125; if (sChar1[arr.get(0)] == sChar2[arr.get(1)] &amp;&amp; sChar1[arr.get(1)] == sChar2[arr.get(0)]) &#123; return true; &#125; return false;&#125; 方法二：优化空间，不用额外的List，而是直接用一个变量记录第一个不同的索引，之后再出现不同直接判断就可以了。 123456789101112131415161718192021222324private boolean convert(String s1, String s2) &#123; if (s1.length() != s2.length()) &#123; return false; &#125; char[] sChar1 = s1.toCharArray(); char[] sChar2 = s2.toCharArray(); int index = -1, count = 0; for (int i = 0; i &lt; sChar1.length; i++) &#123; if (sChar1[i] != sChar2[i]) &#123; count++; if (count &gt; 2) &#123; return false; &#125; if (index == -1) &#123; index = i; &#125; else &#123; if (sChar1[index] != sChar2[i] || sChar2[index] != sChar1[i]) &#123; return false; &#125; &#125; &#125; &#125; return true;&#125; 同义词 734 737 给一堆同义词[(“restaurant”, “cafe”), (“ratings”, “reviews”), …]，再给一些queries[(“restaurant ratings”, “cafe reviews”), …]，要求返回每个query里的对应词是否都是synonym。 如果不需要考虑传递性，就直接把字符作为key、对应的所有同义词的set作为value存入map，正反都放一次，比如map.get(&quot;restaurant&quot;).add(&quot;cafe&quot;)), map.get(&quot;restaurant&quot;).add(&quot;cafe&quot;)，这样在query的时候就可以直接调用了。 123456789101112131415161718192021222324252627282930// 维护一个总的map，每个单词作为key，对等的单词塞入它维护的Set中// 有对称性所以需要正反都加public boolean areSentencesSimilar(String[] words1, String[] words2, String[][] pairs) &#123; if (words1 == null || words2 == null || pairs == null || words1.length != words2.length) &#123; return false; &#125; Map&lt;String, Set&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; pairs.length; i++) &#123; if (!map.containsKey(pairs[i][0])) &#123; map.put(pairs[i][0], new HashSet&lt;&gt;()); &#125; if (!map.containsKey(pairs[i][1])) &#123; map.put(pairs[i][1], new HashSet&lt;&gt;()); &#125; map.get(pairs[i][0]).add(pairs[i][1]); // 构建a-&gt;b map.get(pairs[i][1]).add(pairs[i][0]); // 构建b-&gt;a &#125; for (int i = 0; i &lt; words1.length; i++) &#123; if (words1[i].equals(words2[i])) &#123; continue; &#125; if (map.get(words1[i]) == null || !map.get(words1[i]).contains(words2[i])) &#123; return false; &#125; &#125; return true;&#125; 需要考虑是否可以传递，比如a=b, b=c -&gt; a=c?，可能就需要有个并查集找共同老大。或者直接通过DFS遍历所有可达点。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 和前一个版本的区别是这个可以无限传递a=b=c=d...// 还是map维护每个单词等价的单词，但匹配不上的话还得看它的set里所有单词对应的单词是否能匹配到public boolean areSentencesSimilarTwo(String[] words1, String[] words2, String[][] pairs) &#123; if (words1 == null || words2 == null || pairs == null || words1.length != words2.length) &#123; return false; &#125; // 表示每个单词直接相连的同义词 Map&lt;String, Set&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; pairs.length; i++) &#123; if (!map.containsKey(pairs[i][0])) &#123; map.put(pairs[i][0], new HashSet&lt;&gt;()); &#125; if (!map.containsKey(pairs[i][1])) &#123; map.put(pairs[i][1], new HashSet&lt;&gt;()); &#125; map.get(pairs[i][0]).add(pairs[i][1]); // 构建a-&gt;b map.get(pairs[i][1]).add(pairs[i][0]); // 构建b-&gt;a &#125; for (int i = 0; i &lt; words1.length; i++) &#123; if (words1[i].equals(words2[i])) &#123; continue; &#125; if (!map.containsKey(words1[i])) &#123; return false; &#125; if (!dfs(words1[i], words2[i], map, new HashSet&lt;String&gt;())) &#123; return false; &#125; &#125; return true;&#125;private boolean dfs(String start, String end, Map&lt;String, Set&lt;String&gt;&gt; map, Set&lt;String&gt; visited) &#123; if (map.get(start).contains(end)) &#123; // 终止条件：start连接着end return true; &#125; visited.add(start); Set&lt;String&gt; neighbors = map.get(start); if (neighbors == null) &#123; return false; &#125; for (String neighbor : neighbors) &#123; if (!visited.contains(neighbor) &amp;&amp; dfs(neighbor, end, map, visited)) &#123; return true; &#125; &#125; return false;&#125; 或者通过并查集，初始化时每个单词都是自己的root；然后根据同义词关系将前者的老大设为后者。判断句子是否同义时就找两个单词的老大是否相等即可 123456789101112131415161718192021222324252627282930313233343536373839// 并查集。初始化时每个单词都是自己的root；然后根据同义词关系将前者的老大设为后者。// 判断句子是否同义时就找两个单词的老大是否相等即可public boolean areSentencesSimilarTwo(String[] words1, String[] words2, String[][] pairs) &#123; if (words1.length != words2.length) &#123; return false; &#125; Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); for (String[] pair : pairs) &#123; // 开始时每个老大都是自己 map.put(pair[0], pair[0]); map.put(pair[1], pair[1]); &#125; for (String[] pair : pairs) &#123; String par1 = findParent(pair[0], map); String par2 = findParent(pair[1], map); if (!par1.equals(par2)) &#123; map.put(par1, par2); // par1的老大设为par2 &#125; &#125; for (int i = 0; i &lt; words1.length; i++) &#123; if (words1[i].equals(words2[i])) &#123; continue; &#125; if (!map.containsKey(words1[i]) || !map.containsKey(words2[i])) &#123; return false; &#125; String par1 = findParent(words1[i], map); String par2 = findParent(words2[i], map); if (!par1.equals(par2)) &#123; return false; &#125; &#125; return true;&#125;public String findParent(String str, Map&lt;String,String&gt; map)&#123; while (!str.equals(map.get(str))) &#123; // 追溯str的老大 str = map.get(str); &#125; return str;&#125; flip game 293 294 给一个只含有+和-的字符串，两个人每次选择一个++flip成--。 第一问：求下一步所有可能的情况。直接找连续出现的++然后取前面部分的substring拼上--再拼上后续部分即可。 第二问：问先开始的玩家能否保证赢（操作后再也没有++让对方没法再flip）。暴力的方法是从头开始循环找到每个startsWith(&quot;++&quot;)，然后替换成--再递归判断对方能否稳赢。一旦对方没法稳赢，就直接return了。但是复杂度略高。可以用Set或者Map缓存中间结果，避免重复递归。1234567891011121314151617181920212223242526class Solution &#123; // O(n!!) 复杂度。递归找，找到++的时候就替换成--然后递归判断对方能否保证赢，不能就直接返回true了。 public boolean canWin(String s) &#123; if (s == null || s.length() &lt; 2) &#123; return false; &#125; Map&lt;String, Boolean&gt; map = new HashMap&lt;&gt;(); // 存放已经访问过的的String return canWin(s, map); &#125; private boolean canWin(String s, Map&lt;String, Boolean&gt; map) &#123; if (map.containsKey(s)) &#123; return map.get(s); &#125; for (int i = 0; i &lt; s.length(); i++) &#123; if (s.startsWith("++", i)) &#123; String t = s.substring(0, i) + "--" + s.substring(i + 2); if (!canWin(t, map)) &#123; // 轮到对方操作，判断 map.put(s, true); return true; &#125; &#125; &#125; map.put(s, false); // 缓存起来 return false; &#125;&#125; 首个prefix不匹配字符串 给出一个按字典序排好序的字符串数组dictionary，找出其中第一个不是以指定字符串prefix作为前缀的字符串。如[aa, aaa, ax, b, c], aa -&gt; ax 看到“排好序”，“找”，就想到二分查找了。12345678910111213141516class Google &#123; // O(logN)二分查找第一个不符合要求的XD public String firstUnmatch(String[] words, String prefix) &#123; int lo = 0, hi = words.length - 1; while (lo &lt; hi) &#123; int mid = lo + (hi - lo) / 2; if (words[mid].startsWith(prefix)) &#123; lo = mid + 1; &#125; else &#123; hi = mid; &#125; &#125; return lo == words.length || words[lo].startsWith(prefix)? "none": words[lo]; &#125;&#125; flatten iterator 251 给一个二维List，要求模拟一维iterator，用hasNext和next从头到尾遍历。 方法一： 第一版的两个iterator遍历的方法，其实不必要存下整个vec2d。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Vector2D implements Iterator&lt;Integer&gt; &#123; private List&lt;List&lt;Integer&gt;&gt; vec2d; private Iterator&lt;Integer&gt; itCol = null; private Iterator&lt;List&lt;Integer&gt;&gt; itRow = null; public Vector2D(List&lt;List&lt;Integer&gt;&gt; vec2d) &#123; this.vec2d = vec2d; if (vec2d == null || vec2d.size() == 0) &#123; itRow = null; &#125; else &#123; itRow = vec2d.iterator(); itCol = itRow.next().iterator(); &#125; &#125; @Override public Integer next() &#123; if (!itCol.hasNext()) &#123; return null; &#125; Integer ret = itCol.next(); return ret; &#125; @Override public boolean hasNext() &#123; if (itCol == null) &#123; return false; &#125; if (itCol.hasNext()) &#123; return true; &#125; while (itCol != null &amp;&amp; !itCol.hasNext()) &#123; if (itRow != null) &#123; if (!itRow.hasNext()) &#123; return false; &#125; else &#123; while (itRow.hasNext()) &#123; List&lt;Integer&gt; newRow = itRow.next(); itCol = newRow.iterator(); if (itCol.hasNext()) &#123; return true; &#125; &#125; &#125; &#125; else &#123; return false; &#125; &#125; return false; &#125;&#125;/** * Your Vector2D object will be instantiated and called as such: * Vector2D i = new Vector2D(vec2d); * while (i.hasNext()) v[f()] = i.next(); */ 经过简洁：省略了很多条件语句。 1234567891011121314151617181920212223242526public class Vector2D implements Iterator&lt;Integer&gt; &#123; // 只用到两个iterator，一个存第几行，一个存当前行的第几列 Iterator&lt;List&lt;Integer&gt;&gt; itRow; Iterator&lt;Integer&gt; itCol; public Vector2D(List&lt;List&lt;Integer&gt;&gt; vec2d) &#123; itRow = vec2d.iterator(); &#125; @Override public Integer next() &#123; if (itCol.hasNext()) &#123; return itCol.next(); &#125; else &#123; return null; &#125; &#125; @Override public boolean hasNext() &#123; // 当itCol为空或当前行没有next 并且还有后续行的时候 while ((itCol == null || !itCol.hasNext()) &amp;&amp; itRow.hasNext()) &#123; itCol = itRow.next().iterator(); // 持续挪 &#125; return itCol != null &amp;&amp; itCol.hasNext(); // 空或新行行首 &#125;&#125; 判断二叉树是否对称 101 recursive：对称就是在递归判断左子树和右子树是否对称 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; if (root == null) &#123; return true; &#125; return helper(root.left, root.right); &#125; private boolean helper(TreeNode left, TreeNode right) &#123; if (left == null &amp;&amp; right == null) &#123; return true; &#125; if (left == null || right == null) &#123; return false; &#125; if (left.val == right.val) &#123; // 首先保证节点值相等 // 然后判断左-左和右-右 以及 左-右和右-左 return helper(left.left, right.right) &amp;&amp; helper(left.right, right.left); &#125; return false; &#125;&#125; iterative：用Stack吞吐，左先入栈再到右，弹出判断左右是否相等。然后先入左-左再入右-右，然后左-右和右-左（保证对称） 123456789101112131415161718192021222324252627282930class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; if (root == null) &#123; return true; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root.left); stack.push(root.right); while (!stack.isEmpty()) &#123; TreeNode left = stack.pop(); // take two nodes from stack top if (stack.isEmpty()) &#123; return false; // should always have 2 at &#125; TreeNode right = stack.pop(); if (left == null &amp;&amp; right == null) &#123; continue; &#125; if (left == null || right == null || left.val != right.val) &#123; // ensure equal return false; &#125; stack.push(left.left); // push 2 symmetric positions into stack stack.push(right.right); stack.push(left.right); stack.push(right.left); &#125; return true; &#125;&#125; follow-up：判断多叉树是否对称。直觉就是把left、right换成一个List&lt;TreeNode&gt;，判断对称的时候一个从前往后取子节点、另一个从后往前取子节点。 outbound spiral 給一個String 用outbound spiral方式輸出，例如abcd -&gt; cdba，abcde -&gt; cdbae。(其实没太看懂这题啥意思。。。) 双指针，从中间点开始往两边取。123456789class Google &#123; public spiralString(String s) &#123; StringBuilder sb = new StringBuilder(); char[] sChar = s.toCharArray(); int right = sChar.length / 2, left = right - 1; return sb.toString(); &#125;&#125; Longest substirng with k distinct characters 340 给一个字符串和k，求最长子字符串的长度使得其中只含有k个不同的字符。 substring问题-&gt;双指针。O(N)。123456789101112131415161718192021222324252627282930313233class Google &#123; // 双指针，right向前直到多过允许的k个，然后挪left直到恢复到k个 public int longestSubstringK(String s, int k) &#123; if (s == null || s.length() == 0) &#123; return 0; &#125; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); int maxLen = 0, currCharNum = 0, left = 0; char[] sChar = s.toCharArray(); for (int right = 0; right &lt; sChar.length; right++) &#123; if (!map.containsKey(sChar[right])) &#123; currCharNum++; map.put(sChar[right], 1); &#125; else &#123; map.put(sChar[right], map.get(sChar[right]) + 1); &#125; if (currCharNum &gt; k) &#123; while (currCharNum &gt; k &amp;&amp; left &lt; sChar.length) &#123; Integer temp = map.get(sChar[left]); if (temp == 1) &#123; map.remove(sChar[left]); currCharNum--; &#125; else &#123; map.put(sChar[left], temp - 1); &#125; left++; &#125; &#125; maxLen = Math.max(maxLen, right - left + 1); &#125; return maxLen; &#125;&#125; 正则 10 输入两个字符串，写个支持.和*的正则表达式判断的method。 目标字符串s和正则字符串p之间相互比较，就需要维护一个boolean的二维数组dp[i][j]，表示s[0~i-1]与p[0~j-1]是否匹配。1234567891011121314151617181920212223242526272829303132class Solution &#123; public boolean isMatch(String s, String p) &#123; if (s == null || p == null || s.equals(p)) &#123; return true; &#125; char[] sChar = s.toCharArray(), pChar = p.toCharArray(); int m = sChar.length, n = pChar.length; boolean[][] dp = new boolean [m + 1][n + 1]; // initial the dp states dp[0][0] = true; for (int j = 2; j &lt;= n; j++) &#123; dp[0][j] = pChar[j - 1] == '*' &amp;&amp; dp[0][j - 2]; &#125; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (pChar[j - 1] == '*') &#123; // check if ignoring curr pattern // OR (the char is matched AND ignoring curr pattern) dp[i][j] = (dp[i][j - 2]) || ((sChar[i - 1] == pChar[j - 2] || pChar[j - 2] == '.') &amp;&amp; dp[i - 1][j]); &#125; else &#123; // check if char is matched for curr pattern dp[i][j] = dp[i - 1][j - 1] &amp;&amp; (sChar[i - 1] == pChar[j - 1] || pChar[j - 1] == '.'); &#125; &#125; &#125; return dp[m][n]; &#125;&#125; X删除字眼 给一个字符串如aabbaac，给一个forbidden字眼a，返回删除后的字符串bbc，若不存在就返回本身。 O(N)直接用StringBuilder拼接。12345678910111213class Google &#123; // 直接拼接 public void deleteChar(String s, char c) &#123; StringBuilder sb = new StringBuilder(); char[] sChar = s.toCharArray(); for (char temp: sChar) &#123; if (temp != c) &#123; sb.append(temp); &#125; &#125; return sb.toString(); &#125;&#125; 字母矩阵移动组成单词 给一个列数生成由大写字母组成的矩阵，再给一个单词，从左上角开始挪动，求挪动的路径（用&amp;连接). 求路径，用BFS可以保证最短。在point中加入一个path段记录到达该处的路径，一旦找到目标字符就直接把path拼进去。再以该处为起点继续找后续字符（需要清空path）。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class Google &#123; class Point &#123; int row, col; String path; public Point(int row, int col, String path) &#123; this.row = row; this.col = col; this.path = path; &#125; &#125; final private int CHAR_NUM = 26; public String moveWord(int width, String target) &#123; if (target == null || target.length() == 0) &#123; return new ArrayList&lt;String&gt;(); &#125; char[][] table = buildTable(width); int rows = table.length, cols = table[0].length; char[] targetChar = target.toCharArray(); Point curr = new Point(0, 0); StringBuilder sb = new StringBuilder(); boolean first = true; for (int i = 0; i &lt; targetChar.length; i++) &#123; curr = bfs(table, curr, targetChar[i], new boolean[][] visited); if (!first) &#123; sb.append(" &amp; "); &#125; sb.append(curr.path); curr.path = ""; // 重置当前点为起点 first = false; &#125; return sb.toString(); &#125; private Point bfs(char[][] table, Point p, char c, boolean[][] visited, String path, StringBuilder sb) &#123; if (visited[p.row][p.col]) &#123; return null; &#125; Queue&lt;Point&gt; q = new LinkedList&lt;&gt;(); q.add(p); while (!q.isEmpty()) &#123; Point curr = q.poll(); if (table[curr.row][curr.col] == c) &#123; // 找到了 return curr; &#125; visited[curr.row][curr.col] = true; // 标记当前坐标点已访问 if (curr.col &lt; table[0].length - 1 &amp;&amp; !visited[curr.row][curr.col + 1]) &#123; q.add(new Point(curr.row, curr.col + 1, curr.path + "R")); &#125; if (curr.row &lt; table.length - 1 &amp;&amp; !visited[curr.row + 1][curr.col]) &#123; q.add(new Point(curr.row + 1, curr.col, curr.path + "D")); &#125; if (curr.col &gt; 0 &amp;&amp; !visited[curr.row][curr.col - 1]) &#123; q.add(new Point(curr.row, curr.col - 1, curr.path + "L")); &#125; if (curr.row &gt; 0 &amp;&amp; !visited[curr.row - 1][curr.col]) &#123; q.add(new Point(curr.row - 1, curr.col, curr.path + "U")); &#125; &#125; return null; &#125; private char[][] buildTable(int width) &#123; int height = CHAR_NUM / width; if (CHAR_NUM % width &gt; 0) &#123; height++; &#125; char[][] table = new char[height][width]; char c = 'A'; for (int i = 0; i &lt; height; i++) &#123; for (int j = 0; j &lt; width &amp;&amp; c &lt; 'Z'; j++) &#123; table[i][j] = c++; &#125; &#125; return table; &#125;&#125; 43. multiply-strings 解析在此 123456789101112131415161718192021222324252627282930313233class Solution &#123; public String multiply(String num1, String num2) &#123; if (num1 == null || num2 == null || num1.length() == 0 || num2.length() == 0) &#123; return ""; &#125; int m = num1.length(), n = num2.length(); int[] result = new int [m + n]; char[] cnum1 = num1.toCharArray(), cnum2 = num2.toCharArray(); // from least significant bit for (int i = m - 1; i &gt;= 0; i--) &#123; for (int j = n - 1; j &gt;= 0; j--) &#123; int mult = (cnum1[i] - '0') * (cnum2[j] - '0'); int first = i + j, second = i + j + 1; int sum = mult + result[second]; // add carry from prev steps result[first] += sum / 10; // accumulate result[second] = sum % 10; // overwrite &#125; &#125; StringBuilder sb = new StringBuilder(); int i = 0; // find the first non-zero item while (i &lt; result.length &amp;&amp; sb.length() == 0 &amp;&amp; result[i] == 0) &#123; i++; &#125; while (i &lt; result.length) &#123; sb.append(result[i++]); &#125; return sb.length() == 0? "0": sb.toString(); &#125;&#125; 格子中最长连续 562 给一个只有0和1的int二维数组，求横或竖或两个对角方向上最长连续出现1的个数。 方法一：O(N^2)从每个点出发往四个方向分别遍历，求最长长度。 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; // O(N^3)：矩阵遍历每个点是N^2，对每个点在扫四个方向是4N public int longestLine(int[][] M) &#123; if (M == null || M.length == 0 || M[0].length == 0) &#123; return 0; &#125; int longest = 0; for (int i = 0; i &lt; M.length; i++) &#123; for (int j = 0; j &lt; M[0].length; j++) &#123; if (M[i][j] == 1) &#123; longest = Math.max(longest, getLongest(M, i, j)); &#125; &#125; &#125; return longest; &#125; // 右、下、右下、左下 final private int[][] directions = new int[][] &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;1, 1&#125;, &#123;1, -1&#125;&#125;; private int getLongest(int[][] M, int row, int col) &#123; int maxLen = 1; for (int[] direction: directions) &#123; int len = 1; int newRow = row + direction[0]; int newCol = col + direction[1]; // 持续在一个方向上继续走 while (isValidPosition(M, newRow, newCol) &amp;&amp; M[newRow][newCol] == 1) &#123; len++; newRow += direction[0]; newCol += direction[1]; &#125; maxLen = Math.max(maxLen, len); &#125; return maxLen; &#125; private boolean isValidPosition(int[][] M, int row, int col) &#123; return row &gt;= 0 &amp;&amp; col &gt;= 0 &amp;&amp; row &lt; M.length &amp;&amp; col &lt; M[0].length; &#125;&#125; 方法二：类似于DP，记录下四个方向各自的最大长度。参考这个被lz和N皇后问题很像。 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; // O(N^2)时间，O(M+N)空间 public int longestLine(int[][] M) &#123; // validation if (M == null || M.length == 0 || M[0].length == 0) &#123; return 0; &#125; int rows = M.length, cols = M[0].length; int longest = 0; int[] bucketCol = new int [cols]; int[] bucketDiag1 = new int [rows + cols]; int[] bucketDiag2 = new int [rows + cols]; for (int i = 0; i &lt; rows; i++) &#123; int row = 0; // 新行初始化为0 for (int j = 0; j &lt; cols; j++) &#123; if (M[i][j] == 1) &#123; // 当前为1，对应更新bucket row++; bucketCol[j]++; bucketDiag1[j + i]++; bucketDiag2[j - i + M.length]++; longest = Math.max(longest, row); longest = Math.max(longest, bucketCol[j]); longest = Math.max(longest, bucketDiag1[j + i]); longest = Math.max(longest, bucketDiag2[j - i + M.length]); &#125; else &#123; row = 0; bucketCol[j] = 0; bucketDiag1[j + i] = 0; bucketDiag2[j - i + M.length] = 0; &#125; &#125; &#125; return longest; &#125;&#125; 给出一系列字母求相除结果 399 给一系列字符串的倍数关系，给出后续query的结果。 图论。可以抽象成一个双向图，每个字符串都作为节点，然后权重就是两个节点的商。我的做法分三步：遍历一遍形成str到index的映射，然后建立邻接矩阵并把权重填充进去（正反都放，不存在就是0），最后就query的时候就用DFS，遍历当前节点所有能走到的节点看看能否到达终点。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class Solution &#123; public double[] calcEquation(String[][] equations, double[] values, String[][] queries) &#123; if (equations == null || values == null || queries == null || equations.length == 0 || values.length == 0 || queries.length == 0 || equations.length != values.length) &#123; return new double[0]; &#125; double[] ans = new double [queries.length]; // create string to index mapping and get the total # of str int index = 0; Map&lt;String, Integer&gt; str2Index = new HashMap&lt;&gt;(); for (String[] equation: equations) &#123; if (!str2Index.containsKey(equation[0])) &#123; str2Index.put(equation[0], index++); &#125; if (!str2Index.containsKey(equation[1])) &#123; str2Index.put(equation[1], index++); &#125; &#125; // update the values into matrix double[][] matrix = new double[index][index]; for (int i = 0; i &lt; values.length; i++) &#123; int from = str2Index.get(equations[i][0]); int to = str2Index.get(equations[i][1]); matrix[from][to] = values[i]; matrix[to][from] = 1.0 / values[i]; &#125; // query with dfs for (int i = 0; i &lt; queries.length; i++) &#123; if (!str2Index.containsKey(queries[i][0]) || !str2Index.containsKey(queries[i][1])) &#123; ans[i] = -1.0; &#125; else &#123; boolean[] visited = new boolean[index]; int from = str2Index.get(queries[i][0]); int to = str2Index.get(queries[i][1]); if (from == to) &#123; ans[i] = 1.0; &#125; else &#123; //System.out.println("from: " + from + " to " + to); double temp = dfs(matrix, visited, str2Index, from, to); ans[i] = isZero(temp)? -1.0: temp; &#125; &#125; &#125; return ans; &#125; private double dfs(double[][] matrix, boolean[] visited, Map&lt;String, Integer&gt; str2Index, int from, int to) &#123; if (matrix[from][to] &gt; 0) &#123; return matrix[from][to]; &#125; else &#123; visited[from] = true; for (int i = 0; i &lt; matrix.length; i++) &#123; //System.out.println(" from: " + from + " to " + to); if (matrix[from][i] &gt; 0 &amp;&amp; !visited[i]) &#123; double temp = dfs(matrix, visited, str2Index, i, to); if (temp &gt; 0) &#123; return matrix[from][i] * temp; &#125; &#125; &#125; visited[from] = false; return 0.0; &#125; &#125; private boolean isZero(double val) &#123; return Math.abs(val) &lt; 0.00000001; &#125;&#125; 十进制转七进制 可参考405 十进制转二进制就是除+膜。不过需要注意负数除法的时候不能带上最前面都符号位。 推广到div进制。1234567891011121314final private char[] map = &#123;'0', '1', '2', '3','4','5','6','7','8','9','a','b','c','d','e','f'&#125;; public String trans(int num, int div) &#123; if (num == 0) &#123; return "0"; &#125; long longNum = num &amp; 0x00000000ffffffffL; // 不能直接强制转换，不然会保留符号 String hexStr = ""; while (longNum != 0) &#123; // System.out.println(); hexStr = map[(int)(longNum % div)] + hexStr; longNum /= div; &#125; return hexStr; &#125; 九宫格 面巾 给一个只含有数字【1到9】的矩阵，从矩阵中寻找九宫格(3x3的正方形，横着加，竖着加，对角线加都是15)，返回矩阵中这样的九宫格的个数。 遍历所有九宫格的中心点，求对角线x2、行x3、列x3。有个hint是，只有中心点是5的九宫格才有可能符合要求，因此只需要在5处跑一遍3x3的判断即可。 字符串重组 版本一：pattern和str，判断是否match。比如：输入“acg”和“abcdefg”，输出true。但“agc”和“abcdefg”就不对了，因为顺序不同。双指针。 版本二：莉蔻567。不同之处在于不是subsequence而是严格的substring，且顺序不需要关注，因为是后者包含前者的permutation。 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public boolean checkInclusion(String s1, String s2) &#123; if (s1 == null || s2 == null || s1.length() == 0 || s2.length() == 0 ) &#123; return false; &#125; char[] s1Char = s1.toCharArray(); Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); int len1 = s1Char.length; for (int i = 0; i &lt; len1; i++) &#123; // 统计s1中每个字母出现个数，作为producer map.put(s1Char[i], map.getOrDefault(s1Char[i], 0) + 1); &#125; char[] s2Char = s2.toCharArray(); int count = map.size(); int left = 0, right = 0; while (right &lt; s2Char.length) &#123; // 遍历s2作为consumer消耗字符，直到map中所有字符消耗完 if (map.containsKey(s2Char[right])) &#123; map.put(s2Char[right], map.get(s2Char[right]) - 1); if (map.get(s2Char[right]) == 0) &#123; count--; &#125; &#125; while (count == 0) &#123; // 左指针补回来，直到map中出现available的字符 if (right - left + 1 == len1) &#123; return true; &#125; if (map.containsKey(s2Char[left])) &#123; map.put(s2Char[left], map.get(s2Char[left]) + 1); if (map.get(s2Char[left]) &gt; 0) &#123; count++; &#125; &#125; left++; &#125; right++; &#125; return false; &#125;&#125; 与之类似的莉蔻 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; // O(N)双指针。先一波流统计p中各个字符出现的频数，然后consume掉map中的字符直到没有available的 // 此时判断左右指针之间长度是否等于目标的长度，然后挪动左指针重新往map中加回去，直到出现可选字符 public List&lt;Integer&gt; findAnagrams(String s, String p) &#123; List&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;(); if (s == null || p == null || s.length() == 0 || p.length() == 0) &#123; return ans; &#125; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); char[] pChar = p.toCharArray(); int pLen = pChar.length; for (char c: pChar) &#123; map.put(c, map.getOrDefault(c, 0) + 1); &#125; char[] sChar = s.toCharArray(); int count = map.size(); // 还有count个不同的字符可选 int left = 0, right = 0; while (right &lt; sChar.length) &#123; if (map.containsKey(sChar[right])) &#123; map.put(sChar[right], map.get(sChar[right]) - 1); if (map.get(sChar[right]) == 0) &#123; count--; // 可选字符少了一个 &#125; &#125; while (count == 0) &#123; if (right - left + 1 == pLen) &#123; ans.add(left); &#125; if (map.containsKey(sChar[left])) &#123; map.put(sChar[left], map.get(sChar[left]) + 1); if (map.get(sChar[left]) &gt; 0) &#123; count++; // 恢复可选字符 &#125; &#125; left++; &#125; right++; &#125; return ans; &#125;&#125; 最长无重复字符的子串长度、 最长至多两个不同字符的字串长度、 最长至多k个不同字符的字串长度. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public int lengthOfLongestSubstring(String s) &#123; if (s == null || s.length() == 0) &#123; return 0; &#125; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); char[] sChar = s.toCharArray(); int left = 0, right = 0, ans = 1; while (right &lt; sChar.length) &#123; if (!map.containsKey(sChar[right])) &#123; // 首次出现 map.put(sChar[right], right); // 存出现的索引 &#125; else &#123; ans = Math.max(ans, right - left); // 出现重复字符c，更新长度 left = Math.max(map.get(sChar[right]) + 1, left); // 跳到c上次出现索引的下一位或不动 map.put(sChar[right], right); // 更新c的"最后一次出现索引" &#125; right++; &#125; return Math.max(ans, right - left); // 可能需要看最后一段&#125;// 双指针，右指针负责加入新的字符，一旦和当前范围内除了最后出现字符的另一个字符不同，说明超过了2，则需要更新到最后出现字符首次出现处。public int lengthOfLongestSubstringTwoDistinct(String s) &#123; if (s == null || s.length() == 0) &#123; return 0; &#125; int ans = 1; int firstIndex = 0, lastIndex = -1; char[] sChar = s.toCharArray(); for (int i = 1; i &lt; sChar.length; i++) &#123; if (sChar[i] == sChar[i - 1]) &#123; // 连续相同的，直接往后挪 continue; &#125; if (lastIndex &gt; -1 &amp;&amp; sChar[i] != sChar[lastIndex]) &#123; ans = Math.max(ans, i - firstIndex); firstIndex = lastIndex + 1; &#125; lastIndex = i - 1; // sChar[i]与前一个字符不同，则前一个字符的最后一个出现位置是i - 1 &#125; return Math.max(sChar.length - firstIndex, ans);&#125;// 双指针，right向前直到多过允许的k个，然后挪left直到恢复到k个public int lengthOfLongestSubstringKDistinct(String s, int k) &#123; if (s == null || s.length() == 0) &#123; return 0; &#125; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); int maxLen = 0, currCharNum = 0, left = 0; char[] sChar = s.toCharArray(); for (int right = 0; right &lt; sChar.length; right++) &#123; if (!map.containsKey(sChar[right])) &#123; currCharNum++; map.put(sChar[right], 1); &#125; else &#123; map.put(sChar[right], map.get(sChar[right]) + 1); &#125; if (currCharNum &gt; k) &#123; while (currCharNum &gt; k &amp;&amp; left &lt; sChar.length) &#123; Integer temp = map.get(sChar[left]); if (temp == 1) &#123; map.remove(sChar[left]); currCharNum--; &#125; else &#123; map.put(sChar[left], temp - 1); &#125; left++; &#125; &#125; maxLen = Math.max(maxLen, right - left + 1); &#125; return maxLen;&#125; 莉蔻还有类似的双指针破双字符串的题，如 76最小长度的substring ，即给一个t，求s中最短的字符串使得t中出现的字母都包含在该子串中。 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public String minWindow(String s, String t) &#123; if (s == null || t == null) &#123; return ""; &#125; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); char[] tChar = t.toCharArray(); for (char c: tChar) &#123; // 统计每个字母出现的频数 map.put(c, map.getOrDefault(c, 0) + 1); &#125; int minLen = Integer.MAX_VALUE, start = 0; char[] sChar = s.toCharArray(); int count = map.size(); // count表示可用的不同字符数 int left = 0, right = 0; while (right &lt; sChar.length) &#123; if (map.containsKey(sChar[right])) &#123; map.put(sChar[right], map.get(sChar[right]) - 1); if (map.get(sChar[right]) == 0) &#123; count--; &#125; &#125; while (count == 0) &#123; // 没有avaliable的字符，需要左指针补回来 while (!map.containsKey(sChar[left])) &#123; left++; &#125; int currLen = right - left + 1; if (minLen &gt; currLen) &#123; minLen = currLen; start = left; &#125; map.put(sChar[left], map.get(sChar[left]) + 1); if (map.get(sChar[left]) &gt; 0) &#123; count++; &#125; left++; &#125; right++; &#125; return minLen == Integer.MAX_VALUE? "": s.substring(start, start + minLen); &#125;&#125; 上面这个需要和 727最小长度的subsequence 区分，这里除了出现的字符一样，出现分的先后顺序也要一致。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public String minWindow(String S, String T) &#123; // 动态规划, 行为tLen + 1, 列为sLen + 1, dp[][]表示从dp[i][j]到j到这部分字符串是所求， // 即T[0, j)是S[0, i)的subsequence with substring S[dp[i][j], j). // 初始状态为 // 状态转换为，若当前字符不匹配，则根据左侧（即S前一个字符）情况决定起始位置（保证最短） // 若匹配，则依赖于左上方的结果，即T前一个字符的起始位置。 // 可进一步压缩空间到O(Slen) if (S == null || T == null || S.length() == 0 || T.length() == 0) &#123; return ""; &#125; char[] sChar = S.toCharArray(); char[] tChar = T.toCharArray(); int sLen = sChar.length, tLen = tChar.length; int[] startFrom = new int [sLen + 1]; Arrays.fill(startFrom, -1); int firstOccur = -1; for (int j = 1; j &lt;= sLen; j++) &#123; if (sChar[j - 1] == tChar[0]) &#123; if (firstOccur == -1) &#123; firstOccur = j - 1; &#125; startFrom[j] = j - 1; &#125; else &#123; startFrom[j] = startFrom[j - 1]; &#125; &#125; for (int i = 2; i &lt;= tLen; i++) &#123; int newFirstOccur = -1; for (int j = firstOccur + 1; j &lt;= sLen; j++) &#123; if (sChar[j - 1] == tChar[i - 1]) &#123; if (newFirstOccur == -1) &#123; newFirstOccur = j - 1; &#125; startFrom[j] = startFrom[j]; // don't change &#125; else &#123; startFrom[j] = startFrom[j - 1]; &#125; &#125; firstOccur = newFirstOccur; &#125; int start = 0, end = sLen, minLen = Integer.MAX_VALUE; for (int j = sLen; j &gt; 0 &amp;&amp; startFrom[j] != -1; j--) &#123; int currLen = j - startFrom[j]; if (currLen &lt; minLen) &#123; start = startFrom[j]; end = j; minLen = currLen; &#125; &#125; return minLen == Integer.MAX_VALUE? "" : S.substring(start, end);&#125; stream observer 已知一组字符串，每次观察一个输入的字符，若输入的字符顺序和字符串组里的match，就返回match的list，否则返回空。问题的形式让我有点懵，涉及到了interface，然后让我自己定义一个class，自定member variable， hierarchy等等 我是用sliding window加上trie做的。先找出list中最长单词的长度k。然后维护一个长度为k的window。建trie的时候注意是反向建，每个单词从最后一个字母开始往前建。同时查的时候也是从window的最右边往前查。但如果有多个匹配（例如abc, abcd都在List中），则需要返回List。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113public static class StreamObserver &#123; StringBuilder stream; int maxLen; TrieNode root; List&lt;String&gt; list = new ArrayList&lt;&gt;(); public StreamObserver(String[] targets) &#123; root = new TrieNode(); maxLen = 0; for (int i = 0; i &lt; targets.length; i++) &#123; maxLen = Math.max(targets[i].length(), maxLen); insert(targets[i]); &#125; stream = new StringBuilder(); &#125; public List&lt;String&gt; putChar(char c) &#123; stream.append(c); int len = stream.length(); String window = stream.substring(Math.max(len - maxLen, 0), len); System.out.println("stream: " + stream); if (stream.length() &gt; maxLen) &#123; stream.deleteCharAt(0); &#125; return search(window); &#125; class TrieNode &#123; private boolean isWord; private TrieNode[] next; public TrieNode() &#123; isWord = false; next = new TrieNode[26]; &#125; public TrieNode getNext(int index) &#123; return next[index]; &#125; public void setNext(int index, TrieNode newNode) &#123; next[index] = newNode; &#125; public boolean getIsWord() &#123; return isWord; &#125; public void setIsWord(boolean val) &#123; isWord = val; &#125; &#125; /** Inserts a word into the trie in reversed order. */ public void insert(String word) &#123; if (word == null || word.length() == 0) &#123; return; &#125; char[] wordChar = word.toCharArray(); TrieNode curr = root; for (int i = wordChar.length - 1; i &gt;= 0; i--) &#123; int index = wordChar[i] - 'a'; if (curr.getNext(index) == null) &#123; curr.setNext(index, new TrieNode()); &#125; curr = curr.getNext(index); &#125; curr.setIsWord(true); &#125; public List&lt;String&gt; search(String word) &#123; char[] wordChar = word.toCharArray(); TrieNode curr = root; for (int i = wordChar.length - 1; i &gt;= 0; i--) &#123; int index = wordChar[i] - 'a'; if (curr.getNext(index) == null) &#123; break; &#125; curr = curr.getNext(index); if (curr.getIsWord()) &#123; list.add(word.substring(i, wordChar.length)); &#125; &#125; return list; &#125; /* // Returns if the word is in the trie. public boolean search(String word) &#123; if (word == null || word.length() == 0) &#123; return false; &#125; char[] wordChar = word.toCharArray(); TrieNode curr = root; for (int i = wordChar.length - 1; i &gt;= 0; i--) &#123; int index = wordChar[i] - 'a'; if (curr.getNext(index) == null) &#123; return false; &#125; curr = curr.getNext(index); &#125; return curr.getIsWord(); &#125; // Returns if there is any word in the trie that starts with the given prefix. public boolean startsWith(String prefix) &#123; if (prefix == null || prefix.length() == 0) &#123; return false; &#125; char[] prefixChar = prefix.toCharArray(); TrieNode curr = root; for (int i = 0; i &lt; prefixChar.length; i++) &#123; int index = prefixChar[i] - 'a'; if (curr.getNext(index) == null) &#123; return false; &#125; curr = curr.getNext(index); &#125; return true; &#125; */&#125; 有向无环图最长路径 给出公司并购的关系列表，比如[[&quot;baidu&quot;, &quot;ofo&quot;], [&quot;mobike&quot;, &quot;alibaba&quot;],...]，表示baidu并购了ofo，摩拜并购了阿里巴巴。。。求最长的一个并购链。保证无环。 类似简化版拓扑，完整版拓扑可参考这个submission，不过这里其实只需要找到入度为0的节点，然后更新可达点的同时更新所走的步数。 带时间戳的Map 带时间戳的map: put(k, v, timestamp) get(k , timestamp)EX: 12345put(1, haha, 3)put(1, ha, 5)get(1, 0) -&gt; nullget(1, 4) -&gt; hahaget(1, 6) -&gt; ha 维护Map&lt;Integer, Map&lt;Integer, String&gt;&gt;，新插入的key就新建一个TreeMap，然后时间戳为key，String为value存入。读取的时候就取floorKey(timestamp)，也就是最接近的不大于timestamp的值，有的话即为所求了。 Follow-up是问用ArrayList, LinkedList, BST, Balanced BST实现的get和put的时间复杂度分别是多少。 树的遍历 preorder, inorder, post-order。要求掌握iterative和recursive的方法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; ans = new LinkedList&lt;&gt;(); if (root == null) &#123; return ans; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()) &#123; TreeNode curr = stack.pop();// 栈顶的先输出 ans.add(curr.val); if (curr.right != null) &#123; // 栈优先push右子（让它晚点出来） stack.push(curr.right); &#125; if (curr.left != null) &#123; stack.push(curr.left); &#125; &#125; return ans;&#125;public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); if (root == null) &#123; return ans; &#125; Stack&lt;TreeNode&gt; s = new Stack&lt;&gt;(); TreeNode curr = root; while (curr != null || !s.isEmpty()) &#123; while (curr != null) &#123; s.push(curr); curr = curr.left; // 栈总是优先push左子 &#125; curr = s.pop(); // 直到无左子 ans.add(curr.val); curr = curr.right; &#125; return ans;&#125;public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; ans = new LinkedList&lt;&gt;(); if (root == null) &#123; return ans; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); Stack&lt;Integer&gt; val = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()) &#123; TreeNode curr = stack.pop(); if (curr.left != null) &#123; stack.push(curr.left); &#125; if (curr.right != null) &#123; stack.push(curr.right); &#125; val.push(curr.val); // 栈顶的晚输出 &#125; while (!val.isEmpty()) &#123; ans.add(val.pop()); &#125; return ans;&#125; Frequencey Iterator (类似于利口604) 给一个int数组，奇数位是count偶数位是number，实现next和hasNext函数。如[2,4,0,9,5,3]，那输出就是[4,4,3,3,3,3,3]。 自定义类保存数字和对应的频数，然后入Queue开始输出就好了。12345678910111213141516171819202122232425262728293031323334class FreqNumber &#123; int freq; int num; public FreqNumber(int freq, int num) &#123; this.freq = freq; this.num = num; &#125;&#125;public class MyIterator &#123; Queue&lt;FreqNumber&gt; queue; public MyIterator(int[] array) &#123; int i = 0, n = array.length; // 需要保证是偶数个元素 queue = new LinkedList&lt;&gt;(); while (i + 1 &lt; n) &#123; if (array[i] &gt; 0) &#123; queue.add(new FreqNumber(array[i], array[i + 1])); &#125; i += 2; &#125; &#125; public int next() throws Exception &#123; if (!hasNext()) &#123; throw new Exception(); &#125; FreqNumber top = queue.peek(); if (--top.freq == 0) &#123; queue.poll(); &#125; return top.num; &#125; public boolean hasNext() &#123; return !queue.isEmpty(); &#125;&#125; toeplitz matrix 判断一matrix是不是toeplitz matrix, 就是所有左上到右下对角线的数字都相等。 对角线方向元素其实就是相邻两行元素的前后判断。 12345678910111213141516public class Google &#123; public boolean isToeplitzMatrix(int[][] matrix) &#123; if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123; return false; &#125; int rows = matrix.length, cols = matrix[0].length; for (int i = 1; i &lt; rows; i++) &#123; for (int j = 1; j &lt; cols; j++) &#123; if (matrix[i][j] != matrix[i - 1][j - 1]) &#123; return false; &#125; &#125; &#125; return true; &#125;&#125; follow-up: 如果matrix特别大，每次只能存两行，只用matrix提供的matrix.next, matrix.has_next, 和matrix.size实现。其实上面的方法已经只存两行了。 3sum 给一个数组，求其中所有的a, b, c使得a + b + c == 0123456789101112131415161718192021222324252627282930313233343536373839public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); if (nums == null || nums.length == 0) &#123; return ans; &#125; Arrays.sort(nums); for (int i = 0; i &lt; nums.length; i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; // 固定nums[i]用双指针找后面两个数b, c，使b + c == 0 - nums[i] int left = i + 1, right = nums.length - 1, target = 0 - nums[i]; while (left &lt; right) &#123; int sum = nums[left] + nums[right]; if (sum == target) &#123; List&lt;Integer&gt; currList = new ArrayList&lt;&gt;(); currList.add(nums[i]); currList.add(nums[left]); currList.add(nums[right]); ans.add(currList); left++; right++; while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) &#123; // 避免重复 left++; &#125; while (right &gt; left &amp;&amp; nums[right] == nums[right + 1]) &#123; // 避免重复 right++; &#125; &#125; else if (sum &lt; target) &#123; left++; &#125; else &#123; right--; &#125; &#125; &#125; return ans; &#125; validate 2D array 2-D array，里面有R,G,B,Y四种类型的element，如果横竖没有三个element是同一类型的话，这个2-Darray就是valid的。先让写个function判断一个2-D array是否valid。 感觉和那个OOXX(348 Design tic tac toe)的游戏很像，不过就不能通过简单的加一减一来搞了。这里就是暴力了，判断当前字符的前一行、下一行，以及前一列、下一列。 123456789101112131415161718192021222324252627public static boolean isValidMatrix(char[][] matrix) &#123; if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123; return false; &#125; int rows = matrix.length, cols = matrix[0].length; for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; cols; j++) &#123; if (i &gt; 0 &amp;&amp; matrix[i - 1][j] == matrix[i][j]) &#123; // 等于上一行 if (i + 1 &lt; rows &amp;&amp; matrix[i + 1][j] == matrix[i][j]) &#123; return false; // 判断下一行 &#125; &#125; colBucket[j] = matrix[i][j]; if (j &gt; 0 &amp;&amp; matrix[i][j] == matrix[i][j - 1]) &#123; if (j + 1 &lt; cols &amp;&amp; matrix[i][j + 1] == matrix[i][j]) &#123; return false; &#125; else &#123; j++; if (j &lt; cols) &#123; colBucket[j] = matrix[i][j]; &#125; &#125; &#125; &#125; &#125; return true;&#125; follow-up：能否并行化计算？各种方式有什么优劣？可以replicate原array，每个thread只处理一个颜色。也可以划分成小块，但是边界线情况讨论起来特别复杂，而且会有很多个thread。 2D array search &amp; sum 240 Search a 2D Matrix II，可以直接从第一行的最大列开始找，因为右下方的一定是比当前元素大的，所以只需要查找左下和左前即可。 123456789101112131415161718 // O(M + N)public boolean searchMatrix(int[][] matrix, int target) &#123; if (matrix == null || matrix.length &lt; 1 || matrix[0].length &lt;1) &#123; return false; &#125; int col = matrix[0].length - 1; int row = 0; while (col &gt;= 0 &amp;&amp; row &lt;= matrix.length-1) &#123; if (target == matrix[row][col]) &#123; return true; &#125; else if (target &lt; matrix[row][col]) &#123; col--; &#125; else if (target &gt; matrix[row][col]) &#123; row++; &#125; &#125; return false;&#125; 304. Range Sum Query 2D - Immutable 也是缓存中间结果的思想，利用额外的O(MN)的空间存下来，需要取sum的时候就减左侧、上侧再加回左上侧结果即可。 1234567891011121314151617private int[][] sumRegion;public NumMatrix(int[][] matrix) &#123; if (matrix.length != 0) sumRegion = new int[matrix.length + 1][matrix[0].length + 1]; for (int i = 0; i &lt; matrix.length; i++) &#123; int sum = 0; for (int j = 0; j &lt; matrix[0].length; j++) &#123; sum += matrix[i][j]; sumRegion[i + 1][j + 1] = sum + sumRegion[i][j + 1]; &#125; &#125;&#125;public int sumRegion(int row1, int col1, int row2, int col2) &#123; return sumRegion[row2 + 1][col2 + 1] - sumRegion[row1][col2 + 1] - sumRegion[row2 + 1][col1] + sumRegion[row1][col1];&#125; follow-up是如果要对矩阵时不时进行更新怎么办。如果还是用上面这个的思路，返回sumRegion的时间就不再是constant了，同时update也不是constant。为了更新，还需要把matrix存下来（必须的）。 123456789101112131415161718192021222324252627282930313233343536373839private int[][] sumRegion;private int[][] matrix;public NumMatrix(int[][] matrix) &#123; if( matrix == null || matrix.length == 0 || matrix[0].length == 0 )&#123; return; &#125; this.matrix = matrix; int m = matrix.length; int n = matrix[0].length; sumRegion = new int[m + 1][n]; for(int i = 1; i &lt;= m; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; sumRegion[i][j] = sumRegion[i - 1][j] + matrix[i - 1][j]; &#125; &#125;&#125;//time complexity for the worst case scenario: O(m)public void update(int row, int col, int val) &#123; for(int i = row + 1; i &lt; sumRegion.length; i++)&#123; sumRegion[i][col] = sumRegion[i][col] - matrix[row][col] + val; &#125; matrix[row][col] = val;&#125;//time complexity for the worst case scenario: O(n)public int sumRegion(int row1, int col1, int row2, int col2) &#123; int ret = 0; for(int j = col1; j &lt;= col2; j++)&#123; ret += sumRegion[row2 + 1][j] - sumRegion[row1][j]; &#125; return ret;&#125; 另一个高效办法是Binary Index Tree。我们先看看range sum 1D的情况，2D的暂时放一放。。。 12345678910111213141516171819202122232425262728293031323334353637383940414243int[] nums;int[] BIT;int n;public RangeSum(int[] nums) &#123; this.nums = nums; this.n = nums.length; this.BIT = new int[n + 1]; // n + 1 initiateBIT();&#125;public int lowestBit(int x) &#123; // 获取最低位的1 return x &amp; -x;&#125;public void initiateBIT()&#123; for(int i = 1; i &lt;= n; i++)&#123; this.BIT[i] = 0; for(int j = i; j &gt; i - lowestBit(i); j--)&#123; this.BIT[i] = this.BIT[i] + nums[j - 1]; &#125; &#125;&#125; //每次都只有后继节点会根据当前节点的变化而变化， 所以步长是i + lowestBit(i)public void update(int index, int val)&#123; for(int i = index + 1; i &lt;= this.n; i = i + lowestBit(i))&#123; this.BIT[i] = this.BIT[i] - this.nums[index] + val; &#125; this.nums[index] = val;&#125;//和为所有前驱节点相加， 所以步长是i - lowestBit(i)public int getSum(int k)&#123; int sum = 0; for(int i = k + 1; i &gt; 0; i = i - lowestBit(i))&#123; sum = sum + this.BIT[i]; &#125; return sum;&#125;public int getRangeSum(int i, int j)&#123; return getSum(j) - getSum(i - 1);&#125; voting with timestamp 给一个voteList=[(a, 100), (b, 150), (a, 200)] #(name, timestamp)和时间T，找T时间之前, 得票数最高的人(或任一得票数最高的人)。 直接扫一波vote list，只保留在时间T之前的票存到Map中，顺便记下一个最大值和对应的人名。 follow-up：给voteList、时间T，求top k候选人的list。也是先O(N)扫一波统计，然后再一波loop存入Heap，如果Heap规模达到k就需要比较堆顶和当前票数，若当前票数更大就需要把出堆再push。 follow-up：给voteList、top k候选人的list，求时间T。只想到最暴力的办法，先把所有出现过的时间t存入从小到大的PriorityQueue，然后从小到大暴力搜“给定voteList和T”，看看求得的list和所给的list是否一致。不过这里每次不是从头开始做，而是累加，即前一个t不行，就取优先队列中的下一个t继续往后加，不用从头来过。 feed tree 一棵树，所有节点的value都是正整数，问只能增加某些节点值的情况下，如何调整使得从root到所有leaf的path上经过的节点值之和相等，返回增加的值的和，使这个和最小. 类似贪心，在后续遍历的过程中顺便求叶子到当前节点的和并返回，再用全局变量根据左右两边孩子的差值确定需要补多少，更新的条件是该节点一定有两个孩子来比较，这样就能保证和最小。123456789101112131415161718192021222324252627282930313233343536/* 1 / \ 2 3 / \ / \ 3 2 2 4 \ 1 1 / \ 4 3 / \ / \ 3 3 3 4 \ 1*/class Solution &#123; private int ans; public int minAddToTree(TreeNode root)&#123; // supposing the tree is binary tree ans = 0; feedTree(root); return ans; &#125; private int feedTree(TreeNode root)&#123; // this funciton 'feed' the tree to make all root-&gt;leaf path sums equal // return: path sum of the tree. if (root == null) return 0; int leftPath = feedTree(root.left); int rightPath = feedTree(root.right); if (leftPath != 0 &amp;&amp; rightPath != 0) // check if one child is null, if so no need to feed ans += Math.abs(leftPath - rightPath); return Math.max(leftPath, rightPath) + root.val; &#125;&#125; remove node Given a binary tree, write a function to erase a list of nodes from the tree and return the forest created from this operation.自己决定输入输出形式，自己定义treenode结构. 一个思路是，可以在TreeNode中增加parent节点，这样在删除的时候就方便很多，直接设置就可以了。 1234567class TreeNode &#123; int val; TreeNode left, right, parent; public TreeNode(int val) &#123; this.val = val; &#125;&#125; 如果不加parent，就需要通过postOrder遍历，先递归到当前节点的左和右孩子，再看看孩子是否要删掉，是就直接设为null。 1234567891011121314151617public List&lt;TreeNode&gt; delete(TreeNode root, List&lt;TreeNode&gt; toRemove) &#123; List&lt;TreeNode&gt; res = new ArrayList&lt;TreeNode&gt;(); TreeNode root1 = postorder(root, toRemove, res); if(root1 != null) res.add(root); return res;&#125;public TreeNode postorder(TreeNode root, List&lt;TreeNode&gt; toRemove, List&lt;TreeNode&gt; res) &#123; if(root == null) return null; root.left = postorder(root.left, toRemove, res); root.right = postorder(root.right, toRemove, res); if (toRemove.contains(root)) &#123; // 当前节点需要删除 if (root.left != null) res.add(root.left); if (root.right != null) res.add(root.right); return null; &#125; return root;&#125; 361. Bomb Enemy 给一个只含有0, W, E的char棋盘，炸弹只能放在0处，炸弹可以向上下左右扩散，求一颗炸弹最多炸死多少E。 对于每一行统计敌人数，一旦遇到W就重置为0；对于每一列则需要维护额外的一个数组，也是遇到W就重置。 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; // O(MN)统计每行、每列可杀E的数量，一旦前面（左或上）碰到W就要重新算一遍 public int maxKilledEnemies(char[][] grid) &#123; if (grid == null || grid.length == 0 || grid[0].length == 0) &#123; return 0; &#125; int rows = grid.length, cols = grid[0].length; int ans = 0, rowCount = 0; int[] colCount = new int [cols]; for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; cols; j++) &#123; if (j == 0 || grid[i][j - 1] == 'W') &#123; // 当上一列是W，就重新往右算当前列可以杀多少E rowCount = 0; for (int k = j; k &lt; cols &amp;&amp; grid[i][k] != 'W'; k++) &#123; // 不会提升复杂度因为只有前一个是W才会开始、到W就结束 if (grid[i][k] == 'E') &#123; rowCount++; &#125; &#125; &#125; if (i == 0 || grid[i - 1][j] == 'W') &#123; // 当上一行是W，就重新往下算当前列可以杀多少E colCount[j] = 0; for (int k = i; k &lt; rows &amp;&amp; grid[k][j] != 'W'; k++) &#123; if (grid[k][j] == 'E') &#123; colCount[j]++; &#125; &#125; &#125; if (grid[i][j] == '0') &#123; ans = Math.max(ans, rowCount + colCount[j]); &#125; // else if (grid[i][j] == 'E') &#123; // ans = Math.max(ans, rowCount + colCount[j] - 1); // &#125; &#125; &#125; return ans; &#125;&#125; follow-up：如果在E上也可以放炸弹，要如何修改？那么就加多一个判断是否等于E的步骤，见上面注释部分。 以上是地里大概找的一部分面经。 以下是利口上的孤狗tag题。 4. Median of 2 sorted arrays 给两个有序int数组，返回二者合并后的中位数。 O(M + N)：归并排序依次合并，合并到一半长度知道中位数了。 O(log(M + N))：中位数是用来将数组分割成相等长度的两部分的，因此使用二分查找找出刚好能分成等长的两部分并且前部分的最大值&lt;=后部分的最小值。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; if (nums1 == null || nums2 == null) &#123; return 0; &#125; int m = nums1.length, n = nums2.length; if (nums1.length &gt; nums2.length) &#123; // ensure the len of 1 &lt;= 2 return findMedianSortedArrays(nums2, nums1); &#125; // to ensure equality of the two parts after merged, i + j = m - i + n - j int iLo = 0, iHi = m, allMid = (n + m + 1) / 2; // merge odd / even case // i stands for "how many num taken from nums1 as front part" 0 ~ i-1 | i ~ m-1 // j stands for "how many num taken from nums2 as front part" 0 ~ j-1 | j ~ n-1 while (iLo &lt;= iHi) &#123; int i = (iLo + iHi) / 2, j = allMid - i; // nums1[i-1], nums2[j-1] are the largest element of front part of nums1, nums2 // nums1[i], nums2[j] are the smallest of lag part of nums1, nums2 if (i &lt; m &amp;&amp; nums2[j - 1] &gt; nums1[i]) &#123; // i not big enough iLo = i + 1; &#125; else if (i &gt; 0 &amp;&amp; nums1[i - 1] &gt; nums2[j]) &#123; iHi = i - 1; &#125; else &#123; int maxLeft = 0, minRight = 0; if (i == 0) &#123; maxLeft = nums2[j - 1]; &#125; else if (j == 0) &#123; maxLeft = nums1[i - 1]; &#125; else &#123; maxLeft = Math.max(nums1[i - 1], nums2[j - 1]); &#125; if ((m + n) % 2 == 1) &#123; // I think thats why to make (allMid = (n + m + 1)/2) return maxLeft; // -- to make left part always at least no fewer than right &#125; if (i == m) &#123; minRight = nums2[j]; &#125; else if (j == n) &#123; minRight = nums1[i]; &#125; else &#123; minRight = Math.min(nums1[i], nums2[j]); &#125; return (maxLeft + minRight) / 2.0; &#125; &#125; return 0; &#125;&#125; 17. letter-combinations 给一串数字的字符串，求这些数字可能输出的所有字母字符串，对应关系为手机的按键。 DFS：12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public List&lt;String&gt; letterCombinations(String digits) &#123; List&lt;String&gt; ans = new ArrayList&lt;&gt;(); if (digits == null || digits.length() == 0 || digits.indexOf('1') &gt;= 0 || digits.indexOf('0') &gt;= 0) &#123; return ans; &#125; final char[][] num2Char = new char [][] &#123; &#123;&#125;, &#123;&#125;, &#123;'a', 'b', 'c'&#125;, &#123;'d', 'e', 'f'&#125;, &#123;'g', 'h', 'i'&#125;, &#123;'j', 'k', 'l'&#125;, &#123;'m', 'n', 'o'&#125;, &#123;'p', 'q', 'r', 's'&#125;, &#123;'t', 'u', 'v'&#125;, &#123;'w', 'x', 'y', 'z'&#125; &#125;; char[] str = digits.toCharArray(); dfs(str, 0, num2Char, new StringBuilder(), ans); return ans; &#125; private void dfs(char[] str, int index, final char[][] num2Char, StringBuilder sb, List&lt;String&gt; ans) &#123; if (index == str.length) &#123; ans.add(sb.toString()); return; &#125; int temp = str[index] - '0'; for (int i = 0; i &lt; num2Char[temp].length; i++) &#123; sb.append(num2Char[temp][i]); dfs(str, index + 1, num2Char, sb, ans); sb.deleteCharAt(sb.length() - 1); &#125; &#125;&#125; 20. valid-parentheses 给一个字符串，判断其中三种括号(), [], {}是否匹配。 Stack: 左括号本身并不入栈，而是它对应的右括号入栈，这样当右括号出现的时候只需判断二者是否相等或者是否栈已经空了即可。1234567891011121314public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for (char c : s.toCharArray()) &#123; if (c == '(') stack.push(')'); else if (c == '&#123;') stack.push('&#125;'); else if (c == '[') stack.push(']'); else if (stack.isEmpty() || stack.pop() != c) return false; &#125; return stack.isEmpty();&#125; 22. generate-parentheses 给一个int表示括号的对儿数，输出所有符合括号匹配规则的字符串，存入List中返回。 DFS：左括号、右括号分别1234567891011121314151617181920212223 // O(2^2n)?class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; ans = new ArrayList&lt;&gt;(); if (n &lt; 1) &#123; return ans; &#125; dfs(n, 0, 0, "", ans); return ans; &#125; private void dfs(int n, int left, int right, String s, List&lt;String&gt; ans) &#123; if (left == n &amp;&amp; right == n) &#123; ans.add(s); return; &#125; if (left &lt; n) dfs(n, left + 1, right, s + "(", ans); if (right &lt; left) dfs(n, left, right + 1, s + ")", ans); &#125;&#125; 23. merge-k-sorted-lists 给一个ListNode节点数组，分别是排好序的若干链表头，要求输出合并后的新链表头. 直接用PriorityQueue： 1234567891011121314151617181920public ListNode mergeKLists(ListNode[] lists) &#123; if (lists == null || lists.length == 0) &#123; return null; &#125; PriorityQueue&lt;ListNode&gt; pq = new PriorityQueue&lt;&gt;((a, b) -&gt; &#123; return a.val - b.val; &#125;); for (ListNode l: lists) &#123; if (l != null) pq.add(l); &#125; ListNode fakeHead = new ListNode(0), curr = fakeHead; while (!pq.isEmpty()) &#123; curr.next = pq.poll(); curr = curr.next; if (curr.next != null) pq.add(curr.next); &#125; return fakeHead.next;&#125; 分治法。 1234567891011121314151617181920212223242526272829303132333435// divide and conquer, O(nlogk)public ListNode mergeKLists(ListNode[] lists) &#123; if (lists == null || lists.length == 0) &#123; return null; &#125; // last two params are used to divide into sub problems return mergeKLists(lists, 0, lists.length);&#125;private ListNode mergeKLists(ListNode[] lists, int start, int end) &#123; if (end - start == 1) &#123; // only one list return lists[start]; &#125; else if (end - start == 2) &#123; // merge two lists return mergeTwoLists(lists[start], lists[start + 1]); &#125; else &#123; int mid = start + (end - start) / 2; // cut into first and second halves return mergeTwoLists(mergeKLists(lists, start, mid), mergeKLists(lists, mid, end)); // warning not mid + 1 &#125;&#125;private ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) &#123; return l2; &#125; if (l2 == null) &#123; return l1; &#125; if (l1.val &lt;= l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125;&#125; 31. next-permutation 给一个int数组，将它改造成按字典序的下一个排列，若不存在则直接按从小到大的顺序调整。要求In-place对原数组操作，不能申请额外空间。 这个想法从右往左找相邻的两个数使得first &lt; second，然后再从右往左找首次出现的比first大的数，二者对调，然后将second及其之后的内容reverse一下即可。123456789101112131415161718192021222324252627282930313233// 1324 -&gt; 1342// 6，3，4，9，8，7，1 -&gt; 6，3，7，9，8，4，1 -&gt; 6，3，7，1，4，8，9class Solution &#123; public void nextPermutation(int[] nums) &#123; if (nums == null || nums.length &lt; 2) &#123; return; &#125; for (int i = nums.length - 2; i &gt;= 0; i--) &#123; if (nums[i] &lt; nums[i + 1]) &#123; // 找相邻的两个数 int j = nums.length - 1; while (j &gt; i) &#123; // 从右往左找第一个大于first的数 if (nums[j] &gt; nums[i]) &#123; swap(nums, i, j); // reverse(nums, i + 1); return; &#125; j--; &#125; &#125; &#125; reverse(nums, 0); &#125; private void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125; private void reverse(int[] nums, int start) &#123; for (int i = start, j = nums.length - 1; i &lt; j; i++, j--) &#123; swap(nums, i, j); &#125; &#125;&#125; 42. trapping-rain-water 给一个int数组，其中包含每个索引处墙的高度。求装满水时的横截面的积水的面积。 用两个辅助数组分别表示两侧最高高度，然后再一波遍历看能否装水。 1234567891011121314151617181920212223242526class Solution &#123; public int trap(int[] height) &#123; if (height == null || height.length == 0) &#123; return 0; &#125; int[] hiLeft = new int [height.length]; // leftward highest int[] hiRight = new int [height.length]; // rightward highest int left = height[0], right = height[height.length - 1]; for (int i = 1, j = height.length - 2; i &lt; height.length; i++, j--) &#123; hiLeft[i] = left; left = Math.max(left, height[i]); hiRight[j] = right; right = Math.max(right, height[j]); &#125; int area = 0; for (int i = 0; i &lt; height.length; i++) &#123; int h = Math.min(hiLeft[i], hiRight[i]); if (height[i] &lt; h) &#123; area += (h - height[i]); &#125; &#125; return area; &#125;&#125; follow-up:不能用额外空间呢？ 1234567891011121314151617181920212223242526class Solution &#123; public int trap(int[] height) &#123; if (height == null || height.length == 0) &#123; return 0; &#125; int[] hiLeft = new int [height.length]; // leftward highest int[] hiRight = new int [height.length]; // rightward highest int left = height[0], right = height[height.length - 1]; for (int i = 1, j = height.length - 2; i &lt; height.length; i++, j--) &#123; hiLeft[i] = left; left = Math.max(left, height[i]); hiRight[j] = right; right = Math.max(right, height[j]); &#125; int area = 0; for (int i = 0; i &lt; height.length; i++) &#123; int h = Math.min(hiLeft[i], hiRight[i]); if (height[i] &lt; h) &#123; area += (h - height[i]); &#125; &#125; return area; &#125;&#125; 676. implement-magic-dictionary 给一个字典需要维护某种结构使得查询比较高效，查询是通过一个单词输入后判断字典中是否存在一个单词只替换输入串中的一个字符就能得到。 有点暴力的方法，在输入一个字符串数组的时候就维护一个从String映射到Character的Map，对于每个单词的每一个字符都换成*作为key，然后被替换的字符作为value存入。之后check的时候也是把每个字符都换成*之后再确认map中有没有对应的key。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class MagicDictionary &#123; // 将每个单词的每个字符都替换成*之后，插入map，key是替换后的字符串，value是被替换掉的那个字符 // 如果出现替换过后的key一样，则该位可以放任意字符，因为例如hello和hallo只有在第二位不同，如果替换后是h*llo可以任选一个，一定是true。 Map&lt;String, Character&gt; map = null; /** Initialize your data structure here. */ public MagicDictionary() &#123; map = new HashMap&lt;String, Character&gt;(); &#125; /** Build a dictionary through a list of words */ public void buildDict(String[] dict) &#123; if (dict == null || dict.length == 0) &#123; return; &#125; for (String word : dict) &#123; StringBuilder sb = new StringBuilder(word); int len = word.length(); for (int i = 0; i &lt; len; i++) &#123; sb.setCharAt(i, '*'); Character c = map.get(sb.toString()); if (c == null) &#123; map.put(sb.toString(), word.charAt(i)); &#125; else &#123; map.put(sb.toString(), '*'); &#125; sb.setCharAt(i, word.charAt(i)); &#125; &#125; &#125; /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */ public boolean search(String word) &#123; if (word == null || word.length() == 0) &#123; return false; &#125; int len = word.length(); StringBuilder sb = new StringBuilder(word); for (int i = 0; i &lt; len; i++) &#123; sb.setCharAt(i, '*'); Character c = map.get(sb.toString()); if (c != null &amp;&amp; (c == '*' || c != word.charAt(i))) &#123; return true; &#125; sb.setCharAt(i, word.charAt(i)); &#125; return false; &#125;&#125;/** * Your MagicDictionary object will be instantiated and called as such: * MagicDictionary obj = new MagicDictionary(); * obj.buildDict(dict); * boolean param_2 = obj.search(word); */]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>algorithm</tag>
        <tag>interview</tag>
        <tag>google</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滋衣螺古如普]]></title>
    <url>%2F2017%2F10%2F20%2Fzillow%2F</url>
    <content type="text"><![CDATA[迎难而上，祝我好运。 字符串长度 要求不能用length内建方法。 123456private int getStrLen(String str) &#123; if (str == null || str.equals("")) &#123; return 0; &#125; return 1 + getStrLen(str.substring(1));&#125; 上面这个复杂度达到了O(N^2). 其实循环除了根据长度界定范围，还有一个for-each可以用，所以可以先转成charArray再for-each来找。 1234567891011private int getStrLen(String str) &#123; if (str == null || str.equals("")) &#123; return 0; &#125; int index = 0; char[] sChar = str.toCharArray(); for (char c: sChar) &#123; index++; &#125; return index;&#125; 此外，利用StringIndexOutOfBoundsException可以降到O(N). 1234567891011121314private int getStrLen(String str) &#123; if (str == null || str.equals("")) &#123; return 0; &#125; int index = 0; while (true) &#123; try &#123; char c = str.charAt(index); index++; &#125; catch (Exception e) &#123; return index; &#125; &#125;&#125; BST验证 常见的错误是直接greedy，只判断当前节点和孩子的大小。但BST的定义是比「所有的左子树都大、比右都小」。 方法一：中序遍历时每次都判断前后两个元素的大小关系。又分为recursive和iterative的。 12345678910111213141516171819202122232425262728293031323334353637 // recursive: 全局的prev记录当前节点前一个是谁，比较大小private TreeNode prev = null;private boolean validateBST1(TreeNode root) &#123; if (root == null) &#123; return true; &#125; if (!validateBST1(root.left)) &#123; return false; &#125; if (prev != null &amp;&amp; prev.val &gt;= root.val) &#123; return false; &#125; prev = root; return validateBST1(root.right);&#125; // iterative: 用stack不断深入左节点，直到空再将栈顶与prev比较，然后进入右子树，继续不断向左。private boolean validateBST2(TreeNode root) &#123; if (root == null) &#123; return true; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode prev = null; while (root != null || !stack.isEmpty()) &#123; while (root != null) &#123; stack.push(root); root = root.left; &#125; root = stack.pop(); if (prev != null &amp;&amp; prev.val &gt;= root.val) &#123; return false; &#125; prev = root; root = root.right; &#125; return true;&#125; 方法二：分治，为左右子树给定范围（min, max），在递归时更新左子树的上界、更新右子树的下界。 12345678910111213private boolean validateBST3(TreeNode root) &#123; return dvcq(root, Long.MIN_VALUE, Long.MAX_VALUE);&#125;private boolean dvcq(TreeNode root, long min, long max) &#123; if (root == null) &#123; return true; &#125; if (root.val &lt;= min || root.val &gt;= max) &#123; return false; &#125; return dvcq(root.left, min, Math.min(root.val, max)) &amp;&amp; dvcq(root.right, Math.max(root.val, min), max);&#125; 走迷宫 给一个grid走迷宫，有障碍物，四个方向随便走，要左上角到右下角的最短路径 BFS方法，进入循环时记录需要遍历的点的个数同时更新步数，从当前点开始往下、右、上、左的顺序走，如果没访问过且不是障碍物就放入queue，第一个到达右下角的就是最短路了。123456789101112131415161718192021222324252627282930313233343536373839404142434445private int shortestPath(int[][] grid)&#123; if (grid == null || grid.length == 0 || grid[0].length == 0 || grid[0][0] == 1) &#123; return 0; &#125; boolean[][] visited = new boolean [grid.length][grid[0].length]; Queue&lt;Point&gt; q = new LinkedList&lt;&gt;(); q.add(new Point(0, 0)); visited[0][0] = true; int step = 0; while (!q.isEmpty()) &#123; int size = q.size(); step++; while (size-- &gt; 0) &#123; Point curr = q.poll(); if (curr.x == grid.length - 1 &amp;&amp; curr.y == grid[0].length - 1) &#123; return step; &#125; // down if (curr.x + 1 &lt; grid.length &amp;&amp; grid[curr.x + 1][curr.y] != 1 &amp;&amp; !visited[curr.x + 1][curr.y]) &#123; visited[curr.x + 1][curr.y] = true; q.add(new Point(curr.x + 1, curr.y)); &#125; // right if (curr.y + 1 &lt; grid[0].length &amp;&amp; grid[curr.x][curr.y + 1] != 1 &amp;&amp; !visited[curr.x][curr.y + 1]) &#123; visited[curr.x][curr.y + 1] = true; q.add(new Point(curr.x, curr.y + 1)); &#125; // up if (curr.x &gt;= 1 &amp;&amp; grid[curr.x - 1][curr.y] != 1 &amp;&amp; !visited[curr.x - 1][curr.y]) &#123; visited[curr.x - 1][curr.y] = true; q.add(new Point(curr.x - 1, curr.y)); &#125; // left if (curr.y &gt;= 1 &amp;&amp; grid[curr.x][curr.y - 1] != 1 &amp;&amp; !visited[curr.x][curr.y - 1]) &#123; visited[curr.x][curr.y - 1] = true; q.add(new Point(curr.x, curr.y - 1)); &#125; &#125; &#125; return -1;&#125; Lowest Common Ancestor 任意二叉树的最小共同祖先。 recursive：先看当前root是否符合其中一个，是就返回当前root，否则看看是否分居左、右，是也返回当前root，再否则看看需要深入到哪一边。 1234567891011121314151617private TreeNode getLCA(TreeNode root, TreeNode n1, TreeNode n2) &#123; if (root == null) &#123; return null; &#125; if (root == n1 || root == n2) &#123; return root; &#125; TreeNode left = getLCA(root.left, n1, n2); TreeNode right = getLCA(root.right, n1, n2); if (left != null &amp;&amp; right != null) &#123; return root; &#125; if (left == null &amp;&amp; right == null) &#123; return null; &#125; return left == null? right: left;&#125; follow-up：如果每个节点还给多一个parent引用 123456789class TreeNodeP &#123; int val; TreeNodeP left; TreeNodeP right; TreeNodeP parent; public TreeNodeP(int val) &#123; this.val = val; &#125;&#125; 方法一：将其中一个节点一路上溯到root，将沿途的节点全部存入Set，然后再从另一个节点上溯，看看沿途哪个在set里。 1234567891011121314public TreeNodeP getLCA2(TreeNodeP p, TreeNodeP q) &#123; Set&lt;TreeNodeP&gt; set = new HashSet&lt;&gt;(); while (p != null) &#123; set.add(p); p = p.parent; &#125; while (q != null) &#123; if (set.contains(q)) &#123; return q; &#125; q = q.parent; &#125; return null;&#125; 方法二：先分别求两个节点的深度，将两个节点上溯到相同高度后，同时上溯并在每一步都判断是否相等。 12345678910111213141516171819202122232425public TreeNodeP getLCA3(TreeNodeP p, TreeNodeP q) &#123; int hp = getH(p); int hq = getH(q); while (hp &gt; hq) &#123; p = p.parent; hp--; &#125; while (hq &gt; hp) &#123; q = q.parent; hq--; &#125; while (p != null &amp;&amp; q != null &amp;&amp; p != q) &#123; p = p.parent; q = q.parent; &#125; return p;&#125;private int getH(TreeNodeP root) &#123; int h = 0; while (root != null) &#123; h++; root = root.parent; &#125; return h;&#125; 找第一个unique的字符 方法一：遍历两次，第一次统计次数，第二次碰到次数为1的即可。 12345678910111213141516public int firstUniqChar2(String s) &#123; if (s == null || s.length() == 0) &#123; return -1; &#125; char[] sChar = s.toCharArray(); int[] bucket = new int [256]; for (int i = 0; i &lt; sChar.length; i++) &#123; bucket[sChar[i]]++; &#125; for (int i = 0; i &lt; sChar.length; i++) &#123; if (bucket[sChar[i]] == 1) &#123; return i; &#125; &#125; return -1; &#125; 方法二：只遍历一次，利用LinkedHashMap维护存入的顺序，在统计次数的同时，将次数为1的放入linkedhashmap，如果后续再碰到字符就remove掉，最后就输出第一个就好。 123456789101112131415161718192021public int firstUniqChar(String s) &#123; if (s == null || s.length() == 0) &#123; return -1; &#125; char[] sChar = s.toCharArray(); int[] bucket = new int [256]; Map&lt;Character, Integer&gt; map = new LinkedHashMap&lt;&gt;(); for (int i = 0; i &lt; sChar.length; i++) &#123; if (bucket[sChar[i]]++ == 0) &#123; map.put(sChar[i], i); &#125; else &#123; map.remove(sChar[i]); &#125; &#125; Iterator it = map.entrySet().iterator(); if (it.hasNext()) &#123; Map.Entry pair = (Map.Entry)it.next(); return (Integer)pair.getValue(); &#125; return -1;&#125; 方法三，双指针，慢指针指向当前只出现了一次的，快指针往后统计次数。每次都要判断慢指针指向的是不是已经需要更新了，更新时用while一路往后。当快指针消耗完，慢指针就是了。但感觉也算是遍历两次了。 12345678910111213141516171819public int firstUniqChar(String s) &#123; if (s == null || s.length() == 0) &#123; return -1; &#125; int len = s.length(); int slow = 0, fast = -1; int[] count = new int[256]; char[] c = s.toCharArray(); while (++fast &lt; len)&#123; count[c[fast]] ++; while (slow &lt; len &amp;&amp; count[c[slow]] &gt; 1) &#123; slow++; &#125; if (slow == len) &#123; return -1; &#125; &#125; return slow; &#125; wordBreak 给一个字符串和一个字典，判断该字符串能否通过空格拆分成单词，使得这些单词都来自dict。 方法一：BFS每次入队的都是起点，然后每次从队首拿到起点，开始往后遍历，看能否找到新的起点，找到就入队。如果队都空了还没到最后，就不行。 12345678910111213141516171819202122232425262728293031public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123; if (s == null || s.length() == 0 || wordDict == null || wordDict.size() == 0) &#123; return false; &#125; Set&lt;String&gt; wordSet = new HashSet&lt;&gt;(); int maxLen = 0; for (String word: wordDict) &#123; wordSet.add(word); maxLen = Math.max(maxLen, word.length()); &#125; if (wordSet.contains(s)) return true; Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;(); queue.offer(0); // use a set to record checked index to avoid repeated work. // This is the key to reduce the running time to O(N^2). boolean[] visited = new boolean[s.length() + 1]; visited[0] = true; while (!queue.isEmpty()) &#123; int currIndex = queue.poll(); for (int i = currIndex + 1; i &lt;= s.length() &amp;&amp; i - currIndex &lt;= maxLen; i++) &#123; if (visited[i]) continue; if (wordSet.contains(s.substring(currIndex, i))) &#123; if (i == s.length()) return true; queue.offer(i); visited[i] = true; &#125; &#125; &#125; return false;&#125; 方法二：DFS中也是给定起点，往后遍历看能否找到，如果找到就以该处为起点继续向后，如果找不到，就直接把终点对应都索引标注起来，这样之后再碰到以该点起始都就知道不行了（因为以它结尾都不行，就算后面可以也没用）。 123456789101112131415161718192021222324252627282930313233public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123; if (s == null || s.length() == 0 || wordDict == null || wordDict.size() == 0) &#123; return false; &#125; Set&lt;String&gt; wordSet = new HashSet&lt;&gt;(); int maxLen = 0; for (String word: wordDict) &#123; wordSet.add(word); maxLen = Math.max(maxLen, word.length()); &#125; if (wordSet.contains(s)) return true; boolean[] visited = new boolean[s.length() + 1]; return dfs(s, 0, maxLen, wordSet, visited);&#125;private boolean dfs(String s, int index, int maxLen, Set&lt;String&gt; dict, boolean[] visited)&#123; // base case if (index == s.length()) return true; // check memory if (visited[index]) return false; // recursion for (int i = index + 1; i &lt;= s.length() &amp;&amp; i - index &lt;= maxLen; i++)&#123; String t = s.substring(index, i); if (dict.contains(t)) if (dfs(s, i, maxLen, dict, visited)) return true; else visited[i] = true; // 以i结尾啊是不行的 &#125; visited[index] = false; return false;&#125; 方法三：DP。dp[i]表示取长度为i的字串是否都是dict里的，因此当发现一段子串来自dict之后，还需要看前一位是否true才可以判断当前是否true。 123456789101112131415161718192021public boolean workBreak(String s, List&lt;String&gt; wordDict) &#123; if (s == null || s.length() == 0 || wordDict == null || wordDict.size() == 0) &#123; return false; &#125; Set&lt;String&gt; wordSet = new HashSet&lt;&gt;(); int maxLen = 0; for (String word: wordDict) &#123; wordSet.add(word); maxLen = Math.max(maxLen, word.length()); &#125; boolean[] dp = new boolean [s.length() + 1]; for (int i = 1; i &lt;= s.length(); i++) &#123; for (int j = i - 1; j &gt;= 0 &amp;&amp; i - j &lt;= maxLen; j--) &#123; if (dp[j] &amp;&amp; wordSet.contains(s.substring(j, i))) &#123; dp[i] = true; break; &#125; &#125; &#125; return dp[s.length()];&#125; four missing nums in 1-100 方法一：暴力找，用个辅助数组。 1234567891011121314151617public int[] missingNum(int[] nums) &#123; if (nums == null || nums.length != 96) &#123; return new int[]&#123;0,0,0,0&#125;; &#125; boolean[] mark = new boolean[100]; for (int i = 0; i &lt; 100; i++) &#123; mark[i - 1] = true; &#125; int[] ans = new int [4]; int index = 0; for (int i = 0; i &lt; 100 &amp;&amp; index &lt; 4; i++) &#123; if (!mark[i]) &#123; ans[index++] = i + 1; &#125; &#125; return ans;&#125; follow-up: 如果内存不够，数组很大，怎么破？分批查找，引入一个累加都offset，方法中虽然还是找1-100的，但加上offset就是真实值了。 follow-up: 如果排好序，怎么优化？从头往后看，一旦index和数值差有变化，前一位就是missing的。但是如果都堆积在最末尾，那就要单独讨论了。 Git是什么 Git is a version control system - a tool to manage your source code history. 允许不联网状态下建立本地仓库，通过branch方式分散，用merge合并。联网后有一个remote repo，可以和本地的repo record同步，pull = fetch + merge. 介绍一个数据结构 大致有：Array, List, Set, Map, Queue, Stack, Tree, BST, Heap, Graph Tree: binary tree(Traverse?); BST(validate)? pass by reference和pass by value? Pass by reference: the caller and the callee use the same variable for the parameter. If the callee modifies the parameter variable, the effect is visible to the caller’s variable. Pass by value: the caller and callee have two independent variables with the same value. If the callee modifies the parameter variable, the effect is not visible to the caller. Java is passing by value, but when pass value of object as parameter, that value is actually reference to that object. Though we can’t change the reference relation from callee method, we can still modify the object itself through that reference. Fibonacci sum 求斐波那契数列前n项之和，即0 ~ (n - 1)。 首先看看基本的斐波那契数列怎么求。 123456private static int fib(n) &#123; if (n &lt; 2) &#123; return n; &#125; return fib(n - 2) + fib(n - 1);&#125; 方法一：自然想到连续调用，显然复杂度非常高O(n ^ 2)，因为重复计算了很多。 123456private static int fibSum1(int n) &#123; if (n &lt; 2) &#123; return n; &#125; return fibSum1(n - 1) + fib(n);&#125; 方法二：基于规律，fibSum(n) = fibSum(n - 1) + fib(n) = fibSum(n - 1) + fib(n - 2) + fib(n - 1) = fibSum(n - 1) + fibSum(n - 2) - fibSum(n - 3) + fibSum(n - 1) - fibSum(n - 2) = fibSum(n - 1) * 2 - fibSum(n - 3)。 12345678private static int fibSum(int n) &#123; if (n &lt; 2) &#123; return n; &#125; int prev1 = fibSum(n - 1); int prev3 = fibSum(n - 3); return (prev1 * 2)- prev3;&#125; 方法三：算是DP吧，用数组记录每一项fib，顺便求和。 12345678910111213private static int fibSum2(int n) &#123; if (n &lt; 2) &#123; return n; &#125; int[] fibArray = new int [n + 1]; fibArray[1] = 1; Int sum = 1; for (int i = 2; i &lt;= n; i++) &#123; fibArray[i] = fibArray[i - 1] + fibArray[i - 2]; sum += fibArray[i]; &#125; return sum;&#125; 方法四：更绝的规律，直接求后两项的fib，然后减1即得。 1234567private static int fibSum4(int n) &#123; if (n &lt; 2) &#123; return n; &#125; int f = fib(n + 2); return f - 1;&#125; LRU Cache(146) 模拟Least Recently Used缓存，当要插入新的entry(key, value)时规模不够，最近最少用到的entry会被清除。要求get和put都是O(1)。 由于有键值对，肯定要有Map。key是整数，而put的时候，value不能真的存给的整数value，而是存双向链表中的一个节点，该节点的val再存给定的整数value。put还需要考虑是否是更新，更新则要把原节点val更新后拖到头部；在get的时候，也要注意拖到链表头部。当需要移除最近最少使用元素的时候，就需要把最后一个节点删掉，同时在map中删掉，所以链表节点中还需要存key才能去map中删。双向链表根据节点来删除是O(1)的，因为可以直接访问前后两个节点（单向链表提供待删除节点和它前一个节点也可以做到constant time）。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public class LRUCache &#123; private class DoublyListNode &#123; int key; int value; DoublyListNode prev; DoublyListNode next; private DoublyListNode(int key, int value) &#123; this.key = key; this.value = value; &#125; &#125; int capacity; int currSize; DoublyListNode head, tail; HashMap&lt;Integer, DoublyListNode&gt; map; public LRUCache(int capacity) &#123; this.capacity = capacity; map = new HashMap&lt;Integer, DoublyListNode&gt;(); currSize = 0; head = new DoublyListNode(0, 0); // 伪头部 tail = new DoublyListNode(0, 0); // 伪尾部 head.prev = null; head.next = tail; tail.prev = head; tail.next = null; &#125; public int get(int key) &#123; DoublyListNode node = map.get(key); if (node != null) &#123; moveToFirst(node); return node.value; &#125; else &#123; return -1; &#125; &#125; public void put(int key, int value) &#123; DoublyListNode node = map.get(key); if (node == null) &#123; node = new DoublyListNode(key, value); currSize++; if (currSize &gt; capacity) &#123; currSize--; map.remove(popLast().key); // 尾部的 &#125; add(node); map.put(key, node); &#125; else &#123; node.value = value; moveToFirst(node); &#125; &#125; private void add(DoublyListNode node) &#123; DoublyListNode nextOfHead = head.next; head.next = node; // 插入到头部的下一位，需要调整头指针的指向 node.prev = head; nextOfHead.prev = node; node.next = nextOfHead; &#125; private void remove(DoublyListNode node) &#123; DoublyListNode prevOfNode = node.prev; DoublyListNode nextOfNode = node.next; prevOfNode.next = nextOfNode; nextOfNode.prev = prevOfNode; &#125; private DoublyListNode popLast() &#123; DoublyListNode last = tail.prev; remove(last); return last; &#125; // 被get了，就需要挪到头部，先删除再插入到头部即可 private void moveToFirst(DoublyListNode node) &#123; remove(node); add(node); &#125;&#125;/** * Your LRUCache object will be instantiated and called as such: * LRUCache obj = new LRUCache(capacity); * int param_1 = obj.get(key); * obj.put(key,value); */ 扫雷(529) 点击一个位置，根据是否有雷更新棋盘。如果是雷，直接改成叉叉并返回；如果没有点开并且周围八个相邻格子有雷，则改成雷的数目并返回；如果周围都没有雷，就扩散到相邻格子继续更新。 方法一：根据描述本身就蕴含了递归，所以自然想到DFS。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123; public char[][] updateBoard(char[][] board, int[] click) &#123; if (board == null || board.length == 0 || board[0].length == 0 || click == null || click.length &lt; 2) &#123; return new char [0][0]; &#125; int rowCount = board.length, colCount = board[0].length; int row = click[0], col = click[1]; if (board[row][col] == 'B') &#123; // 已经点开了就直接返回 return board; &#125; if (board[row][col] == 'M') &#123; // 是雷就gg board[row][col] = 'X'; &#125; else &#123; int count = 0; // 计算雷的个数 for (int i = -1; i &lt; 2; i++) &#123; int tempRow = row + i; if (tempRow &lt; 0 || tempRow &gt;= rowCount) &#123; continue; &#125; for (int j = -1; j &lt; 2; j++) &#123; int tempCol = col + j; if (tempCol &lt; 0 || tempCol &gt;= colCount) &#123; continue; &#125; if (board[tempRow][tempCol] == 'M') &#123; count++; &#125; &#125; &#125; if (count &gt; 0) &#123; board[row][col] = (char)('0' + count); &#125; else &#123; board[row][col] = 'B'; // 改为已经reveal，并扩散到周围unreveal的邻居 for (int i = -1; i &lt; 2; i++) &#123; int tempRow = row + i; if (tempRow &lt; 0 || tempRow &gt;= rowCount) &#123; continue; &#125; for (int j = -1; j &lt; 2; j++) &#123; int tempCol = col + j; if (tempCol &lt; 0 || tempCol &gt;= colCount) &#123; continue; &#125; if (board[tempRow][tempCol] == 'E') &#123; // DFS the unrevealed updateBoard(board, new int[]&#123;tempRow, tempCol&#125;); &#125; &#125; &#125; &#125; &#125; return board; &#125;&#125; 方法二：BFS，Queue中存放点击之后扩散的点（如果有的话），一直扩散直到Queue为空。但是和DFS需要区别的是，由于BFS会将相邻的所有E的格子都入队，很可能会出现重复，所以就直接在更新时就赋值为B，防止重复入队。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution &#123; public char[][] updateBoard(char[][] board, int[] click) &#123; if (board == null || board.length == 0 || board[0].length == 0 || click == null || click.length &lt; 2) &#123; return new char [0][0]; &#125; Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;(); int rowCount = board.length, colCount = board[0].length; q.add(click); while (!q.isEmpty()) &#123; int[] curr = q.poll(); int row = curr[0], col = curr[1]; // 和DFS相比少了判断为B的步骤 if (board[row][col] == 'M') &#123; board[row][col] = 'X'; &#125; else &#123; int count = 0; for (int i = -1; i &lt; 2; i++) &#123; int tempRow = row + i; if (tempRow &lt; 0 || tempRow &gt;= rowCount) &#123; continue; &#125; for (int j = -1; j &lt; 2; j++) &#123; int tempCol = col + j; if (tempCol &lt; 0 || tempCol &gt;= colCount) &#123; continue; &#125; if (board[tempRow][tempCol] == 'M') &#123; count++; &#125; &#125; &#125; if (count &gt; 0) &#123; board[row][col] = (char)('0' + count); &#125; else &#123; board[row][col] = 'B'; for (int i = -1; i &lt; 2; i++) &#123; int tempRow = row + i; if (tempRow &lt; 0 || tempRow &gt;= rowCount) &#123; continue; &#125; for (int j = -1; j &lt; 2; j++) &#123; int tempCol = col + j; if (tempCol &lt; 0 || tempCol &gt;= colCount) &#123; continue; &#125; if (board[tempRow][tempCol] == 'E') &#123; // BFS the unrevealed q.add(new int[]&#123;tempRow, tempCol&#125;); board[tempRow][tempCol] = 'B'; // IMPORTANT!!! &#125; &#125; &#125; &#125; &#125; &#125; return board; &#125;&#125; Reverse Integer 给一个整数，求它各个位数字反转后的新的整数。 需要考虑：反转之后越界？末尾是零的话反转到首位怎么表示？ 起始末尾是0如果按照正常数学操作是不用单独考虑的，越界就需要通过每一步与214748364进行比较了，一是防止这一部分就越界了、二是防止后一位加上来之后又越界了（需要分正负判断）。123456789101112131415161718public int reverse(int x) &#123; int ans = 0; while (x != 0) &#123; int curr = Math.abs(ans); if (curr &gt; 214748364) &#123; // 解决反转后越界问题 return 0; &#125; if (curr == 214748364) &#123; // 解决反转后越界问题 int limit = x &lt; 0? 8: 7; if (x / 10 &gt; limit) &#123; return 0; &#125; &#125; ans = ans * 10 + (x % 10); // 更新反转数by加上x当前末尾数 x /= 10; &#125; return ans;&#125; Reverse Bits 给一个数字，反转它对应的bit形式。 此时就不需要考虑什么越界了，因为都是32位，反转了bit也是可以表示出来的。 就从末尾开始通过AND取bit，不断加到result里。注意移位必须是unsigned。 12345678910public int reverseBits(int n) &#123; int result = 0; for (int i = 0; i &lt; 32; i++) &#123; result += n &amp; 1; n &gt;&gt;&gt;= 1; // CATCH: must do unsigned shift if (i &lt; 31) // CATCH: for last digit, don't shift! result &lt;&lt;= 1; &#125; return result;&#125; follow-up：如果这个函数会被反复调用，如何优化？ 优化无非时间空间，空间这里是没啥优化了，那么时间呢？时间优化通常就需要牺牲一点空间，也就是cache中间计算的结果。这里的「中间结果」可以利用bit的规律，将每8 bit（即1 byte）的结果缓存到map中，后续如果碰到了就直接从map中取这部分就好了。123456789101112131415161718192021222324252627public int reverseBits(int n) &#123; byte[] bytes = new byte[4]; for (int i = 0; i &lt; 4; i++) // convert int into 4 bytes bytes[i] = (byte)((n &gt;&gt;&gt; 8*i) &amp; 0xFF); int result = 0; for (int i = 0; i &lt; 4; i++) &#123; result += reverseByte(bytes[i]); // reverse per byte if (i &lt; 3) result &lt;&lt;= 8; &#125; return result;&#125;private final Map&lt;Byte, Integer&gt; cache = new HashMap&lt;Byte, Integer&gt;();private int reverseByte(byte b) &#123; Integer value = cache.get(b); // first look up from cache if (value != null) return value; value = 0; // reverse by bit for (int i = 0; i &lt; 8; i++) &#123; value += ((b &gt;&gt;&gt; i) &amp; 1); if (i &lt; 7) value &lt;&lt;= 1; &#125; cache.put(b, value); return value;&#125; 黑杰克 （不确定题目描述）给一堆扑克牌，1～10是本身面值，JQK是10，而A可以是1也可以是11（同一组牌中只能确定一个取值），求最接近21的组合。例如A,A,J = 12, J,J,A,2 = 23, A,2 = 13。 似乎就是贪心法，先将所有牌加起来，如果没有A就那样，如果有A就先保守地取1并统计A的出现次数，加完之后再比较sum + A_count * 10表示A都取11时的结果，两个取更接近21即可。 三维空间求点 三维空间给定N个点的坐标(x, y, z)，找到N个点其中的一个点，使得其他点到这个点的距离总和最小。 先遍历一遍求所有点的中心点，然后再遍历一遍看看哪个点离中心点最近。 Design tic tac toe(348) XXOO游戏，两个玩家，每一行、每一列、两条对角线都是一样的话，对应玩家就赢了。要设计一个class，其中包含move函数，给坐标和玩家编号，在图里放，如果该玩家赢了就返回玩家编号。每行、每列需要统计两个玩家各自的个数，如果都是其中一个玩家都就赢了，两条对角线也是。 记录行、列、两条对较线。区分两个玩家的O和X就通过正负一来判断，这样如果有一个玩家赢了就意味着一路相加结果是n或者-n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class TicTacToe &#123; private int[] rows; private int[] cols; private int diag1, diag2; private int n; /** Initialize your data structure here. */ public TicTacToe(int n) &#123; rows = new int [n]; cols = new int [n]; diag1 = 0; diag2 = 0; this.n = n; &#125; /** Player &#123;player&#125; makes a move at (&#123;row&#125;, &#123;col&#125;). @param row The row of the board. @param col The column of the board. @param player The player, can be either 1 or 2. @return The current winning condition, can be either: 0: No one wins. 1: Player 1 wins. 2: Player 2 wins. */ public int move(int row, int col, int player) &#123; if (row &lt; 0 || row &gt;= n || col &lt; 0 || row &gt;= n || player &lt; 1 || player &gt; 2) &#123; return 0; &#125; int addVal = player == 1? -1: 1; // for diag1 if (row == col) &#123; diag1 += addVal; if (isConnect(diag1)) &#123; return player; &#125; &#125; // for diag2 if (row + col == n - 1) &#123; diag2 += addVal; if (isConnect(diag2)) &#123; return player; &#125; &#125; // for row rows[row] += addVal; if (isConnect(rows[row])) &#123; return player; &#125; // for col cols[col] += addVal; if (isConnect(cols[col])) &#123; return player; &#125; return 0; &#125; private boolean isConnect(int val) &#123; return val / n != 0; &#125;&#125; Anagrams(49) 给一个String数组，求其中各字符串的anagram，即「相同字符组合的字符串」，并将相同的放在一个List中。 取每个字符串出来，排个序作为key去找map里对应的index，如果存在index就找到ansList中对应index的那一行，插到末尾；如果不存在说明是新的，就把当前ansList的规模作为新的index存入map。1234567891011121314151617181920212223public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; List&lt;List&lt;String&gt;&gt; ans = new ArrayList&lt;&gt;(); if (strs == null || strs.length == 0) &#123; return ans; &#125; Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); for (String str: strs) &#123; char[] sChar = str.toCharArray(); // sort str Arrays.sort(sChar); String newStr = new String(sChar); // the key to get the index in ans if (map.containsKey(newStr)) &#123; int index = map.get(newStr); ans.get(index).add(str); &#125; else &#123; map.put(newStr, ans.size()); List&lt;String&gt; temp = new ArrayList&lt;&gt;(); temp.add(str); ans.add(temp); &#125; &#125; return ans; &#125; Anagramii(438) 给两个字符串，求后者的anagram在前者中子串的所有出现的index。 又是字串问题，考虑双指针。先统计后者的每个字符各出现了几次，并确定有多少个不同的字符。然后双指针从前者头部走起，快指针往后取，直到剩余字符为0，然后慢指针再跟进，碰到map中存在的key就说明当前是anagram其中一个字符，需要加回来，同时判断该字符计数是否从0变成了1，是的话就不能再移慢指针了。此时判断慢指针到快指针之间是不是anagram的长度，是就说明start的index需要放入ans了。12345678910111213141516171819202122232425262728293031323334353637public List&lt;Integer&gt; findAnagrams(String s, String t) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); if (t.length() &gt; s.length()) &#123; // 如果后者比前者还长，根本不可能是anagram return result; &#125; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for(char c : t.toCharArray()) &#123; map.put(c, map.getOrDefault(c, 0) + 1); &#125; int counter = map.size(); // 多少个不同的字符 int begin = 0, end = 0; int head = 0; int len = Integer.MAX_VALUE; while (end &lt; s.length()) &#123; char c = s.charAt(end); if (map.containsKey(c)) &#123; map.put(c, map.get(c) - 1); if (map.get(c) == 0) // 消耗了一个字符 counter--; &#125; end++; while (counter == 0) &#123; char tempc = s.charAt(begin); if (map.containsKey(tempc)) &#123; map.put(tempc, map.get(tempc) + 1); if (map.get(tempc) &gt; 0) &#123; counter++; // 恢复了一个字符 &#125; &#125; if (end - begin == t.length()) &#123; result.add(begin); &#125; begin++; &#125; &#125; return result;&#125; Reverse linked list between m and n 反转链表，给定了范围从m到n。 其实就是从m开始，将最后一个节点插入到前面，逐个反转直到n。1234567891011121314151617181920212223242526public ListNode reverseBetween(ListNode head, int m, int n) &#123; if(head == null) return null; ListNode dummy = new ListNode(0); // create a dummy node to mark the head of this list dummy.next = head; ListNode pre = dummy; // make a pointer pre as a marker for the node before reversing for(int i = 0; i &lt; m - 1; i++) // 直到m的前一位 pre = pre.next; ListNode start = pre.next; // a pointer to the beginning of a sub-list that will be reversed ListNode then = start.next; // a pointer to a node that will be reversed // 1 - 2 -3 - 4 - 5 ; m = 2; n = 4 ---&gt; pre = 1, start = 2, then = 3 // dummy -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 for(int i = 0; i &lt; n - m; i++) &#123; start.next = then.next; // 当前的首位.next指向当前末尾的next then.next = pre.next; // 当前末尾的next改指向前一位的next pre.next = then; // 该前一位指向为当前末尾，完成反转 then = start.next; // 更新当前末尾 &#125; // first reversing : dummy-&gt;1 - 3 - 2 - 4 - 5; pre = 1, start = 2, then = 4 // second reversing: dummy-&gt;1 - 4 - 3 - 2 - 5; pre = 1, start = 2, then = 5 (finish) return dummy.next;&#125; BST中给个target求最接近的值 需要考虑如果树本身为空？接近target的值有两个取大的还是小的？还要注意，target是double而树节点的值都是int！所以需要的话还需要强制转换一下。 方法一：recursive，先取当前节点与target比较，如果大于target就看左子树会不会更接近，否则看右子树。最后与递归结果比较即可。 12345678910public int closestValue(TreeNode root, double target) &#123; if (root == null) return Integer.MAX_VALUE; int currVal = root.val; TreeNode kid = target &lt; currVal ? root.left : root.right; if (kid == null) return currVal; int kidVal = closestValue(kid, target); return Math.abs(currVal - target) &lt; Math.abs(kidVal - target) ? currVal : kidVal;&#125; 方法二：iterative，持续更新root直到空，，一路上不断更新结果。 123456789101112public int closestValue(TreeNode root, double target) &#123; if (root == null) return Integer.MAX_VALUE; int closest = root.val; while (root != null) &#123; if (Math.abs(closest - target) &gt;= Math.abs(root.val - target)) &#123; closest = root.val; &#125; root = target &lt; root.val? root.left: root.right; &#125; return closest;&#125; BST中给个target求其中大于target的最小值。 方法一：recursive，比较当前节点与target，若小于等于，则需要更大的值；若已经大于了，还需要进左子树看看有没有更接近target的。 12345678910public int closestLarger(TreeNode root, double target) &#123; if (root == null) return Integer.MAX_VALUE; int currVal = root.val; if (currVal &lt;= target) &#123; // 当前小于等于目标说明得去右子树找大于的 return cloestLarger(root.right, target); &#125; else &#123; // 当前已经大于目标了，则还要进左子树找大于的，然后取更小的 return Math.min(currVal, closetLarger(root.left, target)); &#125;&#125; 方法二：iterative 1234567891011121314public int closestLarger(TreeNode root, double target) &#123; if (root == null) return Integer.MAX_VALUE; int ans = Integer.MAX_VALUE; while (root != null) &#123; if (root.val &lt;= target) &#123; root = root.right; &#125; else &#123; ans = root.val; root = root.left; &#125; &#125; return ans;&#125; 二叉树根到叶路径和(113) 给一个二叉树和一个目标值，求所有根到叶的路径使经过节点值之和等于target。 路径中会不会出现负数？ 方法一：DFS，从根开始搜索，每次深入之前将target减去当前节点的值。123456789101112131415161718public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); dfs(root, sum, ans, new ArrayList&lt;Integer&gt;()); return ans;&#125;private void dfs(TreeNode root, int sum, List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; curr) &#123; if (root == null) &#123; return; &#125; curr.add(root.val); if (root.val == sum &amp;&amp; root.left == null &amp;&amp; root.right == null) &#123; ans.add(new ArrayList&lt;Integer&gt;(curr)); &#125; else &#123; dfs(root.left, sum - root.val, ans, curr); dfs(root.right, sum - root.val, ans, curr); &#125; curr.remove(curr.size() - 1);&#125; 2sum给一个target，求在数组中能否找到两个数之和等于它。https://leetcode.com/problems/two-sum/description/https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/ 转array189 方法一 1234567891011121314151617181920public class Solution &#123; public void rotate(int[] nums, int k) &#123; if (k &lt; 0) &#123; return; &#125; k = k % nums.length; if (k == 0) &#123; return; &#125; int[] temp = new int [k]; System.arraycopy(nums, nums.length - k, temp, 0, k); System.arraycopy(nums, 0, nums, k, nums.length - k); System.arraycopy(temp, 0, nums, 0, k); &#125; private void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125;&#125; 方法二：123456789101112131415161718192021222324252627全部reverse之后再分两部分reverse。public class Solution &#123; public void rotate(int[] nums, int k) &#123; if (k &lt; 0) &#123; return; &#125; k = k % nums.length; if (k == 0) &#123; return; &#125; reverse(nums, 0, nums.length - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.length - 1); &#125; private void reverse(int[] nums, int start, int end) &#123; while (start &lt; end) &#123; swap(nums, start, end); start++; end--; &#125; &#125; private void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125;&#125; 乘积[238] 给一个数组，求除了当前数字之外剩余数字之积 一：维护左侧乘积和右侧乘积 1234567891011121314151617181920212223public class Solution &#123; public int[] productExceptSelf(int[] nums) &#123; if (nums == null || nums.length &lt; 1) &#123; return new int [0]; &#125; int[] ans = new int [nums.length]; int[] left = new int [nums.length]; int[] right = new int [nums.length]; left[0] = 1; for (int i = 1; i &lt; nums.length; i++) &#123; left[i] = left[i - 1] * nums[i - 1]; &#125; right[nums.length - 1] = 1; for (int i = nums.length - 2; i &gt;= 0; i--) &#123; right[i] = right[i + 1] * nums[i + 1]; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; ans[i] = left[i] * right[i]; &#125; return ans; &#125;&#125; 二：ans初始化为1，left表示 1234567891011121314151617public class Solution &#123; public int[] productExceptSelf(int[] nums) &#123; if (nums == null || nums.length &lt; 1) &#123; return new int [0]; &#125; int[] ans = new int [nums.length]; Arrays.fill(ans, 1); int left = 1, right = 1; for (int i = 0; i &lt; nums.length; i++) &#123; ans[i] *= left; ans[nums.length - 1 - i] *= right; left *= nums[i]; right *= nums[nums.length - 1 - i]; &#125; return ans; &#125;&#125; [299] 123456789101112131415161718192021222324252627public class Solution &#123; public String getHint(String secret, String guess) &#123; if (secret == null || guess == null || secret.length() != guess.length() || secret.length() == 0 || guess.length() == 0) &#123; return "0A0B"; &#125; char[] cSecret = secret.toCharArray(); char[] cGuess = guess.toCharArray(); int[] bucket = new int [10]; int hit = 0, match = 0; for (int i = 0; i &lt; cSecret.length; i++) &#123; if (cSecret[i] == cGuess[i]) &#123; match++; &#125; else &#123; if (bucket[cSecret[i] - '0'] &lt; 0) &#123; hit++; &#125; bucket[cSecret[i] - '0']++; if (bucket[cGuess[i] - '0'] &gt; 0) &#123; hit++; &#125; bucket[cGuess[i] - '0']--; &#125; &#125; return match + "A" + hit + "B"; &#125;&#125; [314] 垂直方向从左到右层级遍历二叉树。1234567891011121314151617181920212223242526272829303132333435363738394041424344public List&lt;List&lt;Integer&gt;&gt; verticalOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (root == null) &#123; return res; &#125; Map&lt;Integer, ArrayList&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); Queue&lt;Integer&gt; cols = new LinkedList&lt;&gt;(); q.add(root); cols.add(0); int min = 0; int max = 0; while (!q.isEmpty()) &#123; TreeNode node = q.poll(); int col = cols.poll(); if (!map.containsKey(col)) &#123; map.put(col, new ArrayList&lt;Integer&gt;()); &#125; map.get(col).add(node.val); if (node.left != null) &#123; q.add(node.left); cols.add(col - 1); min = Math.min(min, col - 1); &#125; if (node.right != null) &#123; q.add(node.right); cols.add(col + 1); max = Math.max(max, col + 1); &#125; &#125; for (int i = min; i &lt;= max; i++) &#123; res.add(map.get(i)); &#125; return res;&#125; [53] Linux命令行awk:分析与处理 对文本进行逐行分段处理，awk &#39;条件类型1{动作1} 条件类型2{动作2}&#39; filename. awk的处理流程是: 读第一行, 将第一行资料填入变量 $0, $1… 等变量中 依据条件限制, 执行动作(awk一次处理是一行, 而一次中处理的最小单位是一个区域) 接下来执行下一行 三个变量：NF: 每一行处理的字段数，NR 目前处理到第几行，FS 目前的分隔符。sed:编辑以行为单位的文本编辑工具，sed可以直接修改档案，sed [-nef] &#39;[动作]&#39; [输入文本] -n : 安静模式, 一般sed用法中, 来自stdin的数据一般会被列出到屏幕上, 如果使用-n参数后, 只有经过sed处理的那一行被列出来. -e : 多重编辑, 比如你同时又想删除某行, 又想改变其他行, 那么可以用 sed -e ‘1,5d’ -e ‘s/abc/xxx/g’ filename -f : 首先将 sed的动作写在一个档案内, 然后通过 sed -f scriptfile 就可以直接执行 scriptfile 内的sed动作 (没有实验成功, 不推荐使用) -i : 直接编辑, 这回就是真的改变文件中的内容了, 别的都只是改变显示. (不推荐使用)动作: a 新增, a 后面可以接字符串, 而这个字符串会在新的一行出现. (下一行) c 取代, c 后面的字符串, 这些字符串可以取代 n1,n2之间的行 d 删除, 后面不接任何东西 i 插入, 后面的字符串, 会在上一行出现 p 打印, 将选择的资料列出, 通常和 sed -n 一起运作 sed -n ‘3p’ 只打印第3行 s 取代, 类似vi中的取代, 1,20s/old/new/ggrep:截取文本搜集工具, 结合正则表达式非常强大.grep [要匹配的内容] [文件名]. -c : 只输出匹配的行 -I : 不区分大小写 -h : 查询多文件时不显示文件名 -l : 查询多文件时, 只输出包含匹配字符的文件名 -n : 显示匹配的行号及行 -v : 显示不包含匹配文本的所有行(我经常用除去grep本身)tail 从文档末尾往前取]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>algorithm</tag>
        <tag>interview</tag>
        <tag>zillow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试代码复习]]></title>
    <url>%2F2017%2F10%2F20%2Finterview_code_repo%2F</url>
    <content type="text"><![CDATA[迎难而上，祝我好运。 1. Two Sum 给定一串整型数组，给一个目标值，求数组中唯一的一对数字，相加得到该目标值。 需要考虑数组中可能有重复项，每个项只能用一次，答案一定存在且唯一。 方法一：用hashmap记录数组中每一个值对应的首次出现的index。然后遍历数组求target减去当前项，看是否在map的key中并且不等于当前索引（只能用一次）。12345678910111213141516171819202122public int[] twoSum(int[] nums, int target) &#123; if (nums == null || nums.length == 0) &#123; return new int[0]; &#125; // take val as key and index as value in the map Map&lt;Integer, Integer&gt; val2Index = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; if (!val2Index.containsKey(nums[i])) &#123; val2Index.put(nums[i], i); &#125; &#125; // take the index of (target - nums[i]) out of map, if exists for (int i = 0; i &lt; nums.length; i++) &#123; int temp = target - nums[i]; if (val2Index.containsKey(temp) &amp;&amp; val2Index.get(temp) != i) &#123; return new int[] &#123;i, val2Index.get(temp)&#125;; &#125; &#125; return new int [0];&#125; 2. Add 2 Num 给两个链表，每个节点是一个反序存放的数字（个-十-百-千-万），输出也是一个链表，每个节点就是那两个输入链表对应节点的值之和。 需要考虑链表是否为空？会否有多余的0开头的节点？链表本身表示的数或者相加之后的结果是否越界都没关系，因为输入本身和结果都用链表表示。 方法一：遍历之。1234567891011121314151617181920212223242526272829303132333435363738394041public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; if (l1 == null) &#123; return l2; &#125; if (l2 == null) &#123; return l1; &#125; ListNode ans = new ListNode(0); ListNode curr = ans; int carry = 0; while (l1 != null &amp;&amp; l2 != null) &#123; int val = l1.val + l2.val + carry; carry = val / 10; val = val % 10; curr.next = new ListNode(val); l1 = l1.next; l2 = l2.next; curr = curr.next; &#125; while (l1 != null) &#123; int val = l1.val + carry; carry = val / 10; val = val % 10; curr.next = new ListNode(val); l1 = l1.next; curr = curr.next; &#125; while (l2 != null) &#123; int val = l2.val + carry; carry = val / 10; val = val % 10; curr.next = new ListNode(val); l2 = l2.next; curr = curr.next; &#125; if (carry &gt; 0) &#123; curr.next = new ListNode(carry); &#125; return ans.next;&#125; 3. Longest substring 给一个字符串，找其中不含重复字符的最长子串的长度。 考虑原字符串是否为null或&quot;&quot;？只含有一个字符？字符交替出现？ 子串问题，优先考虑双指针。右指针不断往后找字符，将字符及对应索引放入map，当发现已经存在key时，先计算目前长度更新到ans中，然后将左指针已到右指针指向字符上一次出现的位置的下一个或者不变（因为可能上一次出现的位置反而回退了）。123456789101112131415161718public int lengthOfLongestSubstring(String s) &#123; if (s == null || s.length() == 0) &#123; return 0; &#125; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); char[] sChar = s.toCharArray(); int left = 0, right = 0, ans = 1; // warning not MIN_VALUE for (right = 0; right &lt; sChar.length; right++) &#123; if (!map.containsKey(sChar[right])) &#123; // first occurance map.put(sChar[right], right); &#125; else &#123; ans = Math.max(ans, right - left); // locate to last occurance left = Math.max(map.get(sChar[right]) + 1, left); // move left. warning not go back map.put(sChar[right], right); // update latest occurance &#125; &#125; return Math.max(ans, right - left); // warning not ans&#125; 4. Median of 2 sorted arrays 给两个int数组，返回二者合并后的中位数。 朴素的做法，逐个merge，然后分奇数、偶数求中位数。注意这里需要返回的是double。时间复杂度Linear,O((m + n)/2)。 1234567891011121314151617181920212223242526272829303132333435public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int len_total = nums1.length + nums2.length; int len_total_half = len_total &gt;&gt; 1; int[] merged = new int [len_total]; int i = 0, j = 0, len = 0; boolean finished = false; while (!finished &amp;&amp; i &lt; nums1.length &amp;&amp; j &lt; nums2.length) &#123; if (nums1[i] &lt; nums2[j]) &#123; merged[len++] = nums1[i++]; &#125; else &#123; merged[len++] = nums2[j++]; &#125; if (len &gt; len_total_half) &#123; finished = true; &#125; &#125; while (!finished &amp;&amp; i &lt; nums1.length) &#123; merged[len++] = nums1[i++]; if (len &gt; len_total_half) &#123; finished = true; &#125; &#125; while (!finished &amp;&amp; j &lt; nums2.length) &#123; merged[len++] = nums2[j++]; if (len &gt; len_total_half) &#123; finished = true; &#125; &#125; if (len_total % 2 == 1) &#123; return merged[len_total_half]; &#125; else &#123; return (double)((merged[len_total_half] + merged[len_total_half-1])/2.0); &#125; follow-up：要求在O(log(m+n))的时间复杂度以内？ 中位数可以把有序数组分成等长的两部分，因此在数组1取i个元素、数组2取j个元素，使得i + j == 剩余数字个数并且满足大小关系1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; if (nums1 == null || nums2 == null) &#123; return 0; &#125; int m = nums1.length, n = nums2.length; if (nums1.length &gt; nums2.length) &#123; // ensure the len of 1 &lt;= 2 return findMedianSortedArrays(nums2, nums1); &#125; // to ensure equality of the two parts after merged, i + j = m - i + n - j int iLo = 0, iHi = m, allMid = (n + m + 1) / 2; // odd: i = j, even: i = j - 1 // i stands for "how many num taken from nums1 as front part" 0 ~ i-1 | i ~ m-1 // j stands for "how many num taken from nums2 as front part" 0 ~ j-1 | j ~ n-1 while (iLo &lt;= iHi) &#123; int i = (iLo + iHi) / 2, j = allMid - i; // nums1[i-1], nums2[j-1] are the largest element of front part of nums1, nums2 // nums1[i], nums2[j] are the smallest of lag part of nums1, nums2 if (i &lt; m &amp;&amp; nums2[j - 1] &gt; nums1[i]) &#123; // i not big enough iLo = i + 1; &#125; else if (i &gt; 0 &amp;&amp; nums1[i - 1] &gt; nums2[j]) &#123; iHi = i - 1; &#125; else &#123; int maxLeft = 0, minRight = 0; if (i == 0) &#123; maxLeft = nums2[j - 1]; &#125; else if (j == 0) &#123; maxLeft = nums1[i - 1]; &#125; else &#123; maxLeft = Math.max(nums1[i - 1], nums2[j - 1]); &#125; if ((m + n) % 2 == 1) &#123; // I think thats why to make (allMid = (n + m + 1)/2) return maxLeft; // -- to make left part always at least no fewer than right &#125; if (i == m) &#123; minRight = nums2[j]; &#125; else if (j == n) &#123; minRight = nums1[i]; &#125; else &#123; minRight = Math.min(nums1[i], nums2[j]); &#125; return (maxLeft + minRight) / 2.0; &#125; &#125; return 0;&#125; ####403. frog-jump 给一个数组表示石头所处的x坐标，青蛙每次只能跳上一次跳跃长度的-1,0,1三种可能，判断能否跳到最后一个石头。 相当于BFS，每个石头处维护一个set存放他可以跳的长度，然后每次都往后跳看看能否有新的石头，有就更新那个石头的可跳长度。123456789101112131415161718192021222324252627282930public boolean canCross(int[] stones) &#123; if (stones.length == 0) &#123; return true; &#125; HashMap&lt;Integer, HashSet&lt;Integer&gt;&gt; map = new HashMap&lt;Integer, HashSet&lt;Integer&gt;&gt;(stones.length); map.put(0, new HashSet&lt;Integer&gt;()); map.get(0).add(1); for (int i = 1; i &lt; stones.length; i++) &#123; map.put(stones[i], new HashSet&lt;Integer&gt;() ); &#125; for (int i = 0; i &lt; stones.length - 1; i++) &#123; int stone = stones[i]; for (int step : map.get(stone)) &#123; int reach = step + stone; if (reach == stones[stones.length - 1]) &#123; return true; &#125; HashSet&lt;Integer&gt; set = map.get(reach); if (set != null) &#123; set.add(step); if (step - 1 &gt; 0) set.add(step - 1); set.add(step + 1); &#125; &#125; &#125; return false;&#125; 249. group-shifted-strings给一个String的数组，要求将其中能通过平移相同offset后相同的字符串group在一起.先根据第一个字母算出与a的offset，然后将后续所有字母都根据这个offset来挪，拼接成key存入map。12345678910111213141516171819202122232425262728public class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupStrings(String[] strings) &#123; List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;List&lt;String&gt;&gt;(); Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;String, List&lt;String&gt;&gt;(); for (String str : strings) &#123; int offset = str.charAt(0) - 'a'; String key = ""; for (int i = 0; i &lt; str.length(); i++) &#123; char c = (char) (str.charAt(i) - offset); if (c &lt; 'a') &#123; c += 26; &#125; key += c; &#125; if (!map.containsKey(key)) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); map.put(key, list); &#125; map.get(key).add(str); &#125; for (String key : map.keySet()) &#123; List&lt;String&gt; list = map.get(key); Collections.sort(list); result.add(list); &#125; return result; &#125;&#125; [Extra][tree]给一个二叉树，和两个节点A，B，找出从A到B的路径，返回结果要求顺序存到一个链表中。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198public class Apple &#123; public static class TreeNode &#123; int val; TreeNode left; TreeNode right; public TreeNode(int val) &#123; this.val = val; &#125; &#125; public static void main(String[] args) &#123; TreeNode root = new TreeNode(0); TreeNode n1 = new TreeNode(1); TreeNode n2 = new TreeNode(2); TreeNode n3 = new TreeNode(3); TreeNode n4 = new TreeNode(4); TreeNode n5 = new TreeNode(5); TreeNode n6 = new TreeNode(6); TreeNode n7 = new TreeNode(7); root.left = n1; root.right = n2; n1.left = n5; n1.right = n6; n2.left = n3; n2.right = n4; n3.left = n7; System.out.println(findPathBetween(root, n2, n5)); &#125; public boolean workBreak(String s, List&lt;String&gt; wordDict) &#123; if (s == null || s.length() == 0 || wordDict == null || wordDict.size() == 0) &#123; return false; &#125; Set&lt;String&gt; wordSet = new HashSet&lt;&gt;(); int maxLen = 0; for (String word: wordDict) &#123; wordSet.add(word); maxLen = Math.max(maxLen, word.length()); &#125; boolean[] dp = new boolean [s.length() + 1]; for (int i = 1; i &lt;= s.length(); i++) &#123; for (int j = i - 1; j &gt;= 0 &amp;&amp; i - j &lt;= maxLen; j--) &#123; if (dp[j] &amp;&amp; wordSet.contains(s.substring(j, i))) &#123; dp[i] = true; break; &#125; &#125; &#125; return dp[s.length()]; &#125; public int firstUniqChar2(String s) &#123; if (s == null || s.length() == 0) &#123; return -1; &#125; char[] sChar = s.toCharArray(); int[] bucket = new int [256]; for (int i = 0; i &lt; sChar.length; i++) &#123; bucket[sChar[i]]++; &#125; for (int i = 0; i &lt; sChar.length; i++) &#123; if (bucket[sChar[i]] == 1) &#123; return i; &#125; &#125; return -1; &#125; public int firstUniqChar1(String s) &#123; if (s == null || s.length() == 0) &#123; return -1; &#125; char[] sChar = s.toCharArray(); int[] bucket = new int [256]; Map&lt;Character, Integer&gt; map = new LinkedHashMap&lt;&gt;(); for (int i = 0; i &lt; sChar.length; i++) &#123; if (bucket[sChar[i]]++ == 0) &#123; map.put(sChar[i], i); &#125; else &#123; map.remove(sChar[i]); &#125; &#125; Iterator it = map.entrySet().iterator(); if (it.hasNext()) &#123; Map.Entry pair = (Map.Entry)it.next(); return (Integer)pair.getValue(); &#125; return -1; &#125; private static TreeNode getLCA(TreeNode root, TreeNode n1, TreeNode n2) &#123; if (root == null) &#123; return null; &#125; if (root == n1 || root == n2) &#123; return root; &#125; TreeNode left = getLCA(root.left, n1, n2); TreeNode right = getLCA(root.right, n1, n2); if (left != null &amp;&amp; right != null) &#123; return root; &#125; if (left == null &amp;&amp; right == null) &#123; return null; &#125; return left == null? right: left; &#125; private TreeNode prev1 = null; private boolean validateBST1(TreeNode root) &#123; if (root == null) &#123; return true; &#125; if (!validateBST1(root.left)) &#123; return false; &#125; if (prev1 != null &amp;&amp; prev1.val &gt;= root.val) &#123; return false; &#125; prev1 = root; return validateBST1(root.right); &#125; private boolean validateBST2(TreeNode root) &#123; if (root == null) &#123; return true; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode prev = null; while (root != null || !stack.isEmpty()) &#123; while (root != null) &#123; stack.push(root); root = root.left; &#125; root = stack.pop(); if (prev != null &amp;&amp; prev.val &gt;= root.val) &#123; return false; &#125; prev = root; root = root.right; &#125; return true; &#125; private boolean validateBST3(TreeNode root) &#123; return dvcq(root, Long.MIN_VALUE, Long.MAX_VALUE); &#125; private boolean dvcq(TreeNode root, long min, long max) &#123; if (root == null) &#123; return true; &#125; if (root.val &lt;= min || root.val &gt;= max) &#123; return false; &#125; return dvcq(root.left, min, Math.min(root.val, max)) &amp;&amp; dvcq(root.right, Math.max(root.val, min), max); &#125; private static String findPathBetween(TreeNode root, TreeNode start, TreeNode end) &#123; if (root == null) &#123; return ""; &#125; TreeNode lca = getLCA(root, start, end); List&lt;TreeNode&gt; pathToStart = new ArrayList&lt;TreeNode&gt;(); findPathTo(lca, start, pathToStart); List&lt;TreeNode&gt; pathToEnd = new ArrayList&lt;TreeNode&gt;(); findPathTo(lca, end, pathToEnd); StringBuilder sb = new StringBuilder(); for (int i = pathToStart.size() - 1; i &gt; 0; i--) &#123; if (sb.length() == 0) &#123; sb.append(pathToStart.get(i).val); &#125; else &#123; sb.append("-&gt;"); sb.append(pathToStart.get(i).val); &#125; &#125; for (TreeNode node : pathToEnd) &#123; sb.append("-&gt;"); sb.append(node.val); &#125; return sb.toString(); &#125; private static boolean findPathTo(TreeNode start, TreeNode end, List&lt;TreeNode&gt; curr) &#123; curr.add(start); if (start == end) &#123; return true; &#125; else &#123; if (start.left != null) &#123; if (findPathTo(start.left, end, curr)) &#123; return true; &#125; &#125; if (start.right != null) &#123; if (findPathTo(start.right, end, curr)) &#123; return true; &#125; &#125; &#125; curr.remove(curr.size() - 1); return false; &#125;&#125; [extra][interval] 给两个interval的数组，求二者overlap的部分. 定义一个endCurr表示当前的结尾，然后取两个数组中start较小的与它比较，如果重合就将start为起点、endCurr为结尾new一个新的interval存入结果，然后更新endCurr（如果比该start处对应的end小了的话） 123456789101112131415161718192021222324public List&lt;Interval&gt; findOverlapping(Interval[] i1, Interval[] i2) &#123; List&lt;Interval&gt; res = new ArrayList&lt;Interval&gt;(); int i = 0; int j = 0; int endCurr = i1[0].start &gt; i2[0].start ? i2[0].start : i1[0].start; while (i &lt; i1.length &amp;&amp; j &lt; i2.length) &#123; if (i1[i].start &gt; i2[j].start) &#123; if (i2[j].start &lt; endCurr) &#123; Interval temp = new Interval(i2[j].start, endCurr); res.add(temp); &#125; endCurr = Math.max(i2[j].end, endCurr); j++; &#125; else &#123; if (i1[i].start &lt; endCurr) &#123; Interval temp = new Interval(i1[i].start, endCurr); res.add(temp); &#125; endCurr = Math.max(i1[i].end, endCurr); i++; &#125; &#125; return res;&#125; Linux命令行awk:分析与处理 对文本进行逐行分段处理，awk &#39;条件类型1{动作1} 条件类型2{动作2}&#39; filename. awk的处理流程是: 读第一行, 将第一行资料填入变量 $0, $1… 等变量中 依据条件限制, 执行动作(awk一次处理是一行, 而一次中处理的最小单位是一个区域) 接下来执行下一行 三个变量：NF: 每一行处理的字段数，NR 目前处理到第几行，FS 目前的分隔符。sed:编辑以行为单位的文本编辑工具，sed可以直接修改档案，sed [-nef] &#39;[动作]&#39; [输入文本] -n : 安静模式, 一般sed用法中, 来自stdin的数据一般会被列出到屏幕上, 如果使用-n参数后, 只有经过sed处理的那一行被列出来. -e : 多重编辑, 比如你同时又想删除某行, 又想改变其他行, 那么可以用 sed -e ‘1,5d’ -e ‘s/abc/xxx/g’ filename -f : 首先将 sed的动作写在一个档案内, 然后通过 sed -f scriptfile 就可以直接执行 scriptfile 内的sed动作 (没有实验成功, 不推荐使用) -i : 直接编辑, 这回就是真的改变文件中的内容了, 别的都只是改变显示. (不推荐使用)动作: a 新增, a 后面可以接字符串, 而这个字符串会在新的一行出现. (下一行) c 取代, c 后面的字符串, 这些字符串可以取代 n1,n2之间的行 d 删除, 后面不接任何东西 i 插入, 后面的字符串, 会在上一行出现 p 打印, 将选择的资料列出, 通常和 sed -n 一起运作 sed -n ‘3p’ 只打印第3行 s 取代, 类似vi中的取代, 1,20s/old/new/ggrep:截取文本搜集工具, 结合正则表达式非常强大.grep [要匹配的内容] [文件名]. -c : 只输出匹配的行 -I : 不区分大小写 -h : 查询多文件时不显示文件名 -l : 查询多文件时, 只输出包含匹配字符的文件名 -n : 显示匹配的行号及行 -v : 显示不包含匹配文本的所有行(我经常用除去grep本身)tail 从文档末尾往前取]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>algorithm</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm reference cheatsheet]]></title>
    <url>%2F2017%2F09%2F04%2Fcheatsheet%2F</url>
    <content type="text"><![CDATA[Some basic ideas of classic problems/algorithms. BinarySearch123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106// without check（看后面那个统一的模版更好）// able to find the first occurance, but not the insert positionprivate int binarySearch(int[] nums, int target) &#123; int left = 0, right = nums.length - 1; while (left &lt; right) &#123; // no '=' int mid = left + (right - left) / 2; if (target &gt; nums[mid]) &#123; left = mid + 1; &#125; else &#123; right = mid; // no '- 1' &#125; &#125; if (nums[left] == target) &#123; return left; &#125; return -1;&#125;// able to find the last occuranceprivate int binarySearch(int[] nums, int target) &#123; int left = 0, right = nums.length - 1; while (left &lt; right) &#123; // no '=' int mid = left + (right - left) / 2 + 1; // biase to right side if (target &lt; nums[mid]) &#123; right = mid - 1; &#125; else &#123; left = mid; &#125; &#125; if (nums[right] == target) &#123; return right; &#125; return -1;&#125;// with checkprivate int binarySearch(int[] nums, int target) &#123; int left = 0, right = nums.length - 1; while (left &lt;= right) &#123; // has '=' here int mid = left + (right - left) / 2; if (target &gt; nums[mid]) &#123; left = mid + 1; &#125; else if (target &lt; nums[mid]) &#123; right = mid - 1; // right move one more backward &#125; else &#123; return mid; &#125; &#125; return -1;&#125;// template from http://fihopzz.blogspot.com/2013/07/enter-post-title-here-binary-search-and.htmlprivate int binarySearchInsertionPos(int[] nums, int target) &#123; int start = -1, end = nums.length; while (end - start &gt; 1) &#123; int mid = start + (end - start) / 2; // invariant relation: nums[start] &lt; target &lt;= nums[end] if (nums[mid] &gt;= target) &#123; end = mid; &#125; else &#123; start = mid; &#125; &#125; return end;&#125;private int binarySearchSqrt(int x) &#123; if (x &lt; 1) &#123; return 0; &#125; long start = -1, end = (long)x + 1; while (end - start &gt; 1) &#123; long mid = start + (end - start) / 2; // invariant condition: start &lt;= target*target &lt; end if (mid &gt; x / mid) &#123; end = mid; &#125; else &#123; start = mid; &#125; &#125; return (int)start;&#125;private int binarySearchFirst(int[] nums, int target) &#123; int start = -1, end = nums.length; while (end - start &gt; 1) &#123; int mid = start + (end - start) / 2; // invariant relation: nums[start] &lt; target &lt;= nums[end] if (nums[mid] &gt;= target) &#123; end = mid; &#125; else &#123; start = mid; &#125; &#125; return end &lt; nums.length &amp;&amp; nums[end] == target ? end : -1;&#125;private int binarySearchLast(int[] nums, int target) &#123; int start = -1, end = nums.length; while (end - start &gt; 1) &#123; int mid = start + (end - start) / 2; // invariant relation: nums[start] &lt;= target &lt; nums[end] if (nums[mid] &lt;= target) &#123; start = mid; &#125; else &#123; end = mid; &#125; &#125; return start &gt;= 0 &amp;&amp; nums[start] == target ? start : -1;&#125; SortSelection Sort 外层循环i从头到尾、内层循环从i往后，每次找最小值所在的index，内层循环结束后和头部swap，这样每次都可以把当前最小值放到最前面。 1234567891011private void selectionSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; int index = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[index]) &#123; index = j; &#125; &#125; swap(arr, i, index); &#125;&#125; Insertion Sort 外层循环i从前往后遍历，内层循环从i往前，每次将相邻的顺序反了的元素swap。 1234567private void insertionSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = i; j &gt; 0 &amp;&amp; arr[j] &lt; arr[j - 1]; j--) &#123; swap(arr, j, j - 1); &#125; &#125;&#125; Shell Sort 插入排序的升级版，循环的interval是从大到小的。排序的本质是消除逆序对，如果增大interval，则一次swap可能会消除更多的逆序对，因此可以突破O(N^2). 1234567891011121314private void shellSort(int[] arr) &#123; int h = 1; while (h &lt; arr.length / 3) &#123; h = 3 * h + 1; &#125; while (h &gt;= 1) &#123; for (int i = h; i &lt; arr.length; i++) &#123; for (int j = i; j &gt;= h &amp;&amp; arr[j] &lt; arr[j - h]; j -= h) &#123; swap(arr, j, j - h); &#125; &#125; h /= 3; &#125;&#125; Bubble Sort 外层循环从头到尾，内层循环从尾到i + 1不断把较小值放到前面。 123456789private void bubbleSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = arr.length - 1; j &gt; i; j--) &#123; if (arr[j] &lt; arr[j - 1]) &#123; swap(arr, j, j - 1); &#125; &#125; &#125;&#125; Bucket Sort 木桶排序牺牲了空间换取速度，达到了O(N)。统计每个值出现的个数，然后依次放回原数组。 12345678910111213private void bucketSort(int[] arr) &#123; int bucket = new int [1000010]; for (int i = 0; i &lt; arr.length; i++) &#123; bucket[arr[i]]++; &#125; int j = 0, k = 0; while (j &lt; arr.length &amp;&amp; k &lt; bucket.length) &#123; while ((bucket[k]--) &gt; 0) &#123; arr[j++] = k; &#125; k++; &#125;&#125; Radix Sort[====TODO====] 基数排序就是根据每个位数字大小，从个位数、十位数、百位数、千位数…存入bucket 12345678910private void radixSort(int[] arr, int radix, int maxLen) &#123; int[] temp = new int [arr.length]; int[] bucket = new int [radix]; for (int i = 0, devide = 1; i &lt; maxLen; i++) &#123; Arrays.fill(bucket, 0); System.arraycopy(arr, 0, temp, 0, arr.length); &#125;&#125; Merge Sort 分治法思想，将两个序列不断拆分，拆到不能再拆后分别排序后合并。归并排序（以及插入排序）是稳定的。 1234567891011121314151617181920212223242526272829303132333435363738public void mergeSort(int[] arr) &#123; partition(arr, 0, arr.length - 1);&#125;private void partition(int[] arr, int start, int end) &#123; if (start &gt;= end) &#123; return; &#125; int mid = (start + end) / 2; partition(arr, start, mid); partition(arr, mid + 1, end); if (arr[mid] &lt; arr[mid + 1]) &#123; return; &#125; merge(arr, start, mid, end);&#125;private void merge(int[] arr, int start, int mid, int end) &#123; int left = start, right = mid + 1, index = start; int[] temp = new int [arr.length]; while (left &lt;= mid &amp;&amp; right &lt;= end) &#123; if (arr[left] &lt; arr[right]) &#123; temp[index++] = arr[left++]; &#125; else &#123; temp[index++] = arr[right++]; &#125; &#125; while (left &lt;= mid) &#123; temp[index] = arr[left++]; &#125; while (right &lt;= end) &#123; temp[index] = arr[right++]; &#125; for (index = start; index &lt;= end; index++) &#123; arr[index] = temp[index]; &#125;&#125; Quick Sort + Shuffle 定义一个pivot值，找到它的位置使得左边都小于等于它、右边都大于等于它，然后再递归到两边去排。最差情况出现在当已经有序的时候，退化成O(N^2)，因为每个pivot都要和后面的比较一波。 12345678910111213141516171819202122232425262728293031323334353637private void shuffle(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; swap(arr, i, Random.nextInt(i + 1)); &#125;&#125;private void quickSort(int[] arr) &#123; quickSort(arr, 0, arr.length - 1);&#125;private void quickSort(int[] arr, int start, int end) &#123; if (start &gt;= end) &#123; return; &#125; int j = partition(arr, start, end); quickSort(arr, start, j - 1); quickSort(arr, j + 1, end);&#125;private int partition(int[] arr, int start, int end) &#123; int left = start, right = end + 1, pivot = arr[start]; while (true) &#123; while (arr[++left] &lt; pivot) &#123; if (left == end) &#123; break; &#125; &#125; while (arr[--right] &gt; pivot) &#123; if (right == start) &#123; break; &#125; &#125; if (left &gt;= right) &#123; break; &#125; swap(arr, left, right); &#125; swap(arr, start, right); // pivot放到它应该放的位置 return right;&#125; Big Integer Calculation123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// https://discuss.leetcode.com/topic/30508/easiest-java-solution-with-graph-explanation/class Multiply &#123; public String multiply(String num1, String num2) &#123; if (num1 == null || num2 == null || num1.length() == 0 || num2.length() == 0) &#123; return ""; &#125; int m = num1.length(), n = num2.length(); int[] result = new int [m + n]; char[] cnum1 = num1.toCharArray(), cnum2 = num2.toCharArray(); // from least significant bit for (int i = m - 1; i &gt;= 0; i--) &#123; for (int j = n - 1; j &gt;= 0; j--) &#123; int mult = (cnum1[i] - '0') * (cnum2[j] - '0'); int first = i + j, second = i + j + 1; int sum = mult + result[second]; // add carry from prev steps result[first] += sum / 10; // accumulate result[second] = sum % 10; // overwrite &#125; &#125; StringBuilder sb = new StringBuilder(); int i = 0; // find the first non-zero item while (i &lt; result.length &amp;&amp; sb.length() == 0 &amp;&amp; result[i] == 0) &#123; i++; &#125; while (i &lt; result.length) &#123; sb.append(result[i++]); &#125; return sb.length() == 0? "0": sb.toString(); &#125;&#125;// https://discuss.leetcode.com/topic/5425/short-and-easy-to-understand-solution?page=1class Power &#123; public double myPow(double x, int n) &#123; if (n == 0 || x == 1) &#123; return 1; &#125; if (n == Integer.MIN_VALUE) &#123; // 防止取负数之后越界 return (1.0 / x) * myPow(x, n + 1); &#125; if (n &lt; 0) &#123; n = -n; x = 1.0 / x; &#125; return (n &amp; 1) != 0 ? x * myPow(x * x, n / 2) : myPow(x * x, n / 2); &#125;&#125; GCD123public int findGcd(int a, int b) &#123; return (a == 0 || b == 0) ? a + b : findGcd(b, a % b);&#125; Union Find 并查集：在UF类中维护一个id数组，这个id表示当前索引的祖宗的索引，若id[idx] = idx说明它本身就是老大，初始时每个元素都是自己的老大。find(p)函数就是返回p的老大的索引，union(p, q)函数就是将索引p和q两伙合并起来，分别找到p和q的老大索引pRoot和qRoot，但是他们谁隶属于谁呢？rank就是在这时候起作用，将rank高的保留，rank低的老大合并到更高的老大那去，若两个老大一样，就随意了，合并后新老大的rank要加加。在UF中还有一个count变量，其实就是算有几个独立老大的，初始时每个1都是老大，而每次成功调用union时count都会减减。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class UF &#123; private int[] id = null; private int[] rank = null; private int count = 0; public UF(char[][] grid) &#123; id = new int [grid.length * grid[0].length]; rank = new int [grid.length * grid[0].length]; for (int i = 0; i &lt; grid.length; i++) &#123; for (int j = 0; j &lt; grid[0].length; j++) &#123; if (grid[i][j] == '1') &#123; count++; &#125; int temp = i * grid[0].length + j; id[temp] = temp; rank[temp] = 0; &#125; &#125; &#125; public int find(int p) &#123; while (id[p] != p) &#123; id[p] = id[id[p]]; p = id[p]; &#125; return p; &#125; public void union(int p, int q) &#123; int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) &#123; return; &#125; if (rank[pRoot] &gt; rank[qRoot]) &#123; id[qRoot] = pRoot; &#125; else if (rank[qRoot] &gt; rank[pRoot]) &#123; id[pRoot] = qRoot; &#125; else &#123; id[pRoot] = qRoot; rank[qRoot] ++; &#125; count--; &#125; public boolean isConnected(int p, int q) &#123; return find(p) == find(q); &#125; public int getCount() &#123; return count; &#125;&#125; BacktrackingSubset(无重复元素)123456789101112131415public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); //Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list , List&lt;Integer&gt; tempList, int [] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; tempList.add(nums[i]); backtrack(list, tempList, nums, i + 1); tempList.remove(tempList.size() - 1); &#125;&#125; Subset(有重复元素)1234567891011121314151617public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i - 1]) continue; // skip duplicates tempList.add(nums[i]); backtrack(list, tempList, nums, i + 1); tempList.remove(tempList.size() - 1); &#125;&#125; Permutations(无重复元素全排列)12345678910111213141516171819public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); // Arrays.sort(nums); // not necessary backtrack(list, new ArrayList&lt;&gt;(), nums); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums)&#123; if (tempList.size() == nums.length) &#123; list.add(new ArrayList&lt;&gt;(tempList)); &#125; else &#123; for (int i = 0; i &lt; nums.length; i++) &#123; if (tempList.contains(nums[i])) continue; // element already exists, skip tempList.add(nums[i]); backtrack(list, tempList, nums); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Permutations(有重复元素全排列)123456789101112131415161718192021public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, new boolean[nums.length]); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, boolean [] used)&#123; if (tempList.size() == nums.length) &#123; list.add(new ArrayList&lt;&gt;(tempList)); &#125; else &#123; for (int i = 0; i &lt; nums.length; i++) &#123; if (used[i] || i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; !used[i - 1]) continue; used[i] = true; tempList.add(nums[i]); backtrack(list, tempList, nums, used); used[i] = false; tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Combinations12345678910111213141516171819202122public class Solution &#123; private void dfs(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; arr, int n, int k, int start) &#123; if (arr.size() == k) &#123; ans.add(new ArrayList(arr)); return; &#125; for (int i = start; i &lt;= n; i++) &#123; arr.add(i); dfs(ans, arr, n, k, i+1); arr.remove(arr.size()-1); &#125; &#125; public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;(); ArrayList&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;(); if (n &lt;= 0) &#123; return ans; &#125; dfs(ans, arr, n, k, 1); return ans; &#125;&#125; combination-sum（无重复元素可重复组合求和）123456789101112131415161718public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, target, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int remain, int start)&#123; if (remain &lt; 0) return; else if (remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else &#123; for (int i = start; i &lt; nums.length; i++)&#123; tempList.add(nums[i]); backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements tempList.remove(tempList.size() - 1); &#125; &#125;&#125; combination-sum（有重复元素不可复用组合求和）12345678910111213141516171819public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, target, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int remain, int start)&#123; if (remain &lt; 0) return; else if (remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else &#123; for (int i = start; i &lt; nums.length; i++)&#123; if (i &gt; start &amp;&amp; nums[i] == nums[i - 1]) continue; // skip duplicates tempList.add(nums[i]); backtrack(list, tempList, nums, remain - nums[i], i + 1); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Stringsubstring palindrome: 516, 647.https://leetcode.com/submissions/detail/121291766/https://leetcode.com/submissions/detail/121292245/ DP State transition: dp[i][j] means taking char from i to j of original string, and check next char if it equals to the leading char of current row. If so, take the previous result dp[i + 1][j - 1] to update. Cached DFS: https://discuss.leetcode.com/topic/78603/straight-forward-java-dp-solution MiscellaneousSet TreeSet，HashSet区别给一个dictionary，能不能放进内存。Trie文本处理]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>algorithm</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Note for LeetCode in Java (301~400)]]></title>
    <url>%2F2017%2F07%2F07%2Fjava_leetcode4%2F</url>
    <content type="text"><![CDATA[刷题。祝我好运。 301. remove-invalid-parentheses 给一个字符串，其中包含小括号和其他一些字符，这些括号可能并不匹配，移除尽可能少的括号使得字符串中的括号能valid，返回所有可能的结果。 ME：这和前面这个求最长匹配的括号子字符串长度有那么一点点相似。回头看了一下求长度，可以用Stack也可以用DP，但是换到这题就陷入了江局。。。 TA：首先看了百事哥的DFS方法，思路是先从左到右根据count判断右括号有没有多，一旦多了（count为负数）就开始尝试删除右括号，尝试的起点是last_j，即上一次删除的索引，重点是当前开始多出来的索引i。从前往后找非连续出现的右括号或者连续的右括号中的第一个，这样就可以保证得到的结果不会重复。但是对于左括号怎么办？那就从右往左再判断一波左括号，答主的做法是直接反转字符串，这样就可以重复使用代码了，当这一波也结束了，就可以把结果反转回来，加入结果List了。模仿了一波写出来是这样。此外还有BFS的方法，从完整的s开始入队，每次poll队首出来，判断是否valid，不valid就用循环尝试删除每一位的括号，并将生成的这些子字符串入队。为了防止重复，用到了Set来存放每一个出现的字符串，如果在Set中出现过就不再入队了。一旦出现了一个合法的，它就是删除最少的括号使之合法的，那么当前这一个level的所有字符串都验证完之后该存的存完之后，就不用继续了。 303. range-sum-query-immutable 给一个int数组，系统会调用rangeSum求两个索引之间的数字和（inclusive）。 ME：用一个cache存从第一个到当前索引的和，要用的时候减一下呗。写出来是这样。 TA：没啥。 304. range-sum-query-2d-immutable 给一个棋盘，求(row1, col1)和(row2, col2)所夹矩形的数字之和。 ME：和上题差不多吧，维护的变成了二维的棋盘，每一格寸的是从左上角到当前位置的元素之和。要求局部之和的时候就减去左边、上面再加回左上角的即可。写出来是这样。 TA：都差不多吧。 306. additive-number 给一个纯数字组成的字符串，判断它是否是additive number字符串，即前后相邻的两个数相加得到下一个数，一路直到最后都符合这种相加的关系。 ME：自己没搞出来。。。 TA：我没有搞清楚的是，只要前两个数确定了，后续数字就都确定了，要做的只是去验证一遍。所以只需要来一波双重循环确定前两个数即可。首先看的是这个方法，两个for的变量分别表示前两个数的长度，于是就确定了前两个数，继续往后check是否符合加法即可。check的时候一旦发现，当前这两个数之和的字符串不是后续字符串的开头（使用startsWith），就不用再检查了，跳出回到双重循环继续穷举前两个数吧。而为了防止越界问题，可以引入import java.math.BigInteger类。另外还有一个挺简洁的recursive方法。 待307. range-sum-query-mutable 相比303，多了一个update(index, value)函数，可以更新原本输入的数组。 ME：一开始就想着直接每次更新的时候O(N)更新对应的sum数组呗，结果超时。毕竟update调用次数和sumRange差不多的话，你这么更新相当于每次都是O(N)的sumRange，那和咸鱼有什么区别？陷入江局。。。感觉进入300题之后基本每题都会陷入江局啊=_= TA： 309. best-time-to-buy-and-sell-stock-with-cooldown 又是这个股票的，相比121那几题多了一天的缓冲期，即出售后必须至少隔一天才能再买。同样是求无限次交易的最大收益。 ME：不会！很气！！连续发烧，状态全无。 TA：看了百事哥的解答终于懂了状态转换是个啥意思。答主给了三种状态，buy, sell和rest，buy就是消耗资金、sell是获得收益。buy[i]要么是继续保持前一天buy[i-1]买入的状态，要么是从两天前卖出sell[i-2]之后再减去当天购买股票要消耗的资金；sell[i]要么是保持前一天sell[i-1]卖出的状态，要么是前一天买入的资金加上今天出手时的价格。这个状态转换还是很清晰的。 310. minimum-height-trees 给一个整数n表示有n个点，再给n-1条边，将其中一个点作为根节点可以变成一个树的样子，求最小高度的树可以以哪些点为根。 ME：不会。。。。。。。。。 TA：又看了百事哥的解答，和大神差距还是很大。思路是，这一坨东西中肯定有至少两个是叶子节点，即只有一个邻接边，每次把这些叶子节点都从它相邻的点的邻接列表中给抹去，相当于把level最低的这些节点从图中删除，然后会形成新的最低层叶子节点，一路遍历一路删，删到最顶上剩余节点一个或两个的时候，就可以输出结果了。邻接表这里用的是ArrayList + Set的形式存放，每次看看List中各个Set的size就知道它是不是叶子节点了。写出来是这样。 311. sparse-matrix-multiplication 给两个二维数组表示的sparse矩阵A和B，其中含有较多的0 element，实现矩阵乘法。 根据矩阵乘法的规律，只有A[i][j]不为0时才去B[j][列数]调取元素相乘并累加到结果矩阵中。123456789101112131415161718192021class Solution &#123; public int[][] multiply(int[][] A, int[][] B) &#123; if (A == null || B == null || A.length == 0 || B.length == 0) &#123; return new int[0][0]; &#125; int m = A.length, n = A[0].length, nB = B[0].length; int[][] AB = new int[m][nB]; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (A[i][j] != 0) &#123; for (int k = 0; k &lt; nB; k++) &#123; if (B[j][k] != 0) &#123; AB[i][k] += A[i][j] * B[j][k]; &#125; &#125; &#125; &#125; &#125; return AB; &#125;&#125; 312. burst-balloons 给一个整数数组表示一系列bonus，吹一个气球就能获得当前bonus乘以左、右相邻的bonus之积，同时该气球就从数组中取走了，然后继续。求最优的顺序使获得的总bonus最多。 ME：不会。。。。。。。。。。 TA：这题又是看百事哥的帖子，毕竟这些题好像还都是他添加的。这个问题首先要考虑哪一步的结果是确定的，因为你抽走了中间的一个数字之后，其左、右元素会并过来，所以不能简单地拆分成左、右两个子问题来做。但是你走到最后，只剩下一个元素的时候，乘积一定就直接是这个bonus了。所以可以用类似于回溯法的思路来思考，给定区间(left, right)，其中left和right位置的bonus不能够被选择/清除，那么中间的某个元素i如果留到最后，它的bonus就是num[left] * num[i] * num[right]，至于剩下其他位置的就需要交给递归(left, i)和(i, right)来做。写出来是这样，用memo二维数组来节省不必要的递归。也可以改写成三重循环的DP，第一重循环从2开始到n，表示区间长度；第二重循环从0开始到n-k，表示起始位置，结束位置直接在循环入口由left + k确定；第三重循环从其实位置的下一位开始，这就是真正更新dp数组的位置了，dp[left][right] = dp[left][i] + dp[i][right] + bonus[i]。写出来是这样的。 313. super-ugly-number 和前面264非常像，只不过把固定的2、3、5改成了一个可自定义的Prime数组。 ME：参考前面的做法搞出来了。定义candidate数组，对应存放prime中每个数可能的倍数形式。而所乘的这个倍数需要来自ugly数组，每一个candidate当前的倍数在ugly中的索引也需要用一个index数组存起来。总的来说执行步骤是，来一波循环找出candidate中最小的那个放入ugly数组，然后在遍历一遍candidate数组找到符合这个最小值的项，根据index去更新。 TA：毕竟我这样每次都来一波循环求最小值并不划算，这个使用PriorityQueue的方法深得我心，自定义了一个Number类，为了让PriorityQueue能排序，需要override一下compareTo函数。这样每次poll出来之后只需要再更新下一个倍数值，直接插入PriorityQueue，之后就可以直接取了。 314. binary-tree-vertical-order-traversal 给一个二叉树，要求进行vertical level traversal， 如果垂直方向是平级的，则从上到下输出。 用Queue + Map解决。要判断垂直方向平级，就利用相对往左、往右移动的步数来判断，对应存到map中。不过事实上可以先走一波求出index的range，然后就可以直接往List里加了，不用额外的map。12345678910111213141516171819202122232425262728293031323334class Solution &#123; int minIndex = 0, maxIndex = 0; public List&lt;List&lt;Integer&gt;&gt; verticalOrder(TreeNode root) &#123; if (root == null) &#123; return new ArrayList&lt;&gt;(); &#125; Map&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); Queue&lt;TreeNode&gt; nodeQueue = new LinkedList&lt;&gt;(); Queue&lt;Integer&gt; indexQueue = new LinkedList&lt;&gt;(); nodeQueue.offer(root); indexQueue.offer(0); while (!nodeQueue.isEmpty()) &#123; TreeNode currNode = nodeQueue.poll(); int currIndex = indexQueue.poll(); maxIndex = Math.max(maxIndex, currIndex); minIndex = Math.min(minIndex, currIndex); map.putIfAbsent(currIndex, new ArrayList&lt;&gt;()); map.get(currIndex).add(currNode.val); if (currNode.left != null) &#123; nodeQueue.offer(currNode.left); indexQueue.offer(currIndex - 1); &#125; if (currNode.right != null) &#123; nodeQueue.offer(currNode.right); indexQueue.offer(currIndex + 1); &#125; &#125; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); for (int i = minIndex; i &lt;= maxIndex; i++) &#123; ans.add(i - minIndex, map.get(i)); &#125; return ans; &#125;&#125; 316. remove-duplicate-letters 给一个只含有小写字母的字符串，要求删除其中重复的字母，且删除后的结果必须lexicographical升序。 ME：不会。。。。。。。。。 TA：看了这个greedy方法感觉怎么这么简单= =。先来一波统计各个字母的出现频数，然后从头往后找当前最小的字母，把它作为第一个并删除后续字符串中的该字母，然后递归继续处理后续字符串。需要注意的是，如果在找最小字母的过程中发现某一个字母已经耗尽了，那么就不能再正常往后找了，因为耗尽的这个字母在后面不会再出现，因此必须以当前找到的最小字母为开头，这样就保证这个耗尽的字母不会被舍弃掉。写出来是这样。还可以使用Stack来存放字母，像这样，若当前字母比栈顶字母小就弹出弹出，直到当前字母能放进去而不比栈顶的大，若栈中已有当前字母（用另一个数组标记）就直接跳过了。此外还有纯iterative的方法，思路是找到每个字母最后一个出现的位置，存入Map。然后遍历Map找到这些索引中的最小值，然后从0到这个最小值之间找最小的字母，并把这个字母从Map中删去，然后从该字母最后一次出现的下一位开始往后，到剩下那些字母中的最小索引位置。 318. maximum-product-of-word-lengths 给一个String的数组，求其中没有重复字母的两个字符串长度之积的最大值。 ME：利用位运算，每一个字母出现则对应位置的bit置为1，然后两两作与运算，如果结果是0说明二者没有重复的字母，把他俩的长度乘一下即可。双重循环求出最大值。写出来是这样。 TA：差不多吧，位运算是最快最方便的了。 319. bulb-switcher 给一个整数n表示灯泡数，按照每一个、每两个…每n个的间隔反转灯泡状态，一开始全关，然后全开，然后隔一个关一个，然后隔两个toggle。。。 ME：一开始老老实实地按题意来做，超时。。。 TA: 没想到这么无聊。因为灯泡最后要能亮着，它经历的操作一定是奇数次，一个数有奇数个因数，那它一定是平方数，所以问题就转换成求n中含有多少个平方数了。写出来就这样。 321. create-maximum-number 给两个一位整数的数组，给一个整数k，要求从两个数组中选取数字组成k位数，使它尽可能大。 ME：不会。。。。。。 TA：又是看了百事哥的解答，思路是根据长度i确定第一个数组能得到的最大数组，然后根据k - i确定第二个数组能得到的最大数组，然后把他俩合并成一个长度为k的数组。主要分成了三个辅助函数。一个是greater，用于比较两个数组组成的数字谁更大，需要找出第一个不同的位置，然后直接判断首个不同的数字谁大。而是maxArray，根据传入的数组和所需的长度，找出最大的一个结果，在外层循环中从第一位遍历到最后一位，在内层取数字时需要与上一位结果进行比较，如果结果还比现在这位数字还小，那把当前数字覆盖掉之前的数字结果就能尽可能大，因此需要回退一波，再继续判断（因此要用while而不能简单地if），当然也不能太贪心一直要取最大的，免得到最后剩下的数字还不够填进去的，因此需要用一个判断n - i + j &gt; k来判断，i为循环变量表示已经从原数组中取到了多少位，j表示结果索引，n为原数组的数字个数，显然剩余数字加上已经取的数字应当大于k才能进行取舍，否则是没得挑的。写出来是这样的。 322. coin-change 给一个数组表示有哪些面值的硬币，然后给一个目标值，求最少用多少枚硬币能达到的这个目标值。 ME：这个很明显的DP，所以我会做，写出来是这样。思路是从前往后更新DP数组，一开始全部初始化为-1表示不可达，dp[i]表示面值为i需要多少枚硬币，显然dp[0]应为0。对coin面值数组排序保证从小到大排列，然后开始从1更新。若i - coin[j] &gt;= 0说明可以从该状态加一枚coin[j]的硬币到达状态i，更新之，否则就可以直接跳出内层循环了，因为再往后看其他面值的coin只会负得更多。最后取dp[amount]即得。 TA：我的是Bottom-up的DP，从无到有累积到目标值。还有一种Top-down的思路，利用递归来直接从目标值往回减。递归的结束条件有两种，一个是target减完成了负数，则不存在，返回0；若target恰好是0，那么直接返回0表示不需要额外添加硬币；还有就是如果在之前的结果中已经计算出了DP的值，直接返回即可。否则就逐个取出coin面值，然后用当前target减去这个面值递归到下一层去看需要多少枚硬币，该结果如果存在，则加一即为当前target所需的硬币数。需要尝试所有面值的硬币来找到最小值。模仿出来是这样。 323. number-of-connected-components-in-an-undirected-graph 给一个n和由0~n-1组成的边，求这些node和edge组成多少个独立的components。 方法一：并查集，指定每一组的祖先，最后再一波遍历看看有多少个root即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123; public int countComponents(int n, int[][] edges) &#123; if (edges == null || edges.length == 0 || edges[0].length == 0) &#123; return n; &#125; int[] id = new int[n]; Arrays.fill(id, -1); for (int i = 0; i &lt; edges.length; i++) &#123; int fromRoot = find(id, edges[i][0]); int toRoot = find(id, edges[i][1]); if (fromRoot != toRoot) &#123; id[fromRoot] = toRoot; &#125; &#125; int ans = 0; for (int i = 0; i &lt; n; i++) &#123; if (id[i] == -1) &#123; ans++; &#125; &#125; return ans; &#125; private int find(int[] id, int p) &#123; while (id[p] != -1) &#123; if (id[id[p]] != -1) id[p] = id[id[p]]; p = id[p]; &#125; return p; &#125;&#125;// 更标准的并查集：以每个index作为label判定是否是root，而不是-1；而且最后也不用一波统计了。public int countComponents(int n, int[][] edges) &#123; int[] roots = new int[n]; for(int i = 0; i &lt; n; i++) roots[i] = i; for(int[] e : edges) &#123; int root1 = find(roots, e[0]); int root2 = find(roots, e[1]); if(root1 != root2) &#123; roots[root1] = root2; // union n--; &#125; &#125; return n;&#125;public int find(int[] roots, int id) &#123; while(roots[id] != id) &#123; roots[id] = roots[roots[id]]; // optional: path compression id = roots[id]; &#125; return id;&#125; 方法二：先把图建起来，然后用BFS／DFS来count。 324. wiggle-sort-ii 325. maximum-size-subarray-sum-equals-k 给一个int数组和一个target sum k，求subarray whose sum等于k中的最长长度。 这种根据sum在数组中找xxx的问题，通常都用map。既然我是要通过sum找在数组中的位置，map中存的就是sum-index pair。如果当前累计的sum减去targetSum在map中出现过，说明该index到当前处这部分的和就是targetSum，更新一下maxLen即可。12345678910111213141516171819202122class Solution &#123; public int maxSubArrayLen(int[] nums, int k) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; int sum = 0, maxLen = 0; // 记录从开头到当前index的sum // 需要sum -&gt; index保证通过sum访问index是O(1)时间 Map&lt;Integer, Integer&gt; sum2Index = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; sum += nums[i]; if (sum == k) &#123; maxLen = i + 1; &#125; else if (sum2Index.containsKey(sum - k)) &#123; // 若有说明index~i这段的和就是k maxLen = Math.max(maxLen, i - sum2Index.get(sum - k)); &#125; sum2Index.putIfAbsent(sum, i); &#125; return maxLen; &#125;&#125; 326. power-of-three 给一个int，判断它是否3的幂。 ME：前面231是判断是否2的幂，用while不断乘3判断，写出来是这样。但是题目问能不能不要用循环或递归，在之前的2的幂用的是bit的特点，n &amp; (n - 1)这样搞的，这个我就不知所措了。。 TA：没想到是这样的，直接用int范围内最大的一个3的幂模n，为0就说明n也是3的幂。 328. odd-even-linked-list 给一个链表，要求将奇数位置的节点挪到链表前半部分、偶数的节点放到后半部分。要求in-place且时间复杂度为O(N)。 ME：从前往后遍历一波找到链表最后一个节点作为边界，然后再从头开始处理，把当前节点的后两个节点作为下一个节点，而原本的下一个节点直接丢到链表末尾拼接上去，一直处理直到碰到边界。写出来是这样。 TA：额，你需要先遍历一波找末尾元素这个不太优雅，这个直接新建一个even一个odd然后逐步往后拼的方法更优雅。 329. longest-increasing-path-in-a-matrix 给一个矩阵，求从某一点开始沿上下左右的最长的完美升序路径的长度。 ME：带memory的DFS咯，如果已经访问过该点就直接返回从该点出发的最长升序路径长度，否则就沿上下左右拓展，若大于等于该方向的数直接返回1，否则就返回DFS该方向的结果加1。写出来是这样。 TA：思路差不多，别人的写得更优雅。 330. patching-array 给一个排好序的数组，给一个目标值n，要求通过数组中的这些数字任意组合之和能够覆盖[1, n]这个范围内（含边界的所有数字），若不满足则可以往里加数字，求最少加多少个数字能满足要求。 ME：一开始想到Set的方法，将当前Set中的数字导入Queue之后，逐个取出并加上后续的数字，然后塞进Set中。然后从前往后遍历，如果Set的规模已经达到n就结束，否则找到第一个Set中缺乏的元素，然后加入进去，然后对应再更新Set即通过这个数字加上Set中原本的数字能够得到哪些新的数字。写出来是这样，但是如果n非常大就爆内存了。 TA：又看了这个眼熟大神的方法才恍然大悟。假设给定范围是[1, n]，假设缺的数字为miss，从1开始，从nums数组中取出数字nums[i]，若不大于miss，则[1, miss + nums[i] - 1]范围内都能取到了，下一个缺的数字就更新为miss + nums[i]；但如果nums[i]超过了miss，说明仅凭这些数字没有办法凑出miss，因此就补一个miss，因此可达范围就更新为[1, miss + miss - 1]，下一个缺乏的数字就变成了miss + miss。写出来是这样。 331. verify-preorder-serialization-of-a-binary-tree 给一个二叉树的前序遍历serialize的字符串，判断这个字符串能否还原出一棵二叉树（但不能真的去还原）。 ME：用Stack搞定。将原字符串以逗号分隔，为数字则push(0)，为#则对栈顶数字加一，若达到了2则弹出，并对前一个数字加一。在这个过程中如果栈已经弹空了而节点还没有遍历完成，说明数字有多，不合法。一直到最后如果栈恰好弹空，则完美。写出来是这样。 TA：百事哥还是6。思路是，每一个节点分为两种边，一定有一个in边，若不是空节点则还有两个out边。初始化计数为diff，从第一个节点开始遍历，默认会因为in边减1，再根据#决定是否加上两个out边。 332. reconstruct-itinerary 给一系列机票出发地/目的地的字符串数组，求一条字典序最小的路径能用遍这些机票。 ME：一开始只想到如何取字典序最小，就是HashMap + PriorityQueue的组合，每次给定一个出发机场就能够拿到目的地中的最小者，但是没留意到可能最小的这条路是个死胡同，去了就回不来了、没法遍历全部目的地。没办法，只能老老实实地DFS。为了保证字典序最小，必须先对这些机场排个序再对应赋索引值，这样按顺序从左到右遍历目的地的时候一定是按照字典序从小到大遍历的，那先达到的答案就一定是字典序最小的了。我一开始提交还没有注意到机票可能有重复的，因此直接用了二维boolean作为邻接矩阵，最后改成这样才过了。 TA：卧槽，没想到我一开始的想法确实是可以的，百事哥就是这么搞出来的。在DFS的时候，对于每个起始点都获取它能到达的目的地的PriorityQueue，按顺序取出来就是字典序最小的，poll出来后DFS它。当它所有的目的地都已遍历结束，就把当前的这个字符串addFirst到结果List中，表示是从我出发前往的。只能说，很强。 334. increasing-triplet-subsequence 给一个数组，判断它是否包含长度为3的升序子序列（可以不连续）。要求O(N)的时间复杂度，O(1)的空间。 ME：一波流遍历。每次需要更新最小值min，若当前值大于min，说明这是一个长度为2的升序，接下来只需要找到比结尾数字更大的就是一个长度为3的升序了。但可能往后找的过程中会出现新的min，或者出现比min大同时又比结尾数字小的，都需要更新。写出来是这样。 TA：别人写得更清晰简洁，只需要维护第一个元素small和第二个元素big即可。 335. self-crossing 给一个含有正整数的数组，表示从原点出发，依次沿上下左右走的长度，判断路径是否会交叉。 ME：不会。。。 TA：这题似乎没什么意思，就是找规律。比如这个。 336. palindrome-pairs 给一个字符串数组，求索引对的List使得word[i]和word[j]拼接而成的字符串自对称。 ME：第一反应和前面的214. shortest-palindrome有点像，但那个是在前面拼接最短的字符串使之自对称，但这里不论长短、前后，能使它自对称就OK。然而不会啊。。。 TA：我擦，没想到这样直接暴力破解也可以，写出来是这样。先一波流把每个字符串放到Map中形成字符串袄索引的映射，然后取每个字符串，用内层循环截成前后两个部分，判断是否对称，然后再适当反转后查找是否存在于Map中，对应添加即可。需要注意的是防止重复，可能需要根据长度判断取还是不取。不过其实这题考察的是Trie结构，所以不提倡前面的暴力法，得看这个。 337. house-robber-iii 给一个二叉树，每个节点表示所能抢到的钱财，强盗不能同时抢具有直接父子关系的两个节点。求最大收益。 ME：偷看了这个写出了个最慢最low的无脑递归方法，写出来是这样。反正就是取当前节点加上后左节点的两个孩子和右节点的两个孩子（可能为空），然后与左右孩子递归结果之和做比较，取较大者。不过似乎有重复计算的节点，比较浪费时间，可以用HashMap&lt;TreeNode, Integer&gt;记录下来，不过也不算特别快？ TA：最后的那个方法是记录状态的，有点DP的意思，写出来是这样。利用一个辅助函数，返回数组int[2]，索引0表示不取当前节点的时候的最大收益、1则表示取，对应地就可以求左节点和右节点取和不取的值，对应加一下，最后返回取或不取root的最大值。 338. counting-bits 给一个正整数num，返回size为num + 1的数组，每个位置对应存放该索引的bit形式含有的1的数量。 ME：最naive的方法，遍历一遍，每个都求一次1有多少个，写出来是这样。但是题目问能不能做到one-pass，不要每个都重新求。我就观察出了规律，把2的幂作为分界，后面都依赖于前面（减去这个幂）的结果，写出来是这样，不过速度好慢。。。 TA：原来还可以这么简洁，规律是直接利用除2的索引和是否为奇数来求，写出来是这样.后来还看到了一个用了循环的方法，也是挺6。 339. nested-list-weight-sum 给一个nested的list，根据nested的深度赋予weight，深度深一层weight就加1，求weighted sum。 递归解决。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * public interface NestedInteger &#123; * // Constructor initializes an empty nested list. * public NestedInteger(); * * // Constructor initializes a single integer. * public NestedInteger(int value); * * // @return true if this NestedInteger holds a single integer, rather than a nested list. * public boolean isInteger(); * * // @return the single integer that this NestedInteger holds, if it holds a single integer * // Return null if this NestedInteger holds a nested list * public Integer getInteger(); * * // Set this NestedInteger to hold a single integer. * public void setInteger(int value); * * // Set this NestedInteger to hold a nested list and adds a nested integer to it. * public void add(NestedInteger ni); * * // @return the nested list that this NestedInteger holds, if it holds a nested list * // Return null if this NestedInteger holds a single integer * public List&lt;NestedInteger&gt; getList(); * &#125; */class Solution &#123; public int depthSum(List&lt;NestedInteger&gt; nestedList) &#123; if (nestedList == null || nestedList.size() == 0) &#123; return 0; &#125; return getSum(nestedList, 1); &#125; private int getSum(List&lt;NestedInteger&gt; nestedList, int level) &#123; int sum = 0; for (NestedInteger i : nestedList) &#123; if (i.isInteger()) &#123; sum += level * i.getInteger(); &#125; else &#123; sum += getSum(i.getList(), level + 1); &#125; &#125; return sum; &#125;&#125; 341. flatten-nested-list-iterator 设计题，一个NestedInteger类List的遍历，即List中元素可能为List也可能为Integer，转化成纯Integer的List。 ME：递归把数字都存起来呗，写出来是这样。 TA：这个告诉你还可以用Stack改写成Iterative的，写出来是这样。 342. power-of-four 给一个int，判断它是否4的幂。 ME：这题都不想自己写循环/递归的了，但还是想不出一行的解法。 TA：没想到就只是比2的幂多了一步判断而已，比如这个是利用num - 1一定是3的倍数来搞的，另外就是利用0x55555555来确认bit中的1是否出现在奇数位。 343. integer-break 给一个正整数，将它拆分成至少两个正整数之和，使得这些小正整数之积最大，求这个积。 ME：用了DP，近似于O(N^2)的复杂度，写出来是这样。 TA：没想到还能这样直接找规律，所有这些小整数，只要尽可能多一些3就能使积最大了。 344. reverse-string 反转字符串。 ME：没啥，就这样 TA：没啥。 345. reverse-vowels-of-a-string 反转字符串中的元音字母。 ME：用个set放元音字母，然后一前一后俩指针对换呗，写出来是这样。 TA：没啥。 Set的初始化方法：Set&lt;Character&gt; vowels = new HashSet&lt;&gt;(Arrays.asList(new Character[]{&#39;a&#39;,&#39;e&#39;,&#39;i&#39;,&#39;o&#39;,&#39;u&#39;,&#39;A&#39;,&#39;E&#39;,&#39;I&#39;,&#39;O&#39;,&#39;U&#39;}));，而不用一个个add。 346. moving-average-from-data-stream 求moving average。其实就是维护一个sum，初一下就好了。skip. 347. top-k-frequent-elements 给一个乱序的int数组，给一个k，求这个数组中出现频数前k高的数，要求时间复杂度优于O( N*logN )。 ME：其实不是自己做出来的，看了这个O(N)木桶法，真的叼，写出来是这样。先扫一遍统计各个数值与对应的频数，构建map映射；然后就是木桶排序了，这里的木桶索引的意义是『频数』，存放的是该频数对应的所有数值的List，也就是从map的keySet()遍历各个key的value，根据这个value确定索引，然后把key给add到木桶对应索引的List中。最后再木桶末尾往前取k个即可。 TA：木桶法确实不太好想具体的索引意义，但是用普通的堆你应该是能想到才对，就像这个，priorityQueue或者TreeMap都可以啊。PriorityQueue需要根据map的value从大到小排序，才能保证队首拿的是频数最高的，而TreeMap可以任意从头从尾取，所以默认的话就是从小到大，从尾取即可。 Map遍历用keySet()获得key的集合，再for-each逐个取吧。Map在put的时候可以用getOrDefault(key, defalutValue)来省去判断containsKey的单独的if。 348. design-tic-tac-toe XXOO游戏，两个玩家，每一行、每一列、两条对角线都是一样的话，对应玩家就赢了。要设计一个class，其中包含move函数，给坐标和玩家编号，在图里放，如果该玩家赢了就返回玩家编号。每行、每列需要统计两个玩家各自的个数，如果都是其中一个玩家都就赢了，两条对角线也是。 记录行、列、两条对较线。区分两个玩家的O和X就通过正负一来判断，这样如果有一个玩家赢了就意味着一路相加结果是n或者-n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class TicTacToe &#123; private int[] rows; private int[] cols; private int diag1, diag2; private int n; /** Initialize your data structure here. */ public TicTacToe(int n) &#123; rows = new int [n]; cols = new int [n]; diag1 = 0; diag2 = 0; this.n = n; &#125; /** Player &#123;player&#125; makes a move at (&#123;row&#125;, &#123;col&#125;). @param row The row of the board. @param col The column of the board. @param player The player, can be either 1 or 2. @return The current winning condition, can be either: 0: No one wins. 1: Player 1 wins. 2: Player 2 wins. */ public int move(int row, int col, int player) &#123; if (row &lt; 0 || row &gt;= n || col &lt; 0 || row &gt;= n || player &lt; 1 || player &gt; 2) &#123; return 0; &#125; int addVal = player == 1? -1: 1; // for diag1 if (row == col) &#123; diag1 += addVal; if (isConnect(diag1)) &#123; return player; &#125; &#125; // for diag2 if (row + col == n - 1) &#123; diag2 += addVal; if (isConnect(diag2)) &#123; return player; &#125; &#125; // for row rows[row] += addVal; if (isConnect(rows[row])) &#123; return player; &#125; // for col cols[col] += addVal; if (isConnect(cols[col])) &#123; return player; &#125; return 0; &#125; private boolean isConnect(int val) &#123; return val / n != 0; &#125;&#125; 349. intersection-of-two-arrays 给两个数组，求其中重复的项（交集），重复出现的只算一个。 ME：用hashSet搞定。 TA：其实有三种方法，后两种都是需要排序之后再操作。一个是排序后用俩指针挪动判断，一个是排序后用二分查找在第一个数组中搜索第二个数组的每个数字。 350. intersection-of-two-arrays-ii 给两个数组，求其中重复的项，只要重复就放进数组，不用管重不重复。 ME：hashmap统计一波各个数字出现的频数，然后从第二个数字取数字，匹配到就放到List中并将map中的频数减1.写出来是这样。 TA：题目有follow-up问题，如果排好序可以直接分别遍历两个数组去判断；如果数组规模太大无法一次性加载到内存中，这里有个办法就是external sort，然后每次只需要读进来两个数字就好了。 352. data-stream-as-disjoint-intervals 自定义了类Interval，给一个数组作为data stream，要求把它转化成Interval的List。 ME：直觉就是二分查找，但是。。。木有自己写出来。 TA：TreeMap来处理Interval边界问题。TreeMap的key是每个interval的起始点，新来的一个val可以在treeMap中找到小于它、大于它的key。分情况讨论，val可能可以恰好把前后两个interval连起来、可能落在前面的区间内/区间后方一位、可能落在后面的区间的前方一位（不可能在区间内，否则lowerKey就是后面这个区间了）、也可能就是独立的一个val。TreeMap的lowerKey, higherKey, put, remove都是O(logN)的。123456789101112131415161718192021222324252627282930class SummaryRanges &#123; private TreeMap&lt;Integer, Interval&gt; treeMap; /** Initialize your data structure here. */ public SummaryRanges() &#123; treeMap = new TreeMap&lt;&gt;(); &#125; public void addNum(int val) &#123; if (treeMap.containsKey(val)) &#123; return; &#125; Integer lower = treeMap.lowerKey(val); Integer higher = treeMap.higherKey(val); if (lower != null &amp;&amp; higher != null &amp;&amp; treeMap.get(lower).end + 1 == val &amp;&amp; val + 1 == higher) &#123; treeMap.get(lower).end = treeMap.get(higher).end; // merge前后两段 treeMap.remove(higher); &#125; else if (lower != null &amp;&amp; treeMap.get(lower).end + 1 &gt;= val) &#123; treeMap.get(lower).end = Math.max(treeMap.get(lower).end, val); &#125; else if (higher != null &amp;&amp; val + 1 == higher) &#123; treeMap.put(val, new Interval(val, treeMap.get(higher).end)); treeMap.remove(higher); &#125; else &#123; treeMap.put(val, new Interval(val, val)); &#125; &#125; public List&lt;Interval&gt; getIntervals() &#123; return new ArrayList&lt;&gt;(treeMap.values()); &#125;&#125; 353. design-snake-game 模拟贪吃蛇游戏，给两个int表示grid大小，给一个food数组表示每次吃完食物之后下一个食物出现的坐标，保证不会出现在贪吃蛇的路径上。每次调用一次move函数，给定移动方向，返回移动之后的分数，若挂了就返回-1. 移动本身不难，难点一是如何维护蛇本身，由于需要在头部增加点、在尾部删除点（若吃到食物则尾部不删除），需要从两头操作，因此想到Deque；二是如何判断蛇有没有hit到自身，通过重写equal和hash函数就可以将自定义的Point类丢进Set中。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182class SnakeGame &#123; class Point &#123; int row, col; public Point(int row, int col) &#123; this.row = row; this.col = col; &#125; @Override public boolean equals(Object o) &#123; if (o instanceof Point) &#123; Point that = (Point) o; return this.row == that.row &amp;&amp; this.col == that.col; &#125; else &#123; return false; &#125; &#125; public int hashCode() &#123; return Objects.hash(row, col); &#125; &#125; int rowTotal, colTotal, score; Deque&lt;Point&gt; snake; Set&lt;Point&gt; body; int[][] food; /** Initialize your data structure here. @param width - screen width @param height - screen height @param food - A list of food positions E.g food = [[1,1], [1,0]] means the first food is positioned at [1,1], the second is at [1,0]. */ public SnakeGame(int width, int height, int[][] food) &#123; this.rowTotal = height; this.colTotal = width; this.food = food; this.score = 0; this.snake = new LinkedList&lt;&gt;(); this.body = new HashSet&lt;&gt;(); snake.addFirst(new Point(0, 0)); body.add(snake.peekFirst()); &#125; /** Moves the snake. @param direction - 'U' = Up, 'L' = Left, 'R' = Right, 'D' = Down @return The game's score after the move. Return -1 if game over. Game over when snake crosses the screen boundary or bites its body. */ public int move(String direction) &#123; Point head = snake.peekFirst(); Point nextHead = null; if (direction.equals("U")) &#123; nextHead = new Point(head.row - 1, head.col); &#125; else if (direction.equals("D")) &#123; nextHead = new Point(head.row + 1, head.col); &#125; else if (direction.equals("L")) &#123; nextHead = new Point(head.row, head.col - 1); &#125; else if (direction.equals("R")) &#123; nextHead = new Point(head.row, head.col + 1); &#125; // System.out.println(nextHead.row + ", " + nextHead.col + " " + checkOutBound(nextHead) + " " + hitSelf(nextHead)); if (nextHead == null || checkOutBound(nextHead) || hitSelf(nextHead)) &#123; return -1; &#125; if (score &lt; food.length &amp;&amp; nextHead.row == food[score][0] &amp;&amp; nextHead.col == food[score][1]) &#123; score++; &#125; else &#123; Point tail = snake.pollLast(); body.remove(tail); &#125; snake.addFirst(nextHead); body.add(nextHead); return score; &#125; private boolean checkOutBound(Point p) &#123; return p.row &lt; 0 || p.row &gt;= rowTotal || p.col &lt; 0 || p.col &gt;= colTotal; &#125; private boolean hitSelf(Point p) &#123; return !p.equals(snake.peekLast()) &amp;&amp; body.contains(p); &#125;&#125; 354. russian-doll-envelopes 给一个数组，存放的是各个信封的规格，要让信封能套进去必须长和宽都小于外面的信封，求最多可以有多少个信封套在一起。 ME：搞了半天没搞出来，各种WA。 TA：这个利用Arrays.binarySearch的方法真的给力。Arrays.binarySearch方法的定义可以看这里 )，有一个很叼的地方是这个二分查找在搜索不到key的情况下会返回- 插入索引 - 1，这样就可以直接知道往哪里插入了。算法总思路是，先根据信封的[0]从小到大排序，[0]相等的情况下[1]大的排在前面。然后遍历原数组，根据[1]去二分查找DP数组，找不到就更正index为最小的大于目标值的索引，然后直接覆盖或插入，最后返回DP的有效长度即可。写出来是这样。还有一个完全暴力的方法，我一开始就打算这么搞的不过没有注意到更新的时候需要Math.max一下，正解写出来是这样。还有个大神提出信封在现实中肯定可以旋转之后塞进去，挺有意思。 Arrays.sort自定义排序参考了这个，传入第二个参数(a, b) -&gt; { if return xxx }。 355. design-twitter 设计题，模拟twitter的发推、关注、取关操作，以及对于给定用户返回最近10条应当显示的推文id。 ME：用Map存储用户id和关注的其他用户的Set，然后自定义一个推文类，用个List存总的timeline，没有删除推文省事很多。写出来是这样。 TA：好吧，每次我调取给定用户应显示的最近十条推文的方法很低效，因为是直接遍历总的timeline然后判断是否是当前用户关注的对象。这里有个看起来很6的设计。它给每个Tweet设置一个时间戳，这样就可以判断谁先谁后了。然后每个用户发送Tweet的时候放在该用户对象的Tweet的链表的头部。在取feed的时候就将每个用户follow的用户的Tweet链表头放到PriorityQueue中（排序规则是时间戳大的在前），然后往外取的时候同时把Tweet的next再插入PriorityQueue，这样就可以保持时间戳大的、且是follow用户发的推文先被取出。 357. count-numbers-with-unique-digits 给一个非负整数n，求在[0, 10^n)范围内有多少个数的各位数字各不相同。 ME：一开始总想着怎么减出结果，后来还是偷看了discuss。。。 TA：这个告诉你，直接用排列组合的思路不就好了嘛！第一位是1~9九个数字，第二位就是0~9减去第一位用掉的数字还剩九个数字，第三位是八个数字，以此类推。写出来是这样。当然还有用回溯法的，用一个used表示是否用了索引对应的数字。 358. rearrange-string-k-distance-apart 给一个只含有小写字母的字符串，再给一个长度k，求其中相同字符串每隔k个才出现的版本。例如s = &quot;aabbcc&quot;, k = 3，整理后就是abcabc. greedy可破。先统计每个字母的出现频数，然后塞入PriorityQueue每次取（consume）频数最高的拼接上去，同时将用掉的这个字符暂存到另一个waitQueue中，之后当用足了长度k，再从waitQueue中取（produce）放回pq。12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public String rearrangeString(String s, int k) &#123; if (s == null || s.length() == 0) &#123; return ""; &#125; if (k == 0) &#123; return s; &#125; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; s.length(); i++) &#123; char c = s.charAt(i); if (!map.containsKey(c)) &#123; map.put(c, 1); &#125; else &#123; map.put(c, map.get(c) + 1); &#125; &#125; PriorityQueue&lt;Map.Entry&lt;Character, Integer&gt;&gt; q = new PriorityQueue&lt;&gt;((a, b) -&gt; &#123; return b.getValue() != a.getValue()? b.getValue() - a.getValue() : a.getKey() - b.getKey(); &#125;); q.addAll(map.entrySet()); Queue&lt;Map.Entry&lt;Character, Integer&gt;&gt; waitQueue = new LinkedList&lt;&gt;(); StringBuilder sb = new StringBuilder(); while (!q.isEmpty()) &#123; Map.Entry&lt;Character, Integer&gt; entry = q.poll(); sb.append(entry.getKey()); entry.setValue(entry.getValue() - 1); waitQueue.offer(entry); if (waitQueue.size() &lt; k) &#123; continue; &#125; Map.Entry&lt;Character, Integer&gt; next = waitQueue.poll(); if (next.getValue() &gt; 0) &#123; q.add(next); &#125; &#125; return sb.length() == s.length()? sb.toString() : ""; &#125;&#125; 359. logger-rate-limiter 给一个string和timestamp，判断是否输出， 输出的条件是在10秒内没有输出过。skip。 360. sort-transformed-array 给一个sorted的int数组，给a, b, c并对数组每个元素求a*x^2 + b*x + c，返回排好序的结果，要求时间复杂度O(N)。 如果是二次函数就是个轴对称问题，一开始实现的时候也是按照这个思路先用二分查找来到中间，然后双指针往外扩张，分了很多种情况讨论。但其实更简单的方法是从两边往中间夹逼，而且只需要讨论a是否大于0即可，不需要再针对b有什么操作。1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public int[] sortTransformedArray(int[] nums, int a, int b, int c) &#123; if (nums == null || nums.length == 0) &#123; return new int[0]; &#125; int n = nums.length, left = 0, right = n - 1; int[] ans = new int[n]; int index = a &gt;= 0 ? n - 1 : 0; while (left &lt;= right) &#123; int leftVal = calculate(nums[left], a, b, c); int rightVal = calculate(nums[right], a, b, c); if (a &gt;= 0) &#123; if (leftVal &gt;= rightVal) &#123; ans[index--] = leftVal; left++; &#125; else &#123; ans[index--] = rightVal; right--; &#125; &#125; else &#123; if (leftVal &lt;= rightVal) &#123; ans[index++] = leftVal; left++; &#125; else &#123; ans[index++] = rightVal; right--; &#125; &#125; &#125; return ans; &#125; private int calculate(int x, int a, int b, int c) &#123; return a * x * x + b * x + c; &#125;&#125; 362. design-hit-counter 实现一个hitCount类，通过hit(timestamp)表示在什么时候出现了hit（可能同一时刻有多次hit），然后通过getHits得到最近300s内hit了多少次。 利用循环数组记录hits即可，容量可以直接设为300，这样最多就可以同时记录300s中每一秒的hit数量，在getHis的时候直接遍历一边如何保证每个bucket都是valid的count呢，就需要记录每一个bucket对应的hit的时刻是几时，因此需要另一个time数组来记录。12345678910111213141516171819202122232425262728293031323334class HitCounter &#123; private int[] hits; private int[] time; final private int TIMEWINDOW = 300; /** Initialize your data structure here. */ public HitCounter() &#123; hits = new int [TIMEWINDOW]; time = new int [TIMEWINDOW]; &#125; /** Record a hit. @param timestamp - The current timestamp (in seconds granularity). */ public void hit(int timestamp) &#123; int index = timestamp % TIMEWINDOW; if (time[index] != timestamp) &#123; time[index] = timestamp; hits[index] = 1; &#125; else &#123; hits[index]++; &#125; &#125; /** Return the number of hits in the past 5 minutes. @param timestamp - The current timestamp (in seconds granularity). */ public int getHits(int timestamp) &#123; int count = 0; for (int i = 0; i &lt; TIMEWINDOW; i++) &#123; if (timestamp - time[i] &lt; TIMEWINDOW) &#123; count += hits[i]; &#125; &#125; return count; &#125;&#125; 363. max-sum-of-rectangle-no-larger-than-k 给一个二维int数组，给一个目标值k，求这个矩阵中的子矩阵各项之和不超过k的最大值。 ME：偷看了这个才写出了这个O(N^4)的纯暴力法。先求从左上角到各个位置的和，然后四重循环固定一个位置往右下角遍历求子矩阵之和，取最接近k的值即可。 TA：刚刚这个答案还给出了更高效的办法，利用了TreeSet。同样是先获取左上角到各格的和，然后固定行r1，让r2从r1开始往下遍历各行，在每个r2再遍历每一列c，求出curr = sum[r2][c] - sum[r1 - 1][c]并存入TreeSet。然后最妙的地方出现了，根据curr - k到TreeSet中找『最小的不小于这个值的值』，如果这个值x存在，那么curr - x就是『最大的不大于k的值』，再和ans取个较大值即可。这是因为curr - k &lt;= x，所以curr - x &lt;= k。写出来是这样，妙哉啊妙哉但是为啥反而更慢了？大概是因为用了个更高级的数据结构TreeSet吧。follow-up还有个问题，如果行数比列数多得多怎么破？这个和刚刚的第二个TreeSet方法差不多，有一点点小区别是在第二重循环那里是从r1开始往0递减的，没啥区别其实。但是他在最开始根据行数和列数做了个类似于转置的操作，保证行数能大于列数，在后续的操作中就直接当作行大于列的矩阵操作了。 364. nested-list-weight-sum-ii 和339题目背景类似，只不过这里是反过来，层数约深weight越小，因此在最外层的要根据最深的层数确定weight. 既然需要求最深的深度，就先走一波求最深深度，然后最外层就乘这个weight，然后逐层叠加。 12345678910111213141516171819202122232425262728293031class Solution &#123; public int depthSumInverse(List&lt;NestedInteger&gt; nestedList) &#123; if (nestedList == null || nestedList.size() == 0) &#123; return 0; &#125; int depth = getDepth(nestedList); return getSum(nestedList, depth); &#125; private int getDepth(List&lt;NestedInteger&gt; nestedList) &#123; int maxDepth = 0; for (NestedInteger i : nestedList) &#123; if (i.isInteger()) &#123; maxDepth = Math.max(maxDepth, 1); &#125; else &#123; maxDepth = Math.max(getDepth(i.getList()) + 1, maxDepth); &#125; &#125; return maxDepth; &#125; private int getSum(List&lt;NestedInteger&gt; nestedList, int depth) &#123; int sum = 0; for (NestedInteger i : nestedList) &#123; if (i.isInteger()) &#123; sum += i.getInteger() * depth; &#125; else &#123; sum += getSum(i.getList(), depth - 1); &#125; &#125; return sum; &#125;&#125; 这个weight其实就相当于加多少遍，因此在进入nested下一层的时候，把上一层的sum传进去重复叠加，即可达到weight的效果了。 1234567891011121314151617181920class Solution &#123; public int depthSumInverse(List&lt;NestedInteger&gt; nestedList) &#123; if (nestedList == null || nestedList.size() == 0) &#123; return 0; &#125; return getSum(nestedList, 0); &#125; private int getSum(List&lt;NestedInteger&gt; nestedList, int prevLevelSum) &#123; int sum = prevLevelSum; // 在当前level重复叠加 List&lt;NestedInteger&gt; nextLevel = new ArrayList&lt;&gt;(); for (NestedInteger i : nestedList) &#123; if (i.isInteger()) &#123; sum += i.getInteger(); &#125; else &#123; nextLevel.addAll(i.getList()); &#125; &#125; return nextLevel.size() == 0 ? sum : sum + getSum(nextLevel, sum); &#125;&#125; 365. water-and-jug-problem 给两个整数表示两个水樽的容量，再给一个目标值，判断仅用这两个水樽，通过加满水、清空水、倒到另一个水樽这三个操作能否获得目标值。 ME：一开始想到用带状态记录的DFS，写出来是这样，但是爆内存了。即便我改成用Map&lt;Integer, Set&lt;Integer&gt;&gt;的形式也还是爆。。 TA：这儿有个超时的BFS方法估计和你的思路差不多，不过它报的错是超时，而不是爆内存。正解是用纯数学方法Bezout’s Identity利用最大公约数，比如这个解答，没啥意思。。。 最大公约数的求法要会！12345678int getGCD(int a, int b) &#123; while (b &gt; 0) &#123; int temp = b; b = a % b; a = temp; &#125; return a;&#125; 366. find-leaves-of-binary-tree 给一个二叉树，求一层层仰视时所能看到的节点，看完后删除这些节点后继续仰视下一层。注意不是层级遍历！ 其实就是利用高度的定义，对于每个节点对应地放到它所属的高度的位置即可。123456789101112131415161718class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; findLeaves(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); height(root, ans); return ans; &#125; private int height(TreeNode node, List&lt;List&lt;Integer&gt;&gt; ans) &#123; if (node == null) &#123; return -1; // 保证叶子节点高度为0 &#125; int h = 1 + Math.max(height(node.left, ans), height(node.right, ans)); // 当前节点的高度 = 左右较大者 + 1 if (ans.size() == h) &#123; // 叶子结点高度为0，索引也为0 ans.add(new ArrayList&lt;&gt;()); &#125; ans.get(h).add(node.val); return h; &#125;&#125; 367. valid-perfect-square 给一个int，判断它是否平方数。 ME：二分查找破之，写出来是这样。 TA：这个的第一个解法很有意思，直接用1 + 3 + 5 + 7 + 9...是平方数的特性，逐渐减得结果。此外还有个牛顿法判断平方数，利用公式curr = (curr + (num / curr)) / 2不断更新，最后就根据curr * curr == num来判断是否平方数。这个。。。如果不知道根本不懂呀。 368. largest-divisible-subset 给一个int数组，元素各不相同，求最大的子序列使得其中的元素两两之间x % y == 0或y % x == 0. ME：一开始想的是DFS，先从小到大排个序，然后从前往后看到能模的就深入DFS，写出来是这样。然而超时。。。 TA：没想到给的tag是DP。参考了这个，一下就懂了，dp[i]的意义是『到i为止的最长能整除子序列的长度』。一开始也是先排序，然后先从前往后走一波二重循环，求到每个索引处的满足要求的最长长度，同时找到储存最长长度的那个索引。接着重开一波循环，从最长长度的这个索引开始往前，若可以整除且对应的dp能对得上号，就加入List（不必在意顺序）。写出来是这样。 369. plus-one-linked-list 给一个用链表存储的int，返回将它加1之后的链表。递归解决。skip. 370. range-addition 给一系列[startIndex, endIndex, value]的组成的二维数组，给一个length表示一个长度为length、初始值为0的数组，求经过这一系列操作之后的结果。例如length = 5, updates = [[1, 3, 2],[2, 4, 3],[0, 2, -2]]，返回[-2, 0, 3, 5, 3]。 tricky的做法，用数组本身来标记从当前索引开始应该加什么value。因为[i, j]加value相当于[i, ~]加value同时[j + 1, ~]减value，因此直接在i处标记一个value，在结尾处j标记一个-value即可。注意这里都不能直接赋值，而是需要累加之前的结果。时间复杂度O(K + N).12345678910111213141516171819202122232425class Solution &#123; // [i, j]加value相当于[i, ~]加value同时[j + 1, ~]减value // 因此直接在i处标记一个value，在结尾处j标记一个-value即可 // 最后一波遍历的时候，直接用一个值delta加这些value，直接把delta赋值到对应位置即可 public int[] getModifiedArray(int length, int[][] updates) &#123; int[] ans = new int [length]; if (updates == null || updates.length == 0) &#123; return ans; &#125; for (int[] update : updates) &#123; ans[update[0]] += update[2]; // 标记i为value if (update[1] + 1 &lt; length) &#123; // 标记j + 1为-value ans[update[1] + 1] -= update[2]; &#125; &#125; int delta = 0; for (int i = 0; i &lt; length; i++) &#123; delta += ans[i]; ans[i] = delta; &#125; return ans; &#125;&#125; 371. sum-of-two-integers 不能使用加、减运算符，实现加法运算。 ME：想到了位操作，但一开始这个只适用于正数，负数就WA了。负数的二进制表示是『除了符号位，所有位取反再加1』，位操作还是挺复杂的。。。 TA：看了这个逆天的位操作总结，真的妙哉啊！回顾一下： 求给定数n的二进制表示中的bit为1的个数，不断更新n为n &amp; (n - 1)直到n等于0，所得的计数即是。 12345678int countOne(int n) &#123; int count = 0; while (n &gt; 0) &#123; n = n &amp; (n - 1); count++; &#125; return count;&#125; 判断是否4的幂：跟2的幂判断相比，多了一步判断那个1bit是否在奇数位置上，即AND 0x55555555不为0. 123boolean isPowerOfFour(int n) &#123; return (n &amp; (n - 1)) == 0 &amp;&amp; (n &amp; 0x55555555) != 0;&#125; 求两个整数的和：利用了异或操作『保留不同的bit、置0相同的bit』，在bit的加法中，不同的bit相加一定是1，而相同的bit如果都是0就没事，如果都是1，则需要在左侧产生进位，因此为了获得这个进位还需要对两个数AND一下获得『同为1』的bit，然后左移1形成进位。递归直到进位为0，加法完全结束。 123int getSum(int a, int b) &#123; return b == 0? a: getSum((a ^ b), (a &amp; b) &lt;&lt; 1);&#125; 对于乱序的规模为n的数组，从0~n中选n个数任意放进去，求缺少的那个数：利用索引和元素的对应关系，持续异或，最后没有异或成0的即为结果。 12345678int missingNumber(int[] nums) &#123; int ans = 0, n = nums.length; for (int i = 0; i &lt; n; i++) &#123; ans ^= i; ans ^= nums[i]; &#125; return (ans ^ n);&#125; 求不超过数n的最大的2的幂：利用了取或操作『保留尽可能多的1』，将n的最高位及其右边的位全部置为1，然后加1就来到了最高位的左边，再右移1即得。 123456int largestNumber(int n) &#123; for (int i = 1; i &lt;= 16; i &lt;&lt;= 1) &#123; n = n | (n &gt;&gt; i); &#125; return (n + 1) &gt;&gt; 1;&#125; 前后反转一个32bit无符号数的bit：从原数的最低位开始取bit，如果是1就对应或个Mask到ans中，其中mask持续右移，n也持续右移，这样每次都取最低位事实上就是从最低到最高取n的各个bit。 1234567891011int reverseBits(int n) &#123; int mask = 1 &lt;&lt; 31, ans = 0; for (int i = 0; i &lt; 32; i++) &#123; if (n &amp; 1 != 0) &#123; ans |= mask; &#125; mask &gt;&gt;= 1; n &gt;&gt;= 1; &#125; return ans;&#125; 给一个范围[lo, hi]，求这个范围内所有数的AND的值：其实就是找lo和hi的最长高位相同部分，lo和hi同时向右移，右移的次数用一个count记录下来，直到lo == hi时跳出循环，此时lo或hi左移count位即为所求。 123456789int rangeAND(int lo, int hi) &#123; int count = 0; while (lo != hi) &#123; lo &gt;&gt;= 1; hi &gt;&gt;= 1; count++; &#125; return lo &lt;&lt; count;&#125; 372. super-pow 给一个整数a表示底数，给一个数组形式的超大整数b表示幂，求(a ^ b) % 1337的值。 ME：完全懵逼，这题干啥子咧。。。 TA： 373. find-k-pairs-with-smallest-sums 给两个排好序的递增int数组，要求从两个数组中分别取一个元素出来组成的数对之和小者排在前面，求前k个这样的组合。 ME：一开始又想得太简单，结果并不是用两个索引就可以搞定的。。。 TA：看了这个，直接把数组对象存入优先队列，数对和小的排在前面，同时数组末尾再增添一个索引，表示当前数组第二个数对应到第二个原数组中的索引，这样就可以把后续的继续添加到优先队列中了。写出来是这样。其实挺简单的。。。 数组的初始化可以不用指定规模，而且后面跟的花括号中的元素可以不是const，例如new int[] {i, j, 0}。 374. guess-number-higher-or-lower 给一个整数n表示在[1, n]内找一个未知数字，通过调用guess(num)的返回值来判定当前猜的数大了还是小了，返回最终猜中的结果。 ME：没啥好说的，二分查找搞定。 TA：没啥。 375. guess-number-higher-or-lower-ii 还是给一个整数n，但是这次猜错了就要交对应数目的罚款，求保证猜对的情况下至少要准备多少罚款。 ME：一开始还以为是二分查找，后来发现是个夹逼猜测的策略更有效，但是不懂怎么推广，找不到可以转换成代码的规律呀。。。 TA：这他喵的就是个带有状态记录的DFS嘛，你应该能写出来才对。第一个递归的方法思路是从起始位置遍历到结束位置，在循环过程中确定当前取的数字加入罚款，然后递归求左半边和右半边的罚款，然后求总和，再用一个变量记录当前这一层调用的最小罚款值，循环结束后就将最小罚款值更新到状态记录的二维数组中，这个二维数组其实只用到了右上部分，因为table[i][j]表示从i到j所需要的最少罚款，而i必须小于j。写出来是这样。第二个就是递归的方法，需要三重循环，第一重循环j=[2, j]，表示结束的位置，即状态记录数组当前已更新到的列数；接下来一重递减循环i=[j-1, 1]表示起始位置；最内层循环k=[i+1, j)就是中界了，中界本身的罚款加上左、右两侧的最小罚款就是当前位置的最小罚款了。 376. wiggle-subsequence 给一个int数组，求最长的wiggle子序列，即子序列中的元素一大一小震锯齿形地往后。 ME：直接一个for循环搞定了，写出来是这样。 TA：我的方法算是贪心吧，看这里有个总结，不过他的贪心写得更优雅。 377. combination-sum-iv 给一个不含重复元素的正整数数组，再给一个target，求有多少中组合方式（元素可重复使用）凑成target。 ME：DFS呗，先从小到大排个序，for循环逐个取出来，然后用target减之得到新的target，再递归去求，当刚好新的target为0的时候，就表示这是一种方式，返回1即可；而在循环过程中减出来的新的target小于0，就直接结束循环了，因为排过序之后后续的元素肯定更大，减出来更负。不过一开始没有设置状态记录数组，导致DFS计算了很多重复的情况，引入cache[target]表示目标为target的时候对应的组合数目，若一波循环之后还是0，则设置为负数，表示当前的target访问过且无法组合出来。写出来是这样。 TA：我这个也能算作是DP了吧。不过这个写得更加优雅，因为他是一开始直接将状态数组全部置为-1，而访问的时候则是从0开始递归累加，省去了很多判断。事实上这是个top-down的思路，还有一个bottom-up的思路，也就是二重循环从前往后更新。写出来是这样。 378. kth-smallest-element-in-a-sorted-matrix 求排好序的二维数组中从小到大排在第k个的元素。这里的排好序意思是同一行从左到右递增、同一列从上到下递增。 ME：一开始理解成了从左到右递增同时下一行的比上一行的都大，还觉得这题怎么这么无脑。。结果还是太天真。。。 TA：看了这个才知道要怎么做。第一个是使用最没技术含量的方式，自定义Item类，先将第一行元素全部入优先队列，然后每次取队首即最小元素出来，取它的下方和右方元素入队，为了防止重复入队，我还申请了二维的boolean数组标记，不过按照原po的做法，他只取出队元素的下方元素，就不用考虑重复的问题了。写出来是这样。第二种方法是二分查找，答主总结得很好，二分有两种二分的对象，一个是索引一个是值。这里不能用索引是因为这是两个方向的顺序，没办法形成索引大小关系和实际值之间的一一映射，因此直接对值进行二分，以左上角元素为下界、右下角元素为上界开始查找。不过相比一般的二分查找，在内部还需要两波循环。外层循环从第一行开始向下，内层循环则从最后一列开始向前，要做的是查找共有多少元素小于等于mid值（内层循环条件就是当前元素大于mid值），而由于同一列的元素是从上到下递增的，因此当前元素如果大于mid，则下面的全部都大于mid，直接将内层循环变量向前挪就行了。计算出小于等于mid的元素数目后，与k比较。如果count &lt; k，说明mid还太小，需要提升下界；否则说明mid略大，就需要降低上界。注意不能在count == k的时候就返回mid了，因为这个mid是由lo和hi计算出来的，并不一定存在于原矩阵当中。最后当lo不小于hi时结束查找，返回lo。写出来是这样。 379. design-phone-directory 实现get, check, release函数，分别对应申请一个号码、查询给定号码是否已分配、释放一个号码。 用数组记录是否被占用、用Queue返回可用号码。一开始用Set，其实没必要，因为对号码的顺序没有要求。如果有要求，可用PriorityQueue。写出来是这样. 380. insert-delete-getrandom-o1 设计题，实现一个类似于set的类，要求平均在O(1)的时间内完成插入、删除、随机获取一个值等操作。 ME：这个O(1)的时间要求搞死我。本来想用Set + List + 自定义类搞的，但是卡在了O(1)时间要求这里，而且Set没法获取原本存储在其中的对象了。后来偷看了discuss还是改掉了。 TA：我看的是这个。他用到了Map + List，O(1)的秘诀就是在删除的时候，直接将最后一个元素覆盖到List中要删除的那个元素的位置，然后再删除List的最后一个元素即可。写出来是这样。 java.util.Random类：使用r.nextInt(val)可以获取[0, val)中的一个随机数。Java的随机数实现默认是根据当前时间种子System.currentTimeMillis()生成的，因此每次执行的结果不一样。要想传入特定种子，可以在构造时写成Random((long)seed)，这样每次执行的结果就一样了。 381. insert-delete-getrandom-o1-duplicates-allowed 和上一题相比，允许在自定义的这个Set类中插入相同元素。 ME：我虽然这样做出来了，但是用Queue的方式在remove的时候并不是O(1)的，所以严格来说我自己没有做出来。 TA：还是参考大神的，他把我的Queue给换成了LinkedHashSet，我研究了一下，感觉直接用Set也行，至于访问元素直接用一下set.iterator().next()即可。写出来是这样。 382. linked-list-random-node 给一个链表，实现一个getRandom函数，随机返回一个节点的值，要求每个节点被返回的概率一样。 ME：转成了ArrayList，结合java.util.Random搞定了。写出来是这样。但是follow-up说如果长度过长，且不能使用额外space怎么破？这就触及到我知识的盲区了。。。 TA：事实上这是一个蓄水池抽样问题，中文博客在此，代码在此。假设链表元素为[1, 2, 3]，每次只能读入一个数字。一开始读入1，只能保留它，概率为1；然后读入2，这是1和2之间保留谁的概率就是1/2；然后读入3，此时保留的数字与3只能保留一个，为了保证概率均等，需要在0~2中产生随机数，只有等于2的时候才选择索引为2的元素即3，概率为1/3，而上一步保留的那个数字留下来的概率则是1/2 * 2/3 = 1/3，概率依然相等。这个算法还可以推广到取k个元素出来的情况，这样内存中始终就只有非常少量（k + 1）的数字需要读入了。写出来是这样。 383. ransom-note 写勒索信的时候要从杂志上剪一些字母出来，给勒索信内容字符串和杂志内容字符串，判断能不能拼出来。 ME：用HashMap存字符和对应到杂志中的索引，下次再找这个字母的时候就从map中索引的下一位开始查找。 TA：没注意到题目说只有lowercase的字母，所以可以把map改成数组就好了，像这个。而且他不需要用到String的indexOf查找函数，直接就两波遍历，杂志的字母加、勒索信的字母减，最后只要没有负数就说明可以拼出来。 384. shuffle-an-array design题，实现一个类，传入元素各不相同的int数组后可以生成shuffle后的数组，调用reset还能返回原数组。要求所有可能的答案返回的概率相同。 ME：第一次接触这种shuffle题，我就只是简单地用Random产生随机的index再结合ArrayList的remove功能，取出该索引对应元素后就删掉它。写出来是这样，但感觉ArrayList的remove非常耗时。 TA：看了这个才知道，原来根本就不需要借助ArrayList，直接在数组上操作，至于生成随机数后如何删除，还是前面那个方法——对调法，直接和最后一个元素swap一下，再把生成随机数的区间减小一个，就不会再访问swap到后面的元素了，也就相当于删掉了。写出来是这样，不过怎么还更慢了？ 385. mini-parser design提，又是NestedInteger类，要求从String形式转化成NestedInteger的形式。 ME：用递归的方法搞咯。本来还想着直接用逗号split的，但是[12,[12,23],2,[1,[2,[3,4],5]]]中用逗号分隔会是各个碎片。所以还是得手动找segment，如果是数字就直接转成NestedInteger了，如果有方括号就往后找到结束位置，然后递归求里面的NestedInteger。写出来是这样，出乎意料地快。 TA：大神又用Stack改写成了Iterative的方法。用Stack存放NestedInteger，若为左括号，则将当前的NestedInteger入栈；若为右括号，则先看看前一位是否是正常的数字，是的话就转成NestedInteger加入当前的NestedInteger，再把栈顶元素取出来，把当前元素作为栈顶元素包含的NestedInteger给add进去；若为逗号，则先看看前一位是否是方括号，不是方括号说明前面是正常的数字，直接转就好。 386. lexicographical-numbers 给一个整数n，从1～n按字典序存入List。字典序即先看数字小的在前面，前缀部分相同则长度短的在前面。 ME：感觉明明不难，又是磕磕绊绊持续debug才搞出来。我是用递归搞的，从curr = 1开始，如果curr的十倍依然在范围内就取它的十倍去递归，直到超过n为止，这时就从curr开始往后逐步加1，但是怎么控制加多少个1呢，我用到的是比较前缀法，例如原本进入递归时curr是11，那就要保证我加1的时候除了不能超过n、而且不能超过20，这就需要除一下10来判断前缀部分是否一致了。而在加1之后如果新形成的curr的十倍又符合要求，则继续。写出来是这样。 TA：这里有个iterative的方法，需要精确地找出规律，每一步都直接跳到下一个正确的数字，不太好想。反正就是从1开始，先尝试乘10并放到list中，然后尝试加1直到末位为9，然后就往前回溯到起点，需要找到9左边第一个非9的数字，然后加1继续。我上面的方法应该也算是DFS，这里还有个更简洁明显的DFS，visualize成一个树，每个节点都是需要放入List的数字，然后下一层就是父节点的数乘以10后加上1～9的结果，然后一层层深入下去找，相当于多叉树的前序遍历吧，写出来是这样。 387. first-unique-character-in-a-string 给一个只含有小写字母的字符串，求其中第一个出现的『只出现了一次的字母』的索引。 ME：循环两波，第一波记录各个字母出现的次数，第二波看字母出现的次数为1时就直接输出了。写出来是这样。不过其实里面的index数组多余了。。。 TA：没啥。 388. longest-absolute-file-path 给一个用字符串表示的文件系统目录，求其中的文件（以.xxx结尾的文件）的最长目录长度。 ME：用自定义类加Stack搞咯。自定义类中存放层级数，然后通过\t来计算当前目录的层级数，如果小于等于栈顶的层级数，说明前一部分的文件目录已经结束了，弹出直到栈顶层级小于当前目录层级，然后再入栈。写出来是这样。 TA：我擦，O(N)并不一定是One-pass呀，我是何必呢。而且，不需要自定义类，看看人家这个。思路是利用一个stack数组，stack[i]表示第i - 1层目录的长度，stack[0]为0。利用split将原字符串拆分成String的数组，遍历之，根据每个字符串的\t数目确定level（可以利用lastIndexOf找到最后一个\t的索引），然后到stack[level]取出第level - 1层的长度，加上当前字符串长度，再加上1（后续\n的长度），再减去level（因为最终结果中所有的\t都是不存在的，只有换行变成了斜杠），就得到了当前level的长度。写出来是这样。 389. find-the-difference 给一个只含有小写字母的字符串，打乱他后再随机插入一个小写字母，形成新的字符串，求插入的这个字符。 ME：用Bucket记录字母出现的频数咯，一个加一个减，频数为负的就是插入的咯。写出来是这样。 TA：没啥。 390. elimination-game 给一个正整数n，表示有1~n这么多个数，从左到右从第一个开始隔一个删一个，然后从右往左从第一个隔一个删一个。求最后留下来的那个数。 ME：想了一下，没想出来高效的办法，不可能暴力搞吧。。 TA：看了这个，找规律找得真6.设置一个头元素head，remain表示剩下多少数字，如果剩下一个就直接输出head了。如果是从左到右，那么删完了一波之后第一个元素就是head加上步长。如果是从右到左，就要看剩下的元素数remain的奇偶性了，只有剩下奇数个从右到左的时候才需要更新head。写出来是这样。此外还有一个break down的方法，直接想挺难想出来的。。。还有这个一行递归的，我的天。也是通过找规律搞出来的。 391. perfect-rectangle 给若干个矩形的左下和右上顶点坐标，判断是否可以组成一个完整的矩形。 ME：看到hard就怂了，结果看到别人写的规律感觉并不难。。暗中观察出的rule是：这些点中最左下和最右上的顶点组成的大矩形的面积必须等于这些小矩形的面积之和；同时把每个矩形的四个顶点都求出来，除了最外侧的四个顶点只出现一次，其余点必须恰好出现偶数次。这个抽象真的完美，写出来是这样。 TA：我上面看的就是这个答案，确实很好懂。还有一个略微复杂的方法，用的是sweepline的思想，从左到右定义每个矩形的竖边为event发生的时间点，定义一个class含有time和完整两个点的坐标数组的类，并重写compareTo函数，先根据发生的时间排序、相同则end的边在前。遍历一波将每个矩形的两个Event都放入pq中，并更新y坐标的上届和下界。然后声明一个TreeSet根据y坐标在下的在前，若两个矩形的竖边有重叠则视为相等。然后从pq里取每个时间点的边进行y范围判断并维护一个当前时间点的y长度，如果它是一个end边就直接从yLen中扣除，为开始边泽加上，如果在开始边的时候发现y有重合（TreeSet加入返回false）则直接不行了；结尾边就直接从set中remove掉，不用管end的yLen是因为start总在end前面嘛，start都通过了那end边也一定不重合；然后当前时间点结束后，就看看目前所得的长度是否是最外围的长度，注意如果是最后的end边，这时长度会降到0（正确的情况下），这需要先判断pq是否为空，为空了就说明完全OK，不为空就说明还没到最后，再和最外围的y判断一下。写出来是这样，略慢啊。。 392. is-subsequence 给两个字符串，判断其中一个字符串是否是另一个字符串的子串，这个字串不要求字符连续出现，只要求出现顺序一致且全部出现即可。 ME：一开始想到扫长的扫一遍记录下每个字符在其中出现的位置，然后在较短串（咦好像少了这个判断在开头）中从头到尾各个字符在长串中的出现索引是否能形成从小到大的顺序，但是写出来谜之WA。后来一看这个，嗬，根本不List来记录嘛，直接两个指针分别扫就是了，写出来是这样，不过那个判断长度那里应该放到if里面更好。虽然这么写似乎很不错，速度也很快，但是根据tag，这题考的其实是二分法和DP，follow-up问的是如果有若干个短串需要check而长串特别长的时候，怎么优化。 TA：看了这个发现我原来的方法似乎是可以的，只不过我是线性地往后找大于prev的索引，而二分查找就把这个过程加速了。总结就是先把长串的每个字符出现的位置存入List，然后根据短串的字符取出对应的在长串中出现的索引List，给定二分查找的key pos，如果找到就完美下一位，找不到就是「-(insertion point) - 1」，因此取个负再减1就是该字符在长串中pos后面的最前一位了。写出来是这样。 List数组的声明不能再忘啦！List&lt;Integer&gt;[] list = new List[n]; 394. decode-string 给一个数字 + 中括号 + 字符串的经过encode的字符串，要求以数字作为后续中括号中字符串的频数decode成完整的字符串。 ME：玛德这么简单的题搞了这么半天。。用了双Stack，一个存频数，一个存后续的字符串。当出现数字时进行乘10的累加，并且在嵌套的情况下意味着前面的字符串结束了，push到栈中；当出现左括号时说明前面的数字结束了，push到栈中；出现右括号时先将当前的字符串push到栈中，然后将栈顶的字符串拼接栈顶的频数那么多次，作为当前的字符串。这样一直到最后，留下的当前字符串就是所求了。写出来是这样。 TA：为什么别人写出来的就这么简洁呢。。。这个跟我的思路基本就是一样的，就是这么简洁。我在提交那里还看到了一个递归的方法，利用全局的index控制起始位置，碰到数字的时候直接往后找左括号确定频数，然后就递归到下一层看对应的字符串是什么，然后根据频数不断地拼接即可；遇到右括号就意味着当前的这部分字符串已经到头，break出来直接返回上层即可。写出来是这样. 395. longest-substring-with-at-least-k-repeating-characters 给一个只有小写字母的字符串，再给一个频数，求最长子字符串的长度使得其中字母出现的次数都不少于给定的频数。 ME：束手无策。。 TA：看了这个解释之后，豁然开朗。这是个O(N^2)分治的做法，揪出当前子串中不满足频数要求的字母，排除掉它，然后递归看左右两边子串的情况，直接返回；如果统计好出现次数后发现它们全都符合要求，那就直接返回目前这段的全长即可。写出来就是这样，还是很直接的。还有一种O(N)双指针的做法，思路是用左右两个索引划定出子字符串的区间，再定义「在这个区间中所能出现的不重复的字符数」，这个字符数就是最外层循环的边界1～26，内层就根据给定的频数和这个限制确定挪动左边界还是右边界：先尝试挪动右边界，如果这个字符在这部分字符串中是否出现过（利用count数组统计频数），并看看更新频数后这个频数是否满足了给定最小频数；如果这一波下来发现当前的子字符串中所有出现的字符都满足最小频数，就更新长度；至于什么时候挪动左边界呢？当子字符串中出现的字符数超过外层循环限制时，就需要挪动左边界，同时更新count数组和相关的变量，例如挪出后出现的字符数和满足最小频数的字符数都可能会受到count数组的影响。写出来是这样。 396. rotate-function 定义一个rotate函数，F(0)表示不旋转、F(1)表示后挪一位…函数输出的是各索引的数字乘以索引之和。求从F(0)到F(n-1)中的最大值。 ME：我只想到了暴力法，感觉也不难实现就啥也没管直接试了一发，就是按照函数的定义这样暴力实现出来，讲道理应该是O(N^2)的时间复杂度，我原本都做好了超时的心理准备了，竟然改好WA之后（一开始以为全是正数，就没有把初始值设成最小负数）这样子就过了。不过看了一下，速度是勉强过的那种，说明症结正解还不是这样。 TA：看到discuss版一溜的O(N)，我震惊了。看了这个顿悟，这踏马的是数列问题啊！根据F的公式可以推导出F(k)和F(k-1)的关系，那就可以从F(0)开始逐步往后更新，用到哪更新到哪，每一步都求一个最大值就好了。写出来O(N)这个果然就快很多了。 397. integer-replacement 给一个数字n，如果是偶数则除2，奇数则加1或减1，求最少经过多少步能从n变成1. ME：第一反应就是DP，但直接用n作为dp数组的规模会导致内存爆炸。后来偷看了一下discuss，发现时bit manipulation位操作，于是又暗中观察了一下，找出了规律。对于偶数可以直接右移一位，奇数则需要递归看看加1和减1的偶数的情况。但是第一次提交还是错误，因为Integer.MAX_VALUE边界情况有点奇怪，正常来说只能是前一个偶数的操作数加1，但是这题其实是允许unsigned数字出现的，因此实际上它还可以往后一个偶数2^31递归，这时就只是简单地从31右移到第0位了，因此是1 + 31.不过我还是觉得很怪。。。写出来是这样。 TA：其实我一开始看的是这个但其实没有认真看答主的思路。他的想法是，每步操作都尽量减少1的个数，对于偶数没话说直接unsigned shift，对于奇数就需要判断一下最后一位之前是0还是1，如果是0说明当前数减1是个好选择，如果是1说明当前数加1能消除尽量多的结尾1. 398. random-pick-index 给一个数组，然后给一个目标值，随机返回一个在数组中这个目标值出现的索引。 ME：偷看了一下discuss，发现又是reservior抽样问题，和前面382很像。。先来一遍找出target出现的所有索引并add到List中，然后从前往后生成Random.nextInt来刷新结果，最后返回。懂了之后写出来是这样。 TA：我看的就是这个，答主并没有用到额外的ArrayList，而是巧妙地利用了索引为0的情况。模仿了一下。 399. evaluate-division 用字符串代表一些数值，给出一系列字符串对，再给一系列它们对应相除的结果，然后给一组字符串对，求这些query的相除结果。 ME：Ummm，一开始WA了一波，只能reshape思路了。偷看了一下别人的思路，我才意识到这是一个graph题，可以抽象成一个双向图，每个字符串都作为节点，然后权重就是两个节点的商。我的做法分三步：遍历一遍形成str到index的映射，然后建立邻接矩阵并把权重填充进去（正反都放，不存在就是0），最后就query的时候就用DFS，遍历当前节点所有能走到的节点看看能否到达终点。写出来是这样，没想到出奇地快。 TA：自己会了之后看类似的就不太有动力看了。。这个倒是挺简洁的，而且也提示我，是不是可以对应修改一下matrix中的值？这样下次query就不会重复计算了。 400. nth-digit 给一个正整数n，求1, 2, 3, …这一系列数组组成的连续字符串中的第n个数字。 ME：一开始自己做居然他喵的超时了。。。 TA：还是看了大神的杰作。思路是先根据数字的长度找到要求的这个n所在的数字具体是几位数，一位数有9个，两位数有90个， 三位数有900个…然后在这个范围内求n所在的数字具体是几，这就可以通过定义一个x位数的起始数字往后加的形式求得了，也就是在前面求n所在范围时不断减去一位数、两位数的个数这样，然后到了当前范围内的第n个，就可以用(n - 1) / 几位数来求n在第几个数，加上起始数字就找到了。最后就是看看n在这个数字内部是第几个，那同样是(n - 1) % 几位数就可以找到了。写出来是这样。]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>algorithm</tag>
        <tag>interview</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闲书摘录2017下]]></title>
    <url>%2F2017%2F07%2F01%2Freading_note2017_2%2F</url>
    <content type="text"><![CDATA[摘录各类书中片段，不代表博主观点。《1984》、《美丽的新世界》、《我们》。 《1984》反乌托邦三部曲之一，久闻大名，现在才看。这本书可以合法面向大陆公众出版，所以其中的内容虽然露骨，但确实是官方认可的。作者乔威尔用极尽夸张的手法描述了想象中的极权国家恐怖的氛围，电屏、英社、新话、思想jing察、老大哥、Dang、篡改历史…人们变得完全没有情感，人和人之间没有信任、互相远离却丝毫不觉得孤独，因为只有对老大哥的爱和崇拜，漫无目的的狂热而不知反抗，不相信客观存在的历史…作者乔威尔最后还煞有介事地专门介绍了一波新话。他还总结了作家的四大写作动机：纯粹的个人主义、美学热情、历时冲动和zz目的。 但这种信息存在于何处？仅仅在他自己的意识里，而不管怎样，这种意识肯定不久将被消除。如果其他所有人都接受了党强加的谎言——如果所有档案上都记录着同样的说法——那么谎言就会进入历史并成为事实。“谁掌握历史，”党的标语这样说，“谁就掌握未来；谁掌握现在，谁就掌握历史。”但是过去——即使其性质可以被篡改——从来没被篡改过，现在什么是真实的，永远都真实。很简单，需要的只是不间断地一次次战胜自己的记忆。“现实控制”，这是他们的说法，在新话里叫“双重思想”。 你难道看不出新话的唯一目标就是窄化思想范围吗？到了最后，我们将会让思想罪变得完全不可能再犯，因为没有单词可以表达它。每种必要的概念将被一个单词精确地表达出来，这个单词的意义有严格规定，其他次要意义将被消除，然后被忘掉。 除非他们觉醒，否则永远不会反抗；但除非他们反抗，否则不会觉醒。 有可能人们如今的平均生活水平确实比革命前提高了一点，唯一相反的证据，是你骨头里的无声抗议，那是种本能的感觉，即你对现在的生活状况无法忍受，而在别的某个时期肯定不一样。 他们就像蚂蚁，只看到小的，看不到大的。在记忆已经失灵、文字记录被伪造时——在这些事情发生时，就只能接受党所声称的人们的生活状况已经得到提高，因为没有可资参照的标准。那种标准现在既不存在，以后也永远不会再有。 禁欲和政治正统性之间有着直接和密不可分的关系，因为党想把党员们的恐惧、仇恨和理智尽失的轻信保持在合适水平，除了抑制某种强烈的本能并把它转化成驱动力，又有什么别的办法？ 党强加于人的世界观在无法理解它的人们那里最容易被接受。他们被迫接受最明目张胆的指鹿为马的行径，因为他们从未全面理解对他们犯下的是何等滔天大罪。也因为对天下大事关心不够，他们没注意到正在发生什么事。靠着缺乏理解力，他们仍保持清醒，只是轻信一切。 她遵循的是自己的标准，她的感情是她自己的，无法从外部来改变。她不会想到一个行动既然没用，就毫无意义。你爱一个人，就去爱他，你什么也不能给他时，你仍然给他以爱。当最后一块巧克力也没了时，他母亲用胳膊搂她的小孩。那没用，并不会因此多产生出一点巧克力，也不会让她或她的小孩免于一死，然而她那样做似乎是自然而然的事。 党所做的最坏之事，是说服人们仅靠冲动或感情解决不了任何问题，而同时让你在现实世界中变得彻底软弱无力。一旦落入党的手里，你感觉到什么或者没感觉到什么，你做了或者控制住没做什么，那都完全无关紧要。 现代战争最重要的目标（根据双重思想原则，这一目标被内党的头头脑脑承认的同时也加以否认）是消耗机器的产品而不提高总体生活水准。 无疑可以想象有这么一个社会，私人财产和奢侈品意义上的财富是平均分配的，而权力仍然把持在享受特权的少数人手里，但事实上，这种社会不可能保持长期稳定。如果所有人都能享受悠闲自在、高枕无忧的生活，绝大多数人都将学会识文断字和独立思考——而一般情况下，他们可能因为贫穷而变得愚昧——他们学会这些后，早晚会意识到享受特权的少数人是尸位素餐者，就会将之扫除。长远而言，等级社会只有建立在贫穷和无知的基础上，才有可能存在。 战争最根本的行为是毁灭，不一定是人命，而是人们的劳动产品。战争是个将物资粉碎或者抛到同温层，或者沉到海底的办法，否则这些物资就会让人们生活得过于舒适，因而从长远意义上说，会过于聪明。 从我们目前统治者的角度来说，唯一的真正危险，是从他们自身阶层分化出一个由能干、未尽其才、渴望权力的人所组成的集团，从而产生出自由主义和怀疑主义精神。这就是说，问题在教育，要不断促进领导集团和紧挨其下的更大的行政管理集团的觉悟，而大众的觉悟则要以否定大众的方式来影响。 寡头统治的要旨不是父传子、子传孙，而是坚持死者加诸生者的某种世界观和生活方式。只要它能指派自己的后继者，统治集团就永远会是统治集团。党所关心的不是血统上的永存，而是自身的不朽。只要等级化结构永远保持不变，至于是谁掌握权力并非重要。 只有当工业技术的发展使得有必要对他们进行更高层次的教育时，他们才会变得危险，但是既然军事、商业以及竞争都不再重要，群众的教育水平实际上是降低了。群众有什么意见或者没有什么意见都被认为是无关紧要之事，他们之所以被允许享受思想的自由，是因为他们没有思想。 党要掌权并非为了自身，而是为了多数人的利益。它要掌权，是因为人民大众是意志薄弱的胆怯之徒，不能忍受自由或者面对事实，一定要被另外那些比他们更坚强的人统治和有系统地欺骗。 《美丽的新世界》在这样的新世界里，人们生活无忧，人和人之间的关系并不受到什么约束，完全不存在家庭，甚至出生都是通过科学手段培育的，在培育过程中再通过控制元素添加来实现阶级分化，人们生下来就知道自己的社会地位和职责，所以一切井井有条，没有什么不满。而当传统的「野蛮人」闯入其中的时候，竟然成了一个异类，完全无法体会这里的人们用唆麻逃避痛苦、滥交的行为。这也是一种极端的乌托邦，很可怕。 很可惜，这确实是一篇杰作。但一旦接受从目标出发所做的解释，结果便很难预料。这一类思想极容易破坏上层种姓中思想不坚定分子已设置的条件——让他们对体现最高的“善”的幸福失去信心，转而相信幸福之外还有着存在于当前人类社会以外的目的，从而相信生活的目的不是维护福利，而是深化意识及扩大知识。 朋友的主要功能之一就是：我们想施加而无法施加于敌人的惩罚，能够以一种较为温和也较为象征性的形式施加于朋友。 没有钢你就造不出汽车，没有社会的动荡你就造不出悲剧。现在的世界是稳定的，人民过着幸福的生活，要什么有什么，得不到的东西他们绝不会要。他们富裕，他们安全，他们从不生病，也不怕死，他们快快活活，不知道激情和衰老，没有什么爸爸妈妈来给他们添麻烦，也没有妻子儿女和情人叫他们产生激情，他们的条件设置使他们实际上不能不按为他们设置的路子行动。 幸福总是与精神生活分不开的。物质生活固然重要，但忽视了精神生活，忽视了人的高贵情操和品德的培养，那个社会里的人绝不可能真正幸福。新世界就是一个生动的例子。这在当前我国“一切向钱看”的现象日益严重的情况下，很值得读者深思。 《我们》很玄幻的作品，天马行空看得有点晕。虽然看起来并不是那种人人幸福快乐的终极乌托邦，但主要是在描述当局的强力压制。光怪陆离的世界，个性被泯灭，我等于我们，不可分割。geming差一点就成功了，然而造福主及时推行的手术清算了一切。 这些反乌托邦文学情节的共同特点就是：人与大自然的隔裂，高度发展的工业化社会，科技文明的发达，高度的统一性压抑了人的个性，而富足是以丧失个性自由为代价的。 你怕它，是因为它的力量大于你；你讨厌它，是因为你怕它；你喜欢它，是因为你无法使它顺从你。人只喜欢他无法占有的东西。” 《带一本书去巴黎》Work in Progress…]]></content>
      <categories>
        <category>Book</category>
      </categories>
      <tags>
        <tag>reading</tag>
        <tag>novel</tag>
        <tag>culture</tag>
        <tag>literature</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Note for Data Structure in CPP]]></title>
    <url>%2F2017%2F06%2F05%2Fdata_structure_cpp%2F</url>
    <content type="text"><![CDATA[刷题中遇到了瓶颈，图论的很多知识只记得有这么个东西，但具体不记得了，一翻课件发现大二上的『算法与数据结构』中很多东西都能找到，就暂停一下，把这部分知识重新过一遍。暂时只记录关键的算法，至于各种数据结构的实现就只是一笔带过了。（原本想翻译成英文的=_= StackFeature Last in First out: all insertions and deletions of entries are made at one end. CPP: #include &lt;stack&gt;, supports push, pop, top, empty.Implementation 存储方式：必须表现元素之间的关系、利于栈运算的实现。-&gt; 数组：写起来容易，很方便；但当规模到达数组容量上限，需要扩容并复制一波过去。-&gt; 链表：动态、灵活、可任意扩容；但写法比数组复杂。（栈顶对应的是链表头部）Application 括号匹配：一个只包含三种括号的字符串，判断各个括号是否合法匹配。Solution：左括号入栈，出现右括号就与栈顶匹配，成功则弹出。 算数表达式的转换：前缀(polish)、中缀、后缀(reverse polish)。口诀分别是『根左右』、『左根右』、『左右根』。将中缀转成后缀：操作数直接输出到结果，左括号和操作符入栈；遇到右括号，则一直弹出栈顶元素直到左括号，输出这部分操作符到结果；还有一种情况需要弹出，就是栈中的操作符必须满足低优先级的在栈底，因此当新进入的操作符优先级低于栈顶，则需要一直弹出不符合的直到空或左括号（相同优先级也弹出），按弹出顺序将这些操作符放入结果中，最后再将新的操作符入栈。 QueueFeature First in First out: Additions at one end and deletion at the other. CPP; #include &lt;Queue&gt;, supports append, serve, retrieve, empty.Implementation 数组：使用circular arrays节省空间，用索引front表示队首，rear表示下一个要插入的位置。注意当队为空时和队满时，都是front == (rear + 1) % max，因此需要引入一个flag标记队是否满了。Application Palindrome：（虽然我觉得这个方法很低效）输入时把每个字符分别入队和入栈，然后分别serve和pop来比较。 双栈模拟队列：stack1专门push来enqueue，stack2专门pop来dequeue。若stack2为空无法取得元素，则把stack1现有元素全部pop依次push到stack2当中，再取之。 BFS：搜索图或树，将当前节点的邻居或后代全部入队，然后将当前节点出队。 LinkedListFeature Singly: 只有value和next，可引入伪头部dummy，链表真正的头部为dummy.next，这样插入、删除都方便很多。 Doubly：除了value和next，还有一个prev指向前一节点，同样可以引入一个dummy。双向链表的删除可以O(1)直接根据传入的节点删除，因为利用prev可以访问到前一个节点。而单向链表如果不传入prev的话，删除时需要遍历一波。 Orthogonal：可以看作有向图的一种存储形式，可以高效存储稀疏矩阵。链表内有非零元素的row, col和value，还有同一行的后继节点right指针，和后续行（因为下一行不一定直接有后继节点）的后继节点down。Application 双指针问题：例如给一个[min, max]的范围，删除这段范围之间的链表节点。又例如数组中的元素swap使得所有奇数都在偶数前面，各占前后两部分。 判断链表是否有环：快慢指针，fast走两格、slow走一格，看fast会否重新与slow重合。 找到有环单向链表的环的入口：快慢指针的基础上再引入一个指针p，当fast与slow重合的时候，p从链表头出发，slow再继续一格格向后挪，当slow与p相遇即为环的入口。这是因为假设从头到入口长度为a，换部分为b，入口到fast和slow相遇为x，则2*(a + x) = a + b + x，因此a = b - x，而slow继续往后走，p从头往后走，分别对应的长度就是b-x和a。 判断两个链表是否相交：将其中一个链表遍历到最后，然后将另一个链表头接在它后面，然后判断是否成环即可。 SearchingBinary Search 在基于comparison的搜索算法中，二分查找是最优的。 forgetful：在二分的过程中可能已经出现了A[mid] == target，但坚持做到最后。 recognizing equality：每一步都check是否吻合target，无法返回『第一次出现的』。因此如果要返回尽可能靠前的结果，则不应该在查找到target的时候就返回索引。1234567891011121314private int binarySearch(int start, int[] nums, int target) &#123; int left = start, right = nums.length - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] == target) &#123; return mid; &#125; else if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; return -1;&#125; Application 最大值最小化：给一个正整数数组，划分成m个连续子序列，使得这些序列各自的和的最大值最小。解法：二分查找这个最小的最大值。先一波O(n)求序列总和为S，单个数字的最大值为Y，就以这俩值为上下界开始二分查找，假设答案为X = (S+Y) / 2，然后再来一波操作求问题P(X)『能否将原序列划分成m个部分，每次尽量往右划分，使得每个部分的和都不超过X』。如果最终的序列数小于m，说明X太大，将上界降低至X-1再二分；如果序列数大于m，说明X太小，将下界提升至X+1再二分；当序列数刚好等于m，也还需要确认是否真的出现了等于m的子序列，否则X还是太大。 Sorting 普林斯顿coursera笔记里有了。 Recursion 经典例子：汉诺塔，挪动小碟子使得大碟子永远在小碟子下面。 Stack frame栈帧：为每个调用函数分配的临时存储区域，包括返回地址、调用参数、局部变量等。对于递归函数的嵌套调用，符合『后入先出』的栈的特点。 递归or迭代：若时间空间允许，递归可读性更强；递归在必要时可以通过迭代+栈的方式代替。 Tail recursion：若递归函数的最后一句执行语句再次调用本身，就是尾迭代。尾迭代可以在主函数中通过外层包裹while循环、内层在执行完递归函数之后修改参数的方式改掉。 Binary TreesStorage 数组：连续存储，直接是2*index + 1, 2*index + 1的索引存储孩子节点。但如果不是满二叉树（堆），k层的二叉树一定要2^k这么大规模的数组，不划算。 链式：用left和right指针/引用指向后续孩子节点。更常用。Terminologies Length of paths：路径的长度就是从节点A到节点B经过的边数。 Depth：根的深度为0，从当前节点到根节点的边数。 Height：叶子的高度为0，从当前节点到叶子节点的边数。Traversal 前序pre：输出当前节点value，再迭代地访问左右节点；或者利用Stack + while，先输出当前节点curr.value，入栈当前节点，然后看左节点是否为null，非空则把这个左节点设为curr；若没有左节点了，则pop栈顶节点出来，看是否有右节点，有则将右节点设为curr，没有就继续pop。直到curr和Stack都空。 中序in：先迭代访问左节点直到null，然后输出当前节点value，再迭代访问右节点；或者利用Stack + while，先入栈当前节点，然后看左节点是否为null，非空则把这个左节点设为curr继续入栈；若没有左节点了，则pop栈顶节点出来，看是否有右节点，有则将右节点设为curr去入栈，没有就继续pop。直到curr和Stack都空。 后续post：迭代地访问左右节点，再输出当前节点value。双Stack+while可以办到，或者直接使用一个Stack+while，但是是使用addFirst将输出的值插入到List的开头。 层级level：利用Queue + while，取队首节点输出同时把其左右子节点放到队尾。 根据上面这些x序遍历的结果还原二叉树：必须有中序才能唯一确定树的结构，否则可能不唯一。例如给定中序和前序，在前序中先出现的为根，那对应去中序里看看这个根的左边都是什么节点、右边都是什么节点，递归找下去。当然，用迭代+Stack也可以。Binary Search Tree 左子树的值都小于根节点、右都大于，不允许重复的值。与堆的区别在于，堆的左右子树之间没什么关系，只是要求根比两个孩子大或小。 BST Sorting：BST的中序遍历即为排好序的结果。 BST Removal：叶子节点直接删除并将父亲节点对应引用改为null，若只有一个子树则直接用该子树根代替被删除节点，若有两个节点，则取左子树的最右根拿上来代替带删除的节点。Free Trees 不一定只有两个子节点了。而且free tree不一定有root，但一定不能有环。 Lexicographic Search Trees(Tries)：字典树是一种多路树，每一个节点存放指针（Java中是引用）的数组和数据域。LeetCode 208就让实现Trie。 Disjoint-Set：一片Forest，用Find操作搜索该树的根节点、用Union操作将两个树合并。LeetCode 200可以用并查集来做。 GraphsTerminologies connected: 无向图总是存在一条通路连接任意两个点。 strongly connected: 有向图中总是存在path连接任意两个点。 weakly connected: 有向图中将方向忽略，对应的无向图是connected的。 degree: 该点处的indegree（指向它） + outdegree（指出去）。Storage Adjacency matrix: 矩阵A[i][j]对应从点i到点j有一条边，将1改为w则可以表示权重。行i的非零项数表示out-degree[i]，列j的非零项数表示in-degree[j]。 Adjacency List: 由于点多的话矩阵可能会很稀疏，因此可以用动态List如vector(ArrayList/LinkedList)来代替静态数组；或者自定义ListNode链表节点，用链式结构存储。Traverse DFS：有点类似二叉树的前序遍历，借助一个visit数组方便判定是否已经访问过当前节点的邻居，当所有邻居都访问过了就回溯。结合Stack可以记录路径，每次判定栈顶元素即可进行search。 BFS：有点类似二叉树的层级遍历，借助Queue将当前节点的所有邻居入队，每次都从队首取元素。也需要利用visit数组保证放入Queue的这些邻居都是未曾访问过的。 BFS Application:-&gt; 无权图最短路：最快到达目标节点的路径就是最短路，那么在BFS的时候一旦入队的节点是目的地，那之前出队的那些节点形成的路径就是最短路了，如果不需要记录路径只需要长度，那每次出队都加加就好了。-&gt; 连通块计数：若一波BFS之后仍有未访问到的节点，说明该节点属于另一个连通块，计数加加然后对该点进行下一波BFS。Topological Sorting 有向无环图，表示先后关系的一种排序。对应LeetCode 210。 BFS：一波流找到所有in-degree为0的节点作为起始点，将这些起始点入队。每次pop队首，将该点的所有出边删除，也就是将相邻点的indegree减减；若出现了新的in-degree为0的点，也入Queue。 DFS：维护一个visit数组和onpath数组，分别表示是否访问过且进入了结果List、是否是递归过程中经过了的，全初始化为false，取任意未访问的节点进行DFS，将该点对应visit和onpath改为true，然后深入DFS它的邻接点，一旦发现回路（即onpath为真）就返回false，当这些点都访问成功则在退出DFS之前将当前这个点插入到结果链表LinkedList的头部，并恢复onpath、但不能恢复visit。 Weighted GraphsMinimum Spanning Tree 给定一个无向带权图，适当地删除边使各边权重和最小。 Kruskal: 把所有边按照权重进行排序，从小到大取边，维护一个并查集，若发现是回路就放弃当前边继续往后取，直到所有节点都访问到。这样一种贪心的策略选出来的边权重之和就是最小了。 Prim：任取一点开始，标记为0，这个标记意味着当前生成树到达该点的权重，除了起始点，所有点的权重都初始化为MAX。每次循环都把与当前生成树直接相邻的点标记上对应经过的边的权重，每次将其中的最小的点加入当前的生成树，然后继续刷新相邻点的标记。Shortest Path Dijkstra：（单源最短路、权重都为正数、O(N^2)）与Prim非常相似，用数组维护从起始点到该处的最小权重和，当前生成树的邻居点加入进来后，可能对原有生成树中的点的权重有优化（该点邻居权重 + 边的权重 &lt; 该点当前权重），则需要更新。 Bellman-Ford：（单源最短路、权重可含负数、O(V*E)）初始化所有点dis[]为正无穷，起点为0；进入循环对每个点i进行『relax』，即比较dis[i]和dis[j] + w[j,i]，若后者小则需要更新前者。需要注意的是，可能出现负权环，在这种情况下最短路不存在，因为越走越短呀。其实这算是一种DP了。 Floyd-Warshall：（多源最短路、非负权、O(N^3)）相当于完整的DP，三重循环，w[i,j]_k表示点i到点j的最短路使用1~k的点作为中间经过的点，在最内层的循环每次都加入新的中间点提供选择，w[i,j]_k = Min{w[i,j]_k-1, w[i,k]_k-1 + w[k,j]_k-1}。]]></content>
      <categories>
        <category>Course</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>interview</tag>
        <tag>cpp</tag>
        <tag>data-structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Note for LeetCode in Java (201~300)]]></title>
    <url>%2F2017%2F06%2F03%2Fjava_leetcode3%2F</url>
    <content type="text"><![CDATA[刷题。祝我好运。 201. bitwise-and-of-numbers-range 给两个数字，求这两个数字之间（含他俩）所有数的And的结果。 ME：从1开始左移，找到恰好不大于下界的2的幂，然后看看上界是否超过了这个幂的两倍，因为一旦这两个数字包含2的倍数，就直接是0了，想想111 &amp; 1000。如果不包含，那么这个幂对应的位置就一定是1了，那么用这个幂与原本的下界和上界取个异或，就得到了后续的部分，递归下去找数字，结果再加上当前这个幂即可。[详情见这里]。 TA：这个方法看似暴力，其实有个trick是每次都约减掉了最高位的1.这个方法的核心则是『寻找m和n的左侧最长的公共部分』，最后用上界与这个公共部分（公共部分以左全为1，不过无所谓）再做个与即为结果。这个也是类似，不过是『右移m和n来找公共部分』，同时用一个factor记录从哪一位开始往左都是相同的了。 202. happy-number 给一个正整数，判断它是否Happy。所谓happy指的是求各位的数字的平方和，得到的是1则是happy，不是1就继续这样算平方和。不是happy的数会陷入循环。 ME：递归加Set标记是否轮回搞定。 TA：这个是Iterative版的set，利用set.add判断是否出现重复。这个借助Floyd Cycle Detection的答案更加妙，来源于快慢指针检测链表中是否有环，这里也是这样，fast是每次往后算两步，slow是一步。当fast到达了1说明是happy，如果fast追上了slow说明成环了。 203. remove-linked-list-elements 给一个链表和一个val，将链表中与val相等的节点删除。 ME：用一个伪头部O( n )搞定。一开始偷懒没有搞双指针，结果没法处理连续删除的问题，例如[1,1]删除1. TA：挖去，原来单指针足够了，关键是你逮到一个与val相等的节点后，当前节点的next重新赋值，但不能往后挪，这样才能保证后续的那个节点也被check到。还有这个recursive的方法，既然函数会返回节点，那么就一路往后直到null，若当前节点需要被删除，就返回后续的节点即可。 204. count-primes 给一个正整数n，求n之前有多少素数。 ME：衣洗题还没搞出来，丢人。一开始就想到用HashSet把非素数给放进去，结果爆内存。后来又想着用暴力方法吧一个个调用isPrime判断一下，果断超时。 TA：没想到竟然可以直接new数组，都不会爆内存，难道测试用例这么弱的吗？这里还有个更subtle的方法，既然偶数都不可能是素数，那一开始就把所有偶数排除掉，count初始化为n/2。利用composite数组记录是否为合数，从3开始遍历，不是合数则进入内层循环，将i * i + a*i对应索引的composite置为true，同时count--。速度炒鸡快。 205. isomorphic-strings 给两个字符串，看能否建立一一映射关系，使得字符串s能转换成t。一一映射要求各个key映射到不同的value，不能多对一，更不可能一对多。 ME：HashMap搞定，利用containsKey判断是否定义过映射，利用containsValue防止多对一。 TA：这个告诉你，由于都是ASCII字符，那么可以用数组代替HashMap嘛，这样会快很多。果然很快。 我去，当年谷歌实习面试的原题，明明做过竟然没搞出来。。。follow-up说如果这些test字符串是million级别的，要怎么优化。不能再给每一组维护a pair of maps，需要找出某种pattern，那么可以根据secret字符串总结出一个pattern，然后后面的字符串都调用相同的算法生成pattern，直接比较pattern字符串即可。123456789101112131415161718192021public boolean isIsomorphic(String s, String t) &#123; if (s == null &amp;&amp; t == null) &#123; return true; &#125; if (s == null || t == null) &#123; return false; &#125; return getPattern(s).equals(getPattern(t));&#125;private String getPattern(String str) &#123; int index = 0; StringBuilder sb = new StringBuilder(); Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; str.length(); i++) &#123; if (!map.containsKey(str.charAt(i))) &#123; map.put(str.charAt(i), index++); &#125; sb.append(map.get(str.charAt(i))).append('#'); &#125; return sb.toString();&#125; 206. reverse-linked-list 给一个链表，反转它，返回反转后的链表头。要求iterative和recursive分别实现。 ME：iterative的很好办，一个prev从null开始，一个curr从head开始，改变curr.next指向prev即可。recursive没想出来。。。 TA：偷看了别人的，写出了recursive的方法。我当时搞不懂怎么写是因为不知道应该返回head还是tail，其实每次递归还是应该返回新的头部，因为tail完全可以用当前元素的next访问到。 207. course-schedule 很典型的图论题，判断根据所给的prerequisite列表能否规划出修完全部课程的方案。术语叫作topological sort，托普排序。 ME：真的抓狂，明明很基础的一个题，想半天搞不出来。回头翻了大二上的数据结构Lecture 13果然找到了托普排序。利用『入度为零』判断哪个点可以作为起始点，将这些点全部入队，然后从队首的点出发，将它相邻的点的入度都减1，相当于『修了这门课』。这样一直循环直到队列为空，看看遍历了多少课程。 TA：课上讲的其实就是这个BFS的方法，此外还有DFS的方法。DFS需要借助visited数组，标记哪些课程已经上过了，如果在后续DFS中回到了上过的课程索引，说明成环了，这样的课程依赖关系永远没有办法满足，直接返回false。如果全部课程都走过一遍了，也没有成环，那就说明可以。注意DFS如果使用数组会超时，因为需要遍历才能知道后续课程索引，而使用ArrayList就直接往后get就好了。 208. implement-trie-prefix-tree Trie树来源于单词『retrieve』，主要用于字典查找、输入法联想，因为可以提供prefix查找。这个就是实现一波。 ME：这个题促使我翻看了大二上的『数据结构与算法』的PPT，理解了相关内容后实现起来非常容易。 TA：因为search和startsWith非常类似，只是search要求在该节点处isWord为真，这个答案告诉你，可以将公共部分提取出来调用这个find函数，返回找到的该字符串对应的最后一个节点。 209. minimum-size-subarray-sum 给一个目标s和一个int数组，求最短长度的连续子串使其元素和大于等于s。 ME：想到了双指针做法，就是fast指针一直往后加知道超过s，然后slow指针再跟进同时减掉slow指针对应的值，一旦小于s就又开始挪fast。这是个O( N )的做法，但是follow up要求想到O( NlogN )的。 TA：这个大神的Two pointer就比你的简单很多咧。此外就是这个O( NlogN )的做法，很容易想到二分查找，但是二分要求数组是有序的，但在这里原数组的顺序matters，不能动，怎么破？我就是不知道这个。其实题目说了都是正数，那么它对应的累积和数组cumultive就是有序的了，在搜索目标s的时候加上之前的和就可以了。这里的二分查找和通常的不太一样，因为通常是找到了就直接输出索引，最后如果没找到就输出-1，在这里就不能这样，因为没找到就要返回『最小的大于目标的索引』，因此需要在princeton版本二分中删除相等即输出的判断，同时最后返回的是left而不是-1，写出来是这样。 210. course-schedule-ii 与207相比需要记录路径了。 ME：BFS很好办，也是利用入度为0筛选出起始点，然后逐步放到Queue里。但DFS就不好理解了，因为前面的那个『成环』的判定，在这里需要记录路径的情况下，似乎不管用了。 TA：DFS的方法我参考了这个，原来需要维护两种状态，一个是完全visited，一个是在DFS过程中经过了这个点onpath，在DFS结束之前恢复的是onpath，表示当前这个recursive path已经退出、不再占用这个点，但visited就不能恢复了。 211. add-and-search-word-data-structure-design 类似于Trie数，但是在search的时候引入了通配字符.，可以任意替代一个字母。 ME：参考前面的Trie题，写出来了这个，需要用一波DFS来处理通配符。 TA：没啥了。 212. word-search-ii 给一个棋盘，再给一个String数组，求在棋盘中出现了哪些字符串。字符串沿四个走位七歪八扭形成的都算出现。 ME：作死，看了一下tag，发现要用Trie，稍微修改一下就OK了。修改在于把search函数拆分成了单步的nextNodeWithChar函数，给一个字符就返回对应的TrieNode，在DFS的时候一旦碰到对应的TrieNode为空就停止继续搜索了。同时TrieNode中存放的不是boolean，而是一个String，这样就不用重新拼接起来获得字符串了。 TA：这个超强答案总结了所有可能的优化。去重这里HashSet可以用TrieNode中增加count，或者干脆每当DFS到了这个word的时候就把这个TrieNode的String给置空，以实现『去重』的目的。此外，onpath这个辅助二维数组也不必要，因为当你已经来到了搜索对应的TrieNode时，当前的节点肯定不会在深入的DFS中用到，因此可以直接修改原board，然后在最终退出DFS之前改回来。 213. house-robber-ii 和前面198的区别在于，要把数组看作一个首尾相连的住宅区，因此第一个和最后一个不能同时选。 ME：这题在上次写得很漂亮，但是这里多了一个条件就纠结死了，WA了嗨多次才过。我维护了一个first的布尔数组表示是否选择了第一户人家，这样到达最后一户的时候，如果是真，那么就减掉第一间，在和前一个结果做比较。但是这样无法通过2,2,4,3,2,5，因为这里就需要在完全不理会第一户的情况下取到最大值10。于是我不得不加入了以第二户为起点的一波比较和赋值，勉强通过，但这个逻辑非常乱，不能提倡。 TA：这个直接来了两波，想法很直接，但我总觉得略low。他们把这个叫作『two pass』，好吧，这不失为一种方法。关键是不容易出错啊哥！ 214. shortest-palindrome 给一个字符串，在它的前面增加尽量短的字符串拼接而成的新字符串自对称。 ME：想到这个方法，自我感觉良好，但中间还是出了很多WA。从中间开始往两边拓展，判断是否对称，让这个『中间』的指针从正中间逐步往字符串头部挪，这样就能找到靠近头部的已经自对称的片段，然后把剩余不对称的拼上去就好了。 TA：这个的前半部分找自对称的子字符串的那段代码实在太强！从后往前，如果前后指针对应字符相等则前指针++，后指针则不论什么时候都一直–，循环重点是后指针到达起点。此时前指针j所在的位置就是不对称部分的开端，那么这一部分就是需要反转并拼在最前面的部分了。但是这还没完，此时（0，j）这一部分还不能断言就是对称的，例如例子&quot;abacfghcabakmnchgfcabaiuytrcfghcnmkabachgfcaba&quot;，因此需要递归地处理( 0,j )这一部分。此外还有一个KMP的方法，这个真是一头雾水，有个博客可以看看，不过先放一放吧。。。 215. kth-largest-element-in-an-array 求一个无序的int数组，经过排序后的第k个大的元素。 ME：立刻想到了quickSort的应用，写出来是这样。我在这里用的是『以首元素为pivot』，而不是之前一直写的『以中间元素为pivot』的快排，不太熟悉，参考了princeton课件。 TA：这个是一个总结，可以使用Java内置的priorityQueue（其实就是大根堆），将原数组的每个元素插入进去，始终维持规模为K，最后剩下的队首就是了。 216. combination-sum-iii 给整数k和n，要求不重复地从1~9中选k个数出来使得它们的和为n。 ME：递归解决。数组索引越界了若干次，没有仔细设置循环/判断条件。从1开始取，used数组对应标true，然后将当前剩余需要拼凑的和减去当前取的这个值，进入下一步递归。为了防止重复，只能往后取值。 TA：这个真的简洁，竟然不需要任何辅助的标记数组！因为每次都是往后取的，所以自然不会取到前面的啦。不过我的因为判断条件比较多，可以提前停止递归，所以比他的快嘿嘿。面试的时候当然还是选择好写的这个来写了。 217. contains-duplicate 给一个int数组，确认其中是否含有出现超过1次的数字。 ME：直接HashSet搞定，在add的时候如果返回false就说明重复了。 TA：这个小总结了一波，可以先sort再前后判断相邻的嘛。 218. the-skyline-problem 给一个int[][]，存储的是一系列三元组，三元组定义了摩天大楼的横坐标起点、终点和高度，求这些摩天大楼的侧视图所形成轮廓中所有横线的左端点坐标。 ME：完全没有头绪！！！感觉这题是仅次于前面那个什么Word Ladder的题，实在是不知怎么抽象出来。。。 TA：看了很多post，这个感觉最好懂（代码最短= =）。首先你原本想到的TreeSet思路是对的，但是没必要重新构建Block保存三个int的对象，这里直接List&lt;int[]&gt;用存储每一条竖线，第一个元素为横坐标、第二个元素为高度，左边缘高度为负、右边缘高度为正这样区分开来。List自定义排序方式就根据横坐标越小的越靠前，若相等则左边靠前。PriorityQueue&lt;Integer&gt;存放的就是高度了，维护从大到小的顺序，初始化插入一个0，然后在循环里取List的元素，如果是右边缘直接remove掉，如果是左边缘就add进去，然后用一个curr取出当前的最大元素，与上一步的最大元素prev做比较，如果不一样了，说明上一步的最大元素已经出队或者新插入的元素高度更大，这两种情况对应下行阶梯或上行阶梯的形状，都需要把左节点插入结果，即当前的这个横坐标以及最大高度。观众朋友会问了，如果刚好全部边都出去了，落到地面了怎么办？这就是为什么要在第一步插入一个0，因为当所有边都出去了，当前横坐标对应的高度就落回到0了，照样可以输出到答案中。写出来是这样的。还有人改造成了TreeMap，因为PriorityQueue的remove任意节点需要O(n)，而TreeMap是O(log N)，因此快很多。不过需要注意的是由于是Map，所以key不能重复，这种限制在priorityQueue中不存在，因此需要对TreeMap的value添加一个计数器，以应对多个相同高度的情况。写出来是这样的。 219. contains-duplicate-ii 给一个int数组，给一个长度k，要求如果找到重复项，这两项的索引之差不超过k，返回布尔值。 ME：一开始直接用HashMap保存值与对应索引，当发现重复的key的时候，就减一下索引看看是否小于等于k，每次都直接put进去更新索引。但是超时，我猜测大概是因为当数组规模很大的时候，每次HashMap查找都比较费时。衣洗题也陷入江局了。。。（但是hin奇怪的是我看别人通过的答案，用Map又是可以的啊。。。） TA：这个的提速在于尽可能压缩HashTable的规模，当索引超过k的时候，nums[i-k-1]不会再被用到，可以用set.remove( Object )删掉它，这样每次查找都会快很多。 220. contains-duplicate-iii 给一个int数组，给偏移范围t和索引差距k，求是否存在差距在k以内的两个索引i和j，使得对应的元素之差的绝对值小于t。 ME：还是用HashSet搞定了，自定义了Range类，根据[mid-t, mid+t]来确定元素之差是否在t以内。但是当t为0时，即退化为前一个问题的时候，会超时，所以就特殊处理了一下，当t == 0时还是跑之前的代码，结果的速度还是挺快的。不记得在哪里看到的，说自定义类作为HashMap的Key是没有意义的，我当时就只是记住了。这次碰到这个问题，不得不考虑自定义Key放入HashSet，参考了这个。HashSet的比较首先是看hashCode，若hashCode相同，再调用equals比较两个对象。 TA：这个答案避免了自定义对象的麻烦。如何将相差为t的尽量map到同一个索引呢？答主想到的是除法，将所有int都减去最小int转化为非负Long，然后除以t + 1将其倍数往后的t个元素都映射到同一个索引bucket，然后建立&lt;bucket, value&gt;键值对插入Map。这样但是光有除法还不够，还需要对前、后两个索引进行比较看看差距是否小于等于t，毕竟不是每个数都是t + 1的倍数嘛，写出来是这样。此外，还有一个利用二分查找树的方法，每次求当前元素 + t在树中的floor，如果大于等于当前元素 - t说明就找到了。与原po相比我稍微改了一下判断条件，同时利用lo和hi防止越Integer界，当然改成Long方便多了。 自定义类插入HashSet/HashMap，需要重写HashCode和equals函数。但还是比较麻烦，尽量想想如何用内置类型代替。 221. maximal-square 给一个只含有0/1的char棋盘，求其中1组成的最大正方形的面积。 ME：感觉我这用的是暴力法，若当前为1则向右下一格去分别向上和向左判断是否全为1，一直向右下深入。AC后看了一下tag，发现竟然可以用DP。 TA：这个DP用一个二维table维护正方形的边长，若当前位置为1，则去左、左上、上三者中的最小值加1作为边长，这样一旦其中一个位置的边长为0就相当于重置了。然后答主又进一步优化了两波，最终只用了一维数组来dp，节省了空间但可读性也就下降了，我模仿着写出了这个。对于dp[j]来说，上对应的就是dp[j]（因为还没改动）、左对的就是dp[j-1]（已经改动过了），那么左上怎么办呢？额外用一个pre来记录，每次刚进入循环时存起来，然后结束循环前赋值给pre，这样在下一步再用到pre就是左上的效果了。 222. count-complete-tree-nodes 给一个complete binary tree，即除了叶子Level，其余level都是满的，而且叶子都是尽可能靠左存在的。求这个树的节点数。 ME：还以为很简单，直接用个类似于level traverse的Queue来搞，结果超时。后来干脆改成一个三行的递归，还是超时。陷入江局。。。 TA：参考了这个眼熟的大神的写出了这个。不过老实说他这个计算height的方法有些诡异，把-1都搞出来了，我后来在提交页面看到了个超快的iterative方法，写出来是这样。这个计算的高度也是只计算最左的高度，符合人眼计算漫漫叠加那样就没有什么-1了。在主函数里先计算根的高度，然后计算右子树的高度，如果右子树高度刚好是根高度减一，说明左子树一定是满的，因此要潜下右子树继续求高度，而左子树那堆满的节点加上根节点，刚好就是1 &lt;&lt; rightH，满的左子树高度就是rootH - 1 == rightH，节点数本来就是1 + 2 + 4 + 8... + 2^( rightH - 1 )，再加个根节点就相当于对应二进制进多了一位1 &lt;&lt; rightH。而如果右子树高度不够根高度减一，说明右子树虽然矮但也是满了的，要潜入左子树继续求高度，而满的右子树节点数就是1 + 2 + ... + 2^( rightH - 1 )，再加个根节点又是1 &lt;&lt; rightH。之前那个外国小哥大神还介绍了和最naive的递归方法相似的一个方法，思路是先同时向左和向右下潜，若二者同时null了，说明是full，直接利用高度求节点数即可；若右空而左没空，则需要分别对第一个左子树和第一个右子树递归调用，再加个根节点，由于每次这两个recursive call中有一个能get到full的，因此不会持续递归，这是相比naive的优化。写出来是这样的。 Did not come up with the simple iterative method.123456789101112131415161718192021222324252627class Solution &#123; private int getHeight(TreeNode root) &#123; int h = 0; while (root != null) &#123; h++; root = root.left; &#125; return h; &#125; public int countNodes(TreeNode root) &#123; int rootHeight = getHeight(root); int ans = 0; while (rootHeight != 0) &#123; int rightHeight = getHeight(root.right);// get right sub height if (rightHeight + 1 == rootHeight) &#123; // means left is full root = root.right; &#125; else &#123; // rightHeight == rootheight - 2, right is full, need to go left root = root.left; &#125; ans += (1 &lt;&lt; rightHeight); // rightHeight == rootHeight -1 or -2, it can make sure // a full sub tree plus root is added into ans rootHeight--; &#125; return ans; &#125;&#125; 223. rectangle-area 给两个矩形的左下和右上点坐标，根据四个点坐标求共同围成的面积。 ME：一大堆条件判断。 TA：这个告诉你，根本不用判断overlap，直接根据坐标大小来就可以了，有一个更简洁的版本，改写成了这个。 224. basic-calculator 给一个只含有数字和加、减、小括号的算式字符串，求结果。 ME：利用两个Stack，一个存数字、一个存运算符和左括号。当遇到数字时，若符号栈顶不是左括号，就直接pop出数字栈顶数字和pop符号、计算一波并将结果入数字栈。当右括号出现则持续计算直到遇到左括号。写出来是这样。 TA：这个 只用到了一个Stack，因为符号的加减可以通过一个变量来控制而不用存起来，每次直接就运算掉了，而括号也不需要去验证是否匹配，因此也不用存起来，当出现左括号就把前面的运算结果入栈，同时把括号前的符号入栈，当右括号出现，就先取栈顶的符号乘以当前运算结果，再加上栈顶数字就完成了这部分括号的计算。很优雅。这个 也差不多，模仿了一波。 225. implement-stack-using-queues 用Queue实现Stack的功能。 ME：用两个Queue实现了。 TA：这个告诉你，只用一个就够了，为了维持『后入先出』，队列要在push的时候维持倒序，这个方法的push是O( n )而pop和top都是直接队首就搞定了。 226. invert-binary-tree 镜像翻转一个二叉树。传说中有名的一题，因为有一个不会写这个而被谷歌拒的牛人。 ME：递归搞定。这里是有返回值的版本，如果是void版本呢？也差不多其实。 TA：这个改成了iterative的方法，其实就是level traverse中途把每个node的两个孩子对调了，就是镜像了。这里解释了为什么iterative更受青睐：递归可能在函数嵌套过程中增加了overhead、递归容易溢出函数栈、最后一个没看懂，大概是说『更容易拆解』？？？ Need to remember iterative one12345678910111213141516171819202122232425class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if (root == null) &#123; return null; &#125; if (root.left == null &amp;&amp; root.right == null) &#123; return root; &#125; Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.add(root); while (!q.isEmpty()) &#123; TreeNode curr = q.poll(); TreeNode temp = curr.left; // swap at each node curr.left = curr.right; curr.right = temp; if (curr.left != null) &#123; // push into Collection q.add(curr.left); &#125; if (curr.right != null) &#123; q.add(curr.right); &#125; &#125; return root; &#125;&#125; 227. basic-calculator-ii 给一个只含有+ - * /四则运算的String，求运算结果。 ME：模仿学到的单Stack做法，处理优先级不同的情况。利用upgrade确认是否需要提升优先级，提升时将前面的运算结果和符号依次Push入栈，把当前数字设为当前结果，然后往后计算结果，直到回到加减运算时，再将当前结果乘以栈顶的符号、加上再前一位的数字，然后继续往后算。写出来是这样，还是复杂了点。 TA：在提交页面看到一个超叼的不用Stack的方法，模仿了一波写成了这样。对于加减符号，把符号之前的一个数字乘以sign，直接就往结果里加了，然后更新后续的符号；对于乘法，很巧妙的是直接将乘法前的一个数字融到了sign符号里面，因为sign本身也是要乘后续数字的嘛；对于除法稍微复杂一些，碰到除法符号就设置divide标志，然后将除法符号前的数字赋值给一个prev，然后在除法符号之后的那个数字结束时，完成prev / num的除法，赋值给num，然后再后续计算。讨论区里也有一个类似的。 228. summary-ranges 给一个排好序的int数组，求其一个个连续的值域，用String表示并添加到List中。 ME：既然排好序了，那么连续的话就必须有『索引之差等于值之差』，我首先想到的是二分查找，如果索引差小于值差，则向左半部分找，否则到右半部分。查找完成后start~right即为连续的值域，然后把start赋值为right+1，继续，写出来是这样。 TA：哇去，我还以为自己这个O( NlogN )的想法很妙，美滋滋哩，结果提交页面看到个one-pass O( N )的，讨论区也有个类似的，笋干爆炸。思路是直接判断前后两个是否差值为1，找到差值不为1的时候结束循环，输出到结果，虽然双重循环但是内层循环的索引用的是外层的，所以还是O( N )。默默学习了一波，写出来是这样。 229. majority-element-ii 给一个乱序的int数组，求其中出现次数超过三分之一规模的所有数。要求linear time，O( 1 )space。 ME：想了半天不知道除了HashMap还能怎么搞，回看了169有个morre voting，但是只适用于求超过一半的元素的情况。陷入江局。。。 TA：玛德，刚看到这个的开头笋干就懂了大概的思路，既然求一半以上的用的是一个数字，那求三分之一以上的，可能有两个数字，那就设两个变量嘛。不过细节还是得参考才能写出来，例如当count1和count2不断归零之后，新产生的num1、num2不一定超过三分之一频数，还需要遍历一波看看是不是真的符合。写出来是这样。后续有推广到k分之一频数的方法，就是把count和num都对应放到数组里。 230. kth-smallest-element-in-a-bst 给一个BST，求第k小的元素。 ME：丢脸，又忘记二叉树的iterative的in-order怎么写，参考了173才写出来了这题，用一个Stack保存节点，每次持续把左节点入栈，取栈顶加入List，同时看这个节点是否存在右节点，有就深入下去，继续持续把左子树入栈。。。 TA：这个大神给出了三种方法，玛德貌似我的iterative方法是最不preferable的，而且我用了个List其实根本没必要，因为我只关心最后一个元素，可以直接让k减减嘛。先看看recursive版本的，用一个全局变量count = k不断减减，直到零就说明找到了，遍历也是优先往左子树递归，若当前不是第k个，再往右子树递归。写出来是这样。第一个答主说是最preferable的，但时间复杂度O( N logN )并不低啊，不过还是模仿了一波。思路是利用左节点数判断，若左边子树的节点数恰好是k - 1，那么当前节点就是了。若左子树节点数多于k - 1，则需要递归进入左子树进一步找。若左子树节点数多于k - 1，则需要递归到右子树，但此时就需要更新k为k - 1 - count。 Need to know more methods… Implementation OK though.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class Solution &#123; // counting nodenum of leftTree and decide which way to dig into public int kthSmallest(TreeNode root, int k) &#123; if (root == null) &#123; return 0; &#125; int numLeft = getNodeNum(root.left); if (numLeft &gt;= k) &#123; // k-th should be in left return kthSmallest(root.left, k); &#125; else if (numLeft == k - 1) &#123; return root.val; &#125; else &#123; return kthSmallest(root.right, k - numLeft - 1); &#125; &#125; private int getNodeNum(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; return 1 + getNodeNum(root.left) + getNodeNum(root.right); &#125;&#125;class Solution &#123; // recursive pre-order traverse to update global count private int count; private int ans; public int kthSmallest(TreeNode root, int k) &#123; count = k; ans = 0; helper(root); return ans; &#125; private void helper(TreeNode root) &#123; if (root == null) &#123; return; &#125; helper(root.left); count--; if (count == 0) &#123; ans = root.val; return; &#125; helper(root.right); &#125;&#125;class Solution &#123; // basic iterative pre-order tarverse public int kthSmallest(TreeNode root, int k) &#123; if (root == null) &#123; return 0; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (root.left != null) &#123; stack.push(root.left); root = root.left; &#125; while (!stack.isEmpty()) &#123; TreeNode curr = stack.pop(); if (--k == 0) &#123; return curr.val; &#125; if (curr.right != null) &#123; curr = curr.right; while (curr != null) &#123; stack.push(curr); curr = curr.left; &#125; &#125; &#125; return 0; &#125;&#125; 231. power-of-two 给一个整数，判断它是不是2的幂。 ME：用一个pivot从1开始往左移，直到最高位。写出来是这样。 TA：在提交页面看到个超叼的方法，思路是直接用n和n-1作一个与运算，如果是2的幂直接全是0了，否则就不是2的幂。模仿了一下。 232. implement-queue-using-stacks 用Stack模拟Queue的功能。 ME：印象深刻好吧，一个栈专门输入、另一个栈专门输出，当输出的空了，就把in的全部给导过来，再pop/peek。写出来是这样。 TA：没啥了。 233. number-of-digit-one 给一个整数n，求从0~n这些数字中，一共出现了多少次1. ME：纠结了好久自己写出来了个这个，速度神慢。思路是求最高的非0位，从1000000000开始逐步除以10去找，求商和余数。若余数为0，说明恰好是整的临界数，除非是1000这样的能在最高位提供1，6000这些都无法在最高位提供1，我的做法是递归地直接去找n - 1这个数的1的出现次数。若不是临界数，再看商，若商为1，则说明『最高位能提供的1由后续数字决定，即余数加1个』，否则最高位能提供的就是完整的当前被除数firstOne个1了。然后递归往后找，一部分是由余数决定的，另一部分就是『商』这么多个完整的firstOne - 1中包含的1了。例如1234，最高位能提供的1就有235个，然后余数234递归去求，还有999往前也要递归去求。98765也类似，最高为能提供的1是8766个，然后递归去求8765中含的1，以及9个10000 - 1中含有的1. TA：又是这个脸熟的大神，看到这个我是震惊的，怎么可以这么短。。。这个大神思路是这样，k作为1、10、100…的一个除数。当k == 1，此时关注的是个位，每10个数就会在个位出现一个1，共有( n / k ) / 10个『10个数』；当k == 10，此时关注的是十位，每100个数就会在十位出现十个1，共有( n / k ) / 10个『100个数』，对应1的个数为( n / k ) / 10 * k，这就是基本公式了。但是对于特殊的数字1x, 11x...，可以在最高位提供额外的1，有多少个额外的1呢？n % k + 1个，而判断是否特殊的条件是( ( n / k ) % 10 == 1 )；此外，还需要考虑2x，因为按照目前的公式在计算十位出现的1的时候，( 2x / 10 ) / 10 * 10算出来是0，我们需要让1x在计算十位时得到0而后续的2x~9x都为10，一个trick是在公式中加8，( ( 2x / 10 ) + 8 ) / 10 * 10得到的就是10了。综上，最终的公式就是( ( ( n / k ) + 8 ) / 10 * k ) + ( ( n / k ) % 10 == 1? n % k + 1: 0 )。此外还有这个方法，这个情况更加简洁直观，对于数字xyzdabc来说，考虑千位d出现的1的次数，若d == 0则xyz0000往后都不可能有千位的1，只能向前找，也就是0 ~ xyz-1即xyz * 1000个1了；若d == 1，则除了前面的xyz * 1000个，往后还有0 ~ abc即abc + 1个；若d &gt; 1，则xyz1000 ~ xyz1999都可以被取到，所以直接是xyz * 1000 + 1000，更推荐这个方法！ 234. palindrome-linked-list 判断一个链表是否自对称。 ME：一开始用了Stack，后来直接把前半部分链表反转了。利用快慢指针找到中间节点，再根据fast指针后续的情况判断出总节点的奇偶，微调一下，然后pop栈比较、或者直接把前面反转后的链表和后续链表比较。 TA：没啥吧，不过这里有两个大神争论什么叫作『O( 1 ) space』。 235. lowest-common-ancestor-of-a-binary-search-tree 给一个BST的根节点，给其中的两个节点，求二者最低层的共同的祖先。 ME：BST根、左、右孩子有大小关系，而且不含重复元素，所以直接根据val来判断递归即可。所给的p、q其中一个已经是root了，那root就是共同祖先了。否则就根据p, q, root的val的大小关系，若p &lt; q &lt; root则往左递归，若root &lt; p &lt; q则往右递归，若p &lt; root &lt; q，则p和q分属两侧，root直接就是共同祖先了。写出来是这样。 TA：又是这个外国大神小哥总结了Iterative和Recursive的方法，其中iterative方法利用root - p和root - q是否同号来判断大小关系实在是妙哉，当其中一个等于root的时候也可以直接跳出循环了。 Just make use of the property of binary search tree;1234567891011121314151617class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if (root == null || p == null || q == null || p == root || q == root) &#123; return root; &#125; if (p == q) &#123; return p; &#125; if (Math.max(p.val, q.val) &lt; root.val) &#123; return lowestCommonAncestor(root.left, p, q); &#125; else if (Math.min(p.val, q.val) &gt; root.val) &#123; return lowestCommonAncestor(root.right, p, q); &#125; else &#123; return root; &#125; &#125;&#125; 236. lowest-common-ancestor-of-a-binary-tree 给一个可能带有重复元素且大小关系不确定的二叉树，给两个节点，求他们的最底层的公共祖先。 ME：一开始以为没有重复元素，直接向两侧递归如果都能找到两个节点其中一个，就返回当前节点了。结果WA看了一下样例才发现可以重复。想了一晚上都不知道怎么破，陷入江局。。。 TA：看了这个我恍然大悟，我犯了一个严重的错误，用『值』来判定节点是否相等，而事实上就算『值』重复，两个节点对象那就是两个节点对象，是绝对可以分开的。因此你原来的思路算是可行的，如果当前节点是其中一个，直接就可以返回了；否则就递归往两侧找，如果左侧找不到那说明在右侧、如果右侧为空说明在左侧，如果都不空那就是当前节点了。写出来是这样的。还有一个利用HashMap, Stack, HashSet的iterative的方法，你别说，我还真想到过，但没敢动手实现。思路是利用HashMap记录每个节点的父节点，然后用Stack（其实Queue也行）一直往后类似于层级遍历，当Map中记录到了p和q作为key的键值对，就结束记录父亲的工作。然后用Set记录p的所有父亲，一路向上直到root。然后再从q开始往上找Parent，找到的第一个在Set中出现的，就是最low的共同祖先啦。写出来是这样的。 fail to come up with the recursive method checking node equation.12345678910111213141516171819class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if (root == null) &#123; return null; &#125; if (root == p || root == q) &#123; return root; &#125; TreeNode left = lowestCommonAncestor(root.left, p, q); // dig left TreeNode right = lowestCommonAncestor(root.right, p, q); // dig right if (left != null &amp;&amp; right != null) &#123; // both side has return node return root; &#125; if (left == null &amp;&amp; right == null) &#123; return null; &#125; return left == null? right: left; &#125;&#125; 237. delete-node-in-a-linked-list 给一个单向链表中的节点，删除这个节点。 ME：单向链表按道理是不能给定节点直接删除的，题目没说不能用赋值的方法『伪删除』，而且强调了不能删除最后一个节点，我就想到是更改节点的val，一直到最后，将倒数第二个节点的next指向null就完成了。这题没啥意思。。。 TA：玛德，哪里用全部赋值啊，直接把要删除节点之后一个节点的值覆盖过来，然后把next指向下下个就好了啊。 238. product-of-array-except-self 给一个数组num[]，求对应长度的数组使得output[i]为所有数的积除了num[i]，要求O( n )且不能用除法。 ME：不给我用除法我整个人是懵逼的，脑子一下转不过来，陷入江局。。。 TA：这个给出了如何从辅助数组到O(1)space的思考过程。首先这个辅助数组的方法我怎么就想不出来呢，left数组从左开始每一格存储的是『除了当前数字的前面数字之积』，right数组从右开始存储的是『除了当前数字的后续数字之积』，然后再来一波对应把left和right乘起来就得到了『除了当前数字前面和后面数字之积』。这怎么能想不到呐？？写出来是这样。至于从O( N )到O( 1 )的空间复杂度，知道了之后也没啥了，以后再碰到尽量想起来吧。既然每一个地方都需要哟还能感到它左边所有项之积和右边所有项之积，而如果只维护left和right两个值，无法在循环到第一位的时候就获得右边所有数的积，怎么办？答主的做法是在一步循环里，对两端进行更新，也就是每个位置会被更新两次，一次是随left更新，一次是随right更新，left和right就分别从左和从右向另一端去乘。妙哉！如果把这个one-pass拆开来写，就是这样的. 239. sliding-window-maximum 给一个数组，给一个window的size，要求从左到右滑动窗口，输出每滑动一格所能看到的数中的最大值，汇总在数组中输出。 ME：维护最大值，而且要方便删除，我就想到了PriorityQueue，218摩天大楼那题用到了。不过为了提升效率我用的是TreeMap，这样删除任意一个元素就是O( logN )了。先根据前k个元素初始化TreeMap，然后继续往后遍历，每次取firstKey就是最大值（不过要在构造时传入Collections.reverseOrder才是从大到小），然后删除窗口中的第一个元素、添加后一个元素，一直往后。写出来是这样，看了tag给的也是Heap。 TA：挖去！！这个真的妙，思路是利用Deque维护索引，左侧头部就是窗口范围内最大值对应的索引，右侧头部就是依次递减的值对应的索引，在Deque内所存储索引对应的值一定是递减的。循环开始时，先确认最左侧的索引是否已经超出了窗口范围，超出了就需要poll掉（答主用了while，其实if足矣）。然后从右侧比较后续元素，如果新加入的元素比前面的大，就直接pollLast，一直比较，直到可以维持递减状态再把新加入元素的索引add进去（最坏情况是新加入元素比前面的都大，就一直清空了原Deque直接留下新的索引了）。最后就直接把Deque左侧索引对应元素存入结果就好。太妙了！！！写出来是这样。还有一个方法也是挺巧妙的不过不太好移植，根据窗口长度划分区域，分别求左边开始的和右边开始的可见最大值，最后综合一下left[i + k - 1]和right[i]，写出来是这样。在提交页面还看到一个很简单粗暴的想法，维护一个max，如果窗口前的元素是max，就往后再找一波新的max，这个复杂度感觉就不是O( N )了。。。 240. search-a-2d-matrix-ii 给一个m*n的二维数组，其中每一行的元素都满足左边小于等于右边、每一列元素都满足上面小于等于下面，给一个target，判断是否在这个矩阵里面。 ME：马上想到二分查找嘛。取左上和右下的中间元素（横纵分别取中点），若target较小，则递归搜索中点上方的矩形和它左方的矩形，若target较大，则递归搜索中点下方和它右方的矩形。写出来是这样，不过速度好慢。。。我这样的时间复杂度貌似是（M * log( N )）? TA：玛德，原来这个线性查找就已经很快了，O( M + N )呢！ 241. different-ways-to-add-parentheses 给一个只含有数字和加、减、乘的算式，求各种加括号的方式对应的值，不论值是否重复都输出到List中。 ME：隐约感到要递归，纠结了很久终于还是写出来了，但是神慢啊。思路就是分成两半，前半部分的数字依次乘以后半部分的数字。 TA：我的方法跟这个很像，在提交页面最快的方法就是基于这个，再加一个HashMap来避免重复计算。这还有一个DP的方法，dp[i][j]存的是从第i个数字到第j个数字（不是索引！）的算式的所有可能值。首先对字符串做预处理，拆解成一个个独立的String，数字str与运算符str交替。假设整理后有N个数字，让d从0循环到N-1，表示取第i~i+d个整数的结果，即dp[i][i+d]。而当d=0，就只取一个数字，也就是本身了。内层还有两重循环，就是根据拆分成两半分别求的结果来更新了。 242. valid-anagram 给两个字符串，判断它们是否是anagram，既一个把字母打乱后重新组合可得到另一个。 ME：用bucket数组咯，算字符出现的个数，s出现就++，t出现的就–，最后再扫一波看看是否全部都为0.写出来是这样。 TA：没啥了。 243. shortest-word-distance 给一个String数组，给两个其中的String，求它们的最小距离。 方法一：用两个List记录它们出现的所有index，然后用minimum distance between two sorted array的双指针搞法求最短距离。 1234567891011121314151617181920212223242526272829class Solution &#123; public int shortestDistance(String[] words, String word1, String word2) &#123; if (words == null || words.length == 0) &#123; return 0; &#125; List&lt;Integer&gt; index1 = new ArrayList&lt;&gt;(); List&lt;Integer&gt; index2 = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; words.length; i++) &#123; if (words[i].equals(word1)) &#123; index1.add(i); &#125; else if (words[i].equals(word2)) &#123; index2.add(i); &#125; &#125; int ptr1 = 0, ptr2 = 0, min = words.length; while (ptr1 &lt; index1.size() &amp;&amp; ptr2 &lt; index2.size()) &#123; min = Math.min(Math.abs(index1.get(ptr1) - index2.get(ptr2)), min); if (min == 1) &#123; return 1; &#125; if (index1.get(ptr1) &lt; index2.get(ptr2)) &#123; ptr1++; &#125; else &#123; ptr2++; &#125; &#125; return min; &#125;&#125; 方法二：不需要记录每一个index，直接在出现的时候就可以比较了。这样就是完美的one-pass. 12345678910111213141516171819class Solution &#123; public int shortestDistance(String[] words, String word1, String word2) &#123; if (words == null || words.length == 0) &#123; return 0; &#125; int ptr1 = -1, ptr2 = -1, min = words.length; for (int i = 0; i &lt; words.length; i++) &#123; if (words[i].equals(word1)) &#123; ptr1 = i; &#125; else if (words[i].equals(word2)) &#123; ptr2 = i; &#125; if (ptr1 != -1 &amp;&amp; ptr2 != -1) &#123; min = Math.min(Math.abs(ptr1 - ptr2), min); &#125; &#125; return min; &#125;&#125; 244. shortest-word-distance-ii 还是给一个String数组，给两个其中的String，求它们的最小距离。但是现在需要实现一个类，会call很多次求距离的function。 将每个word出现的索引存入List，还是用minimum distance between two sorted array的双指针搞法求最短距离。12345678910111213141516171819202122232425262728293031323334353637class WordDistance &#123; Map&lt;String, List&lt;Integer&gt;&gt; map; Map&lt;String, Map&lt;String, Integer&gt;&gt; cache; public WordDistance(String[] words) &#123; map = new HashMap&lt;&gt;(); cache = new HashMap&lt;&gt;(); for (int i = 0; i &lt; words.length; i++) &#123; map.putIfAbsent(words[i], new ArrayList&lt;&gt;()); map.get(words[i]).add(i); &#125; &#125; public int shortest(String word1, String word2) &#123; if (cache.containsKey(word1) &amp;&amp; cache.get(word1).containsKey(word2)) &#123; return cache.get(word1).get(word2); &#125; List&lt;Integer&gt; index1 = map.get(word1); List&lt;Integer&gt; index2 = map.get(word2); int ptr1 = 0, ptr2 = 0, min = Integer.MAX_VALUE; while (ptr1 &lt; index1.size() &amp;&amp; ptr2 &lt; index2.size()) &#123; min = Math.min(Math.abs(index1.get(ptr1) - index2.get(ptr2)), min); if (min == 1) &#123; break; &#125; if (index1.get(ptr1) &lt; index2.get(ptr2)) &#123; ptr1++; &#125; else &#123; ptr2++; &#125; &#125; cache.putIfAbsent(word1, new HashMap&lt;&gt;()); cache.get(word1).put(word2, min); cache.putIfAbsent(word2, new HashMap&lt;&gt;()); cache.get(word2).put(word1, min); return min; &#125;&#125; 245. shortest-word-distance-iii 还是给一个String数组，给两个其中的String，求它们的最小距离。与i不同的是这两个word可能相同，不能返回0而是要找出两两之间的最短距离。 还是双指针法搞定。12345678910111213141516171819202122232425262728293031323334class Solution &#123; public int shortestWordDistance(String[] words, String word1, String word2) &#123; if (words == null || words.length == 0) &#123; return 0; &#125; if (word1.equals(word2)) &#123; int ptr = -1, min = words.length; for (int i = 0; i &lt; words.length; i++) &#123; if (words[i].equals(word1)) &#123; if (ptr == -1) &#123; ptr = i; &#125; else &#123; min = Math.min(i - ptr, min); ptr = i; &#125; &#125; &#125; return min; &#125; else &#123; int ptr1 = -1, ptr2 = -1, min = words.length; for (int i = 0; i &lt; words.length; i++) &#123; if (words[i].equals(word1)) &#123; ptr1 = i; &#125; else if (words[i].equals(word2)) &#123; ptr2 = i; &#125; if (ptr1 != -1 &amp;&amp; ptr2 != -1) &#123; min = Math.min(Math.abs(ptr1 - ptr2), min); &#125; &#125; return min; &#125; &#125;&#125; 246. strobogrammatic-number 给一个只含有数字的字符串，判断将它180度翻转后是否还是原来的字符串。skip. 250. count-univalue-subtrees 给一个二叉树，求其中所有节点的value都相同的子树个数。DFS+全局变量来求即可，当左子树和右子树都为uni-value时，再判断当前跟节点是否和左、右孩子都相等。skip。 252. meeting-rooms 给一个Interval的数组，每个Interval含有meeting的开始和结束时间戳，问是否能参加所有会议。 贪心算法，根据start排序，然后取前后两个看有没有overlap。1234567891011121314class Solution &#123; public boolean canAttendMeetings(Interval[] intervals) &#123; if (intervals == null || intervals.length == 0) &#123; return true; &#125; Arrays.sort(intervals, (a, b) -&gt; a.start - b.start); for (int i = 1; i &lt; intervals.length; i++) &#123; if (intervals[i].start &lt; intervals[i - 1].end) &#123; return false; &#125; &#125; return true; &#125;&#125; 253. meeting-rooms-ii 给一个Interval的数组，每个Interval含有meeting的开始和结束时间戳，求至少需要多少个meeting room. 最少的会议室就需要最大可能利用前面的会议室，因此需要记录之前的会议的结束时间，因此想到用PriorityQueue存，每次和最早结束的比较看看能否接上即可，然后把当前会议的结束时间加入PQ即可。最后在PQ中留下的会议个数就是需要的独立会议室个数。12345678910111213141516class Solution &#123; public int minMeetingRooms(Interval[] intervals) &#123; if (intervals == null || intervals.length == 0) &#123; return 0; &#125; Arrays.sort(intervals, (a, b) -&gt; a.start - b.start); PriorityQueue&lt;Integer&gt; endTime = new PriorityQueue&lt;&gt;(); for (int i = 0; i &lt; intervals.length; i++) &#123; if (!endTime.isEmpty() &amp;&amp; endTime.peek() &lt;= intervals[i].start) &#123; endTime.poll(); &#125; endTime.add(intervals[i].end); &#125; return endTime.size(); &#125;&#125; 254. factor-combinations 给一个整数，求它所有的factors的组合。 DFS(backtracking)，给定起始factor，循环判断能否整除直到n，能整除则递归下去求n/factor和factor为起始的新因数。递归停止条件是给的n小于等于1，说明没有更多factor了，这时就把这一路经过的因数存入ans。然后回到上一次调用递归的位置，删除path的最后一个factor，继续往后遍历。时间复杂度有点难分析。。。12345678910111213141516171819202122232425class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; getFactors(int n) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); if (n &lt; 4) &#123; return ans; &#125; getFactors(n, 2, new ArrayList&lt;Integer&gt;(), ans); return ans; &#125; private void getFactors(int n, int factor, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; ans) &#123; if (n &lt;= 1) &#123; // 已经除尽了，说明没有更多factor if (path.size() &gt; 1) &#123; // 当前path就是一路走过来用过的factor ans.add(new ArrayList&lt;Integer&gt;(path)); &#125; return; &#125; for (int i = factor; i &lt;= n; i++) &#123; if (n % i == 0) &#123; // 可以整除，说明i是n的一个factor path.add(i); // 将i加入path，将n除掉i，再递归从i开始继续往后找大于等于i的factor getFactors(n / i, i, path, ans); path.remove(path.size() - 1); &#125; &#125; &#125;&#125; 257. binary-tree-paths 给一个二叉树，返回所有从root到叶子节点的路径，用String的形式存入List。 ME：DFS搞定，但是我的字符串拼接不合理，&quot;-&gt;&quot;的拼接显得很笨。而且由于用了StringBuilder来真的拼接，所以在DFS结束之前还要删除当前的结果，速度还真不一定比String和加号来得快。写出来是这样。 TA：这个就是String和加号的，实在是太简洁啦！写出来是这样。这个则给出了Queue和Stack的方法，其实就是类似于层级遍历，找到叶子就把对应的String输出就欧了。Stack代码几乎一样，只不过由于每次都是先处理后进来的节点，所以效果是DFS，先获取的是最右边的路径，然后依次往左。还有一个recursive的，但没有辅助函数，每次将当前节点插入到递归返回列表中各字符串的前面，表示『是从我这个节点到这些字符串的』，最终就是完整的Path了。 need to know more different solutions.123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123; public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123; List&lt;String&gt; ans = new ArrayList&lt;&gt;(); dfs(root, ans, new StringBuilder()); return ans; &#125; private void dfs(TreeNode root, List&lt;String&gt; ans, StringBuilder sb) &#123; if (root == null) &#123; return; &#125; String temp = null; if (sb.length() == 0) &#123; temp = String.valueOf(root.val); &#125; else &#123; temp = "-&gt;" + String.valueOf(root.val); &#125; sb.append(temp); if (root.left == null &amp;&amp; root.right == null) &#123; ans.add(sb.toString()); &#125; else &#123; dfs(root.left, ans, sb); dfs(root.right, ans, sb); &#125; sb.delete(sb.length() - temp.length(), sb.length()); &#125;&#125;// no auxiliary methodsclass Solution &#123; public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123; List&lt;String&gt; ret = new ArrayList&lt;&gt;(); if (root == null) &#123; return ret; &#125; if (root.left == null &amp;&amp; root.right == null) &#123; ret.add(String.valueOf(root.val)); &#125; for (String path: binaryTreePaths(root.left)) &#123; ret.add(root.val + "-&gt;" + path); &#125; for (String path: binaryTreePaths(root.right)) &#123; ret.add(root.val + "-&gt;" + path); &#125; return ret; &#125;&#125; 258. add-digits 给一个非负数，不断把它各位加起来，求最终得到的一位数。follow-up是不用循环/递归，在O( 1 )时间内求。 ME：用循环搞啊，这没啥意思。但follow up的规律想了一下没想出来。 TA：这个在纸上写写，一下就搞出来了，没啥意思。。。 259. 3sum-smaller 给一个数组，和一个target，求数组中所有满足nums[i] + nums[j] + nums[k] &lt; target的组合数，即使数字相同只要index不同也算不同的组合。 固定k，双指针搞i和j。12345678910111213141516171819202122class Solution &#123; public int threeSumSmaller(int[] nums, int target) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; Arrays.sort(nums); int count = 0; for (int k = 2; k &lt; nums.length; k++) &#123; int t = target - nums[k]; int i = 0, j = k - 1; // 双指针 while (i &lt; j) &#123; if (nums[i] + nums[j] &lt; t) &#123; // 固定i，取j,j-1, ..., i+1 count += (j - i); i++; &#125; else &#123; j--; &#125; &#125; &#125; return count; &#125;&#125; 260. single-number-iii 给一个数组，大多数数字都是恰好出现两次，有两个单身狗只出现一次，找出这两个单身狗。follow-up是不能使用额外的空间。 ME：还是用了hashset才搞定。但这和前面137. single-number-ii不同了，因为在那里面都只有一个单身狗，而这里有俩。 TA：这个解释得很清楚。既然有两个不同的数，那么全部异或一遍之后，剩下的就是不同的这两个数的XOR结果，其中为1的就是二者不同的bit，随便取其中一位作为划分依据，这样原数组就分成了两派，一派是该bit为1的，一派是该bit为0的，分别去异或，最后剩下的就是两排中各自的单身狗了。代码参考的是这个，找不同的那个bit用的是取原异或结果的负数（等价于减一再取反），然后与原数做一个AND就得到了最右的原异或结果中的1、同时其他位全部为0.写出来是这样。 261. graph-valid-tree 给一个整数n和0~n-1的点组成的无向edges，判断这些点和边是否能组成valid1的tree. 方法一：tree的定义是每个点只有一个parent、边数是节点数-1. 并查集用来存放每个点的parent，每次加入无向边的时候先取两个点的root，这样可以随时判断是否成环（两个点已经共享root了）。最后再判断一下点数和边数即可。 123456789101112131415161718192021222324class Solution &#123; public boolean validTree(int n, int[][] edges) &#123; if (edges == null || edges.length == 0 || edges[0].length == 0) &#123; return true; &#125; int[] id = new int[n]; Arrays.fill(id, -1); // 初始时每个点都是root for (int i = 0; i &lt; edges.length; i++) &#123; int fromRoot = find(id, edges[i][0]); int toRoot = find(id, edges[i][1]); if (fromRoot == toRoot) &#123; // 成环时一定会归到同一root处 return false; &#125; id[toRoot] = fromRoot; &#125; return edges.length == n - 1; &#125; private int find(int[] id, int p) &#123; if (id[p] == -1) &#123; return p; &#125; return find(id, id[p]); &#125;&#125; 方法二：用图论的办法，先用Map建图，对于每一个node维护相邻点的set，然后DFS／BFS进行labeling。由于是一个tree，所以只能有一个label，因此一旦重复出现就说明两点之间有多于一条路径，成环了。 263. ugly-number 给一个int，判断它是否ugly number，即因数只由2、3、5组成。 ME：三个单独的循环，分别模5、3、2，最后看看是否剩下1.写出来是这样。 TA：差不多吧，有的大神把我5、3、2这三个循环都放到外层循环里了。 264. ugly-number-ii 给一个整数n，求第n个ugly-number。 ME：暴力法当然知道，就一波循环往后走，每个判断是否ugly-number呗。我又想了一个不太暴力的暴力法，就是用TreeSet，每次取最前的元素，尝试乘以2、乘以3这样往里放，然后每次就直接取首位就是当前的元素。不过为了防止越界，一开始用的是curr * i &gt; 0后来改成curr * i &gt; curr，最后改成curr * i / i == curr才对。写出来是这样的，略慢。。。tag给的是DP，但我没想出来怎么个DP法。 TA：这个讲得很棒。既然都是2、3、5的倍数组成的，那我们就可以分成三个独立的部分共同组成ugly-number的数组，每次从2、3、5倍数中选择最小的放到ugly中，然后更新被选中的那个的倍数，即从ugly中一直往后取倍数乘以相应的2/3/5。写出来是这样，注意中间的三个if不可以写成else if，因为可能factor有重复的，例如2*3和3*2，一旦取了6，factor2和factor3都需要更新。这应该就是题目想要考察的DP了。 266. palindrome-permutation 给一个String，判断它的某一个排列是否能形成palindrome。 看看是否有多于一个奇数count的字符即可。123456789101112131415161718192021class Solution &#123; public boolean canPermutePalindrome(String s) &#123; if (s == null || s.length() == 0) &#123; return true; &#125; boolean[] isOdd = new boolean[256]; for (char c : s.toCharArray()) &#123; isOdd[(int)c] = !isOdd[(int)c]; &#125; boolean hasOdd = false; for (int i = 0; i &lt; isOdd.length; i++) &#123; if (isOdd[i]) &#123; if (hasOdd) &#123; return false; &#125; hasOdd = true; &#125; &#125; return true; &#125;&#125; 268. missing-number 给一个规模为n的数组，里面包含了0~n-1的数字，除了一个，找到缺的这一个。要求linear time complexity. ME：很直接地想到了木桶法呀。follow-up要求不用extra space，感觉又是异或，但是没试出来。。。 TA：这里列举了三种方法，一是求和法，可以用『首项加末项乘以项数除以二』先求出总和，然后逐个去减，最后得到的就是那个Missing Number了。二是位操作，利用a ^ b ^ b = a，从头到尾一口气异或索引和数字，因为基本上每个索引都会对应到它的数字，0-0, 1-1, ..., nums[index] - index，除了缺的那个数。写出来是这样。三是二分查找，不过还有一步排序并不是O(N)，所以不太合题意。 269. alien-dictionary 给一个按照某种外星人字典序排好序的String数组，只包含小写字母，求这些出现过的字母的顺序。若有多种可能（平级）则任意顺序均可。 topo排序问题，前后两个字符串逐个字符找到第一对不同的字符，确定先后顺序（前-&gt;后）构成一条边，两两字符串全部遍历完之后就形成了一个graph。维护一个inDegree，每次BFS时从入度为0的节点出发，将它可达的所有邻接点的入度都减1（删掉这些边），最后如果全部字符都遍历到了即可。如果出现了环，则一定会又入度不为0的点残留。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution &#123; public String alienOrder(String[] words) &#123; if (words == null || words.length == 0) &#123; return ""; &#125; Map&lt;Character, Set&lt;Character&gt;&gt; graph = new HashMap&lt;&gt;(); Map&lt;Character, Integer&gt; inDegree = new HashMap&lt;&gt;(); initInDegree(words, inDegree); buildGraph(words, graph, inDegree); Queue&lt;Character&gt; q = new LinkedList&lt;&gt;(); for (char c : inDegree.keySet()) &#123; if (inDegree.get(c) == 0) &#123; q.offer(c); &#125; &#125; StringBuilder sb = new StringBuilder(); while (!q.isEmpty()) &#123; char c = q.poll(); sb.append(c); if (graph.containsKey(c)) &#123; Set&lt;Character&gt; neighbors = graph.get(c); for (char neighbor : neighbors) &#123; inDegree.put(neighbor, inDegree.get(neighbor) - 1); if (inDegree.get(neighbor) == 0) &#123; q.offer(neighbor); &#125; &#125; &#125; &#125; if (sb.length() != inDegree.size()) &#123; return ""; &#125; return sb.toString(); &#125; private void initInDegree(String[] words, Map&lt;Character, Integer&gt; inDegree) &#123; for (String word : words) &#123; for (char c : word.toCharArray()) &#123; inDegree.put(c, 0); &#125; &#125; &#125; private void buildGraph(String[] words, Map&lt;Character, Set&lt;Character&gt;&gt; graph, Map&lt;Character, Integer&gt; inDegree) &#123; for (int i = 1; i &lt; words.length; i++) &#123; String prev = words[i - 1]; String curr = words[i]; int len = Math.min(prev.length(), curr.length()); for (int j = 0; j &lt; len; j++) &#123; char c1 = prev.charAt(j); char c2 = curr.charAt(j); if (c1 != c2) &#123; // 找到第一个不同的字母 graph.putIfAbsent(c1, new HashSet&lt;Character&gt;()); if (graph.get(c1).add(c2)) &#123; inDegree.put(c2, inDegree.get(c2) + 1); &#125; break; &#125; &#125; &#125; &#125;&#125; 271. encode-and-decode-strings 实现encode和decode函数，将字符串List和单一条字符串互相转换。 字符含有哪些？（所有ASCII字符都可能出现） 由于每个符号都有可能出现，所以不能想着用某个特殊符号来拼接和拆分。因此需要额外的信息进行标记，这里用的是在/之前加上所跟字符串的长度的方式，decode时每次从特定位置开始找/，然后取出它前面的长度信息直接截取后面的子字符串。1234567891011121314151617181920212223public class Codec &#123; // Encodes a list of strings to a single string. public String encode(List&lt;String&gt; strs) &#123; StringBuilder sb = new StringBuilder(); for (String str : strs) &#123; sb.append(str.length()).append("/").append(str); // 长度 + / + 字符串内容 &#125; return sb.toString(); &#125; // Decodes a single string to a list of strings. public List&lt;String&gt; decode(String s) &#123; List&lt;String&gt; ans = new ArrayList&lt;&gt;(); int i = 0; while (i &lt; s.length()) &#123; int index = s.indexOf("/", i); int len = Integer.valueOf(s.substring(i, index)); ans.add(s.substring(index + 1, index + 1 + len)); i = index + 1 + len; &#125; return ans; &#125;&#125; 273. integer-to-english-words 给一个非负的整数，返回它对应的英文念法字符串。 ME：各种判断，然后递归去求每三位的念法，写出来是这样。其实没什么算法上的难度。。。 TA：这个和我的思路差不多，不过他直接用的是数字，没想到也挺方便的！也是每次取三位来转换，在数字这里就直接是num % 1000了。而且答主也没有纠结空格加不加，反正统一都在末尾加上空格，最后返回之前就trim一下就行了。 274. h-index 给一个数组，存的是某学者的论文的引用数，求这个学者的h-index，既他有h篇论文引用数大于等于h，剩下的N - h篇都小于等于h。 ME：我原本的想法是，排个序，然后二分查找。但是各种边缘条件搞得我崩溃。。。失败 TA：挖去，原来二分竟然是比较弱的了，因为你排个序起码就O(NlogN)了。这个O(N)的木桶法非常好懂，思路是声明一个规模恰好比原数组多1的bucket，表示索引为i的论文有bucket[i]篇。然后根据引用数在相应索引处加加，注意有可能引用数超过了规模，那么统一加到最大索引处。然后再一波流从后往前累加，当刚好累加到论文数大于等于索引（引用数）的时候，就可以输出了；若一直都没有，说明全都集中在0，那就输出0吧。写出来是这样. 275. h-index-ii 如果原citations数组已经是升序排列了，改进算法。 ME：这绝笔是二分查找了，之前搞了一晚上没搞出来。。。这次就直接看discuss了，因为我怀疑搞不出来是因为理解有误。 TA：这个说了，不可能有多个解，所以只要符合条件的h就可以直接输出了。我先参考了这个，一旦找到引用数与右边论文数相等的就直接输出；若引用数略小，说明右边论文数太多，提升左界；若引用数略大，说明应该往左多取一些论文，下降右界；最后输出有不需要那么多乱起八糟的判断，直接输出右边论文数就可以了，即len - (right + 1) = len - left。回帖里有个大神说她的更标准，因为要求一个边界是可以取的而另一个是不可取的，这个还是第一次听说。。。 277. find-the-celebrity 给一个API函数判断i是否认识j，celebrity的定义是在n个人中，n-1个人都认识他、他却完全不认识他们。 O(n^2)搞定，对于每个人，一旦他认识别人、或者别人不认识他就跳出循环。 12345678910111213141516171819202122/* The knows API is defined in the parent class Relation. boolean knows(int a, int b); */public class Solution extends Relation &#123; public int findCelebrity(int n) &#123; for (int i = 0; i &lt; n; i++) &#123; boolean found = true; for (int j = 0; j &lt; n; j++) &#123; if (j == i) &#123; continue; &#125; if (!knows(j, i) || knows(i, j)) &#123; // 看别人是否都认识i且i完全不认识别人 found = false; break; &#125; &#125; if (found) &#123; return i; &#125; &#125; return -1; &#125;&#125; 此外还有一种更巧妙的办法，从头开始一个pass，判断如果i认识j则把candidate设为j，如果i不认识j则j不可能是candidate；然后再一个pass看这个candidate是不是不认识所有人、且所有人都认识他。 12345678910public int findCelebrity(int n) &#123; int candidate = 0; // 先假设第一个人是名人 for (int i = 1; i &lt; n; i++) &#123; // 他认识别人就，把他排除掉了 if (knows(candidate, i)) candidate = i; &#125; for (int i = 0; i &lt; n; i++) &#123; // 确认他是否认识某个人或者某个人不认识他，那他也不是名人 if (i != candidate &amp;&amp; (knows(candidate, i) || !knows(i, candidate))) return -1; &#125; return candidate;&#125; 278. first-bad-version 给一个整数n表示最新的版本号，从1到n一旦有一个版本是bad，那么后续全都是bad，找到这第一个bad的版本。判断某版本号是否bad调用题目本身提供的API，不用理。 ME：必须二分查找啊，写出来是这样。 TA：看了很多答案都比我的简洁，比如这个.我最后那个判断left是否bad其实没有必要，因为当right - left = 2的时候，mid刚好比left多1，如果它是bad，那么right就会降到mid；若mid不是bad，left直接飙升到mid + 1 = right，此时right也是bad，因此最后统一返回right就好了。 279. perfect-squares 给一个正整数，求至少由多少个平方数相加能得到它。 ME：这题不会啊。感觉是要DP的，列了个数组，但是没找到前后依赖/转换关系。陷入江局。。。 TA：看了这个，感觉也不难啊哥，可能今天状态不好吧。第一个DP的思路是，把当前数减去一个平方数，求得索引对应的值加1就是了，遍历当前索引能减的所有平方数（相减后非负）。写出来是这样。第二种DP就是把dp数组声明为static的List，持续add在末尾，这样当重复构造Solutions类对象的时候，可以共用一个，如果之前的结果已经求出来了，后续便可以直接访问了。第三种是用拉格朗日数学定理『Legendre’s three-square theorem』，结果只可能是1、2、3、4四种，写一个isSquare函数判断是否平方数得到结果1，利用定理知当且仅当n != 4^a (8b + 7)的时候，n由三个完全平方数组成，因此当n == 4^a (8b + 7)时，结果要么为4要么为2。第四种方法是BFS，首先把不大于n的平方数列举出来，入队后对这些平方数进行拓展，逐个加平方数并入队，直到达到n。 280. wiggle-sort 给一个int数组，要求重新排序使得nums[0] &lt;= nums[1] &gt;= nums[2] &lt;= nums[3]...。 抽象以下就是需要奇数位大于等于前一位、偶数位小于等于前一位。in-place做法比较tricky，利用swap。假设0~i满足条件，当i是odd，如果nums[i+1]大于nums[i]了，就需要swap一下i和i+1，因为nums[i]已经大于等于前一位了，比他大的nums[i+1]换过来肯定行。123456789101112131415161718192021public void wiggleSort(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; if (i % 2 == 1) &#123; // 对于奇数位，必须不小于前一位 if (nums[i] &lt; nums[i - 1]) &#123; swap(nums, i, i - 1); &#125; &#125; else &#123; // 对于偶数位，必须不大于前一位 if (i &gt; 0 &amp;&amp; nums[i] &gt; nums[i - 1]) &#123; swap(nums, i, i - 1); &#125; &#125; &#125;&#125;private void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp;&#125; 281. zigzag-iterator 给两个List，实现Iterator交替输出二者的元素。 用Queue的思路，如果List还有多的元素就把它的iterator放进去，没有就继续。使用Queue拓展成k个List输入也很方便。12345678910111213141516171819202122232425public class ZigzagIterator &#123; private Queue&lt;Iterator&gt; q; public ZigzagIterator(List&lt;Integer&gt; v1, List&lt;Integer&gt; v2) &#123; q = new LinkedList&lt;&gt;(); if (v1 != null &amp;&amp; !v1.isEmpty()) &#123; q.offer(v1.iterator()); &#125; if (v2 != null &amp;&amp; !v2.isEmpty()) &#123; q.offer(v2.iterator()); &#125; &#125; public int next() &#123; Iterator it = q.poll(); int ret = (Integer) it.next(); if (it.hasNext()) &#123; q.offer(it); &#125; return ret; &#125; public boolean hasNext() &#123; return !q.isEmpty(); &#125;&#125; 282. expression-add-operators 给一个纯数字的字符串和一个int的目标值，求这些数字通过加、减、乘如何能够得到target。数字可以组合成多位数但必须维持原顺序，且需要注意运算优先级。 ME：题目描述的最后一句话是我按照自己理解码完代码（递归）才发现的漏洞，多位数倒是好解决（递归外加一层循环），但是优先级是真的不知所措。。。 TA：参考了这个，和我的思路基本一致，处理优先级用的是反向相减，利用一个multi参数记录『如果接下来的操作符是乘法，应该乘的数』，如果再往前一步是+ x，那碰到+ x*y的时候就要先从当前结果中减去x再加上x * y；如果是- x，就直接当成『加负数』来看待就好了；如果是* x，优先级是相同的，那就是从当前结果中减去multi再加回multi乘以当前的数字。此外，还需要考虑Integer的边缘情况，直接用Long就搞定了。在我原本的版本上改了一下，写出来是这样。还有这个DFS方法，感觉也是大同小异，怎么会那么快？它就是把相加的时机滞后了，这样就可以持续计算相乘的结果，而不往里加，一旦出现优先级变化才会真正加到结果中。 283. move-zeroes 给一个数组，要求把所有0挪到非零的右边，并保持原有非零项的相互顺序。要求In-place，并尽可能减少操作。 ME：从前往后遍历，碰到零就往后找非零元素并swap。写出来是这样，有点慢。 TA：这个告诉你，根本不需要用到swap，直接覆盖就好了。思路是从前往后找非零元素，然后直接赋值给Index对应位置，一直遍历一波，这样Index就保存了原数组中所有的非零元素了，最后再往后全部赋值为0即可。这个也用到了swap，但比你的简洁太多，用一个j记录『最前的0的索引』，然后i往后找非零元素跟j交换即可。后面还有一个one line python的，用的是sort的comparator，让非零元素在零前面，也是666。 284. peeking-iterator design题，实现一个具有peek功能的iterator，返回的是调用Next时的元素。 ME：不太懂Iterator有啥用，直接看了discuss。 TA：一开始看的是这个，其实就是比正常的Iterator多维护了一个变量next，存储peek应当返回的元素。原po判定hasNext是通过next变量是否为Null来判定的，但这个答主认为，Null理论上是可以作为合法的元素放进去的，因此应当额外维护一个done的布尔值判定是否已经全部吐干净了。 286. walls-and-gates 给一个mxn的int数组，INF表示空房间、-1表示走不通、0表示可走的gate，更新每个INF为到最近的gate的距离。 BFS，先一波O(MN)把所有gate入queue，然后从每个gate出发，先到的INF就一定是最短的。123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; private final int INF = 2147483647; public void wallsAndGates(int[][] rooms) &#123; if (rooms == null || rooms.length == 0 || rooms[0].length == 0) &#123; return; &#125; // BFS，从每个gate出发，先到的INF就一定是最短的 Queue&lt;int[]&gt; cells = new LinkedList&lt;&gt;(); int rows = rooms.length, cols = rooms[0].length; for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; cols; j++) &#123; if (rooms[i][j] == 0) &#123; cells.offer(new int[] &#123;i, j&#125;); // 所有gate作为起点 &#125; &#125; &#125; while (!cells.isEmpty()) &#123; int[] cell = cells.poll(); int row = cell[0], col = cell[1]; // 上下左右更新，同时入queue if (row &gt; 0 &amp;&amp; rooms[row - 1][col] == INF) &#123; rooms[row - 1][col] = rooms[row][col] + 1; cells.offer(new int[] &#123;row - 1, col&#125;); &#125; if (row + 1 &lt; rows &amp;&amp; rooms[row + 1][col] == INF) &#123; rooms[row + 1][col] = rooms[row][col] + 1; cells.offer(new int[] &#123;row + 1, col&#125;); &#125; if (col &gt; 0 &amp;&amp; rooms[row][col - 1] == INF) &#123; rooms[row][col - 1] = rooms[row][col] + 1; cells.offer(new int[] &#123;row, col - 1&#125;); &#125; if (col + 1 &lt; cols &amp;&amp; rooms[row][col + 1] == INF) &#123; rooms[row][col + 1] = rooms[row][col] + 1; cells.offer(new int[] &#123;row, col + 1&#125;); &#125; &#125; &#125;&#125; 287. find-the-duplicate-number 给一个规模为n + 1的数组，元素的值域为[1, n]，其中有一个元素是重复的，重复次数未知，求这个重复的数。原数组不可修改，时间复杂度必须小于O(N^2)，O(1)空间。 ME：对于这种计数的题，一旦不给用extra space比如HashSet之类的，我就懵逼了。之前做的使用异或操作，但这题想了半天似乎找不出异或能怎么解决。陷入江局。。。 TA：这个真的是逆天了，竟然能把这个找重复元素的问题转化成『找链表环的入口』的问题。答主的解释是，既然所有元素都只出现一次而某一个出现多次，而且元素的值域严格限制在数组规模以内，那就可以利用当前索引对应的值作为下一步访问的索引，一路访问，利用快慢指针（索引），当两个指针相遇后再从头来多一个指针，和慢指针同时继续后移，相遇即为环的入口。模仿出来是这样。当然前面这个方法比较难想到，但是另一个基于Binary Search思想的方法讲道理应该是能想出来的。既然元素值域为[1, n]，那每次取中值mid，再O(n)扫一遍看看小于等于mid的元素数是否小于等于mid个（小于是因为不要求每个元素都出现），最终下界即为所求。模仿出来是这样。 288. unique-word-abbreviation 给一个String数组，对每个string求abbreviation，保留头尾两个字母，中间替换成长度。主要需要clarify什么叫unique，若其中已经存在这个abbr而src不同，则不唯一；但如果是同一个src形成的abbr，则视作唯一的。skip。 289. game-of-life 经典的GameOfLife问题，如果细胞周围有超过三个就死，少于两个也死，而死细胞周围恰好有三个的时候就可以复活。 ME：in-place搞定，活细胞死则保持1、死细胞复活也保持0；活细胞活为2，死细胞死为-1，最后在遍历一波将大于1的值都减1、小于1的都加1。写出来是这样。 TA：这个和我的也差不多吧，不过答主用的是2-bit的形式来区分状态的，第一位bit是新的状态，第二位bit是原本的状态，最后只要全部右移一位就把旧的状态抹去了。follow-up有个问题是说如果是无线大的棋盘怎么办，这个大神给出了解答. 290. word-pattern 给两个String，一个表示pattern，另一个是待匹配的由空格分隔的若干单词组成的字符串，判断是否匹配。 ME：直接用HashMap搞定。写出来是这样。 TA：这个略叼，第一次见Map可以不指定type混存的，大神答主同时把char和string作为key、索引作为value存入map。如果其中一个key重复了就会存入失败，这样就检测出不匹配了。 291. word-pattern-ii 给两个String，其中一个作为pattern如abab，另一个作为str，判断str是否符合给定的pattern。 DFS暴力解法。每一个字符可能会映射到一个单词，因此需要一个map维护这种映射关系。从pattern出发，每一个字符可能映射1～整个str这么长，递归判断即可。123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public boolean wordPatternMatch(String pattern, String str) &#123; Map&lt;Character, String&gt; char2WordMap = new HashMap&lt;&gt;(); Set&lt;String&gt; wordSet = new HashSet&lt;&gt;(); return checkMatch(pattern, 0, str, 0, char2WordMap, wordSet); &#125; private boolean checkMatch(String pattern, int patternIndex, String str, int strIndex, Map&lt;Character, String&gt; char2WordMap, Set&lt;String&gt; wordSet) &#123; if (patternIndex == pattern.length() &amp;&amp; strIndex == str.length()) &#123; // 同时到末尾，完美 return true; &#125; if (patternIndex == pattern.length() || strIndex == str.length()) &#123; // 某一个已经到末尾，gg return false; &#125; char c = pattern.charAt(patternIndex); if (char2WordMap.containsKey(c)) &#123; // 该字符已经有映射，则判断在str中是否符合 String word = char2WordMap.get(c); if (!str.startsWith(word, strIndex)) &#123; // strIndex标记起始位置 return false; &#125; return checkMatch(pattern, patternIndex + 1, str, strIndex + word.length(), char2WordMap, wordSet); &#125; // 若没有这个字符的映射，则需要遍历后续所有可能的情况，逐一判断 for (int endIndex = strIndex + 1; endIndex &lt;= str.length(); endIndex++) &#123; String word = str.substring(strIndex, endIndex); if (wordSet.contains(word)) &#123; // 防止a-&gt;xxx, b-&gt;xxx的情况 continue; &#125; char2WordMap.put(c, word); wordSet.add(word); if (checkMatch(pattern, patternIndex + 1, str, endIndex, char2WordMap, wordSet)) &#123; return true; &#125; wordSet.remove(word); char2WordMap.remove(c); &#125; return false; &#125;&#125; 292. nim-game 两个人玩取石头的游戏，每次取1/2/3个，最后把石头取完的赢。给一个整数表示石头数，判断先取者是否能稳赢。 ME：一开始还用了个DP数组，结果爆内存。后来改成模4一行搞定，摊手。 TA：模4也可以用位操作表示成这样。其实也有人提出了DP的方法。 295. find-median-from-data-stream 在一个数字输入流中，随时调用函数返回当前的中位数。 ME：要维护从小到大顺序，又要方便访问到中间的元素。。。陷入了江局。瞄了一眼讨论版，看见了要用到两个Heap，前一半和后一半，秒懂。不过Heap我一开始用的是TreeSet，但是这就不允许重复元素了。而PriorityQueue就没法自由访问最前和最后的元素了，再次陷入江局。再次偷看discuss，发现了Collections.reverseOrder，再观察我的代码，对于前半部分我只需要访问最后一个数字，那就直接反过来，就这样过了。 TA：我最开始看的是这个大神的，答主先直接都变成了Long类型来防止Integer的越界问题。每次直接add到large中，同时把large首位poll出来取个负数直接add到small中。若large元素少于small了，再把small首位（最小的负数即最大的正数）poll出来add到large中。取Medium的时候若large元素多于small，直接就取large的最小元素即可，否则就取large最小元素和small最小元素之负数的平均数。至于我是怎么想到要Collections.reverseOrder，就是看这个了，原po的答案有点绕。但他们的答案真的很简洁呀！第一遍我先不追求简洁，做出来、逻辑清晰就好。 297. serialize-and-deserialize-binary-tree LeetCode中对树的表示是通过数组的形式来做的，这题就是实现一下如何在树节点和它对应的字符串表示，空节点就是null。刚好之前东哥问了一个类似的问题，他还是自己想的，相当于他自己搞了一个Hard题出来？ ME：题目规定了不能在类中用新的变量来记录state。所以就是BFS咯，写出来是这样。用类似于层级遍历的思路，维护两个Queue，一个存放有效的节点、一个存放Null的索引。根据上一层的有效节点数 * 2得到当前层的节点数，然后用for循环从0开始，如果匹配到Null的索引，就在字符串上拼上,null，否则就正常从节点队列中取队首并拼接到字符串中，同时判断该节点的左右孩子是否为空，为空就把索引add到索引队列中。需要指出的是，for循环的变量和计算孩子索引所用的变量是不同的，每一层的『有效孩子节点数』需要单独用当前层级的『有效节点数』count记录，乘以2就得到了理论的孩子节点数了。 TA：唔。。。事实上不需要严格按照LeetCode的字符串格式来表示树，所以这个方法就直接用X代替了Null，没有前后的方括号，也没有处理最末位的逗号，直接用一个队列（原po用了Deque但这里用了Queue）存储经过split的各个字符串数字。递归地访问各个节点并将节点的值拼接到StringBuilder上；在恢复成树的时候，从队首取出字符、转为数字并新建一个节点出来，此时队列已经更改了，再调用buildTree就能构建左右孩子了。这样写简洁很多。 298. binary-tree-longest-consecutive-sequence 给一个二叉树，求其中parent-child路径最长的连续increasing的长度。 递归+全局变量，初始长度为1表示若以当前节点结束，可以增加长度为1，然后递归潜入下层child，如果发现当前节点和child可以形成increment则将递归返回的长度加1，返回给上层。12345678910111213141516171819202122class Solution &#123; private int max = 0; public int longestConsecutive(TreeNode root) &#123; helper(root); return max; &#125; private int helper(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; int len = 1; // 以当前节点结束，则长度为1 int left = helper(root.left), right = helper(root.right); if (root.left != null &amp;&amp; root.left.val == root.val + 1) &#123; len = left + 1; // 根据孩子节点val判断长度是否累加 &#125; if (root.right != null &amp;&amp; root.right.val == root.val + 1) &#123; len = Math.max(len, right + 1); // 取两个孩子长度的max &#125; max = Math.max(max, len); return len; &#125;&#125; 299. bulls-and-cows 给两个String，secret表示预先确定的数字串，guess表示猜测的数字串。bull表示数字和位置完美匹配，cow表示数字是对的但是位置不对，二者不能重复计算。最后返回xAyB的字符串。 ME：首先判断是否完美匹配（bull），不完美匹配则用bucket记录，若在secret中出现则加加、在guess中出现则减减。cow的判断就是依赖这个bucket，如果在加的时候已经是负数，说明在guess中出现过；反之亦然。写出来是这样。 TA：没啥了。 300. longest-increasing-subsequence 给一个无序数组，求其中最长升序子序列的长度。 ME：题目基本的要求是时间复杂度在O(N^2)，所以一开始我就直接暴力搞了，固定一个值然后往后取比它大的，递归到最后再换一个值继续循环，结果超时。挠破头皮也没想出来，感觉会不会是DP？一看tag果然。。。 TA：非常恼火连O(N^2)的方法都搞不出来，看了这个发现真的不难，DP的思路是固定子序列的最后一个元素，然后从最前方往后遍历判断『取当前子序列的最后一个元素』的时候，最长长度是多少。真的不难才对，模仿着写出来是这样。另外还有二分查找的方法，简直是五体投地螺旋服。维护一个数组tail，tail[i]表示当最长升序子序列的长度为i+1的时候，所有可能中最大元素的最小值。在二分查找中左界为0、右界为当前的tail已填充的size，求一个中点。从原数组中取元素x出来，若tail[mid] &lt; x，说明还能再往后找找，左界往后，否则就压缩右界。当前后两个指针相等时，直接更新当前位置的tail，然后若i已经到达末尾则更新size。真的。。。强！服！]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>algorithm</tag>
        <tag>interview</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Note for LeetCode in Java (101~200)]]></title>
    <url>%2F2017%2F05%2F14%2Fjava_leetcode2%2F</url>
    <content type="text"><![CDATA[刷题。祝我好运。 101. symmetric-tree 给一个二叉树根节点，判断这棵树是否对称。recursive和iterative都想想。 ME：只想到了recursive，很好写。iterative一开始想到了中序遍历转成前后对称的数组来判断，但感觉是小题大作了，毕竟中序遍历似乎并不必要。偷看了一下关键词，DFS和BFS。 TA：这个告诉你，原来可以借助Stack！每次取栈顶两个节点，先判断其值是否相等，然后将二者的左、右子节点和右、左子节点入栈，继续判断。 JAVA可以重载呀，同名方法、不同参数列表即可，不用绞尽脑汁想另一个名字哇。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// recursiveclass Solution &#123; public boolean isSymmetric(TreeNode root) &#123; if (root == null) &#123; return true; &#125; return helper(root.left, root.right); &#125; private boolean helper(TreeNode left, TreeNode right) &#123; if (left == null &amp;&amp; right == null) &#123; return true; &#125; if (left == null || right == null) &#123; return false; &#125; if (left.val == right.val) &#123; return helper(left.left, right.right) &amp;&amp; helper(left.right, right.left); &#125; return false; &#125;&#125;// iterativeclass Solution &#123; public boolean isSymmetric(TreeNode root) &#123; if (root == null) &#123; return true; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root.left); stack.push(root.right); while (!stack.isEmpty()) &#123; TreeNode left = stack.pop(); // take two nodes from stack top if (stack.isEmpty()) &#123; return false; // should always have 2 at &#125; TreeNode right = stack.pop(); if (left == null &amp;&amp; right == null) &#123; continue; &#125; if (left == null || right == null || left.val != right.val) &#123; // ensure equal return false; &#125; stack.push(left.left); // push 2 symmetric positions into stack stack.push(right.right); stack.push(left.right); stack.push(right.left); &#125; return true; &#125;&#125; 102. binary-tree-level-order-traversal level层面的遍历二叉树，返回一个List&lt;List&lt;Integer&gt;&gt;。 ME：用了辅助的List&lt;List&lt;TreeNode&gt;&gt;记录每一层的节点情况，同时为了防止加入空的List，设置了一个isNull布尔值判断是否这一层已经没有后续节点了。相当于BFS。 TA：BFS原来不用多一个双重List，直接一个Queue就搞定了。这个DFS方法则是通过Level层级控制当前节点应当塞到哪一层对应的List当中。1234567891011121314151617181920212223242526class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); if (root == null) &#123; return ans; &#125; Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.add(root); while (!q.isEmpty()) &#123; List&lt;Integer&gt; curr = new ArrayList&lt;&gt;(); int len = q.size(); while (len-- != 0) &#123; TreeNode node = q.poll(); curr.add(node.val); if (node.left != null) &#123; q.add(node.left); &#125; if (node.right != null) &#123; q.add(node.right); &#125; &#125; ans.add(curr); &#125; return ans; &#125;&#125; 103. binary-tree-zigzag-level-order-traversal level层面的遍历二叉树，但是遍历顺序不是固定的从左到右，而是蛇形，这一层从左到右、下一行从右到左。 ME：使用Queue&lt;TreeNode&gt;+按照每层节点计数循环遍历的BFS比较容易想到，根据level的奇偶，在加入结果之前将当前层级的List使用Collections.reverse反转一下就好了。而DFS也是利用level的奇偶，决定把当前节点的值插入List的头还是尾。DFS还是略快一点。 TA：看这个发现，BFS的时候也可以用LinkedList的addFirst将当前值插入头部（或者ArrayList的add(index, Element)），而不必在最后来Collections.reverse。 should be simple to come up with reversed version of normal level-traverse…12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); if (root == null) &#123; return ans; &#125; Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.add(root); boolean rev = false; while (!q.isEmpty()) &#123; int len = q.size(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while (len-- != 0) &#123; TreeNode node = q.poll(); list.add(node.val); if (node.left != null) &#123; q.add(node.left); &#125; if (node.right != null) &#123; q.add(node.right); &#125; &#125; if (rev) &#123; Collections.reverse(list); &#125; ans.add(list); rev = !rev; &#125; return ans; &#125;&#125;class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); if (root == null) &#123; return ans; &#125; dfs(root, ans, 0); return ans; &#125; private void dfs(TreeNode root, List&lt;List&lt;Integer&gt;&gt; ans, int level) &#123; if (root == null) &#123; return; &#125; if (level == ans.size()) &#123; ans.add(new LinkedList&lt;Integer&gt;()); &#125; List&lt;Integer&gt; list = ans.get(level); if (level % 2 == 1) &#123; // odd level should reverse list.add(0, root.val); &#125; else &#123; list.add(root.val); &#125; dfs(root.left, ans, level + 1); dfs(root.right, ans, level + 1); &#125;&#125; 104. maximum-depth-of-binary-tree 求二叉树的深度。 ME：三行的递归。毕竟衣洗题。 TA：没啥了。 105. construct-binary-tree-from-preorder-and-inorder-traversal 给出前序遍历和中序遍历的数组，构造一个完整的二叉树，树的节点值不会重复。 ME：明明是数据结构讲树的时候讲过的，但是就是不记得了。。。憋了很久，不会。偷看了一下tag，提到了DFS。更可怕的是，我发现中序和前序被我搞反了，做的草稿都是反的。 TA：这个介绍得很清楚，在preorder中先出现的一定是root，那么对应在inorder中找到它的位置，其左到inStart都是它左子树的节点，其右到inEnd都是它右子树的节点，递归下去找root的左节点和右节点即可。注意此题说了节点的值不重复，因此用循环在inorder中找root的位置时一旦找到就可以break；但如果允许值重复，则应当保证是当前查找范围内『最后一个出现的』，这也是上面这个答案的方式。我一开始一直在思考怎么用Stack，似乎记得老师讲过，果然看到了这个用栈的iterative方法，不过其实这个Java版的更简洁，或者看我提交的，Java版的思路是先把跟节点入栈，然后每次从取栈顶元素和inorder比，不匹配则继续把preorder元素入栈；一旦匹配则持续出栈并继续与inorder后续元素比较，直到栈顶元素不再匹配，则把最后一个匹配的栈顶元素的右节点设为preorder的元素并入栈。 very basic isn’t it? But need to know the iterative one.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123; public TreeNode buildTree(int[] preorder, int[] inorder) &#123; if (preorder == null || inorder == null) &#123; return null; &#125; return helper(preorder, inorder, 0, 0, inorder.length - 1); &#125; private TreeNode helper(int[] preorder, int[] inorder, int preStart, int inStart, int inEnd) &#123; if (preStart == preorder.length || inStart &gt; inEnd) &#123; return null; &#125; int pos = inStart; for (int i = inStart; i &lt;= inEnd; i++) &#123; if (inorder[i] == preorder[preStart]) &#123; // get the pos of current root in inorder pos = i; &#125; &#125; TreeNode root = new TreeNode(preorder[preStart]); // all in front of pos in inorder are in left part, while latter are in right part root.left = helper(preorder, inorder, preStart + 1, inStart, pos - 1); root.right = helper(preorder, inorder, preStart + 1 + pos - inStart, pos + 1, inEnd); // note that right part need to shift (pos - inStart), which means how many elements in left. return root; &#125;&#125;class Solution &#123; public TreeNode buildTree(int[] preorder, int[] inorder) &#123; if (preorder == null || inorder == null || preorder.length == 0 || inorder.length == 0) &#123; return null; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode root = new TreeNode(preorder[0]); TreeNode prev = root; int indexPre = 1, indexIn = 0; while (indexPre &lt; preorder.length) &#123; if (prev.val == inorder[indexIn]) &#123; // reaches a root of its subtree indexIn++; while (!stack.isEmpty() &amp;&amp; inorder[indexIn] == stack.peek().val) &#123; prev = stack.pop(); // pop until reaches previous root indexIn++; &#125; TreeNode curr = new TreeNode(preorder[indexPre]); // always take from preorder prev.right = curr; // set to previous root's right prev = curr; // go into right &#125; else &#123; TreeNode curr = new TreeNode(preorder[indexPre]); // take from preorder prev.left = curr; // simply means curr is prev's left stack.push(prev); prev = curr; &#125; indexPre++; &#125; return root; &#125;&#125; 106. construct-binary-tree-from-inorder-and-postorder-traversal 给出中序遍历和后续遍历的数组，构造一个完整的二叉树。节点值不重复。 ME：按照上一题学习的，用Stack搞的iterative方法和recursive的方法都搞定了，毕竟刚刚才做过，记忆还很新鲜。 TA：由于元素不重复，因此可以考虑用一个HashMap来保存inorder中的值与对应的索引，这样就省去了线性查找的时间了。 107. binary-tree-level-order-traversal-ii 给一个二叉树的头结点，返回按从下到上的层级遍历的结果。 ME：老办法，BFS用一个Queue从上到下遍历，返回之前Collections.reverse一发。还尝试了一波DFS，借助level，最后reverse。 TA：我的方法应该是有点取巧了lol，虽然应该是比add(index, Element )好一点的，取反是一波流，而每次插入挪动的元素反而还多。通常大家的做法是，BFS中每次添加到结果的时候用add(0, List )，DFS中则是get的时候不是直接get对应level的那个List去添加，而是size - level - 1取到对称位置的。 108. convert-sorted-array-to-binary-search-tree 给一个排好序的数组，构造出对应的二分查找树。 ME：recursive的方法，每次进行二分找到根节点，然后在前、后两半各自确定左、右子节点。 TA：同样有大神将recursive的方法改成了iterative的方法，利用了三个stack模拟递归。递归的方法都可以通过栈来改写成遍历。 Recursive OK.123456789101112131415161718192021class Solution &#123; public TreeNode sortedArrayToBST(int[] nums) &#123; if (nums == null) &#123; return null; &#125; return helper(nums, 0, nums.length - 1); &#125; private TreeNode helper(int[] nums, int start, int end) &#123; if (start &gt; end) &#123; return null; &#125; if (start == end) &#123; return new TreeNode(nums[start]); &#125; int mid = (start + end) / 2; TreeNode root = new TreeNode(nums[mid]); root.left = helper(nums, start, mid - 1); root.right = helper(nums, mid + 1, end); return root; &#125; &#125; 109. convert-sorted-list-to-binary-search-tree 这回给的是一个排好序的链表的头结点，构造出对应的二分查找树。 ME：采用快慢指针的方式找中间节点，需要分节点数为奇、偶两种情况适当地挪动来取得中间节点作为当前根节点。 TA：这个解答也是快慢指针，但写起来比你的简洁好多。它传入了start和end，slow和fast一开始都指向start，利用tail判断什么时候停止挪动fast，然后直接将slow作为当前的根节点，其left和right递归去找就可以了，这个代码真的很漂亮。还有一种是先遍历一遍得到长度，然后根据长度分成左半部分和右半部分，速度也不慢，不过借助了一个全局变量来遍历原链表，不太喜欢，也不好懂，毕竟在递归的时候变来变去的比较绕。 110. balanced-binary-tree 给一个二叉树，判断它是否balanced。 ME：一开始想法错了，以为左、右子树都是balanced就是了（你想想为啥）。后来改成老老实实根据高度来判断，若出现了左右两子树高度差大于1则返回-1，一直回溯到根。WA了两次才过，丢人呀还是个衣洗题。 TA：这里提到了两种，一种是比较浪费时间的自顶向下每次求高度法，另一种就是自下向上累计高度法。我就用的累计法，方便确认平衡状态嘛。 Recursive OK.12345678910111213141516171819class Solution &#123; public boolean isBalanced(TreeNode root) &#123; return getHeight(root) &gt;= 0; &#125; private int getHeight(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; if (root.left == null &amp;&amp; root.right == null) &#123; return 1; &#125; int left = getHeight(root.left); int right = getHeight(root.right); if (left == -1 || right == -1 || Math.abs(left - right) &gt; 1) &#123; return -1; &#125; return Math.max(left, right) + 1; // accumulate with max of left sub and right sub. &#125;&#125; 111. minimum-depth-of-binary-tree 求最小深度，即从根到最浅的叶子节点经过的节点数。 ME：递归搞定。 TA：没啥了。12345678910111213class Solution &#123; public int minDepth(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; int left = minDepth(root.left); int right = minDepth(root.right); if (left == 0 &amp;&amp; right == 0) &#123; return 1; &#125; return 1 + (left == 0? right: right == 0? left: Math.min(left, right)); &#125;&#125; OK.112. path-sum 给一个整数和一棵二叉树，判断是否存在路径使得经过的节点的值之和是给定的这个sum。 ME：递归搞定，每次深入之前先把sum减掉当前节点的值，达到sum的时候再判断是否是叶子节点。 TA：差不多吧。123456789101112class Solution &#123; public boolean hasPathSum(TreeNode root, int sum) &#123; if (root == null) &#123; return false; &#125; if (root.val == sum &amp;&amp; root.left == null &amp;&amp; root.right == null) &#123; return true; &#125; int newSum = sum - root.val; return hasPathSum(root.left, newSum) || hasPathSum(root.right, newSum); &#125;&#125; OK.113. path-sum-ii 给一个整数和一棵二叉树，返回所有的从根到叶的和为sum的路径。 ME：DFS递归搞定。 TA：没啥了。1234567891011121314151617181920class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); dfs(root, sum, ans, new ArrayList&lt;Integer&gt;()); return ans; &#125; private void dfs(TreeNode root, int sum, List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; curr) &#123; if (root == null) &#123; return; &#125; curr.add(root.val); if (root.val == sum &amp;&amp; root.left == null &amp;&amp; root.right == null) &#123; ans.add(new ArrayList&lt;Integer&gt;(curr)); &#125; else &#123; dfs(root.left, sum - root.val, ans, curr); dfs(root.right, sum - root.val, ans, curr); &#125; curr.remove(curr.size() - 1); &#125;&#125; 114. flatten-binary-tree-to-linked-list 给一个二叉树，将它in-place地改造成一个以右节点为next的链表状的树。 ME：作死地看了一下提示。。用DFS和本身的flatten相互嵌套递归，然后将左子树的最右下叶子节点的右指针指向经过flatten的右子树，返回给root。这种嵌套的写法，写是写得出来，但似乎不太好跟人解释。 TA：写得太短真心不好懂，比如这个，摆个全局变量在那，很不好想。这个给改成了传参版，也。。 This is really an extremely beautiful solution:12345678910111213class Solution &#123; private TreeNode prev = null; public void flatten(TreeNode root) &#123; // sth like post order if (root == null) &#123; return; &#125; flatten(root.right); // but go right first to locate prev at root of right flatten(root.left); // prev will be connected to the very right of left sub root.left = null; // prev will become root of left sub root.right = prev; prev = root; &#125;&#125; 115. distinct-subsequences 给两个字符串S和T，在S中任意去除字符后得到T，求总共有多少种操作可以做到。 ME：画了个dp[tLen+1][sLen+1]，DP搞定。dp[i][j]表示T从0取到i-1位、S从0取到j-1位的时候，S有多少种删法能完美得到T。对于第i=0行来说，T是空，因此S不论取多少都只有一种删法能得到T；从i=1开始就要逐位确认字母是否匹配，若匹配则为左一位和左上一位之和，即dp[i][j] = dp[i-1][j-1] + dp[i][j-1]；若不匹配，则j-1这一位的字母必须删除，因此直接由左一位决定，即dp][i][j] = dp[i][j-1]。 TA：DP嘛，都差不多。最下面这个给改成了一维，确实是可以的，因为我更新dp table的时候刚好也是斜向下对角线更新的。 116. populating-next-right-pointers-in-each-node 给一个二叉树，要求把所有节点的next都指向其同level的右边的节点。只能用O(1)的extra space，且这里的二叉树一定是perfect的，所有叶子都在一个level上、每个节点都有两个子树。 ME：第一次碰到不给run的题目，只能写完直接submit。还是递归嘛，每个根节点都先右后左地深入去connect，但这样还不够，因为从左子树和右子树的节点也有要相连的，因此又写了个connectL2R方法。不过这样一来感觉会浪费一些时间，因为两边深入下去搞完了回到根节点，还要再深入一次。 TA：这个很强，我一开始也想用一个prev一个curr搞的，但是逻辑没有理清楚。这里prev从root开始，让curr从prev的左子树开始挪动设置next，最妙的是左右两个子树的连接，是通过curr的next是否为null判断之后办到的，如果curr的next存在，那么curr.right.next就应当指向curr.next.left，画个图就明白了。之后curr就挪到curr.next，继续设置。妙哉！这样节省了我方法里的重复深入，而且不需要递归呢。 Did not come up with prev + curr method.1234567891011121314151617181920public class Solution &#123; public void connect(TreeLinkNode root) &#123; if (root == null) &#123; return; &#125; TreeLinkNode prev = root; // first of each level TreeLinkNode curr = null; // go throught the level while (prev.left != null) &#123; curr = prev; while (curr != null) &#123; curr.left.next = curr.right; // nodes on this level have set next if (curr.next != null) &#123; curr.right.next = curr.next.left; &#125; curr = curr.next; &#125; prev = prev.left; &#125; &#125;&#125; 117. populating-next-right-pointers-in-each-node-ii 给一个二叉树，要求把所有节点的next都指向其同level的右边的节点。只能用O(1)的extra space，但不一定是perfect的了。 ME：用上一题学到的prev+curr写法，写了一大堆条件判断，因为不是perfect的话，curr在设置next的时候要考虑很多情况，prev在挪动的时候也不只是简单的prev.left了，而是先判断如果当前是叶子，得往next找下一层的首个节点。WA了三四次才过。 TA：手动再见。看人家这个写的，多么清晰简洁，既然每一层的head无法直接确定，那不妨多设一个变量来存放嘛，每一层每一层这样设置next，非常优雅！还有一个使用dummyHead的方法，dummyHead作为每一层伪头部，总是指向该层的首个元素，再用一个pre去往后设置next，当上一层的root.next为null说明当前这一层设置完成，root来到dummy.next就到达当前这一层的首个元素了，这时需要切断dummy.next，再继续设置。妙哉！ Similar to 116, just generalized.1234567891011121314151617181920212223242526public class Solution &#123; public void connect(TreeLinkNode root) &#123; if (root == null) &#123; return; &#125; TreeLinkNode fakeHead = new TreeLinkNode(0); TreeLinkNode prev = fakeHead; // previous node that should set its next while (root != null) &#123; if (root.left != null) &#123; prev.next = root.left; prev = prev.next; // should not be put outside &#125; if (root.right != null) &#123; prev.next = root.right; prev = prev.next; &#125; root = root.next; if (root == null) &#123; // means the level of root is expired root = fakeHead.next; // go to next level prev = fakeHead; fakeHead.next = null; // IMPORTANT! reset fakeHead to ensure root will become null &#125; &#125; &#125;&#125; 118. pascals-triangle 给一个整数，返回对应层数的完整的杨辉三角。 ME：暴力O(n^2)做呀，List嘛。 TA：没啥了。 119. pascals-triangle-ii 给一个整数，返回该层的杨辉三角，如row = 0则返回[1]。 ME：说是只能用O(k)的空间，那么我就用了两个List交替更新，一开始理解错这个rowIndex了搞死我。写出来发现速度好慢啊。 TA：我发现我好像搞错了，我那样其实还是有多余的空间，真正精简的O(k)应该是这样，而且答主还用了我一直想用的数组，省去了set的麻烦。妙哉！还有直接用公式的，这个就。。。 数组转List可以用Arrays.asList()，不过这个数组不能是基本类型的，要改成对应的封装类。 120. triangle 给一个List]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>algorithm</tag>
        <tag>interview</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Note for LeetCode in Java (1~100)]]></title>
    <url>%2F2017%2F04%2F16%2Fjava_leetcode%2F</url>
    <content type="text"><![CDATA[刷题。祝我好运。 1. Two Sum 给定一串整型数组，给一个目标值，求数组中唯一的一对数字，相加得到该目标值。 ME：先排序，然后二分查找遍历一遍看看给定数字a能否找到数字b = target - a。确定后再回到原数组扫出a和b的位置。时间nlogn + n*logn + n. TA：利用HashMap，从头到尾扫原数组，先查看b = target - a是否在HashMap的Key中，不在则把值和索引分别作为键和值加入HashMap。一旦扫到符合的即可输出，时间为n。（Java的HashMap查找是O(1 )的，C++中是O(logn )） 2. Add 2 Num 给两个链表，每个节点是一个数字，输出也是一个链表，每个节点就是那两个输入链表对应节点的值之和。 ME：就是个简单版模拟加法，和归并排序总体思路差不多，都是一个将两个链表相加直到其中一个为空，再把剩余内容继续倒出来，只不过要考虑多个进位问题。开始没通过就是因为没考虑两个链表都加完了，进位可能还得加的情况。 TA：想法一样，但代码简洁很多。我的三个while循环可以归整到一个while里面，在里面再判断链表谁空了；进位和加法整合，上一步的进位直接用到这一步的加法中，省去了一个变量；少了first_flag因为他直接设了一个sentinel，它的下一位才是要返回的内容。 3. Longest substring 给一个字符串，找其中不含重复字符的最长子串的长度。 ME：利用HashMap，再利用一个log数组记录每个字符的对应的长度计数（其实可以不用），然后从前往后扫-&gt; 若不在HashMap中则直接把char, index插入，并在log的对应位置赋值为前面一位计数值+1；-&gt; 若已经出现过，则取『前面一位计数值+1』和『距离HashMap中存放index的距离』二者的较小值。 TA：引入了双指针而不需要我这样的log数组， 左指针指向在HashMap出现过的字符get到的index的下一位，右指针一直向后遍历。两个指针之间的距离就是所求的最大子串了。还有一种DP动态规划的方法，用一个数组模拟HashMap，初始值为-1，每个字符出现时就会更新为它的索引，不过它也需要和ME的方法一样用到一个取max的过程来保证更新最大长度时不出错。 HashMap的get(key)返回的value需要强制转换一下才能用。(???当时为啥写这句) Two pointers. three fails. 4. Median of 2 sorted arrays 给两个int数组，返回二者合并后的中位数，要求在O(log(m+n))的时间复杂度以内。 ME：很直接地想到mergeSort的最后一步，将两个有序数组合并，然后合并到总长度一半的时候就知道中位数了。但这个方法时间复杂度似乎是O((m+n)/2)？虽然AC了但并不符合要求。。。其实看到有序、logN，还能想到的就是二分查找了。 TA：中位数是用来将数组分割成相等长度的两部分的，因此使用二分查找找出刚好能分成登等长的两部分并且前部分的最大值&lt;=后部分的最小值。边缘情况真的特别复杂，比较难理解，怪不得是hard题。 BinarySearch. know nothing about the method of split and check.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; if (nums1 == null || nums2 == null) &#123; return 0; &#125; int m = nums1.length, n = nums2.length; if (nums1.length &gt; nums2.length) &#123; // ensure the len of 1 &lt;= 2 return findMedianSortedArrays(nums2, nums1); &#125; // to ensure equality of the two parts after merged, i + j = m - i + n - j int iLo = 0, iHi = m, allMid = (n + m + 1) / 2; // merge odd / even case // i stands for "how many num taken from nums1 as front part" 0 ~ i-1 | i ~ m-1 // j stands for "how many num taken from nums2 as front part" 0 ~ j-1 | j ~ n-1 while (iLo &lt;= iHi) &#123; int i = (iLo + iHi) / 2, j = allMid - i; // nums1[i-1], nums2[j-1] are the largest element of front part of nums1, nums2 // nums1[i], nums2[j] are the smallest of lag part of nums1, nums2 if (i &lt; m &amp;&amp; nums2[j - 1] &gt; nums1[i]) &#123; // i not big enough iLo = i + 1; &#125; else if (i &gt; 0 &amp;&amp; nums1[i - 1] &gt; nums2[j]) &#123; iHi = i - 1; &#125; else &#123; int maxLeft = 0, minRight = 0; if (i == 0) &#123; maxLeft = nums2[j - 1]; &#125; else if (j == 0) &#123; maxLeft = nums1[i - 1]; &#125; else &#123; maxLeft = Math.max(nums1[i - 1], nums2[j - 1]); &#125; if ((m + n) % 2 == 1) &#123; // I think thats why to make (allMid = (n + m + 1)/2) return maxLeft; // -- to make left part always at least no fewer than right &#125; if (i == m) &#123; minRight = nums2[j]; &#125; else if (j == n) &#123; minRight = nums1[i]; &#125; else &#123; minRight = Math.min(nums1[i], nums2[j]); &#125; return (maxLeft + minRight) / 2.0; &#125; &#125; return 0; &#125;&#125; 5. Longest palindromic substring 给一个字符串，返回最长的回文子串（对称）。 ME：没有想出来高招，暴力法果断超时。。暴力法就是一个指针从头开始，另一个指针从尾巴往回扫，看看是否和前面指针相同，相同就进一步分别向右挪/向左挪，以此类推。。。 TA：这个似乎也是暴力法，只是用了更优雅的方式——双指针分别扩展，而我的暴力法是双指针向中间合拢，扩展的方式在worst case下复杂度也是O( n^2 )。 Brute force - expanding to double side index. edge case mistakes… DP也可以解决。 6. zigzag-conversion 给一个字符串和行数，输出转换为zig-zag形式的对应字符串。 ME：找规律找出来的，直接用下标变化规律，不像是在解算法题，或者说只是我运气好找到了规律。（话说回来，我的代码速度还挺快的，毕竟是直接套规律搞出来的） TA：按照真正的zig-zag式分布来写，每一行都定义了一个StringBuffer，从上往下再从下往上将每一行的字符串逐步拼接起来，最后汇总一下即可，这样的代码非常方便别人理解，不像你的要是不解释下标的变化规律别人怎么可能看得懂。 String转char[]用s.toCharArray( )。 Just using stringbuilder appending to simulate the process. Two fails for numRows too small / charCount too small. 7. reverse-integer 给一个32bit的带符号整数，输出倒序的这个数字并保持符号。若越界则返回0. ME：简单粗暴取商、取模来做，负数则直接取反来搞。两次WA，一是越界判断是用『加完后变为负值』而实际上越界可以一越越到了正值部分，所以不可以这样；而是-2147483648这个值直接取反会越界，我后来直接处理着情况了。。。有点jian。 TA：直接使用取商、取模而不理会正值或负值，在JAVA中负数取模会尽量让商更大（-7 % 3 = -1），看起来就是正数取模加个负号罢了。而越界判断使用的是计算出的值减去个位数除以10看看是否等于计算前的值。 Ok. Just mod and divide. Negetive mod is very similar to positive mod in Java. 8. string-to-integer-atoi 待。。。 9. palindrome-number 给一个整数，判断它是不是回文数。要求不能额外申请对象空间，也就不能转成字符串处理了。 ME：简单粗暴，头尾分别取数字对比。边缘情况包括0和负数。但跑测试用例速度巨慢。。。 TA：在这个方法中直接改变原数字x，取x的前半部分和后半部分之reverse对比，不过除了x==rev，还有一种情况是奇数时rev比x多一位，这时需要判定x==rev/10。边缘情况是负数和个位为0直接判定false，0不用。 Forgot the method of cutting into half and reverse the latter to compare. the condition to end the loop of splitting into half is awesome. Fail at case x=10 because 0 digit in the right half can’t be represented properly into front after reversed. 10. regular-expression-matching 实现一个字符串正则表达式匹配函数，需要实现.和*。 ME：真心不会。。。看了讨论板块发现要用到DP，必须学一波动态规划了。 TA：参考了一个带有比较详细解释的C++帖子。动态规划DP关键是找到状态以及状态之间的转换规律，在这题中，既然是目标字符串s和正则字符串p之间相互比较，就需要维护一个boolean的二维数组dp[i][j]，表示s[0~i-1]与p[0~j-1]是否匹配。观众朋友会问了，那么dp[i][0]和dp[0][j]表示什么呢？-&gt; dp[i][0]就是正则字符串p为空的情况，显然dp[0][0]为真，而只要s不为空就不可能用空的p来匹配上它，因此dp[i][0]除了首位，全部初始化为false；-&gt; dp[0][j]就表示目标字符串s为空的情况，由于p可能有一个bug级的&#39;*&#39;存在，不能轻易全部赋值为false，例如a*b*c*就可以匹配空的s，对于dp[0][j]就需要动用状态转移了，dp[0][j]取决于当前字符p[j-1]是否为&#39;*&#39;且往前两位字符处的匹配情况dp[0][j-2]。至此，dp数组初始状态设置完成。下面正式讨论状态转移。-&gt; 当前字符p[j-1]不是&#39;*&#39;: dp[i][j]取决于当前字符p[j-1]是否等于s[s-1]且须考虑前一个字符的匹配情况dp[i-1][j-1]。-&gt; 当前字符p[j-1]是&#39;*&#39;，则又要讨论这个&#39;*&#39;前面的字符p[j-2]应该算几个：i) 算0个：说明把p[j-2]和p[j-1]抽离后不影响判断，由s[0~i-1]和p[0~j-3]决定，即dp[i][j-2];ii) 算&gt;=1个：说明把目标字符串s末尾若干个与p[j-2]相同的元素抽离后不影响判断，那么此处就以抽离一个为判断依据，除了判断s[i-1] == p[j-2]，还要考虑抽离s[i-1]后的s[0~i-2]也与p[0~j-1]匹配（&#39;*&#39;前面的这个字符在这里大不了算0次，但这也是之前就出来的结果了，这一步直接用就好）至于&#39;.&#39;字符就在判断各个字符的时候单独拎出来判断一下就好了。 Not able to analyse DP, let alone implementing.123456789101112131415161718192021222324252627282930313233class Solution &#123; public boolean isMatch(String s, String p) &#123; if (s == null || p == null || s.equals(p)) &#123; return true; &#125; char[] sChar = s.toCharArray(), pChar = p.toCharArray(); int m = sChar.length, n = pChar.length; boolean[][] dp = new boolean [m + 1][n + 1]; // initial the dp states dp[0][0] = true; for (int j = 2; j &lt;= n; j++) &#123; dp[0][j] = pChar[j - 1] == '*' &amp;&amp; dp[0][j - 2]; &#125; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (pChar[j - 1] == '*') &#123; // check if ignoring curr pattern // OR (the char is matched AND ignoring curr pattern) dp[i][j] = (dp[i][j - 2]) || ((sChar[i - 1] == pChar[j - 2] || pChar[j - 2] == '.') &amp;&amp; dp[i - 1][j]); &#125; else &#123; // check if char is matched for curr pattern dp[i][j] = dp[i - 1][j - 1] &amp;&amp; (sChar[i - 1] == pChar[j - 1] || pChar[j - 1] == '.'); &#125; &#125; // note that match means char equalation or equal to dot &#125; return dp[m][n]; &#125;&#125; container-with-most-water 给一串int数组，取其中两个作为高、Index距离作为宽组成的面积最大是多少。 ME：只想到暴力法，果断超时。。。 TA：利用双指针，分别从头和尾向中间移动来更新max值，每次移动二者之间的较小值。证明在此，若左边小于右边则向右移动左指针的道理是，左指针既然已经小过右指针了，此时体积就由左边决定，右指针往左移只会让面积越变越小没有计算的意义，而左指针往右移倒可能碰上更高的边从而有更大的面积；若右边小于左边则向左移动右指针的道理也类似，既然右边都小了你再让左边挪过来缩短宽度只会让面积更小，移右边才可能有更大面积。 Fail to come up with double pointer method from front and end. Implementation OK after knowing it.1234567891011121314151617181920class Solution &#123; public int maxArea(int[] height) &#123; if (height == null || height.length == 0) &#123; return 0; &#125; // initial two pointers starting from front and end int left = 0, right = height.length - 1, area = 0; while (left != right) &#123; if (height[left] &lt; height[right]) &#123; area = Math.max(area, height[left] * (right - left)); left ++; &#125; else &#123; area = Math.max(area, height[right] * (right - left)); right --; &#125; &#125; return area; &#125;&#125; integer-to-roman 给一个int，转化为罗马数字字符串。 ME：暴力法，每次取一位数字来决定输出多少M D C L X V I，速度贼慢。 TA：直接用一个数组把1000、100、10、1级别的0~9都定义在数组里，每次直接取了append到字符串即可。服。 Seems a boring problem…But at first glance, still unable to figure out the simplified appending method above. Implementation OK.12345678910111213class Solution &#123; public String intToRoman(int num) &#123; if (num &lt; 0) &#123; return ""; &#125; final String[] ONES = &#123;"", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"&#125;; final String[] TENS = &#123;"", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"&#125;; final String[] HDRS = &#123;"", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"&#125;; final String[] THSS = &#123;"", "M", "MM", "MMM"&#125;; return THSS[(num / 1000)] + HDRS[(num % 1000)/100] + TENS[(num % 100)/10] + ONES[(num % 10)]; &#125;&#125; roman-to-integer 给一个罗马数字，转化为int. ME：开了switch case语句和一堆判断。速度竟然超过96%的方法，惊了。 TA：二楼是比较整洁的代码。 Still unable to come up with the method using table and simple add/substract. The rule of add/subtarct is subtle. Implementation with error of MISSING NEW!!!!12345678910111213141516171819202122232425262728class Solution &#123; public int romanToInt(String s) &#123; if (s == null || s.length() == 0) &#123; return 0; &#125; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); map.put('I', 1); map.put('V', 5); map.put('X', 10); map.put('L', 50); map.put('C', 100); map.put('D', 500); map.put('M', 1000); int ans = 0, prev = 0; char[] sChar = s.toCharArray(); for (int i = sChar.length - 1; i &gt;= 0; i--) &#123; int curr = map.get(sChar[i]); if (curr &lt; prev) &#123; ans -= curr; &#125; else &#123; ans += curr; &#125; prev = curr; &#125; return ans; &#125;&#125; 14. longest-common-prefix 给一串字符串数组，求这些字符串开头的公共部分。 ME：暴力解之，每次取较短的作为终止长度，逐个字符判断。 TA：用了Array.sort将字符串数组从小到大排序，只比较最短的和最长的前置部分有什么相同的。不过从复杂度来说，排序的nlogn是逃不掉的。最主要省时间的地方是比较，它只比较最前和最后的两个，而你的是每个都要比较。 OK. 15. 3 Sum 给一个int数组，列出三个数使得它们的和为0. ME：排序之后暴力一前一后暴力找，果断超时，连2Sum时想到的二分查找都没想到，还自鸣得意地用一前一后两个指针在挪着着，果断慢啊，思考又复杂写出来还慢，实在浪费脑力和时间呀。改成二分查找就AC了，但是速度巨慢只超过6%的人。（老是忘记在函数入口确认传入参数的合法性！） TA：好像和我刚开始想法差不多，也是两个指针怼，只不过是确定最小的去找中间的和最大的来凑成triplets。我不服啊。。。 List、ArrayList用法。List是抽象类，不能直接用；返回值类型是List&lt;List&lt;Integer&gt;&gt;可以用两层ArrayList不断add来生成。 Update two pointers’ condition not clear at first…123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); if (nums == null || nums.length == 0) &#123; return ans; &#125; Arrays.sort(nums); for (int i = 0; i &lt; nums.length; i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; // 固定nums[i]用双指针找后面两个数b, c，使b + c == 0 - nums[i] int left = i + 1, right = nums.length - 1, target = 0 - nums[i]; while (left &lt; right) &#123; int sum = nums[left] + nums[right]; if (sum == target) &#123; List&lt;Integer&gt; currList = new ArrayList&lt;&gt;(); currList.add(nums[i]); currList.add(nums[left]); currList.add(nums[right]); ans.add(currList); left++; right--; while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) &#123; // 避免重复 left++; &#125; while (right &gt; left &amp;&amp; nums[right] == nums[right + 1]) &#123; // 避免重复 right--; &#125; &#125; else if (sum &lt; target) &#123; left++; &#125; else &#123; right--; &#125; &#125; &#125; return ans; &#125;&#125; 3sum-closest 给一个int数组，给一个target，求数组中哪三个数之和最接近target，输出这个和。 ME：本打算直接在3sum的基础上改一改，让二分查找当没有找到时返回最接近该目标值的位置，但始终调不好，一次都没有提交。 TA：玛德，看答案居然是三指针O(n^2)暴力解法，不服啊。。 O(N^2) OK12345678910111213141516171819202122232425262728293031323334class Solution &#123; public int threeSumClosest(int[] nums, int target) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; Arrays.sort(nums); int diff = Integer.MAX_VALUE, ans = 0; // set target as target - nums[i] for two pointer search for (int i = 0; i &lt; nums.length; i++) &#123; int newTarget = target - nums[i]; int left = i + 1, right = nums.length - 1; while (left &lt; right) &#123; int sum = nums[left] + nums[right], newDiff = Math.abs(sum - newTarget); // update diff if closer is found if (diff &gt; newDiff) &#123; diff = newDiff; ans = sum + nums[i]; &#125; // if (sum == newTarget) &#123; return target; &#125; else if (sum &lt; newTarget) &#123; left++; &#125; else &#123; right--; &#125; &#125; &#125; return ans; &#125;&#125; 17. letter-combinations 给一串数字的字符串，求这些数字可能输出的所有字母字符串，对应关系为手机的按键。 ME：组合问题，DFS搞定。至于数字到字母的映射用了一个HashMap刷这么些题第一次自己写出来迭代，毕竟DFS不复杂。 TA：映射完全不必那么复杂，可以用String搞定，而key就是当前数字与字符’0’之差，完美变为数组的index。DFS属于recursive的方法，可以直接改成遍历iterative的方法，还有一种是使用FIFO队列，用了LinkedList的peek函数获取当前队列头元素，总共三重循环。第一重遍历digits读取数字，第二重获取队首元素长度若尚未append本轮新读取数字对应的字母，则取出这个队首并进入最后一重循环把所有可能的字母加在后面。复杂度不低但代码优雅，巧妙的就是在第二重循环入口利用长度来判断是否需要拼接。 搞熟普通数组、ArrayList的初始化！HashMap映射对象为数组时怎么写（虽然在这题其实是没必要的）！ OK. Just DFS.1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public List&lt;String&gt; letterCombinations(String digits) &#123; List&lt;String&gt; ans = new ArrayList&lt;&gt;(); if (digits == null || digits.length() == 0 || digits.indexOf('1') &gt;= 0 || digits.indexOf('0') &gt;= 0) &#123; return ans; &#125; final char[][] num2Char = new char [][] &#123; &#123;&#125;, &#123;&#125;, &#123;'a', 'b', 'c'&#125;, &#123;'d', 'e', 'f'&#125;, &#123;'g', 'h', 'i'&#125;, &#123;'j', 'k', 'l'&#125;, &#123;'m', 'n', 'o'&#125;, &#123;'p', 'q', 'r', 's'&#125;, &#123;'t', 'u', 'v'&#125;, &#123;'w', 'x', 'y', 'z'&#125; &#125;; char[] str = digits.toCharArray(); dfs(str, 0, num2Char, new StringBuilder(), ans); return ans; &#125; private void dfs(char[] str, int index, final char[][] num2Char, StringBuilder sb, List&lt;String&gt; ans) &#123; if (index == str.length) &#123; ans.add(sb.toString()); return; &#125; int temp = str[index] - '0'; for (int i = 0; i &lt; num2Char[temp].length; i++) &#123; sb.append(num2Char[temp][i]); dfs(str, index + 1, num2Char, sb, ans); sb.deleteCharAt(sb.length() - 1); &#125; &#125;&#125; 4 Sum 给一个int数组，给一个target值，返回所有quadruplets四元组使它们之和等于target。 ME：想一招鲜，从头到尾三个指针挪，最后一个数二分查找找出来，然而超时了。没法子了。 TA：我只能说你死脑筋，这都第三次做这种题了怎么还不会用双指针？老想着二分查找快，但你在循环最里层加个logN的查找，有可能快吗？这种sum的题，套路差不多都是这样：Arrays.sort排个序，外面套几层循环不管，最重要的是到2Sum时里面是双指针一前一后往中间夹逼，根据当前求得的sum和target作比较来确定双指针下一步怎么移，这里有个kSum的推广了。你在2sum能用二分查找只能说运气好，确实是一种方法，但O(N^m * logN )的复杂度当m变高自然就没法通过了。 OK. These kind of k-sum problem can all be solved by sorting and two-pointer moving strategy.1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); if (nums == null || nums.length == 0) &#123; return ans; &#125; Arrays.sort(nums); for (int i = 0; i &lt; nums.length; i++) &#123; for (int j = i + 1; j &lt; nums.length; j++) &#123; int newTarget = target - (nums[i] + nums[j]); int left = j + 1, right = nums.length - 1; while (left &lt; right) &#123; int sum = nums[left] + nums[right]; if (sum == newTarget) &#123; ans.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right])); do &#123; left++; &#125; while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]); do &#123; right--; &#125; while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]); &#125; else if (sum &lt; newTarget) &#123; do &#123; left++; &#125; while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]); &#125; else &#123; do &#123; right--; &#125; while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]); &#125; &#125; while (j + 1 &lt; nums.length &amp;&amp; nums[j + 1] == nums[j]) &#123; j++; &#125; &#125; while (i + 1 &lt; nums.length &amp;&amp; nums[i + 1] == nums[i]) &#123; i++; &#125; &#125; return ans; &#125;&#125; remove-nth-node-from-end-of-list 给一个链表的头结点，给一个整数n，要求删除倒数第n个节点，返回删完后的链表头，n可以保证合法。要求one-pass。 ME：既然没有空间要求，那我就用一个ArrayList来存这个链表了，然后按索引把前一节点的next指向后一节点。交了个WA，玛德又是边界条件没考虑到，一个是删除头结点，一个是删除最后的节点。 TA：快慢指针。一开始我确实有想到这个，不过考虑的是在判断链表有环无环时所用的2倍速度快指针，而这里是固定间隔为n+1的快慢指针，同时还有一个trick是在head之前建一个dummy节点使其next指向head，快慢指针从此处开始向后遍历即可（不是同时开始！快指针先动n+1步）。如果要消除dummy节点，这个方法直接指向head，快指针先动n+1步，利用n的合法性应对删除头结点的情况，其实跟前面的没什么差别。 fail to come up with two pointer slow/fast method.12345678910111213141516171819202122class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; if (head == null) &#123; return null; &#125; ListNode slow = head, fast = head; // fast move first for (int i = 0; i &lt; n; i++) &#123; fast = fast.next; &#125; if (fast == null) &#123; // fast reaches end means deleting first node return head.next; &#125; while (fast.next != null) &#123; slow = slow.next; fast = fast.next; // move slow to the front node of the one to be deleted &#125; slow.next = slow.next.next; // change prev node.next reference return head; &#125;&#125; 20. valid-parentheses 给一个字符串，判断其中三种括号(), [], {}是否匹配。 ME：Stack数据结构搞定，左括号入栈，碰到右括号就出栈看看二者是否一对。 TA：也是Stack，不过左括号本身并不入栈，而是它对应的右括号入栈，这样当右括号出现的时候只需判断二者是否相等或者是否栈已经空了即可。 Ignored.. 21. merge-two-sorted-lists 给两个已从小到大排好序的链表头结点，归并两个链表，返回合并后的链表头结点。 ME：归并排序的一部分，挺熟悉了，不过之前都是用数组高的，现在用链表也没差。 TA：recursive的写法，高大上一些，每次都把较小的值的节点设为头结点返回，一层一层调用最终就归并好了。还有一个极其简洁版的，省去了头结点变量，每次直接返回较小的节点。 OK. Iterative and recursive.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) &#123; return l2; &#125; if (l2 == null) &#123; return l1; &#125; ListNode fakeHead = new ListNode(0); ListNode curr1 = l1, curr2 = l2, curr = fakeHead; while (curr1 != null &amp;&amp; curr2 != null) &#123; if (curr1.val &gt; curr2.val) &#123; curr.next = curr2; curr = curr2; curr2 = curr2.next; curr.next = null; &#125; else &#123; curr.next = curr1; curr = curr1; curr1 = curr1.next; curr.next = null; &#125; &#125; if (curr1 != null) &#123; curr.next = curr1; &#125; if (curr2 != null) &#123; curr.next = curr2; &#125; return fakeHead.next; &#125;&#125;// recursivepublic ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) &#123; return l2; &#125; if (l2 == null) &#123; return l1; &#125; if (l1.val &lt;= l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125;&#125; 22. generate-parentheses 给一个int表示括号的对儿数，输出所有符合括号匹配规则的字符串，存入List中返回。 ME：一兴奋想用前面letter-combinations刚学到的用LinkedList + 长度判断 + String拼接来做组合，结果手抖点了下提交，怒得WA，因为这个还要求括号匹配合法，更何况列举个数都不同，输入n出来的长度2*n呢。后来还是改回了我的DFS，左右括号分别用一个int来记录确保右括号数量不超过左括号就可以了。还是熟悉的好哇。 TA：这题竟然也可以用DP动态规划，然而我还没有掌握。还有一种想法是找规律，也是动态规划的一部分，因为有个状态转移，虽然答主没提到DP。 DFS OK. Did not come up with DP, which seems expensive (O(N^4))…123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; ans = new ArrayList&lt;&gt;(); if (n &lt; 1) &#123; return ans; &#125; dfs(n, 0, 0, "", ans); return ans; &#125; private void dfs(int n, int left, int right, String s, List&lt;String&gt; ans) &#123; if (left == n &amp;&amp; right == n) &#123; ans.add(s); return; &#125; if (left &lt; n) dfs(n, left + 1, right, s + "(", ans); if (right &lt; left) dfs(n, left, right + 1, s + ")", ans); &#125;&#125;class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;List&lt;String&gt;&gt; dp = new ArrayList&lt;&gt;(); if (n &lt; 1) &#123; return new ArrayList&lt;String&gt;(); &#125; dp.add(Arrays.asList("")); for (int i = 1; i &lt;= n; i++) &#123; List&lt;String&gt; curr = new ArrayList&lt;&gt;(); for (int j = 0; j &lt; i; j++) &#123; for (String first : dp.get(j)) &#123; for (String second : dp.get(i - 1 - j)) &#123; curr.add("(" + first + ")" + second); &#125; &#125; &#125; dp.add(curr); &#125; return dp.get(n); &#125;&#125; 23. merge-k-sorted-lists 给一个ListNode节点数组，分别是排好序的若干链表头，要求输出合并后的新链表头。题目特别提示注意时间复杂度。 ME：一开始硬上，每次都遍历一遍链表头来获取最小值，然而超时。我又考虑既然每次都只需要一个最小值，那完全可以维护一个小根堆，直接取根节点就好，然而改了半天还是超时。没辙了。其实这个想法是可以的，看下面就知道为什么了，现在看来你之前整理的堆排序也是错的。 TA：看了tag，写着分治法、堆，说明我用小根堆的思路是其中一种。这个用了Java内建的PriorityQueue，其实就和小根堆是一回事。令我吃惊的是后面这个答案明明也是维护了一个小根堆，怎么他就可以呢？原来他对于小根堆分成了两个函数，一个是create从尾到头确保小根、一个是adjust从根向下每次*2一次性调整完毕，而我全程用的create来调整，复杂度自然高了。于是我也拆成create和maintain两个，怒AC。看看分治，前面做过了mergeTwoLists，那这里分治就是把原链表数组拆分后再两两归并，最终合体。借助归并排序的分治法思想实现了一波，比小根堆快一点。 2 fails with PriorityQueue because of null ListNode condition. Did not come up with Divide and Conquer method. But what about implementing your own Heap structure? Ummm, skipping the manual heap method…1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; // divide and conquer public ListNode mergeKLists(ListNode[] lists) &#123; if (lists == null || lists.length == 0) &#123; return null; &#125; // last two params are used to divide into sub problems return mergeKLists(lists, 0, lists.length); &#125; private ListNode mergeKLists(ListNode[] lists, int start, int end) &#123; if (end - start == 1) &#123; // only one list return lists[start]; &#125; else if (end - start == 2) &#123; // merge two lists return mergeTwoLists(lists[start], lists[start + 1]); &#125; else &#123; int mid = start + (end - start) / 2; // cut into first and second halves return mergeTwoLists(mergeKLists(lists, start, mid), mergeKLists(lists, mid, end)); // warning not mid + 1 &#125; &#125; private ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) &#123; return l2; &#125; if (l2 == null) &#123; return l1; &#125; if (l1.val &lt;= l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125; &#125;&#125; 24. swap-nodes-in-pairs 给一个链表头，要去反转所有相邻的节点，返回反转后的头。不可以修改头的val，这能修改next。 ME：设一个伪头部，然后建一个反转后续两个节点的函数，搞定。 TA：基本都是我这样了吧。有一个用recursion的，我总感觉能不用就不用吧，一个是不好懂，一个是递归对栈的消耗不是constant space。 OK. reverse-nodes-in-k-group 给一个链表头和小组内节点个数，按小组倒转链表，返回分组反转后的头。 ME：伪头部之后，将k长度的节点存入数组方便访问，然后循环一波调整各自的next指向。 TA：除了我这种迭代的方法，另外就是递归了，不得不说，递归的代码真心短，所以不太好懂。答主做法是一直往后找到最后一段需要反转的k元组，其中利用curr和head两个指针来反转还是比我用数组的优雅很多。话说回来，我用了数组的话，也相当于额外申请了空间哎，题目要求constant memeory。。。吓得我改造了一发把数组给改掉了，改造的时候要特别注意NullPointerException，因为我用了一个伪头部而答主没有。 Don’t know how to reverse the array at all!123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseKGroup(ListNode head, int k) &#123; if (head == null || k &lt; 1) &#123; return head; &#125; int count = 0; ListNode curr = head; // locate curr at the next node of k-tuple group while (curr != null &amp;&amp; count &lt; k) &#123; curr = curr.next; count++; &#125; if (count == k) &#123; // set curr as starting head to reverse the following groups recursively curr = reverseKGroup(curr, k); while (--count &gt;= 0) &#123; ListNode headNext = head.next; head.next = curr; curr = head; // curr is moving forward since head.next = curr head = headNext; &#125; return curr; &#125; return head; &#125;&#125; remove-duplicates-from-sorted-array 给一个已排好序的int数组，删除其中的重复项，返回长度。玛德我一开始以为只需要返回一个长度而不用对原数组开刀，还在想这题这么衣洗。题目说的leave beyond length是说该长度之后数组里是什么内容不关心，又不是说besides。。。 ME：既然不在意长度之后的内容，那我就直接用后面的覆盖掉前面最后一次重复的元素，省去了数组删除需要移动一大堆元素的过程。 TA：想法差不多，这个显得更优雅，因为已经排好序所以后面的只要不同就一定比前面的大。 Did not come up with elegant lazy move method.1234567891011121314class Solution &#123; public int removeDuplicates(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; int len = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[len] != nums[i]) &#123; // lazy move len nums[++len] = nums[i]; // when num[i] is diff from nums[len] &#125; &#125; return ++len; // since last one cannot be compared to next different element &#125;&#125; remove-element 给一个任意排序的int数组，给一个key，要求返回删除这个key元素的新长度，同样不关心该长度之后的内容，同时返回时数组内的key顺序可以换。同样要求in-place. ME：从前往后找key，一旦发现就从后往前找不是key的元素就覆盖掉前面的。 TA：当大家想法差不多，就会开始比谁的代码短。。。这个真心短，答主不是从后往前找不是key的元素覆盖，而是直接按顺序来。这样要考虑的坑少一些，我那个又是正的又是反的，跟这个比就复杂了。 OK.1234567891011121314class Solution &#123; public int removeElement(int[] nums, int val) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; int len = nums.length; for (int i = 0; i &lt; len; i++) &#123; if (nums[i] == val) &#123; nums[i--] = nums[--len]; &#125; &#125; return len; &#125;&#125; implement-strStr 实现一个strStr函数，给一个字符串在其中找子字符串第一次出现的索引。 ME：手动实现呗。第一次WA竟然是因为在字符串中找””永远返回0。 TA：这个代码很优雅，直接上双重循环，一旦有一位字符不同就跳出内层循环；如果长度超过了原字符串，说明找不到；如果能在内层循环顺利达到target的长度说明找到了，返回外层循环的当前索引即可。 String转char数组用toCharArray。注意strStr在Java中对应的是indexOf，Java中并没有strStr。 OK.12345678910111213141516171819202122232425class Solution &#123; public int strStr(String haystack, String needle) &#123; if (haystack == null || needle == null) &#123; return -1; &#125; if (needle.length() == 0) &#123; return 0; &#125; char[] hChar = haystack.toCharArray(); char[] nChar = needle.toCharArray(); int end = hChar.length - nChar.length; for (int i = 0; i &lt;= end; i++) &#123; if (hChar[i] == nChar[0]) &#123; int j = 1; while (j &lt; nChar.length &amp;&amp; hChar[i + j] == nChar[j]) &#123; j++; &#125; if (j == nChar.length) &#123; return i; &#125; &#125; &#125; return -1; &#125;&#125; 29. divide-two-integers 给两个数字，不使用乘、除、模运算前者除以后者之商，若结果越界则返回MAX_INT。 ME：直接用个循环一点一点叠加除数看看sum是否&gt;=被除数，符号则是统一把两个数都变为负数，毕竟负数的界比正数多1。然而超时了。。。 TA：玛德忘记了除了加减乘除还有位运算这种东西。我原本确实想过通过翻倍来加速求sum的过程，不过当时并没有想到位运算，只是想着通过数组从被除数开始往后一直翻倍记录increment，不过在极限情况下（-2147483648 / -1）的情况下，数组要2^16这么大，把我吓跑了。按照这个C++的答案改造成了Java，果然优雅。事实上题目所说的越界情况也就只有 -2147483648 / -1 而已，所以我之前超时的那个很多判断都是没必要的。 Did not come up with the shift method. Actually using long will ease a lot of troubles.1234567891011121314151617181920212223242526272829303132class Solution &#123; public int divide(int dividend, int divisor) &#123; if ((dividend == Integer.MIN_VALUE &amp;&amp; divisor == -1) || divisor == 0) &#123; return Integer.MAX_VALUE; &#125; if (dividend == 0) &#123; return 0; &#125; // using XOR to adjust sign int sign = (dividend &lt; 0) ^ (divisor &lt; 0)? -1: 1; int ans = 0; long longDividend = Math.abs((long)dividend); long longDivisor = Math.abs((long)divisor); long sum = 0; while (sum &lt; longDividend) &#123; // warning use long abs value! int count = -1; long next = longDivisor; while (sum + next &lt;= longDividend) &#123; count++; next &lt;&lt;= 1; &#125; if (next == longDivisor) &#123; break; &#125; sum += (next &gt;&gt; 1); // how much has accumulated ans += (1 &lt;&lt; count); // how many divisor used &#125; return sign * ans; &#125;&#125; 30. substring-with-concatenation-of-all-words 给一个长字符串s，然后一个相同长度m的word字符串的数组，要求找出该数组中字符串各种可能排列成的新字符串在s中出现的位置 ME：使用DFS将所有可能的target字符串拼接出来存入HashSet，然后逐个取出使用indexOf找。然而超时。。。 TA：给出的tag又是双指针，或者说是滑动窗口，这个双指针有点无敌啊。我的方法最耗时的部分应该就是DFS拼接所有可能的target那部分，在这个方法中，直接把每个word作为独立个体看待。首先利用一个mapping为各个word分配索引，然后从头到尾扫一遍s每次取长度为m的子串看看能否在mapping中get到，get的索引存在smapping中。固定窗口长度为m，总共滑动m次，每次循环都是一左一右两个指针扫smapping，右指针先以m的步长扫smapping获得索引并相应减去该索引的word的计数，当所有word都用完了，就挪左指针扫smapping（其实就是重走了一段右指针走过的路），扫到第一个属于word的就看看长度是否为k*m，因为各个word的长度相同所以我们只要简单判断长度就能知道这部分内容满不满足要求。还有一个更简短的，这里直接把构建table的过程简化成map搞定，同时省去了构建smapping的过程而直接在大循环中get，面试时相同的思路当然是代码越短越好，才写得完嘛。 Set的遍历，数组赋值Arrays.fill。 Did not come up with the method of mapping and search. After knowing and implementing it, still time limit exceeded, because calling containsKey too much. But actually there is a much faster one, which use raw array to implement the mapping relations, including finding the matched substrings in s.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112class Solution &#123; public List&lt;Integer&gt; findSubstring(String s, String[] words) &#123; List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); if (words == null || words.length == 0) &#123; return ans; &#125; // construct map for each word and its count Map&lt;String, Integer&gt; wordCount = new HashMap&lt;String, Integer&gt;(); for (int i = 0; i &lt; words.length; i++) &#123; wordCount.put(words[i], wordCount.containsKey(words[i])? wordCount.get(words[i]) + 1: 1); &#125; // check each slot in s with fixed length wordLen int wordLen = words[0].length(); int end = s.length() - words.length * wordLen; for (int i = 0; i &lt;= end; i++) &#123; Map&lt;String, Integer&gt; temp = new HashMap&lt;&gt;(wordCount); int j = i; // increase from i, each time increase by wordLen while (j &lt; s.length()) &#123; if (j + wordLen &lt;= s.length()) &#123; // in case substring exceed boundary String currStr = s.substring(j, j + wordLen); if (!temp.containsKey(currStr)) &#123; break; &#125; else &#123; int leftCount = temp.get(currStr); if (leftCount == 1) &#123; temp.remove(currStr); &#125; else &#123; temp.put(currStr, leftCount - 1); &#125; &#125; &#125; j += wordLen; &#125; if (temp.isEmpty()) &#123; ans.add(i); &#125; &#125; return ans; &#125;&#125;class Solution &#123; public List&lt;Integer&gt; findSubstring(String s, String[] words) &#123; List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); if (words == null || words.length == 0) &#123; return ans; &#125; // map each word with unique index into map; Count unique wordNum int wordNum = 0; Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); int[][] table = new int [2][words.length]; for (int i = 0; i &lt; words.length; i++) &#123; Integer index = map.get(words[i]); if (index == null) &#123; index = wordNum++; map.put(words[i], index); &#125; table[0][index]++; &#125; // tarverse s and check each index if it has word in words[], mark the wordIndex int[] sIndex = new int [s.length()]; Arrays.fill(sIndex, -1); int wordLen = words[0].length(); int end = s.length() - wordLen + 1; for (int i = 0; i &lt; end; i++) &#123; String sub = s.substring(i, i + wordLen); Integer mapResult = map.get(sub); if (mapResult != null) &#123; sIndex[i] = mapResult; &#125; &#125; // use left ptr to recover word repo, right to consume word int expectedLen = wordLen * words.length; for (int i = 0; i &lt; wordLen; i++) &#123; int left = i, right = i; int wordRemain = wordNum; Arrays.fill(table[1], 0); while (right &lt; end) &#123; // move right with slot len == wrodLen while (wordRemain &gt; 0 &amp;&amp; right &lt; end) &#123; // make sure there'r still word to consume int hitIndex = sIndex[right]; // get hitIndex from sIndex in step 2 if (hitIndex != -1 &amp;&amp; ++table[1][hitIndex] == table[0][hitIndex]) &#123; wordRemain--; // increase the corresponding count // when all is consumed, this word is drained to 0 &#125; right += wordLen; &#125; // move left to recover the consumed words until at least one word exists while (wordRemain == 0 &amp;&amp; left &lt; right) &#123; int hitIndex = sIndex[left]; if (hitIndex != -1 &amp;&amp; table[1][hitIndex]-- == table[0][hitIndex]) &#123; wordRemain++; // when this word comes from fully consumed // recover the wordRemain if (right - left == expectedLen) &#123; ans.add(left); &#125; &#125; left += wordLen; &#125; &#125; &#125; return ans; &#125;&#125; 31. next-permutation 给一个int数组，将它改造成按字典序的下一个排列，若不存在则直接按从小到大的顺序调整。要求In-place对原数组操作，不能申请额外空间。 ME：考虑最右顺序对，这个和归并求逆序对有点像。既然求最右那就需要把原本的merge函数改成从右往左找，但写成了代码才发现不对！！！没辙了。 TA：这个想法从右往左找相邻的两个数使得first &lt; second，然后再从右往左找首次出现的比first大的数，二者对调，然后将second及其之后的内容reverse一下即可。这才是正解，和我的思路差别还是略大。这是值得警惕的倾向，看到一个题就像往熟悉的东西上面套，套上了就很难抽出来。另外，这里给出了问题的来源，原来是一个很古老的问题了，而且可以应用在Permutation问题中，对重复也可以处理。 Forgot the method of finding ascending pair, swap and reverse.12345678910111213141516171819202122232425262728293031class Solution &#123; public void nextPermutation(int[] nums) &#123; if (nums == null || nums.length &lt; 2) &#123; return; &#125; for (int i = nums.length - 2; i &gt;= 0; i--) &#123; if (nums[i] &lt; nums[i + 1]) &#123; int j = nums.length - 1; while (j &gt; i) &#123; if (nums[j] &gt; nums[i]) &#123; swap(nums, i, j); reverse(nums, i + 1); return; &#125; j--; &#125; &#125; &#125; reverse(nums, 0); &#125; private void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125; private void reverse(int[] nums, int start) &#123; for (int i = start, j = nums.length - 1; i &lt; j; i++, j--) &#123; swap(nums, i, j); &#125; &#125;&#125; longest-valid-parentheses 给一个只包含了(和)的字符串，求其中合法匹配的最大子字符串长度。 ME：一开始直接用stack判断括号匹配的思路做，左括号++，右括号出现时则左括号–。但是对于( )(( )就错了。于是考虑那从右往左再来一次，求左右二个max的较小者？但是又一次被( ) )( )( )(( )打败，左边右边对称，算出来都是错的。 TA：一开始参考这个写，维护一个存索引的stack，左括号则直接把索引push进去，右括号则看看栈顶的索引对应是否为左括号，是则弹出，否则把右括号的索引push进去，完成遍历后栈里面留下的就是造成invalid的一个个分割处的索引，遍历一遍栈的内容即得最长。不过照着实现一波之后发现超时。于是又参考这个，把之后的那一步遍历stack给融合到了前面的字符串遍历当中：同样维护一个存放int的stack，左括号直接入栈，右括号则需要分叉，若栈为空则说明不匹配，把left标记挪到当前这个索引；若非空则匹配成功，直接pop（因为栈中索引只可能是左括号的），弹出后再判断栈是否为空，若空了则之前的一长串括号都成功匹配了，用当前索引减去left即得这一段的长度；若非空则使用当前索引减去栈顶的索引表示当前已匹配的长度。很神奇，挺好懂的。当然，这题给的tag是DP，所以这个也要学习下。DP主要是状态转移方程，这里维护一个数组存放以当前索引结尾的字符串的最长valid长度。对于str[i] == &#39;(&#39;，不可能以它为结尾，故直接设longest[i] = 0；对于str[i] == &#39; )&#39;，若前一位字符为左括号，则longest[i] = longest[i-2] + 2，若前一位字符为右括号，则需要看这个右括号所能匹配的最远的距离的再前一个字符是否为左括号，即str[i-longest[i-1]-1] == &#39;(&#39;，若满足则不仅要加2，而且还要加上该左括号之前以为的valid长度（处理连续两个独立的且都是valid的括号组），即longest[i] = longest[i-1] + 2 + longest[i-longest[i-1]-2]。DP真的优雅，关键是找到这种『当前结果依赖之前结果』的规律，不一定是『前一项』，可以是往前若干项的结合。这题很漂亮。 Forgot the DP method!!12345678910111213141516171819202122232425262728class Solution &#123; public int longestValidParentheses(String s) &#123; if (s == null || s.length() == 0) &#123; return 0; &#125; int[] dp = new int [s.length()]; // maxLen till curr char (only for valid ')') char[] sChar = s.toCharArray(); int ans = 0; for (int i = 0; i &lt; sChar.length; i++) &#123; // only ) is count as valid bit if (sChar[i] == ')') &#123; // "xxx)" if (i &gt; 0) &#123; if (sChar[i - 1] == '(') &#123; // prev is (, simply add 2 to prevprev dp[i] = 2 + (i &gt; 1? dp[i - 2]: 0); &#125; else &#123; // prev is ( int prev = i - dp[i - 1] - 1; // move to the very front of prev slot if (prev &gt;= 0 &amp;&amp; sChar[prev] == '(') &#123; // only ( can match curr ) dp[i] = (prev &gt; 0? dp[prev - 1]: 0) + 2 + dp[i - 1]; // check ('s prev &#125; &#125; ans = Math.max(ans, dp[i]); &#125; &#125; &#125; return ans; &#125;&#125; search-in-rotated-sorted-array 给一个已排好序但可能前后两段换了位置（例如12345变成45123），给一个target找出它的索引。 ME：排好序、查找，很自然想到二分，但是这个边界条件搞死我了。这个rotated的结果只有三种：left &lt; mid &lt; right, mid &lt; right &lt; left, right &lt; left &lt; mid，在这里面再分别对target讨论，很琐碎，面试时恐怕很难想周全，leetcode还可以在WA时告诉你是什么样例通不过，面试可就没这么好了。 TA：我的天，为什么这个可以这么简洁？！思想是，总有一半的数组是有序的，需要确认target在哪一半，这个代码真的是一看就懂，比你的不知高到哪里去了。 Trapped in edge conditions of your own method, which is complicated and impossible to debug in interview. After knowing the method of splitting into ascending part and mixed part, implementation is still not bug-free, because of edge cases in binary search.1234567891011121314151617181920212223242526272829303132class Solution &#123; public int search(int[] nums, int target) &#123; if (nums == null || nums.length == 0) &#123; return -1; &#125; int left = 0, right = nums.length - 1; while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (nums[mid] == target) &#123; return mid; &#125; // firstly decide which part is ascending order // warning: although no duplicate in nums[], // there is an = here! because when left == mid, nums[left] == nums[mid] if (nums[left] &lt;= nums[mid]) &#123; // first half is in order if (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) &#123; // nums[mid] excluded right = mid - 1; // target is in range of first half &#125; else &#123; left = mid + 1; &#125; &#125; else &#123; // second half in order if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) &#123; left = mid + 1; // target in range of second half &#125; else &#123; right = mid - 1; &#125; &#125; &#125; // return nums[left] == target? left: -1; &#125;&#125; find-first-and-last-position-of-element-in-sorted-array 给一个已排好序的数组，给一个target，找出这个target出现的索引范围，存入length为2的int数组。要求时间复杂度为logn的常数倍。 ME：二分查找到了之后，再往左和往右分别继续进行二分查找，找到leftMost和rightMost的索引。 TA：这个是C++写的，直接用一个二分找左界，然后再额外找一个右界。稍微改一下二分，可以让它变为『查找首次出现的target索引』或者『最后一次出现的target索引』，这个要灵活一点。 Fail to implement the binary search which returns the first occurred index of target… For left, actually it’s non interrupt return version on BS, first index is at left; for right, need to prompt mid (add 1) to biase to right and last index is at right.1234567891011121314151617181920212223242526272829303132class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; if (nums == null || nums.length == 0) &#123; return new int [] &#123;-1, -1&#125;; &#125; int left = 0, right = nums.length - 1; while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (target &gt; nums[mid]) &#123; left = mid + 1; &#125; else &#123; right = mid; &#125; &#125; if (nums[left] != target) &#123; return new int [] &#123;-1, -1&#125;; &#125; int leftMost = left; right = nums.length - 1; while (left &lt; right) &#123; int mid = left + (right - left) / 2 + 1; if (target &lt; nums[mid]) &#123; right = mid - 1; &#125; else &#123; left = mid; &#125; &#125; int rightMost = right; return new int[] &#123;leftMost, rightMost&#125;; &#125;&#125; search-insert-position 给一个已排好序的、不存在重复元素的数组，给一个target，找出他的索引或者他应该插入的位置。 ME：直接用刚刚学到的“第一个出现位置”的二分查找搞。末尾直接返回lo而不用判断，因为如果不等于的话其实也就相当于他应该插入的位置了。但是又忘记了边缘情况，例如hi取不取到length、数组中没有元素或者只有一个元素怎么办？ TA：毕竟是个衣洗提，大家想法差不多，比短码就没啥意思了，本来就没多少行。。。 Similar to previous return first binary search result function, but need to consider if the final return value should check target v.s. nums[left] or not: in the middle, nuh; in the rightmost end, yep.12345678910111213141516171819class Solution &#123; public int searchInsert(int[] nums, int target) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; int left = 0, right = nums.length - 1; while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (target &gt; nums[mid]) &#123; left = mid + 1; &#125; else &#123; right = mid; &#125; &#125; // warning: terminate condition should consider the rightmost insertion return left == right &amp;&amp; target &gt; nums[left]? left + 1: left; &#125;&#125; 36. valid-sudoku 给一个二维char数组，里面是一个未完成的数独9x9棋盘，要求每一行、每一列、每个3x3方块中数字1-9有且仅有出现一次。判断这个棋盘是否符合数独规则，返回布尔值。 ME：一脸懵逼地用了个四重循环解决了。。。说是四重循环其实也就是遍历一遍9x9的棋盘，这应该是必须的。分别借助两个9x9的数组记录行和列的数字使用情况，再用一个长度为9的一维数组记录每个小正方形的，数组的索引通过字符-&#39;1&#39;获得，这样就省得用Map了。 TA：思想差不多吧，这个就是用Map的。这个是利用Set然后定义了一种String来记录是否出现过，利用set.add的返回值判断该字符串是否出现过，这个方法挺绝的。 Kinda boring…just check if current board is valid, not checking if it is solvable.1234567891011121314151617181920class Solution &#123; public boolean isValidSudoku(char[][] board) &#123; if (board == null || board.length == 0 || board[0].length == 0) &#123; return false; &#125; Set&lt;String&gt; set = new HashSet&lt;&gt;(); for (int i = 0; i &lt; board.length; i++) &#123; for (int j = 0; j &lt; board[0].length; j++) &#123; if (board[i][j] != '.') &#123; if (!set.add(board[i][j] + " in row " + i) || !set.add(board[i][j] + " in col " + j) || !set.add(board[i][j] + " in block " + (i / 3) + '-' + (j / 3))) &#123; return false; &#125; &#125; &#125; &#125; return true; &#125;&#125; 37. sudoku-solver 给一个二位char数组，里面是一个未完成的数独9x9棋盘，要求每一行、每一列、每个3x3方块中数字1-9有且仅有出现一次。解出数独，解有且仅有一种，直接在原二维数组中将.改为数字的char。 ME：纠结了半天，感觉是一个dfs的节奏，但是迟迟疑疑不敢下手怕是浪费时间，于是偷偷瞄了一眼discuss，发现就是用backtrack回溯，回溯和DFS在这里感觉是一回事？？于是用上一题的row col sqr记录来判断行、列、小方块是否合法，dfs搞定。 TA：偷瞄的就是这个。答主没有用辅助函数，直接遍历，然后另外用一个函数循环一波来判断是否合法。这个想法非常直接，一目了然。 DFS, use prev encoded string set.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123; final String inRow = " in row "; final String inCol = " in col "; final String inBlk = " in blk "; public void solveSudoku(char[][] board) &#123; if (board == null || board.length != 9 || board[0].length != 9) &#123; return; &#125; Set&lt;String&gt; set = new HashSet&lt;&gt;(); for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; if (board[i][j] != '.') &#123; set.add(board[i][j] + inRow + i); set.add(board[i][j] + inCol + j); set.add(board[i][j] + inBlk + i/3 + "-" + j/3); &#125; &#125; &#125; dfs(board, set); &#125; private boolean dfs(char[][] board, Set&lt;String&gt; set) &#123; for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; if (board[i][j] == '.') &#123; for (int c = 0; c &lt; 9; c++) &#123; char temp = (char)(c + '1'); String row = temp + inRow + i; String col = temp + inCol + j; String blk = temp + inBlk + i/3 + "-" + j/3; if (!set.contains(row) &amp;&amp; !set.contains(col) &amp;&amp; !set.contains(blk)) &#123; set.add(row); set.add(col); set.add(blk); board[i][j] = temp; if (dfs(board, set)) &#123; return true; &#125; else &#123; set.remove(row); set.remove(col); set.remove(blk); board[i][j] = '.'; &#125; &#125; &#125; return false; &#125; &#125; &#125; return true; &#125;&#125; count-and-say 从1开始变化，数每个数字连续出现的个数代替原数字，例如1, 11, 21, 1211, 111221, 312211这样。给一个int表示往后的次数。 ME：用循环数连续出现数字的个数，相应的字符串用一个StringBuffer不断往后append就好。 TA：差不多吧，这是个衣洗题，不管了。 OK123456789101112131415161718192021222324class Solution &#123; public String countAndSay(int n) &#123; if (n &lt; 1) &#123; return ""; &#125; StringBuilder sb = new StringBuilder("1"); while (--n != 0) &#123; int i = 0, len = sb.length(); StringBuilder temp = new StringBuilder(); while (i &lt; len) &#123; int count = 1; char curr = sb.charAt(i++); while (i &lt; len &amp;&amp; sb.charAt(i) == curr) &#123; i++; count++; &#125; temp.append(count); temp.append(curr); &#125; sb = temp; &#125; return sb.toString(); &#125;&#125; combination-sum 给一个全为正整数的、不含重复项的int数组和一个正整数target，求任意个数组元素的list使得它们的和为target。 ME：全是正整数，立刻想到了桶排序，但这个『任意个元素组合』很不好搞，一时想不出来。。。 TA：依然是回溯法，似乎没人考虑怎么排序+二分使之更高效。这里有个大神总结了一个套路可以任意放在组合问题中，很强。受到这个点拨之后，这题和下一题都写出来了。以后要是还碰到这种回溯题，你得会了啊。需要指出的是，这题似乎是一个典型的动态规划题，因为涉及到了状态转换方程，解出target - candidate[x]的组合则target自然也就出来了。由于结果是二维的，DP就需要维护一个三维的List了。这次我竟然看懂了DP，自己也试了一波，下次争取盲写出来吧。不过跑出来比backtrack慢，大概是因为算了一些没必要的东西吧，毕竟要维护一个三维数组呢。。 Still DFS… I think it is a good point to conclude DFS as In-and-Out: Put sth in and assume it can count into result can go deeper, after that pop it out. There is also DP solution.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); if (candidates == null || candidates.length == 0) &#123; return ans; &#125; Arrays.sort(candidates); dfs(candidates, 0, target, 0, new ArrayList&lt;Integer&gt;(), ans); return ans; &#125; private void dfs(int[] candidates, int index, int target, int sum, List&lt;Integer&gt; curr, List&lt;List&lt;Integer&gt;&gt; ans) &#123; for (int i = index; i &lt; candidates.length; i++) &#123; int newSum = sum + candidates[i]; if (newSum &gt; target) &#123; break; &#125; else &#123; curr.add(candidates[i]); if (newSum == target) &#123; List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(curr); ans.add(temp); &#125; else &#123; dfs(candidates, i, target, newSum, curr, ans); &#125; curr.remove(curr.size() - 1); &#125; // remove duplicate because if this number has answer // it is already solved in the previous DFS iterations // Actually fits next problem.... while (i + 1 &lt; candidates.length &amp;&amp; candidates[i + 1] == candidates[i]) &#123; i++; &#125; &#125; &#125;&#125;class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); if (candidates == null || candidates.length == 0) &#123; return ans; &#125; Arrays.sort(candidates); // still need to guarantee the order // dp[t] means the List&lt;List&lt;&gt;&gt; that sums up at t+1 List&lt;List&lt;Integer&gt;&gt;[] dp = new List[target + 1]; for (int i = 1; i &lt;= target; i++) &#123; dp[i] = new ArrayList&lt;List&lt;Integer&gt;&gt;(); // allocate memory // make sure candidate no larger than curr target i for (int j = 0; j &lt; candidates.length &amp;&amp; candidates[j] &lt;= i; j++) &#123; if (candidates[j] == i) &#123; // exact match -&gt; dp[i].add(Arrays.asList(i)); break; // actually no use. because there's no duplicate in cdds[] &#125; else &#123; int index = i - candidates[j]; for (List&lt;Integer&gt; l: dp[index]) &#123; if (candidates[j] &lt;= l.get(0)) &#123; List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); temp.add(candidates[j]); temp.addAll(l); dp[i].add(temp); &#125; &#125; &#125; &#125; &#125; return dp[target]; &#125;&#125; combination-sum-ii 给一个全为正整数的、可能含重复项的int数组和一个正整数target，求数组元素的list使得它们的和为target且每个元素最多只能用一次。 ME：和上面一样，backtrack小改一下搞定。试了一下DP，在三维的情况下对于标记『某元素已经使用过』比较麻烦，就没试了。 Almost the same. Skep it. 41. first-missing-positive 给一个乱序整数数组，要求返回所缺正整数中的最小值。要求constant space，O(n). ME：看到O(n )和整数我就想到了木桶排序，这个想法肯定可行，但实现后发现Memory Limit Exceeded，看来题目并不给我开太大的数组。改小之后对小数据还是可以的，但总感觉借助了额外的空间不太符合要求。。。 TA：看了这个答案简直了，算是个技巧题吧，基本思想类似于往k+1个桶里扔k个有标号的球，漏掉的那个总会出现在1~k+1之间，那只需要把标号对应的球投入桶中，再从头遍历一遍找到空桶即得。在这题里，就是把正数k通过交换放到k-1处，从头到尾处理过一遍之后，总会有部分位置i的值不等于i+1，这个就是所求了。 O(N) time DOES NOT MEAN ONE-PASS!!! Fail to come up with this swapping and overwrite method. Critical at conditioning.1234567891011121314151617181920212223242526272829class Solution &#123; public int firstMissingPositive(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 1; &#125; int i = 0; while (i &lt; nums.length) &#123; if (nums[i] == i + 1 || nums[i] &lt;= 0 || nums[i] &gt; nums.length) &#123; i++; &#125; else if (nums[nums[i] - 1] != nums[i]) &#123; // warning: not nums[i] != i + 1 // critical: avoid re-overwriting that corrent spot swap(nums, i, nums[i] - 1); // i is curr index, nums[i] - 1 is where it should be &#125; else &#123; i++; &#125; &#125; i = 0; while (i &lt; nums.length &amp;&amp; nums[i] == i + 1) &#123; i++; &#125; return i + 1; &#125; private void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125;&#125; 42. trapping-rain-water 给一个int数组，其中包含每个索引处墙的高度。求装满水时的横截面的积水的面积。 ME：扫一遍获得每个索引处的左侧最高墙和右侧最高墙，再从头扫一遍，若是凹形（比较小值还小）则用该较小值减去本索引的高度得到该索引处水的高度，即是面积了。 TA： 服气，这个答案又见双指针，直接把我的两个分开的循环合并到一次里面完成了。其中的plank跟我的leftHi很像，都是从左往右遍历的过程中只能增加，但是plank是一次性比较两个指针的较小值，和我那个单向的比较高端（难懂）。代码越短越不好懂，类似的方法可能这个C++的好懂一丢丢。自己学着写了一波，速度稍微快了那么一点。 Ok for my own method with two auxiliary arrays. But if follow-up asks me to do it in constant space, need to know the method of two pointers.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123; public int trap(int[] height) &#123; if (height == null || height.length == 0) &#123; return 0; &#125; int[] hiLeft = new int [height.length]; // leftward highest int[] hiRight = new int [height.length]; // rightward highest int left = height[0], right = height[height.length - 1]; for (int i = 1, j = height.length - 2; i &lt; height.length; i++, j--) &#123; hiLeft[i] = left; left = Math.max(left, height[i]); hiRight[j] = right; right = Math.max(right, height[j]); &#125; int area = 0; for (int i = 0; i &lt; height.length; i++) &#123; int h = Math.min(hiLeft[i], hiRight[i]); if (height[i] &lt; h) &#123; area += (h - height[i]); &#125; &#125; return area; &#125;&#125;class Solution &#123; public int trap(int[] height) &#123; if (height == null || height.length == 0) &#123; return 0; &#125; int area = 0, maxLeft = 0, maxRight = 0; int left = 0, right = height.length - 1; while (left &lt;= right) &#123; if (height[left] &lt;= height[right]) &#123; // 左指针处高度不大于右指针 if (maxLeft &lt;= height[left]) &#123; maxLeft = height[left]; &#125; else &#123; // 只有当前高度完美小于左侧最大值才能储水 area += maxLeft - height[left]; &#125; left++; &#125; else &#123; // 左指针处高度完美大于右指针 if (maxRight &lt;= height[right]) &#123; maxRight = height[right]; &#125; else &#123; area += maxRight - height[right]; &#125; right--; &#125; &#125; return area; &#125;&#125; 43. multiply-strings 给两个字符串形式的int，模拟乘法求他们的积，返回字符串。 ME：这种数组模拟大数运算的题目我有点提不起劲，于是瞄了一眼答案做出来了。。。 TA：这个利用索引的小trick，一看就明。 44. wildcard-matching 和前面的regular-expression-matching很像，但这里用?代表任意一个字符、用*代表任意长度的任意字符而不依赖它前面的字符（而且不只能匹配单一个字符，直接匹配任意长度的任意字符组合）。总的来说比上一题简单，要讨论的情况少了。 ME：按照刚刚学习的动归DP思路维护一个二维boolean数组，dp[i][j]表示s[0~i-1]和p[0~j-1]是否匹配。初始化方面，对于空的p，dp[i][0]仍是除dp[0][0]外全部false，不可能用空的p去匹配非空的s；对于空的s，dp[0][j]就要看当前是否是&#39;*&#39;且考虑dp[0][j-1]。接着双重循环更新dp-&gt; 若当前字符p[j-1]是&#39;*&#39;，则考虑忽略它时，s[0~i-1]和p[0~j-2]的匹配情况，即dp[i][j-1]；或将&#39;*&#39;假设为s[i-1]那个字符，看看s[0~i-2]与p[0~i-1]的匹配情况，即dp[i-1][j]。-&gt; 若当前字符p[j-1]不是&#39;*&#39;，就直接看s[i-1]和p[j-1]的匹配情况再结合dp[i-1][j-1]了。除了DP，这个题目似乎还可以用贪心给两个字符串分别用一个指针一直向后挪。 Misunderstood the problem, especially the ‘*’.12345678910111213141516171819202122232425262728293031323334class Solution &#123; public boolean isMatch(String s, String p) &#123; if (s == null || p == null || s.equals(p)) &#123; return true; &#125; int m = s.length(), n = p.length(); char[] sChar = s.toCharArray(), pChar = p.toCharArray(); boolean[][] dp = new boolean [m + 1][n + 1]; dp[0][0] = true; // "" fits "" for (int j = 1; j &lt;= n; j++) &#123; // only "x*" can fit "" if (pChar[j - 1] == '*') &#123; dp[0][j] = dp[0][j - 1]; &#125; else &#123; dp[0][j] = false; &#125; &#125; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (pChar[j - 1] == '*') &#123; // don't take * or view * as one char or just // get rid of the char in sChar dp[i][j] = dp[i][j - 1] || dp[i - 1][j - 1] || dp[i - 1][j]; &#125; else &#123; if (pChar[j - 1] == sChar[i - 1] || pChar[j - 1] == '?') &#123; dp[i][j] = dp[i - 1][j - 1]; &#125; else &#123; dp[i][j] = false; &#125; &#125; &#125; &#125; return dp[m][n]; &#125;&#125; jump-game-ii 给一个元素非负的int数组，每个元素表示最多向后移几步，从index=0开始求最少经过几个节点到达末尾（含起点）。 ME：维护多一个一维数组，表示当前点一跳最远可以到达什么索引。贪心法，每次都选当前可达节点中下一步能跳得最远的点。 TA：这个似乎不需要额外的数组，毕竟每次你只关注『后续节点中最远可达的索引』。还有一种方式是考虑成BFS『分层问题』，当前可达的节点属于同一层，一直找到末尾节点所在的层数。 Know part of the idea but fail to implement it bug-freely…because you missed the condition to add step count.12345678910111213141516class Solution &#123; public int jump(int[] nums) &#123; if (nums == null || nums.length == 0 || nums.length == 1) &#123; return 0; &#125; int farthest = 0, step = 0, currEnd = 0, endIndex = nums.length - 1; for (int i = 0; i &lt; endIndex; i++) &#123; // warning: not nums.length farthest = Math.max(farthest, nums[i] + i); if (i == currEnd) &#123; // reaches edge means you have to add 1 to go farther step++; currEnd = farthest; &#125; &#125; return step; &#125;&#125; permutations 给一个各元素不同的int数组，求全排列。 ME：回溯法（或者说带有visited标志的DFS）搞定。 TA：如果面试官要求不能用recursive的方法，那这个iterative的方法就可以搬出来了。思想是每次借助上一次的结果，把当前元素依次往每个位置插而产生新的排列。由于要利用上一次的结果，那么就在第一重循环之前先给ans放入只有一个nums[0]元素的序列，然后每次取出一个ans中的序列并来一波循环插入新元素。 DFS OK. 1234567891011121314151617181920212223242526class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); if (nums == null || nums.length == 0) &#123; return ans; &#125; boolean[] used = new boolean [nums.length]; dfs(nums, used, new ArrayList&lt;Integer&gt;(), ans); return ans; &#125; private void dfs(int[] nums, boolean[] used, List&lt;Integer&gt; curr, List&lt;List&lt;Integer&gt;&gt; ans) &#123; if (curr.size() == nums.length) &#123; ans.add(new ArrayList&lt;Integer&gt;(curr)); return; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; if (used[i] == false) &#123; curr.add(nums[i]); used[i] = true; dfs(nums, used, curr, ans); curr.remove(curr.size() - 1); used[i] = false; &#125; &#125; &#125;&#125; permutations-ii 给一个可能有重复元素的int数组，求全排列，不可以有重复。 ME：也是回溯法，与上一题区别在于需要先排个序，然后每次往里放元素之前先判断是否和前面空闲元素相等，若相等则不能选取，因为前面相等的元素空闲说明这个位置它已经排列过了。 TA：按照上一题的那个iterative的方法改造了一下，去重只需要排序+在插入时判断要插入位置前一个字符是否相同即可，相同就跳过了。 Pretty much the same thing to previous one.12345678910111213141516171819202122232425262728293031class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); if (nums == null || nums.length == 0) &#123; return ans; &#125; Arrays.sort(nums); // sort for duplication avoidance boolean[] used = new boolean [nums.length]; dfs(nums, used, new ArrayList&lt;Integer&gt;(), ans); return ans; &#125; private void dfs(int[] nums, boolean[] used, List&lt;Integer&gt; curr, List&lt;List&lt;Integer&gt;&gt; ans) &#123; if (curr.size() == nums.length) &#123; ans.add(new ArrayList&lt;Integer&gt;(curr)); return; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; if (!used[i]) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]) &#123; continue; &#125; used[i] = true; curr.add(nums[i]); dfs(nums, used, curr, ans); curr.remove(curr.size() - 1); used[i] = false; &#125; &#125; &#125;&#125; rotate-image 给一个n*n的int数字矩阵，顺时针旋转90°。 ME：直接走in-place了，思路是每一条正方形上边缘的n-1个元素来挪动，沿边的长度挪动n-1次，然后再到内部的正方形去继续移动，直到n-1 &lt; 1，说明只剩一个元素或没有元素了。在纸上写了一堆矩阵找规律，好歹找出来了。 TA：我还以为自己好不容易找到一个还不错的规律，没想到还能通过对角线对称+左右对称搞定。这个可以扩展到顺时针（左右swap）、逆时针（上下swap）的通用解法。 fail to come up with the above symmetric method. Even know the idea, I just didn’t make the diagnol symmetric correct. diagnol is from top-left to bottom-right12345678910111213141516171819202122232425class Solution &#123; public void rotate(int[][] matrix) &#123; if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123; return; &#125; int n = matrix.length; // firstly get diagonal symmetric for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; int temp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = temp; &#125; &#125; // then flip left and right part for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n / 2; j++) &#123; int temp = matrix[i][j]; matrix[i][j] = matrix[i][n - j - 1]; matrix[i][n - j - 1] = temp; &#125; &#125; &#125;&#125; group-anagrams 给出一个String的数组，找出其中的『同字母异序』字符串并归类存入二维String数组返回。 ME：先对原数组排序，然后对每个字符串转成char数组，计算各位char的ascii码之和并重新排序，将这些整理后的string一个个再存入新的数组，然后再双重循环往后比较。被String默认的sort（compareTo）坑了，他是先找有没有字母不同，然后再看长度。后来利用传入自定义的Comparator，结果超时了。 TA：这个方法每次都把原数组中抓到的String转成char[]再排个序，把这个再转为String作为key来查找HashMap]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>algorithm</tag>
        <tag>interview</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Note for Java]]></title>
    <url>%2F2017%2F04%2F14%2Fjava_basic%2F</url>
    <content type="text"><![CDATA[学校课程并没有专门教Java，所以自己整理了一些基本Java语法之类的东西，还涉及一部分操作系统、计网、数据库的大山中学时做的笔记。另外结合Geeks4geeks做一些补充。 Java基础Java简介 Java版本分为三种-&gt; Java SE: 标准版，适用于桌面系统；-&gt; Java ME：微缩版，适用于小型设备；markdown tablemarkdown table-&gt; Java EE：企业版，适用于创建服务器应用程序和服务。 JDK和JRE的区别：-&gt; JDK：开发套件，提供了Java的开发环境，是面向开发人员使用的SDK；-&gt; JRE：执行环境，提供了Java的运行环境，是面向程序的使用者。 SDK和API的区别：-&gt; SDK：software development kit, a collection of implementation tools.-&gt; API：application programming interface, defines how to call another service. Java编译、执行： Java的文件名必须与代码中的public类名相一致。若类不是public则不必要，但注意一个文件中的多个类只能有一个用public修饰，编译后每一个类对应一个.class文件。 main是程序的入口方法，必须在Java程序中定义，它的签名是固定的。main可以定义在任何一个类中，不一定是public修饰的那个类。 编译命令：javac –d . .HelloWorld.java。其中-d表示生成类的时候按照包结构生成文件夹，.表示在当前路径下开始生成。 执行命令：java myPackage.HelloWorld。包名.类名的格式，将可执行字节码文件交给JVM执行。 运行过程：源码文件.java经过编译器javac后生成与平台无关的字节码文件.class，最后交给Java解释器执行字节码。总结起来就是『先编译，后解释』。编译指的是生成可执行文件（效率高、不跨平台），解释指的是将源文件逐行解释（效率低、跨平台）。 Java是跨平台的语言，Write Once and Run Anywhere(WORA)。真正执行的不是二进制代码，而是字节码，由JVM负责解释执行。Java跨平台的特性其实是基于JVM，但JVM本身是C语言编写的、并不是跨平台的。所以Java能够跨平台，本质上是依靠了不跨平台的JVM。 Java面向对象 面向对象是一种程序设计方法、一种程序设计范型，基本思想是使用对象、类、继承、封装、消息等概念来设计程序。面向对象强调以问题域中的事物为中心来思考问题、认识问题，根据这些事物的本质特点，把它们抽象地表示为系统中的对象作为系统的基本构成单位。如此一来，系统便可以直接映射问题域，保持问题域中事物及其相互关系的本来面貌。 Object: represents an entity with unique identity, state(attributes), behavior(operations). state: condition where the object exists. behavior: how the object acts to requests from other objects. Class: description of a set of objects with same stucture(attributes) and behavior(operatios), serving as template for creating objects. 面向对象的四个主要特征：抽象abstraction、封装ecapsulation、分层hierarchy、模块化Modularity。 抽象：Essentail characteristics of an entity reltive to a given perspective, eliminating details. 只关注事物的相似点、共性，忽略与当前主题无关的方面。例如每个人都有不同，但我只关注姓名、年龄、收入这些内容，那就可以抽象成一个人，而不必管其他身高体重之类的无关数据。通过抽象可以简化、提炼问题的本质。 封装：grouping of related elements into single entity, helping to hide information. 希望程序的部件”高内聚、低耦合”，防止程序相互依赖而带来的变动影响。在面向对象编程中，对象是封装的基本单位，面向对象的封装就是把描述一个对象的属性和行为的代码封装在一个类中。其中属性用变量定义，行为用方法定义，方法可以直接访问同一对象中的属性。通常将属性定义为private，这样就可以思考具体的方法究竟要定义到什么类中。例如人在黑板上画圆这个过程，显然圆心和半径都是圆的私有属性，所以画圆必须定义到圆这个类中，人只是负责发送一个消息给圆让它画一个。 分层：分为组合aggregation(is-part-of)和继承inheritance(is-a-kind-of)。继承是子类自动共享父类数据和方法的机制，是类之间的一种关系，提高的代码的可重用性和可扩展性。在定义和实现一个类的时候，可以利用已有的类，将它的内容作为自己的基础内容，然后再添加一些新的内容或修改覆盖原有内容。通过继承，我们实现了多态polymorphism，多态指的是程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编译时并不确定，在程序运行时才会确定。程序真正运行时才能确定引用变量到底会指向哪个类的实例对象、调用谁的方法。如此一来，就可以改变程序运行时绑定的具体代码，让程序可以选择多个运行状态。 模块化：decomposition of a large entity into smaller modules, which are independent, cohesive. Low coupling, high cohesion. Java的数据类型 基本数据类型：8种 -&gt; 整形：byte(1), short(2), int(4), long(8) -&gt; 浮点型：float(4), double(8) -&gt; 字符：char(2) -&gt; 布尔：boolean -&gt; 字符类型要用单引号括起来，\u0000表示将字符转换为对应unicode编码。 -&gt; 数字默认浮点型为double，强制用0.12f。 -&gt; Long类型也需要加123l(l = L). 引用数据类型：类、接口、数组12// 引用类型 变量名 = new 类名(参数)String str = new String("hehe"); Java内存空间分配与回收 栈：存放简单数据类型变量（值+变量名），存放引用数据类型的变量名+所指向实例的首地址。栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。 堆：存放引用数据类型的实例本身。JVM只有一个堆区(heap)被所有线程共享。 方法区：静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量。 垃圾回收：用后台线程gc进行垃圾回收。只有JVM发现内存不够的时候才会中断代码运行并进行垃圾回收。垃圾指的是不再被引用的对象如局部变量、没有指针指向的对象。 局部变量、实例变量、静态变量 局部：不是出现在类体花括号中的变量。必须先赋值才能使用。 实例：属于某个对象的变量，必须实例化对象之后才会分配空间（在堆，和对象在一起）、才能使用。 静态：直接属于一个类，又称类变量，只要程序加载类字节码就会给静态变量分配空间（在方法区），直接通过类名访问、使用。类的静态变量在内存中只存在一个，被所有类的实例共享，只能通过类名访问而不能通过特定的对象访问。Main方法必须声明为static的，这样就可以不通过对象而直接在类加载的时候找到程序入口，执行程序。 包 Package：通常以公司域名的反转为报名，每个字母小写。 目录结构：在环境变量设置中会有一个默认包的位置，要想使用自己定义的包及其下属的类，就需要指定包的目录结构，保证.class文件在对应目录中，执行时需要加上java com.bobby.HelloWorld这样。在其他程序中也可以通过包名导入类，如import com.bobby.HelloWorld; 数组 数组是对象，是有序数据的集合。声明数组并没有真的创建一个对象，而是要通过new来创建对象。声明时不需要指定长度，new时才需要指明空间。 12int[] I = new int[2];Student[] s = new Student[10]; 数组创建后元素有初始值，对象则会调用无参数的构造子。 二维数组其实是一维数组中每个元素又分别是一个一维数组。高维要先分配好空间才能给低维数组分配（否则就是空中楼阁）。 数组拷贝：使用系统类System提供的Static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); srcPos表示源数组的什么位置开始拷贝，destPos表示放到dest的那个位置开始。 数组排序：可以用java.util.Arrays.sort(object obj, Comparator myComparator);自定义排序可以通过自定义MyComparator来实现。或者直接声明匿名类，甚至使用lambda。123456789101112131415161718192021class MyComparator implements Comparator &#123; public int compare(Object obj1, Object obj2) &#123; User u1 = (User)obj1; User u2 = (User)obj2; if (u1.age &lt; u2.age) &#123; return -1; // 升序排列 &#125; else if (u1.age &gt; u2.age) &#123; return 1; // 降序排列 &#125; else &#123; // 年龄相同按String排序 return u1.name.compareTo(u2.name); &#125; &#125;&#125;// actually we don't need to explicitly define thisArrays.sort(arr, new Comparator() &#123; public int compare(Node a, Node b) &#123; return a.val - b.val; &#125;&#125;);// and more easily Arrays.sort(arr, (a, b) -&gt; a.val - b.val); 然后在public的类的main中ArrayList arrayList = new ArrayList();之后，在往里add User的实例对象。Object[] users = arrayList.toArray();之后就可以java.util.Arrays.sort(users, new MyComparator());这样调用了。 Java的串行化（序列化） 串行化可以使你将一个对象的状态写入一个Byte流中，并且可以从其他地方把该Byte流的数据读出来，重新构造一个相同的对象。这样就可以将对象通过网络进行传播、随时把对象持久化到数据库、文件系统中。 序列化就是一种处理对象流的机制，将对象的内容进行流化，可以对流化后的对象进行读写操作，也可通过网络传输。 final 类似于const，表示不许改变。修饰变量、方法、类。 final修饰的变量称为常量，没有默认初始值，必须进行一次直接赋值或者在构造方法里赋值，只能赋值一次。而在前面再加上static，则只能直接赋值。而final修饰的引用变量指的是引用不能随意改变指向，但是指向的那个对象本身还是可以变的。 final修饰的方法保持方法稳定性，不允许被子类覆盖。 final修饰的类不能被继承，类中的方法都是final的。 final, finally, finalize区别 -&gt; final用于声明属性、方法和类，分别表示属性不可变、方法不可覆盖、类不可继承。内部类要访问一个局部变量，则该局部变量必须定义为final类型。 -&gt; finally是异常处理末尾的统一出口，总是执行。 -&gt; finalize是Object类的一个方法，在垃圾回收执行时调用被回收对象的finalize方法，可以覆盖重写以进行其他资源的回收如关闭文件等。 abstract 抽象类：含有抽象方法的类都是抽象类(需要声明abstract关键字)，但是抽象类其实也可以全是具体方法。抽象类不能生成对象实例，但可以作为对象变量声明的类型，只能定义一个引用，指向属于该抽象类的子类的实例。抽象类相当于半成品，需要子类覆盖其中的抽象方法。 抽象方法：定义了一种标准，不含有具体实现，子类负责继承并实现父类所有抽象方法后才能实例化。 abstract和final不能同时使用。abstract修饰明摆着就是需要继承、重写的，这与final相违背。private也不能同时使用，因为private直接就阻止了继承和重写。 Java不支持多继承，因为可能出现在父类中定义了相同的方法（method with same signature），然后同时继承，调用该方法的时候就不知道调用的是哪一个方法了(diamond of death)。或者解释说这是一个is-a问题，不能同时是同等级的东西。 接口interface 接口本质上是特殊的抽象类。通过接口可以间接实现多继承，而不会增加类关系的复杂度。因为接口是对类的进一步抽象，可以分出主、次关系类型。接口定义了一种标准，接口的调用者是在使用这种标准，接口的实现类则是在实现标准。通过接口可以将使用标准和实现标准分离开来，解除耦合关系，具有可移植性。 在接口中，所有的方法都是public abstract、所有的属性都是public static final。 接口与接口之间可以多继承，extends后用逗号隔开。这是因为接口仅仅定义了一种约定contract，仅仅是方法的signature而不涉及implementation，这样在子接口中发现相同的signature，直接归为一类。接口没有构造子，也没有main方法，不过在Java8中出现了接口的default方法，也允许一部分带有implementation的方法被继承，在子类implement这些接口的时候，需要手动调用I1.super.func1()来防止编译器不知道是哪个接口的方法。 接口的实现是通过类。public class className implements itf1, itf2, itf3 来实现接口，允许实现多个接口。类必须实现接口中所有的方法，否则仍为抽象类。实现类中的方法必须加上public。 包装类及其拆箱装箱 前面提到了八种基本数据类型，都是值类型，并不是类。它们都有对应的引用数据类型，即类类型。 装箱：把基本类型用它们对应的引用类型包起来，具有对象的特征。自动装箱则是每当需要一种类型的对象时，便可自动把基本类型封装到对应的包装中。 123int i = 11;Integer i =I; // 自动装箱int k = I; // 自动拆箱 拆箱：把引用类型的对象重新简化成值类型的数据。自动拆箱则是每当需要一个值时，被装箱的对象中的值就会提取出来而无需显示调用intValue()方法。 IntegerCache类缓存：为了提高效率，IntegerCache类中有一个static数组缓存了-128~127的Integer对象，在自动装箱时若真实值落在这个范围内，则直接从Integer数组中取出来使用，这样直接比较对象的引用，也会发现是相等的。但是手动new出来的就不会有这个cache的事了。当超出这个范围后，即便自动装箱也不会有cache的事了。 123456Integer a = 100;Integer b = 100;a == b // trueInteger c = 200;Integer d = 200;c == d // false 更有意思的是，原本是new出来的对象，经过自动拆箱再自动装箱，又会用到cache了： 12345Integer m = new Integer(5);Integer n = new Integer(5);m == n; // falsem = m – 1; n = n – 1;m == n; // true ==，!=比较的是引用对象的地址而不会自动拆箱;&gt;，&gt;=，&lt;=，&lt;，则会触发自动拆箱取出对象中的值。要比较Object的值，还是需要调用equals或实现compareTo方法为妙。 String, StringBuffer, StringBuilder String：不可改变的Unicode字符序列。在String类中，以”xxx”的字面值创建时，直接到Java方法空间的串池中查找，若已存在则直接返回该串地址，若无则新建。 123String s1 = "abc"; // 新建String s2 = "abc"; // 直接从池中取出String s3 = new String("abc"); // 在堆中创建，不管池 调用String类的任何方法都不会改变String对象本身。 StringBuffer：可改变的Unicode字符序列。synchronous允许并发操作，thread-safe是线程安全的。最典型的使用场景是String的连接，使用append方法会比新建String高效。 StringBuilder：可改变的Unicode字符序列。但不支持并发操作，不是线程安全的，不过就更快。 内部类 内部类作为类的一个成员，依附于外部类存在。内部类提供了某种进入其外围类的窗口，通常使用场景是内部类继承自某个类或实现某个接口，在内部类代码中操作创建其外围类的对象。无论外围类是否已经继承了某个接口，都对内部类没有影响。主要分为成员内部类、局部内部类、静态内部类、匿名内部类。 成员内部类：作为一个成员，与外部类的属性、方法并列。在内部类中可以访问外部类的所有成员，不能定义静态成员。依附于外部类的具体对象，才能生成内部类对象。 局部内部类：在方法中定义的内部类，不再是外部类的一个成员，但仍需依附于外部类的对象。 静态内部类（嵌套类）：允许存在独立于外围类对象存在的内部类对象。而在普通内部类中隐含地保存了一个引用，指向创建它的外部类对象。静态内部类可用public, protected, private修饰，内部可定义静态或非静态成员，但只能访问外部类的静态变量&amp;静态方法。 匿名内部类：当只需要用到类的一个实例、定义后马上就用到、类本身非常小、给类命名并不会增加代码可读性，就推荐使用匿名内部类。匿名内部类本身是局部内部类，但它不含构造子、不能定义任何静态成员、方法或类、它不能是static, public, private, protected修饰的、一定跟在new后面。 异常 try + catch + finally assert 要想使用断言，在执行时需要java –ea 类名这样强制开启。 断言保证了最基本的、关键的正确性。assert 布尔表达式 字符串;一旦这个表达式为false，后面的字符串就会显示出来。 equals与== 在Object类中，equals的定义就是==，表示的是判断两个变量指向的对象是否是同一个变量。所以如果希望比较的是对象的内容，还是需要自己覆盖equals方法。 overload重载与override覆盖重写 重载表示同一个类中可以有多个相同名字的方法，只是参数列表不同（类型or个数）。 覆盖（重写）表示子类的方法可以与父类的方法的名字和参数列表完全一样，但是在子类中重新定义，这样通过子类创建对象时就会调用子类的这个方法，这是多态的一种表现。 Abstract与interface 抽象类不能创建实例对象，其中的方法不必是抽象的。其抽象方法必须在具体子类concrete中实现。抽象类不能有抽象的构造子或静态方法。 Interface可看作抽象类的特例，接口中的所有方法都一定是抽象的。默认方法均为public abstract修饰，默认成员变量都是public static final. interface abstract class 方法必须是抽象的 可含抽象/非抽象方法 成员变量必须final，可含有static 可含final/static/普通成员变量 接口只能extend另一个接口 抽象类可extends另一个类或implements多个接口 深拷贝与浅拷贝 浅拷贝(Object类中的clone()方法)是指在拷贝对象时，对于基本数据类型的变量会重新复制一份，而对于引用类型的变量只是对引用进行拷贝。它只是使用一个已知实例对新创建实例的成员变量逐个赋值，只复制基本变量值、传递类对象引用，不能完全复制实例。 深拷贝则是对对象及该对象关联的对象内容，都会进行一份拷贝。基本变量的值是肯定会复制的，而引用则不仅仅是复制引用，而引用指向的对象也会创建一个相同的对象。 Clone方法：定义在Object类中，将对象复制了一份并返回给调用者。在派生类中覆盖基类的clone()方法，并声明为public。在派生类的clone()方法中，调用super.clone()。在派生类中实现Cloneable接口。 参数传递 Java中的方法都是都是按值传递的，所以对于基本数据类型是无法修改从外部传入的变量的(联想C/C++中接触过的swap)。但是对于引用类型，引用变量本身的指向就算在方法里面指向一个new的对象，最终这个引用变量的值确实不会变更的，但是通过引用指向的对象本身还是可以更改的，你在方法中调用一些set函数之类的，都是有效的。 swap 由于java中的参数都是按值传递的，所以肯定没法像C/C++一样用一个&amp;搞定。但是Java中的Integer类又不允许直接修改里面的属性Int。有几种间接方法： 自定义MyInteger类 1234567891011121314151617class MyInteger &#123; private int value; public MyInteger(int i) &#123; this.value = i; &#125; public void setValue(int value) &#123; this.value = value; &#125; public int getValue() &#123; return this.value; &#125; public static void swapMyInteger(MyInteger a, MyInteger b) &#123; Myinteger c = new MyInteger(a.getValue()); a.setValue(b.getValue()); b.setValue(c.getValue()); &#125;&#125; 数组的形式 12345public static void swap(int[] data, int a, int b) &#123; int t = data[a]; data[a] = data[b]; data[b] = t; &#125; 外部内联 12345678910111213141516171819202122public class Swap2 &#123; public static void main(String args[]) &#123; Swap2 sw = new Swap2(1,2); System.out.println("i is" + sw.i); System.out.println("j is" + sw.j); sw.swap(); System.out.println("i is" + sw.i); System.out.println("j is" + sw.j); &#125; int i, j; public Swap2(int i, int j) &#123; this.i = i; this.j = j; &#125; public void swap()&#123; int temp; temp = i; i = j; j = temp; &#125; &#125; Collections.swap class.forName(String ClassName)的作用 返回与给定的字符串名称相关联类或接口的Class对象。它是static的方法，不依赖Class类对象。Class类没有显式的构造子可以调用，只有类加载器的defineClass自动调用。 Java程序在运行时，Java运行时系统一直对所有的对象进行所谓的运行时类型标识。这项信息纪录了每个对象所属的类。虚拟机通常使用运行时类型信息选准正确方法去执行，用来保存这些类型信息的类是Class类。Class类封装一个对象和接口运行时的状态，当装载类时，Class类型的对象自动创建。 ClassLoader如何加载Class ClassLoader用于将Class文件加载到JVM，使java动态加载类定义的特性成为可能。 当运行一个程序的时候，JVM启动，运行bootstrap classloader，加载java核心API，再调用ExtClassLoader加载扩展API，最后AppClassLoader加载CLASSPATH目录下定义的class。 这个bootstrap classloader不是用java编写的。它在JVM运行时加载java核心API以满足java程序最基本的需求。 类加载的双亲委托模式：每一个自定义的ClassLoader都继承ClassLoader这个抽象类，同时还有个parent指向父类。这个Parent不是真正的被继承的父类，而是在实例化ClassLoader时指定的一个ClassLoader。若这个parent是Null，则默认其父类为bootstrap ClassLoader。当parent无法加载成功才会由自己的findClass加载。所以我们要实现一个自定义类时，只需要实现一个findClass方法即可。 双亲委托模式作用：一是避免重复加载，当parent已经可以加载该类，就没必要让子ClassLoader再加载一次；二是考虑安全因素，保证核心API中定义的类不会被轻易替换掉，例如String一定会现在Bootstrap ClassLoader中加载好，轮不到自定义的findClass. JVM加载类：装载、连接、初始化。装载是找到相应的class文件并读入JVM，连接分为三步：验证class是否符合规格、为类变量分配内存并设置默认初始值、解释（可选），即根据类中的符号引用查找相应的实体，再把符号引用替换成一个直接引用的过程。 使用forName加载一定会将Class进行解释和初始化；loadClass加载类时默认不进行解释和初始化。hashCode方法的作用 根据对象的内存地址换算出的一个值。利用哈希可以提高从集合中查找元素的效率，它将集合分为若干个存储区域，每个对象都尅算出一个哈希值，再将哈希值分组，每组对应某个存储区域。 结合equals可以帮助判断在集合（list或set）中是否存在某元素。在调用hashCode之后若该物理地址上没有元素则直接存入，若有则还需要用equals判断元素是否相同。注意，hashCode相同不一定就能确定两元素相同。 Equals和hashCode都是从Object类中继承来的，但通常都会在子类中覆盖掉。Equals改写时应满足对称性(x = y, y = x)、反射性(x = x)、类推性(x = y, y = z)、一致性(持久x = y)、对象不合全假性(x != null, x != 不同类对象)。 hashset：继承Set接口，Set接口又实现的是Collection接口。Hashset不允许重复对象，对象顺序也不确定。在hashset中判定两个元素是否重复就是通过(1)hashCode是否相等（相等则进行(2)）；(2)使用equals运算判断。 JVM JVM的学习有两个重要部分：Java代码编译和执行的整个过程 &amp; JVM内存管理和垃圾回收机制。 Java代码的编译由Java源码编译器完成：生成的JVM字节码的执行由JVM执行引擎完成： Java代码编译和执行的整个过程包含三个重要机制： -&gt; Java源码编译机制：三步走——分析和输入到符号表、注解处理、语义分析和生成class文件。最后生成的class文件包含了结构信息（class文件格式、版本号、各部分的数量和大小信息）、元数据（对应于java源码中声明和常量信息，包括类、父类、实现的接口的声明信息、域和方法声明信息和常量池）、方法信息（对应java源码中语句和表达式对应的信息，包括字节码、异常处理器表、求值栈和局部变量区大小、求值栈的类型记录、调试符号等信息）。 -&gt; 类加载机制：通过ClassLoader及其子类完成，加载顺序依次为 -Bootstrap ClassLoader(加载$JAVA_HOME中jre/lib/rt.jar的类，由C++实现而非ClassLoader子类) -Extension ClassLoader(加载$JAVA_HOME中jre/lib/*.jar的其他扩展功能包) -App ClassLoader (加载classpath指定的jar包) -Custom ClassLoader(应用程序根据自身需要自定义的ClassLoader) 最终会从下往上检查是否所有类都加载成功。 -&gt; 类执行机制：基于栈来执行class字节码。线程创建后，会产生程序计数器pc和栈stack，pc存放下一条要执行的指令在方法中的偏移量，栈中存放一个个栈帧，每个栈帧对应每个方法的每次调用，栈帧由局部变量区（存方法中的局部变量和参数）和操作数栈（存放方法执行时的中间结果）两部分组成。 JVM内存管理JVM栈由堆、栈、本地方法栈、方法区等部分组成。 -&gt; 堆：存放对象内容，所有new出来的内容都在堆中分配。堆分为新生代和旧生代，其中新生代存放新建对象于eden区，当edne空间不足是会移到survivor取。旧生代存放多次垃圾回收后仍然存活的对象。 -&gt; 栈：每个线程执行每个方法的时候都会在栈中申请一个栈帧。 -&gt; 本地方法栈：用于支持native方法的执行，存储了每个native方法调用的状态。 -&gt; 方法区permanent space：存放了要加载的类信息、静态变量、final类型的常量、属性、方法信息。 JVM垃圾回收 JVM对新生代和旧生代采用不同的垃圾回收机制。 生代通常存活时间较短，故用Copying算法扫描出存活的对象并复制到一块新的完全未使用的空间（Eden的From Space复制到To Space）。新生代GC的触发由空闲指针的方式控制，指针记录最后一次分配的对象在新生代区间的位置，当下一次又要分配内存时就会检查空间是否足够，不够就触发GC。当连续分配对象的时候，对象会逐渐从eden到survivor，最后到旧生代。 旧生代对象存活时间较长，故采用Mark算法扫描出存活的对象并回收未被标记的对象，回收后对空间合并或标记为空闲方便下次分配。 Main objective: free heap memory by destroying unreachable objects. Mark and sweep algorithm: when objects are created, their marked bit is set to false. when gc starts, mark phase will DFS from root(assume one only) to all the other nodes and mark the reachable ones as true; in sweep phase, all the nodes that are marked false will be swept away from heap and those marked true will be reset as false. 多线程进程与线程 进程：同一个OS中执行的一个程序，包含了虚拟CPU、代码、数据。进程是资源的拥有者，是资源分配的基本单元。 线程：在同一进程当中执行的子程序流。线程是进程中执行的程序片段，是调度的基本单元。 进程与线程：有点类似包含关系，线程从属于进程的一部分。进程之间是独立的，这表现在内存、上下文环境上，不能去占用其他进程持有的空间；而同一进程下的线程则共享一片内存空间。具体地，进程拥有独立的进程空间，数据存放空间栈空间、堆空间都是独立的；而线程的堆空间是共享的，栈空间是独立的，线程消耗的资源少于进程，相互之间会有影响。 多进程：同一个OS中执行的多个并行的程序，可以提高CPU利用率。 多线程：同一个进程中并发执行的多个子程序流，可以提高CPU利用率。 只有运行状态的线程才有机会执行代码，主线程的中止（main方法退出）不会影响其他正在运行中的线程，在线程内部，程序按顺序执行。只有进程中的所有线程都中止，进程(JVM进程)才会退出。 线程编程 写一个类extends Thread类，并覆盖其中的run()方法。之后在main中实例化对象后再.start()即可运行。由于Java不支持多继承，所以在这种情况下就没法再继承别的基类了。不过可以访问Thread类中定义的yield, interrupt等方法。 1234567class MyThread extends Thread &#123; public void run() &#123; ... &#125;&#125;Thread t1 = new MyThread();T1.start(); 写一个类implements Runnable接口，实现其中的run()方法。但是这个类不能直接作为对象开启线程，而是作为线程Thread的对象构造子的参数实例化一个线程后，还是通过线程来开启。由于这只是实现了接口，因此还可以继承某种别的基类或实现若干别的接口。 12345678class MyThread implements Runnable &#123; public void run() &#123; ... &#125;&#125;Runnable myThread = new MyThread();Thread t2 = new Thread(myThread);T2.start(); 线程的生命周期 初始状态new：创建了一个线程对象，线程只是处在JVM中，并没有真正开始运行。 就绪状态ready/runnable：已经具备了运行条件，但还没有分配到CPU。处于就绪队列中（或者叫可运行池）等待CPU调度。 运行状态running：拥有CPU的执行权。 阻塞状态waiting：运行状态中的线程若需要等待I/O资源或者调用了sleep等方法，就会进入阻塞状态。阻塞之后的线程会重新进入就绪队列等待调度。 终止状态terminate：线程运行结束。所有线程都over了这个进程才会over。 等待队列状态：一个线程调用一个对象的wait()，就会放弃该对象的锁标记，进入等待队列状态。当其他线程调用临界资源的notify或notifyAll就会将等待队列的线程释放进入锁池状态。 锁池状态：每个对象都有互斥锁标记，防止对临界资源的访问造成数据的不一致、不完整性。一个线程拥有一个对象的锁标记后，其他线程若想访问这个对象，就需要在锁池中等待，由OS决定将锁标记分配给哪个线程。线程拿到锁标记后进入就绪状态等待调度。 多线程模型 User thread：受内核支持，受用户级线程库管理； Kernel thread：直接受内核支持和管理。 分三类模型：多对一、一对一、多对多。 -&gt; 多对一：多个user映射到一个kernel; 对用户级线程的控制可通过用户级线程库实现，不需要模式切换； -&gt; 一对一：user与kernel thread一一对应；可并行处理，即多核同时处理一个进程，且一个线程的挂起不会导致多个线程的阻塞。 -&gt; 多对多：将多个user thread映射到小于等于其个数的kernel thread; 可并行处理，即多核同时处理一个进程，且一个线程的挂起不会导致多个线程的阻塞。 多线程同步 多线程并发访问同一个对象，若不对线程进行同步控制，则会破坏原子操作导致临界资源的数据不一致。竞争条件：多线程并发访问、操作同一数据块且执行结果与访问的顺序有关。解决临界区冲突应满足：互斥、前进、有限等待。 每一个对象都有一个互斥的锁标记和一个锁池。只有线程拥有这个锁标记才能访问这个资源，其他线程都在锁池中等待。这种等待状态若陷入无法改变的情况，就形成了死锁。死锁的四个条件：互斥、占有且等待、非抢占、循环等待。 Synchronized：在方法范围内对当前对象加锁，只有拿到对象锁标记的线程才能执行这个方法。锁对象相同，同步语句串行；锁对象不同，同步语句并行。 多线程编程的优势 -&gt; Responsiveness：程序可以在部分线程阻塞的情况下运行。 -&gt; SourceSharing：同一进程下的线程共享资源，可节约空间并方便访问。 -&gt; economy：创建线程并不涉及大量资源分配，开销小。 -&gt; 多核的使用：线程可以并发运行，使多核处理器能物尽其用。 Wait()方法：调用加锁的对象使用wait会使当前持有对象锁标记的线程（wait在syncrhronized方法中因此该线程必定持有锁）释放锁标记并进入该对象的等待队列（这还不是锁池！）。若此时另一个线程获得了该对象的锁标记，并进入代码块调用notify()，则会放出等待队列中的一个线程进入锁池。 Notify()方法：从对象的等待队列中移出任意一个线程（由系统决定）放入锁池，等待锁标记。 NotifyAll()方法：移出所有等待队列中的线程放入锁池。 Sleep与wait方法 sleep：Thread类中的方法，表示线程休眠，会自动唤醒。Sleep只是将执行机会让给其他线程而不会释放对象锁，监控状态依然保持、之后会自动恢复。 wait：Object类中的方法，表示当前线程释放对象锁并进入等待队列，待针对此对象的notify方法执行后才会进入锁池。 当一个线程进入一个对象的一个synchronized方法后，其他线程可否进入该对象的其他方法？ 分情况来看。 若其他方法无synchronized关键字修饰，则可以； 若该sychronized方法内部有调用wait，则可以进入其他synchronized方法； 若其他方法都有synchronized关键字修饰且当前synchronized方法没调用wait，则不能； 若其他方法是static，则它用的同步锁是当前类的字节码，不能与非静态的方法同步，因为非静态方法用到的是this必须有对象。 Synchronized与java.util.concurrent.locks.Lock异同？ 同：Lock可以完成synchornized的所有功能； 异：Lock有比synchronized更精确的线程语义和更好的性能。Lock要求手动释放锁、必须在finally中释放，而synchronized是自动释放锁。 进程间通信 管道（pipe）及有名管道（named pipe）：管道可用于具有继承关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。 信号（signal）：信号是在软件层次上对中断机制的一种模拟，它是比较复杂的通信方式，用于通知进程有某事件发生，一个进程收到一个信号与处理器收到一个中断请求效果上可以说是一致的。 消息队列（message queue）：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定的规则向消息队列中添加新信息；对消息队列有读权限的进程则可以从消息队列中读取信息。 共享内存（shared memory）：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。 信号量（semaphore）：主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段。 套接字（socket）：这是一种更为一般的进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。 线程间同步通信 信号量 消息 事件 集合框架Collection综述 结构 Collection是最基本的集合接口，一个Collection代表一组Object，称为Collection的元素。保存的必须是对象而不能是简单类型。 ArrayList实质上是长度会增长的数组。查询效率高、增删效率低。加载大批量数据时，可以用ensureCapacity(int minCapacity)手动扩容以提高效率。 HashSet：Object类中的hashCode方法是所有类都会继承的方法，用于计算一个Hash码值返回，HashSet就用这个哈希值基于数组的长度取模，这个模值就是存放的下标，若这个下标已经有对象则需要判断这两个对象是否相同，不同则需要另找位置添加。故对于自定义类来说调用HashSet就需要同时覆盖hashCode()和equals()方法。 TreeSet：可排序的Set。SortedSet接口是Set的子接口，TreeSet是SortedSet接口的实现类，他可以对集合中的元素进行排序。为了实现自定义类的排序，需要实现java.lang.Comparable接口（可省去hashCode方法）。接口只定义了compareTo(Object o)这个方法，返回值是整型，小于参数对象返回-1，大于返回+1. 另外需要注意的是java.util.Comparator接口，compare(Object o1, Object o2)其实跟前面也差不多，创建集合时把定义好的比较器也作为参数便可构造有序集合。 HashMap：基于哈希表的Map接口的实现，提供键值映射，允许空值和空键null，非线程安全，不支持并发控制. HashMap的遍历首先是调用keySet获得所有键，遍历这个集合根据key拿到value。 Hashtable：不允许空值和空键null，线程安全，支持并发控制。一般不用。 SortedMap接口：Map的子接口，可根据键排序规则整理加入的键值对，排序规则类比SortedSet。 Key通常是八种基本数据类型的对应类以及String，自己定义的类作为Key没有意义。 ArrayList与Vector 同：都实现了List接口，都是有序（有索引）集合，随机访问效率高，数据允许重复。 异： -&gt; 同步性。Vector是旧版本，保证了线程安全，它的方法之间是线程同步的；ArrayList是线程不安全的。若只有一个线程，显然用ArrayList更高效，因为它根本不考虑线程同步问题。（同步性问题Vector&amp;ArralList – Hashtable&amp;HashMap可以类比，都是一老一新，老的能保证线程安全） -&gt; 数据增长。当元素超出容量时，Vector一次增长一倍，ArrayList增加0.5倍。他们都可以设置初始长度，但这个增加长度只有Vector可以设置。 List, Map, Set三个接口存取元素时各有什么特点？ Set：单列元素的集合，父接口为Collection。不允许重复元素，重复不仅指相同更指相等equals。故存入的add方法会调用equals方法遍历集合判断是否已经有相等对象。取元素不是按索引取，而是要通过Iterator接口取得所有元素遍历。而HashSet通过hashCode值的某种运算方式进行存储，而不是直接根据hashCode结果作为存储顺序。 List：单列元素的集合，父接口为Collection。允许重复元素，可以根据索引取元素，随机访问效率高。调用add方法可以指定插入的索引位置，或者说是该位置的索引变量指向了add参数中的对象。除了get(index)根据索引取，List也可以通过Iterator接口取得所有元素遍历。 Map：双列元素的集合，通过put(Object key, Object value)存入键值对。Key不可以重复。Map.Entry可以获得键值对的集合。 ArrayList, Vector, LinkedList的存储性能和特性 ArrayList：使用数组的方式存储数据，非线程安全故性能稍优于Vector. Vector：使用数组的方式存储数据，使用synchronized方法保证线程安全。 LinkedList：使用双向链表实现存储，按序号索引数据需要前向或后向遍历，但插入数据只需记录本项的前后项即可，插入效率高。非线程安全。LinkedList提供了一些方法可以当作堆栈和队列使用。 ArrayList的实现原理 是List接口的可变数组的非同步实现，提供所有可选列表的操作，允许包括Null在内的所有类作为元素。线程不安全，在多线程访问时需要保证外部同步。 ArrayList底层本质就是数组。private transient Object[] elementData; 构造子有三种： -&gt; ArrayList()默认大小为10； -&gt; ArrayList(int initialCapacity)传入指定初始capacity； -&gt; ArrayList(Collection&lt;? Extends E&gt; c)构造一个包含指定collection的元素的列表。 存储/添加元素： -&gt; set(int index, E element)直接替代已有元素； -&gt; add(E e)加到尾部，add(int index, E element)加到指定索引处、其后元素均后移一位； -&gt; addAll(Collection&lt;? Extends E&gt; c)按照Collection的迭代器所返回的元素顺序依次加入尾部； -&gt; addAll(int index, Collection&lt;? Extends E&gt; c) 按照Collection的迭代器所返回的元素顺序依次插入指定索引处。其中需要注意的是index的越界验证（&lt; 0 || &gt; size），添加用到的是系统提供的拷贝方法：System.arraycopy(src, start_src, dst, start_dst, len); 如何知道要将原列表内容拷贝多少到右边？以第四个方法为例： 12345678910int numMoved = size – index; //从index往右都有多少元素要挪Object[] a = c.toArray();int numNew = a.length();ensureCapacity(size + numNew);if (numMoved &gt; 0) &#123; System.arraycopy(elmentData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); Size += numNew; return (numNew != 0); // 返回布尔值以示插入成功&#125; 读取指定索引元素：直接返回，注意也需要index的越界验证。 删除元素： -&gt; 给定索引进行删除，右边所有元素都会向左移动一位： 123456numMoved = size – index – 1;if (numMoved &gt; 0) &#123; system.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // 垃圾回收 return oldElement;&#125; -&gt; 给定元素进行删除，只会删除首次出现的指定元素：for循环查找索引用equals对比，其实还是按索引删除。注意Null对象是允许存放在列表中的，所以也需要处理null的情况（直接左移）。 调整容量ensureCapacity(int minCapacity)，只能扩大且至少扩大为1.5倍：关键是末尾调用了一发elementData = Arrays.copyOf(elementData, newCapacity); 也可以将末尾冗余项剔除：trimToSize()方法将length长度缩减为实际size. HashMap实现原理 是基于哈希表的Map接口的非同步实现，提供所有可选的映射操作，允许null值、null键在内的所有类，Key通常是八种基本数据类型的对应类以及String，自己定义的类作为Key没有意义。HashMap不保证映射的顺序，且不保证顺序恒久不变。 HashMap底层也是数组，它的长度一定是2的幂，而每一项又是一个链表，称之为”链表散列”。事实上，java中最基本的结构就两种，一是数组，二是引用（模拟指针），所有数据结构都能用这两个基本结构来构造。 Transient Entry[] table数组中每一项为Entry，内含键值对和下一个元素的引用： 123456static class Entry&lt;K, V&gt; implements Map.Entry&lt;K, V&gt; &#123; final K key; V value; Entry&lt;K, V&gt; next; Final int hash;&#125; 存储元素：put元素时先根据key的hashCode重新计算hash值，然后根据hash值得到这个元素在数组中的索引，若该位置已经存放了其他元素，则新加入的将作为链表头存在此处，最先加入的元素放在链尾。当然这个null要单独处理，例如键为null则放在数组第一位。 1234567891011121314151617public V put(K key, V value) &#123; if (key == null) return putforNullKey(value); int hash = hash(key.hashCode()); int I = indexfor(hash, table.length); for (Entry&lt;K, V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key) || key.equals(k)) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i); // 这个addEntry就是将新创建的Entry指向原来该位置的元素。 return null;&#125; Hash方法：根据key的hashCode重新计算一次散列，加入了高位运算，防止低位不变、高位变化时造成hash冲突。由于HashMap的数据结构是数组和链表的结合，所以当然希望其中的元素位置尽量分布得均匀一些，这样找到这个位置就可以直接判断元素是否符合key而不用遍历整个链表。对于任意对象，只要hashCode返回值相同、丢到hash里计算值也相同。 1234static int hash(int h) &#123; h ^= (h &gt;&gt;&gt; 20)^(h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125; indexfor方法用于计算对象应该保存在数组的什么索引处。为了让元素分布更平均，首先想到的是将hash值对数组长度取模运算。但是取模的运算消耗过大，实际是采用h &amp; (table.length - 1)来得到该对象的保存位，而HashMap底层数组长度一定是2的幂，故这个运算和取模h % length是等价的。 123static int indexfor(int h, int length) &#123; return h &amp; (length - 1);&#125; 当数组长度为2的幂，length – 1所得二进制数各位均为1，这样低位的hash不变，高位的则由hashCode优化处理（???），这使得不同key算得index相同的几率较小。 读取元素：首先计算hashCode，再通过hash方法得到索引，找到数组中对应位置的第一个元素，然后往后遍历链表用equals对比key。 Resize：当HashMap中的元素越来越多时，由于长度不变，hash冲突几率增大，这时就要考虑扩容了。在扩容时，原数组中的所有元素都必须计算其在新数组中的位置，并放到该处。默认扩容的阀值为数组大小的0.75（默认负载因子），达到这么多元素就扩容一倍。 FailFast：由于HashMap线程不安全，需要用modCount记录修改次数，若当前在使用迭代器时其他线程做了修改，就会抛出异常ConcurrentModificationExcetion. modCount声明为volatile，volatile用于声明简单类型变量，他们的操作为原子级别的。但是当这些简单变量的操作由该变量以前的值相关(n++, n = n*2)，则volatile不起作用。 HashSet的实现原理 是基于哈希表的Set接口的非同步实现，实际上由一个HashMap实例对象支持。 需要重写覆盖equals和hashCode方法，以保证存入对象的唯一性。 LinkedHashMap 是Map接口的哈希表和链接列表实现，有可预知的迭代顺序，但不保证映射顺序，不保证顺序持久不变。LinkedHashMap继承了HashMap，底层使用哈希表和双向链表来存储所有元素，原本的数组table也是继承了的。 Entry与HashMap有所不同，因为它需要同时记录before和next形成双向链表。 I/O流的概念及基本分类 流：直观地理解，读取数据时开启一个通向数据源的流，这个数据源可以是文件、内存、或网络连接；写入数据时则是开启一个通向目的地的流。 分类： -&gt; 根据数据方向分为InputStream/Reader和OutputStream/Writer; -&gt; 根据数据类型分为字节流InputStream/OutputStream和字符流Reader/Writer. 字节流：读取时读到一个字节就返回一个字节，可以处理所有数据类型如图片、音频，对文件本身直接操作而不会用到缓冲区的； 字符流：使用字节流读到一定字节（1byte-英文, 2byte-中文, 3byte-UTF8）时，先去查指定的编码表，然后将对应的字符返回。字符流只能处理字符数据，通过缓冲区操作文件。 使用字节流的优势：硬盘上所有文件都是以字节的形式存储、传输，而字符只会在内存中形成。当然，纯文本数据还是要优先使用字符流的。 常用流用法 InputStream类为所有字节输入流的父类，有三个基本read方法： -&gt; int read() 从流里读出一个字节，不推荐使用； -&gt; int read(byte[] b) 将数据读入一个字节数组中，返回所读的字节数； -&gt; int read(byte[] b, int off, int len) 定义了offset和len。 此外还有一些方法。int available()返回不受阻塞地从此输入流读取的字节数。 OutputStream类为所有字节输出流的父类，有三个基本write方法： -&gt; void write(int n) 将指定字节写入此输出流； -&gt; void write(byte[] b) 将b.length个字节从字节数组中写入此输出流； -&gt; void write(byte[] b, int off, int len) … 此外还有一些方法。void flush()刷新此输出流并强制写出所有缓冲的输出字节。 FileInputStream/ FileOutputStream（详情见后面） -&gt; FileInputStream fis = new FileInputStream(&quot;test.txt&quot;);文件必须存在且可读； -&gt; FileOutputStream fos = new FileOutputStream(&quot;test.txt&quot;);默认为覆盖模式。想改为追加写入，则在后面跟多一个参数true. InputStreamReader/OutputStreamWriter 桥梁流，不直接用于输入输出，只是将字节流转成字符流的桥转换器，可指定编解码方式。 BufferedReader/BufferedWriter 过滤流，需要用其他的节点流来做参数传入构造子。 PipedInputStream/PipedOutputStream 管道流 File类 Import java.io.* 导入库 创建文件： 123456File f = new File("D:\\hello.txt"); try &#123; f.createNewFile();&#125; catch (Exception e) &#123; e.rintStackTrace();&#125; File类静态常量File.separator和File.pathSeparator。这样就可以让代码跨平台而不必总是修改路径了：String filename = &quot;D:&quot;+File.separator+&quot;hello.txt&quot;; 删除文件：if (f.exist()) f.delete(); 创建文件夹：File f = new File(&quot;D:\\helloDir&quot;); f.mkdir(); 列出目录下全部文件：File f = new File(&quot;D:\\&quot;); String[] str = f.list(); 判断是否为目录：f.isDirectory(); 穷举目录下所有文件，包括子目录： 1234567891011121314public static void print(File f) &#123; if (f != null) &#123; if (f.isDirectory()) &#123; File[] fileArray = f.listFiles(); if (fileArray != null) &#123; for (int I = 0; I &lt; fileArray.length; i++) &#123; print(fileArray[i]); &#125; &#125; &#125; else &#123; System.out.println(f); &#125; &#125;&#125; 复制文件： 12345678InputStream input = new FileInputStream(file1);OutputStream output = new FileOutputStream(file2);if (input != null &amp;&amp; output != null) &#123; int temp = 0; while ((temp = input.read()) != (-1)) &#123; Output.write(temp); &#125;&#125; 字节流InputStream/OutputStream 写入字符串 123456File f = new File(Filename);OutputStream out = FileOutputStream(f);String str = "xxx";Byte[] b = str.getBytes();out.write(b); // (也可以用循环一个一个write(b[i])) out.close(); 向文件追加新内容 12OutputStream out = FileOutputStream(f, true);Out.write(b); out.close(); 读取文件内容 123456789File f = new File(fileName);InputStream in = new FileInputStream(f);Byte[] b = new byte[1024];（也可以byte[] b = new byte[(int)f.length]; 避免浪费）in.read(b);in.close();// 也可用in.read的返回值长度确定打印的长度，防止后面输出一大堆空格。// int len = in.read(b);// System.out.println(new String(b, 0, len)); 使用while读到文件末尾 123while((temp = in,read()) != -1) &#123; b[count++] = (byte)temp;&#125; 字符流Reader/Writer 写入数据 123File f = new File(fileName);Writer out = new FileWriter(f);out.write(str); out.close(); 追加写入Writer out = new FileWriter(f, true); 读取字符 12345Char[] ch = new char[100];Reader rdr = new FileReader(f);int count = rdr.read(ch);Rdr.close();System.out.println(new String(ch, 0, count)); 循环读取 1234int temp = 0;while((temp = rdr.read()) != -1) &#123; Ch[count++] = (char)temp;&#125; 字节/字符转换流OutputStreamWriter和InputStreamReaderOutputStreamWriter将输出的字节流转换成字符流；InputStreamReader将输入的字节流转换为字符流； 将字节输出流转换为字符输出流 123Writer out = new OutputStreamWriter(new FileOutputStream(file));out.write(str); out.close(); 将字节输入流转换为字符输入流 12Reader rdr = new InputStreamReader(new FileINputStream(file));Rdr.read(ch); 管道流PipedOutputStream/PipedInputStream 用于线程之间的通信 例如一个消息发送类、一个消息接受类：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Send implements Runnable &#123; private PipedOutputStream out = null; public Send() &#123; Out = new PipedOutputSream(); &#125; public PipedOutputStream getOut() &#123; return this.out; &#125; public void run() &#123;String message = "hey";try &#123; Out.write(message.getBytes());&#125; catch (Exception e) &#123; e.printStackTrace();&#125; &#125;&#125;class Receive implements Runnable &#123; private PipedInputStream input = null; public Receive() &#123; This.input = new PipedInputStream(); &#125; public PipedInputStream getInput() &#123; return this.input; &#125; public void run() &#123;Byte[] b = new byte[100];int len = 0;try &#123; Len = this.input.read(b);&#125; catch (Exception e) &#123; e.printStackTrace();&#125; try &#123; Input.close();&#125; catch (Exception e) &#123; e.printStackTrace();&#125; &#125;&#125;class hello &#123; public static void main(String[] args) throws IOException &#123;Send send = new Send ();Receive receive = new Receive();try &#123; Send.getOut().connect(receive.getInput());&#125; catch &#123; e.printStackTrace();&#125;New Thread(sent).start();New Thread(receive).start(); &#125;&#125; 打印流PrintStream 123PrintStream print = new PirntStream(new FileOutputStream(new File("D:" + File.separator + "hello.txt")));print.printf("%s: %d", name, age);print.close(); BufferedReader BufferedReaer只能接受字符流的缓冲区，因为每个中文需要占用两个字节，所以需要将System.in这个字节输入流变为字符输入流：BufferedReader buf = new BufferedReader(new InputStreamReader(System.in)); Scanner类 键盘数据输入最常用的方式：Scanner scnr = new Scanner(System.in);可指定读入的基本数据类型：int t = scnr.nextInt();另有scnr.nextFloat()之类的. Scanner可以接受任何输入流。例如从文件中读取：123456File file = new File("xxx.txt");Scanner scnr = null;try &#123; Scnr = new Scanner(file);&#125; catch ...String str = scnr.next(); System.out.println(str); 数据操作流DataOutputStream/DataInputStream 1234567891011File file = new File("D:" + File.separator + "xxx.txt");Char[] ch = &#123;"a", "b", "c"&#125;;DataOutputStream out = null;Out = new DataOutputStream(new FileOutputSream(file));for (char temp : ch) Out.writeChar(temp);Out.close(); // 写入abcDataInputStream input = new DataInputStream(new FileInputStream(file));while ((temp = input.readChar()) != "c") Ch[count++] = temp;System.out.println(ch); //读取"ab" 合并流SequenceInputStream 用于将两个流合并在一起。 1234567InputStream input1 = new FileInputStream(f1);InputStream input2 = new FileInputStream(f2);OutputStream output = new FileOutputSteram(f3);SequenceInputStream sis = new SequenceInputStream(input1, input2);while ((temp = sis.read()) != -1) Output.write(temp);Close() * 4. 文件压缩流类ZipOutputStream与压缩文件类ZipFile 1234567891011121314151617181920212223242526272829303132InputStream input = new FileInputStream(file);File zipFile = new File("D:\\xxx.zip");ZipOutputStream zipOut = new ZipOutputStream(new FileOutputStream(zipFile))// 解压一个：File file = new File("D:" + File.separator +"xxx.zip"); // 已存在的zipZipFile zipFile = new ZipFile(file);ZipEntry entry = zipFile.getEntry("xxx.txt"); // 从zip中取出一个txt// 解压内含多个时就需要用到ZipInputStream类：File file = new File("D: " + File.separator + "xxx.zip"); // 已存在的zipFile outFile = null;ZipFile zipFile = new ZipFile(file);ZipInputStream zipInput = new ZipInputStream(new FileInputStream(file));ZipEntry entry = null;InputStream input = null;OutputStream output = null;while ((entry = zipInput.getNextEntry()) != null) &#123; outFile = new File("D:" + File.separator + entry.getName()); if (!outFile.getParentFile().exists()) &#123; outFile.getParentFile().mkdir(); &#125; if (!outFile.exists()) &#123; outFile.createFile(); &#125; Input = zipFile.getInputStream(entry); Output = new FileOutputStream(outFile); while ((temp = input.read()) != -1) &#123; Output.write(temp); &#125; Close()xxxxx.&#125; 网络编程网络编程基础介绍 网络编程的目的是直接或间接地通过网络协议与其他计算机进行通讯。网络编程的两个主要问题，一是如何准确地定位网络上的一台或多台主机，二是找到主机后如何可靠高效地进行数据传输。TCP/IP协议就提供了解决方案，IP层负责网络主机的定位、数据传输的路由；TCP层提供了面向应用的可靠数据传输机制，TCP层是网络编程的主要对象。 网络编程模型：当前流行的是C/S结构，即通信双方一作为服务器等待客户提出请求并给予响应，客户端则在需要服务时向服务器提出申请。服务器持续运行，监听网络端口，一旦有客户请求，就会启动一个服务线程来响应客户，在这个过程中依然保持监听端口。 IP地址：IP网络中每台主机都必须有一个唯一的IP地址，因特网上的IP地址具有全球唯一性。IP是逻辑上的地址，32bit，4byte，点分十进制表示。 OSI(Open System Interconnection)开发系统互联参考模型将网络的不同功能划分成7层：物理层 – 数据链路层 – 网络层 – 传输层 – 会话层 – 表示层 – 应用层各层之间严格单向依赖，下层向上层提供服务。 OSI各层所用协议：-&gt; 应用层：远程登陆协议Telnet、文件传输协议FTP、超文本传输协议HTTP、域名服务DNS、简单邮件传输协议SMTP…-&gt; 传输层：传输控制协议TCP(Transmission Control Protocol，面向连接的可靠传输协议)、用户数据报协议UDP(User Datagram Protocol无连接的不可靠协议)。-&gt; 网络层：网际协议IP、Internet互联网控制报文协议ICMP、Internet组管理协议IGMP。-&gt; 物理层：直接传输bit。物理介质分为guided(twisted pair, coax, fiber(single mode/ multimode))和unguided(air).数据链路层 Node-to-node节点传输，主机、路由都为节点，数据以frame帧的形式在链路上传播，链路分为有线、无线、LAN. 提供服务：framing, error detection, error control, medium access control. Error detection：处理位错误、包错误-&gt; 位错误：parity checking(添个0/1是总1数为奇/偶)checksum(16bit从左到右依次求和、有进位加到个位)cyclic redundancy check(给定generator，源bit末尾补上gen.length – 1个0以后作竖式除法)。-&gt; 包错误：Stop and wait：死等ACK回复，直到timeout重发。原因：数据丢失、ACK丢失、ACK延迟。Go back N：将丢失帧及其之后帧一并重传，ACK意指xx号之前的帧已收到并传给上层、期待xx号帧。可加入滑动窗口，SWS定义了发送的未收到ACK帧缓冲范围、RWS = 1足以应付go back N.Selective repeat：引入NAK，意指xx号帧之前的帧已受到并传给上层、请重传第xx号帧。一旦发送方收到NAK，该丢失帧及其之后帧的timeout都加倍以满足重传。若单单是NAK丢失，不会有大碍，因为timeout机制还是能保证没有ACK的帧会重发一份。落在SW/RW以外的ACK/数据帧直接丢弃。Selective Acknowledge：??? PPP = point-to-point protocol最常用两种：ADSL(ppp over Ethernet) &amp; VPN(ppp tunnel protocol)PPP分为两步：LCP(link control protocol, 初始化、结束链接)NCP(network control protocol, 每个网络层协议都会有一个对应的控制协议) LAN = local area network局域网共享链路，广播形式传输；范围小，传输速率高。分为两个子层：-&gt; MAC(medium access control, 解决接入冲突，如Ethernet, Token Ring, Wifi)-&gt; LLC(logic link control, 向上层提供Link service) Error controlMAC层提供的服务。-&gt; Pure Aloha：一有数据立刻就发，不管数据多长不管信道是否空闲-&gt; Slotted Aloha：将时间分成一个个时间片，从时间片开头独占则可以发送，有冲突则都以概率p在之后发送-&gt; CSMA载波监听多路访问：发现信道空闲就发送，分为1监时（持续监听、空闲即发）、无监时（随机隔一阵才监听一次）、p监时（持续监听，空闲时以概率p发送，适用于slotted）。 ——————————–以上都无法解决冲突—————————–-&gt; CSMA/CD带冲突检测的载波监听多路访问：对数据进行分帧，然后1监时持续监听信道，持续96bit都空闲则立即发送，发送过程中均无冲突则ok，有冲突则停止并发送32bit的JAM信号，用二进制指数退避算法延时一段时间后重新开始1监时。二进制指数退避算法就是第一次冲突在0t、1t中选一个时长延时，第二次冲突则0、t、2t、3t中选…十次冲突往后就到2^10=1024 – 1中选。 Hub与Switch-&gt; Hub：无存储功能，直接泛洪给其余所有端口，半双工。-&gt; Switch：有逻辑，可以存储转发给对应MAC地址，全双工 网络层 Host-to-host 提供服务：routing, forwarding. Type：circuit switching(FDM, TDM), packet switching(datagram - IP, virtual circuit - ATM).-&gt; IP(connectionless, best effort).-&gt; ATM(connection-oriented, QoS). IP datagramIP包头20byte+由于以太网帧有长度限制（数据部分最多1500byte），故可能需要拆分IP包。IP包放入以太网帧的data部分，在协议类型处标明0x8000 IP协议，在MF标记、offset都做好相应记录。 IP地址分层的（而MAC地址是flat的）。主机部分不能全为1或全为0.-&gt; A类网：0.0.0.0 ~ 127.255.F.F [0 7网络 24主机 ]-&gt; B类网：128.0.0.0 ~ 191.F.F.F [10 14网络 16主机]-&gt; C类网：192.0.0.0 ~ 223.F.F.F [110 21网络 8主机] IP控制相关协议-&gt; ARP(address resolution protocol)：将IP这类协议地址转换成LAN中的local地址如MAC。ARP请求帧包含源IP、源MAC、目的IP，等待目的MAC回应。-&gt; DHCP：动态分配IP。-&gt; ICMP：显示监测信息，例如超时错误、无法访问目标主机。 路由协议RIP、OSPF-&gt; RIP(routing information protocol)：在自治域中每30s向邻居发送路由表，同时接受邻居发过来的路由表，对比更新为最短路。-&gt; OSPF(open shortest path first)：用链路状态让每个路由器都存储整个AS的拓扑和权值。 传输层 End-to-end. 原理：将进程绑定到指定的IP的指定端口号上，对于发往指定IP指定端口的数据就可以到达对应的进程了。 提供服务：可靠传输 + 流量控制。 UDP(user datagram protocol)：无连接，直接一次发送。 UDP header：8byte，记录了源端口、目的端口、头部和数据长度、校验和。发送时在data前加上Header封成socket，放入下层传输。每个数据报都在64kB以内，多了存不下。 TCP(transmission control protocol)：面向连接，需要建立/释放连接以及互动反馈。采用包交换，一个IP可以向多个端口发起连接，一个端口也可以建立多条连接。源IP、目的IP、源端口、目的端口四者只要一个不同，就认为是新的连接。 TCP header：20byte(+/-4)，记录了源端口、目的端口、数据包序号(保证顺序)、确认序号(指明ACK是谁的)、header长度、6个标志位、发送窗size、校验和etc。其中的标志位有-&gt; URG(紧急位，基本不用)、-&gt; ACK(数据段是否有ACK功能)、-&gt; PSH(催促接收端尽快上传，基本不用)、-&gt; RST(重置连接，如在出错时强制中断连接)、-&gt; SYN(建立连接时同步两端序列号)、-&gt; FIN(提醒对方我不会再发新的内容了，用于关闭连接)。 发送TCP包：需要将data与MSS, maximum segment size比较，若大了就需要拆分。 三次握手建立连接：目的是client和server相互确认身份+确认链路完整性（可达且有空闲端口）+ 协商序列号和发送窗口大小。(1) 客户发起请求：标志位SYN=1，指定seq = x说明客户端初始序列号为x，并告诉服务器自己的RWS窗口剩余大小。(2) 服务器响应请求：标志位ACK=1，ack字段为x+1表示序列号为x的已经成功收到，SYN=1表示同意跟你连接，再返回seq=y指出服务器的初始序列号，并告诉发送方自己的RWS窗口剩余大小。(3) 客户确认连接，服务器分配资源：标志位SYN=0，ACK=1，ack字段为y+1表示客户端已经收到了服务端的初始序列号，并继续告诉服务器自己的RWS窗口剩余大小。-&gt; 一次握手的坏处：client不知自己的请求是否得到了server的接受，无法保证有效连接。-&gt; 两次握手的坏处：server不知该请求是在信道里阻塞了很久才到达的还是别人恶意伪造占用server端口资源。 四次挥手释放连接：(1) 一方A发起释放请求：标志位FIN=1表示自己不会再发新的数据了，指定seq = x说明A当前序列号为x。(2) 另一方B收到FIN：标志位ACK=1，ack字段为x+1表示序列号为x的已经成功收到。B会尽快将自己的data处理好。(3) B回复FIN：B确认data已处置妥当，标志位FIN=1，指定seq=y表示B当前序列号为y。(4) A收到FIN：标志位ACK=1，ack字段为y+1。此时A会等多一阵子才真正释放连接，而B收到这个包可以立即释放。A还要等一阵子的原因是让ACK到达B，让本次连接的数据从因特网中彻底消失。 应用层 DNS：Domain Name System HTTP：HyperText Tranfer Protocol 基于URL的高层次Java网络编程 URL(unform resource locator)：一致资源定位器，表示因特网上某一资源的地址。 URL组成：protocol://resourceName，资源名应该是完整地址，包括主机名、端口号、文件名或文件内部的一个引用。 java.net中实现了类URL。URL编程是基于TCP的应用，要用到下层的socket接口。 创建URL：需要catch(MalformedURLException e) 1234567891011// public URL(string spec);URL urlBase = new URL("www.xxx.net");// public URL(URL context, String spec);URL index = new URL(urlBase, "index.html");// public URL(String protocol, String host, String file);URL fileOnHost = new URL("http", "www.xxx.net", "/pages/Gamelan.net.html");// public URL(String protocol, String host, int port, String file);URL fileOnPort = new URL("http", "www.xxx.net", 80, "/pages/Gamelan.net.html"); 解析URL：一个URL对象生成后，它的属性可以通过各种get方法获得，但这些属性都是不能改变的。getProtocol, getHost, getPort, getFile, getRef, getQuery… 从URL读取资源：使用URL对象的openStream方法得到InputStream类对象，便可以从这个连接中读取数据： 123456URL tirc = new URL("http://www.tirc1.cs.tsinghua.edu.cn/");BufferedReader in = new BufferedReader(new InpputStreamReader(tirc.openStream()));String inputLine;while ((inputLine = in.readLine()) != null) &#123; ...&#125; 向URL发送数据：使用java.net的类URLConnection 12345URL url = new URL("htps://www.javasoft.com/cgi-bin/backwards");URLConnection conn = url.openConnection();DataInputStream dis = new DataInputStream(conn.getInputStream());PrintStream ps = new PrintStream(conn.getInputStream());ps.println("写入服务器的内容"); 基于Socket的低层次Java网络编程 Socket：网络上两个程序通过一个双向的通信连接实现数据交换，这条双向链路的一端称为一个socket。Socket通常用来实现客户端和服务器的连接。 Socket工作步骤：创建socket -&gt; 打开连接到socket的输入输出流 -&gt; 按照协议对socket进行读写操作 -&gt; 关闭socket。 Java.net中的类Socket和ServerSocket(待…)分别用作客户端和服务器。123456789101112131415Socket socket = new Socket("127.0.0.1", 4700);BufferedReader sin = new BufferedReader(new InputStreamReader(System.in));PrintWriter os = new PrintWriter(socket.getOutputStream());BufferedReader is = new BufferedReader(new InputStreamReader(socket.getInputStream()));String readline = sin.readLine();while (!readline.equals("exit")) &#123; os.println(readline); os.flush(); readline = sin.readLine();&#125;ServerSocket sv = null;sv = new ServerSocket(4700);// 服务端待补充... 表示层 定义数据格式及加密。 会话层 定义如何开始、控制和结束一个会话。对多个双向消息的控制和管理，让表示层看到的数据是连续的。 设计模式设计模式六大原则 单一职责：每个类值负责一项职责，不要引入多于一个导致类变更的原因。只有逻辑足够简单，才可以在代码级别上违反单一职责的原则（引入新的逻辑，如if分支、for循环）；只有类的方法数量足够少，才能在方法级别上违反单一职责原则（加入与原方法并列的新方法）。这个并不是面向对象编程特有的，只要模块化设计都必须遵循单一职责原则。 里氏替换：所有引用基类的地方必须都能透明地使用其子类的对象，当类B继承类A时除添加新的方法完成新的功能之外，尽量不要重写覆盖（重载也不要）A的方法。这是为了限制面向对象编程时由于继承带来的耦合性，特别是运用多态比较频繁的时候，重写的方法出错几率更大。 依赖倒置：高层模块不应依赖低层模块，它们都应依赖更高层的抽象（接口），核心是面向接口编程。相对于细节的多变性，抽象的东西要稳定得多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构稳定得多。在java中，抽象指的就是接口或抽象类，细节就是具体的实现类，使用接口或抽象类的目的是指定好规范和契约，将展现细节的任务交给实现类去完成。所以底层模块尽量用抽象类或接口、变量的声明类型尽量是抽象类或接口、同时继承时遵循里氏替换原则。 接口隔离：一个类对另一个类的依赖应该建立在最小接口上。核心思想是建立单一的接口，尽量细化接口使每个接口方法尽量少。通过分散多个接口可以预防外来变更的扩散（所有实现接口的类都要实现全部接口中的方法）。例如interface Itf 有五个方法method1~5。class A中的三个方法depend1~3(Itf i)分别用到了Itf接口的前三个方法1~3，class B实现Itf接口并在使用时传入A的方法的参数列表。如此一来，B不得不实现I中的4、5方法，尽管他们压根不用（因为A不用）。正确的做法就是将I拆分成前三个和后两个，这样针对类A的三个方法就可以构造一个只实现Itf中1~3方法的类B了。 12345678910111213141516171819202122232425262728293031323334353637383940414243interface Itf &#123; public void method1(); public void method2(); public void method3(); public void method4(); public void method5();&#125;class A &#123; public void depend1(Itf i) &#123; i.method1(); &#125; public void depend2(Itf i) &#123; i.method2(); &#125; public void depend3(Itf i) &#123; i.method3(); &#125;&#125;class B implements Itf &#123; public void method1() &#123; System.out.println("B implements method1 in Itf"); &#125; public void method2() &#123; System.out.println("B implements method2 in Itf"); &#125; public void method3() &#123; System.out.println("B implements method3 in Itf"); &#125; // 由于实现了接口的非抽象类必须完全实现所有接口函数，所以即使A不会用method4和5也要实现一波，即使里面什么也不做 public void method4() &#123;&#125; public void method5() &#123;&#125;&#125;public class Client &#123; public static void main(String[] args) &#123; A a = new A(); a.depend1(new B()); a.depend2(new B()); a.depend3(new B()); &#125;&#125; 最少知道法则：一个对象应对其他对象保持最少的了解。软件编程的原则是低耦合、高内聚。对象应该只与直接的朋友通信，直接的朋友指的是成员变量、方法参数、方法返回值中的类，陌生的类不应以局部变量出现在类的内部。但是这意味着需要通过中介类来实现陌生类的通信，这可能会导致系统变得复杂。 开闭原则：一个软件实体如类、模块、函数应该对扩展开放、对修改关闭。当软件需要修改时，尽量通过扩展软件实体的行为来实现变化而不是修改已有的代码来实现变化。用抽象构建框架，用实现拓展细节。 Design Pattern revisit(18653 Software Architecture and Design)Creational Patterns 提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 factory: 创建对象时不会向client暴露创建的逻辑，通过一个共同的接口让client决定创建那种具体子类。 abstract factory: 用一个抽象工厂作为「其他工厂的工厂」，具体的工厂extends该超级工厂，再通过接口创建具体的类。 singleton: 通过一个类创建自己的对象，同时保证只有一个对象存在于系统中。 Builder: 产生一个复杂对象时通过多个更简单的对象一步步生成。 Prototype: 直接创建对象比较costly（如一顿复杂的数据库调用才能创建出来），在创建duplicate对象时可以通过一个原型接口创建该对象的clone返回。 Structural Patterns 关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。 Adapter: 使用一个类作为两个不兼容接口的桥梁，创建真正可以执行该操作的对象并调用对应的方法。 Bridge: 将抽象化与实现化解耦，提供二者之间桥接结构的借口，使实体类的功能独立于接口实现类。 Filter(Criteria): 使用不同的标准来过滤一组对象，通过逻辑运算（AND OR）以解耦的方式把它们连接起来，结合多个标准来获得单一标准。 Composite: 整体部分模式，把一组相似的对象当作单一的对象对待，想象一个树形结构来组合对象。 Decorator: 向一个现有对象添加新的功能，动态地给对象添加额外的职责同时不改变它的结构。 Facade: 隐藏系统的复杂性，只给client暴露一个访问的接口（不一定非得是interface，实体类也可），提供了简化的client方法和对系统类方法的调用。 Flyweight: 减少创建对象的数量，重用现有的同类对象，找不到再新建（类似cache）。 Proxy: 为其他对象提供一个代理来控制对某对象的访问（类似快捷方式）。 Behavioral Patterns 关注对象之间的通信。 Chain of responsibility: 为request创建了handler的链，如果当前对象不能处理该请求就通过next传递到下一个。 Command: 请求以命令的形式包裹在对象中，再将命令对象传给接受者进行相应的操作。 Interpreter: 实现一个表达式接口，解释特定的上下文如语言、表达式等。 Iterator: 迭代遍历。 Mediator: 提供一个中介类来处理不同类之间的通信，降低多个对象／类之间的通信复杂性。 Memento: 保存一个对象的中间状态，以便在适当的时候恢复对象。 Observer: 存在一对多的自动推送关系时使用。 State: 类的行为基于其状态而改变，需要创建不同状态的对象和context对象来随状态对象改变而改变行为，context作为参数传入各种State，由state对象改变context的状态并执行行为。 Strategy: 类的行为或算法可以在运行时改变，需要创建各种策略的对象和context对象来随策略对象改变而改变行为，策略的实现类作为参数传入context，由context执行行为。 Template: 一个抽象类作为模版，子类可以重写其中的方法，client通过模版提供的方法进行调用。 Visitor: 使用visitor类，改变元素类的执行算法。基础类对象接受visitor，同时将自身引用传给visitor供其visit。 数据库Catelog/database数据库 采用多数据库的方式来保存不同类别的数据。这样『多数据库』管理的模式可以便于对各个catelog进行个性化管理，同时也可避免表名命名冲突，且可指定各catelog的各用户接入许可使安全性更高。 Table表：将数据库内的数据分类管理，即将不同类型的资料放到不同的”区域”中，这些区域就是表。 Column列：又称field字段，给一个表内的物品规定好标签格式，用于统一地显示数据的特性。 DataType数据类型：对每一列填入数据给出规定，例如类型、字数等，可节约空间占用提高访问效率、确定对数据进行操作的正确处理（字符串的+与数值的+）。 Row/record记录：一行数据就代表了一个表中某个对象的资料。表其实就是行和列的二维表。 PrimaryKey主键：唯一标识一行记录的ID. Index索引：为某一列建立索引相当于自定义排序，这样之后搜索匹配时可以快速定位到第一个匹配项的位置、大大减少扫描量。当然，索引会占据一定的磁盘空间，且降低了数据插入和删除的速度（因为每次插入删除都必须更新索引），特别是当表拥有的索引很多时。 表关联：将表中某些field的信息替换成其他表的ID。当某些信息在表中重复多次形成冗余，会无谓地占据空间，且相同数据录入同样还要重复输入这些信息，在日后维护数据正确性时不得不把所有表中相关数据都更新一遍。若我们为这些数据新建一个表，则可以通过编号（主键）唯一标识一个对象，则对应字段都可以用编号的方式关联到这个专门新建的表了。通过表关联可以使数据不再孤立、表达复杂的数据关系。 SQL(structured query language) 高级非过程化语言，在高层数据结构上工作，具有不同底层结构的数据库系统可以使用相同的SQL语言作为数据输入和管理的接口。 table 创建数据表：可设置非空、默认值，指定主键/复合主键，定义外键。 12345678910CREATE TABLE tableName( fieldName1 type(maxLength) NOT NULL, fieldName2 type(maxLength) NOT NULL, fieldName3 type(maxLength) DEFAULT defaultValue, … PRIMARY KEY(fieldName1), // 放在字段定义之后，主键必须设置非空约束 // PRIMARY KEY(fieldName1, fieldName2), 联合主键，慎用 FOREIGN KEY(fieldName3) REFERENCES anotherTableName(fieldName)); 定义外键：外键是体现关系数据库中”关系”二字的关键，使用外键可以把互相独立的表关联起来，即在某字段引用其他表的主键作为值。 修改已有数据表 12ALTER TABLE tableName ADD newFieldName type(maxLength);ALTER TABLE tableName DROP oldFieldName; 删除数据表DROP TABLE tableName;注意若存在外键关联关系，被引用的数据表必须等到引用的表删除后才能删除，否则会破坏外联关系导致已有的表出问题。 Data manipulation 数据的检索/排序／整理ORDER BY语句必须放在SELECT完整语句末尾;当前面的规则得出字段值相等时，会根据后面的规则进一步排序。GROUPBY语句可以进行分组，将指定fieldName相等的条目划分成一组。 123456789101112131415161718192021222324-- 直接取出所有数据。SELECT * FROM tableName;-- 取给定列且若重复出现则只取一个SELECT DISTINCT colName, colName2 FROM tableName;-- 只取1/多个field字段下的所有数据。SELECT fieldname1, fieldname2 FROM tableName;-- 给列起别名。SELECT fieldName1 AS Name, fieldName2 AS Salary FROM tableName;-- 按条件过滤。SELECT * FROM tableName WHERE fieldName1 &lt; 2000 OR fieldName2 &gt; 20;-- 先按用户名升序，相同则按年龄降序SELECT * FROM tableName ORDER BY username ASC, age DESC; -- 根据column_name进行分组合并，通常用于统计特定id的sumSELECT column_name, aggregate_function(column_name)FROM table_nameWHERE column_name operator valueGROUP BY column_name; 插入数据 12INSERT INTO tableName (colName1, colName2, colName3) VALUES (value1, value2, value3); 以上的插入语句不一定要把所有字段都填写完整，只要不要求非NULL就可以留空。主键值必须唯一，当主键字段的值已经出现过，则插入会报异常。外键值必须已存在对应的表、且目标表中存在该外键值。 更新数据 1234567891011UPDATE table_nameSET column1 = value1, column2 = value2,...WHERE some_column = some_value; ``` 其中WHERE语句可以加入逻辑连接词如OR、NOT。 主键值必须唯一，当更新主键字段的值已经出现过，则更新会报异常。 外键值必须已存在对应的表、且目标表中存在该外键值。 * 删除数据 ```SQLDELETE FROM tableNameWHERE fieldAge &gt; 20; 删除表中的数据，完成后表为空。 数据汇总：提供了MAX, MIN, AVG, SUM, COUNT等函数。 1234567891011121314151617-- 求最大SELECT MAX(fieldName1) AS Max_Salary FROM tableNameWHERE fieldName2 &lt; 25;-- 求均值SELECT AVG(fieldName1) FROM tableNameWHERE fieldName2 &lt; 25;-- 求和SELECT SUM(fieldName1)FROM tableName;-- 这里的COUNT可以用*表示全部数据有多少条目，而传入某些字段则会忽略该字段为NULL的条目。SELECT COUNT(*), COUNT(fieldName2)FROM tableName; 通配符过滤LIKE：可以模糊检索字符串 12345-- 指定了该字段的值共五位，第一位任意SELECT * FROM tableName WHERE fieldName1 LIKE "_eery";-- "k%": 以k开头，长度任意的字符串。-- "%n%":含有n的字符串，长度不限，n的位置不限。-- "%n_":含有n的字符串，长度不限，n的位置一定在倒数第二位。 NULL的检索 12SELECT * FROM tableNameWHERE fieldName1 IS NOT NULL AND fieldName2 IS NULL; 反义运算符和一般编程不同，这个可以直接在&lt;、&gt;前加个!. 特别地，&lt;&gt;表示不等于。 多值检测为了简化OR，可以用IN语句。WHERE fieldname IN (a, b, c); SQL JOIN-&gt; INNER JOIN：如果表中有至少一个匹配，则返回行-&gt; LEFT JOIN：即使右表中没有匹配，也从左表返回所有的行-&gt; RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行-&gt; FULL JOIN：只要其中一个表中存在匹配，则返回行 Java 8 新特性Stream Stream API用于处理Collection中的object，提供可pipelined的方法（若干个intermediate方法和一个terminal方法）产生结果而不会改变原数据结构中的值。 Intermediate Operations map: 映射每个元素到对应的结果。 123// 获取对应的平方数List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);List&lt;Integer&gt; squaresList = numbers.stream().map(i -&gt; i * i).distinct().collect(Collectors.toList()); filter: 设定条件只保留满足条件的元素。 123// 获取空字符串的数量List&lt;String&gt;strings = Arrays.asList("abc", "", "bc", "efg", "abcd","", "jkl");int count = strings.stream().filter(string -&gt; string.isEmpty()).count(); sorted: 对流进行排序。 此外还有一些类似于SQL的操作如count, limit。 Terminal Operations collect: 将操作结果收集并返回，可与Collectors类结合使用。 123List&lt;String&gt;strings = Arrays.asList("abc", "", "bc", "efg", "abcd","", "jkl");List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());String mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(", ")); forEach: 遍历stream中的每个元素。 12Random random = new Random();random.ints().limit(10).forEach(System.out::println); // 这有一个Java8特性，将方法引用作为参数 reduce: 将stream元素聚拢成为一个结果。 1234// 求数组中偶数之和List number = Arrays.asList(2,3,4,5);int even = (int) number.stream().filter(x-&gt; ((int)x % 2 == 0)).reduce(0,(ans,i)-&gt; ((int)ans + (int)i));System.out.println(even);]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>interview</tag>
        <tag>os</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闲书摘录2017上]]></title>
    <url>%2F2017%2F01%2F08%2Freading_note2017%2F</url>
    <content type="text"><![CDATA[摘录各类书中片段，不代表博主观点。2017年上半年完结。《如彗星划过夜空》、《我也有一个梦想》、《总统是靠不住的》、《历史深处的忧虑》、《别对我撒谎》、《魔鬼经济学》、《单恋》、《你是在恋爱,还是在发神经》、《宿命》、《菊与刀》、《彷徨之刃》、《怪笑小说》。 2017.06.26 《如彗星划过夜空》近距离看美国之四。独立战争之后民主制度的尝试。国父华盛顿。严格保密费城制宪会议，虽说是怕泄露后各州难以达成妥协，但也可以理解成精英统治P民的一种形式？要共和不要民主，民主困惑，政治不正确。越战五角大楼文件的报道，司法部保密需求与新闻自由的较量。 在战争年代，华盛顿将军的高明之处，是他在打了几个败仗以后就明白，在北美这块远离英国的土地上，对于义军，定出的目标不可能是“消灭英军或把他们赶出去”，而是要用自己的军事存在，向英王表明北美独立的决心。北美义军的关键是“存在”，只要持久存在，目的就达到了。事实上，北美最终获得独立，正是由于这支军队存在的坚韧。可是，在华盛顿将军心中，“枪杆子”只是带来了追求自由的一个可能。惟有民众的授权，才是政府权力的合法来源。 世界在向前发展。人们已经不可能仅仅依靠分散的、自然的状态，应付一个需要良好政府组织的现代社会。假如说，民主不是一个简单的理想，而是一种帮助人们取得自由的制度，那么这个制度必须经得起复杂的、发展着的现实的考验。 他们并不想以革命的方式，也就是剧烈变革的方式去过度推进。美国革命的结果，仅仅是英王离开，各州原有的法律制度一点没有破坏。而这四年的“散”，却给各州带来了制度实践的空间，民主制度先在地方城镇和州一级开始尝试、实施，给国家层面的民主制度的建立，垫了底。 政治人物持有怎样的主观愿望，是善是恶，只能根据他的自述，很难客观评判。做了最糟糕的事情，也可以辩解说是好心办了坏事。人们能够评判的，只是客观结果。政治人物对权力的过分崇拜，不论是出于“抱负”还是“野心”，都是危险的。美国的国父们看上去缺乏自信，却正是当时政治家很难得的谦卑。 他赞同苏格兰思想家大卫·休谟的看法，人在孤处时比在公共生活中更诚实，“良心，这惟一残留的纽带，在个人身上实为不足。在稠人广众之中，人们对良心实无期待”，大家一起做事，如浑水摸鱼，对个人行为的制约力反而消失了，结成群的人会互相为不良行为提供虚假理由。这就是一些平时看看还蛮善良的人，一进入群体就表现得十分邪恶的原因。 人实在是一种很难说服的动物，人不仅会趋向于自以为是，而且常有虚荣、固执的一面。一旦争执发生，不要说认为自己没错，就是明明知道自己是错的，也会因为放不下面子，就非要坚持自己错误的主张。 政治制度，其实是需要一个相应的社会文明程度去配合的。在民主制度自然生成的国家，是文明的土壤长出了这棵制度之树，而不是相反。也就是说，没有这样的土壤，压根儿长不出这棵树来。 “过激民主”就是民众掌握了超越其水平的决策权。这才是美国制宪会议在反对的事情。在他们眼中，这种“民主”几乎就等同于无政府、无秩序、无法律，“过激民主”就可能是暴民做主。在他们看来，“过激民主”与“暴民政治”，其实只有一步之遥。更何况，希腊城邦只是小国寡民，将要建立的美国，可是一个大国。怎么敢随意“过激”，掉以轻心。 民主制度是需要有一个相应的社会文明程度去配合的。这个“社会文明程度”，既是指处于社会上层的政治家、也是指身在底层的民众。事实上，人类社会从专制走向民主的过程，是从文明积累最厚实的那个部分开始推动的。底层民众是社会的最弱势，是最值得同情和关怀的群体。可是，通常人们闭起眼睛不看的是由于文明积累层的薄弱，底层同时也是社会最危险的一个部分。因此，看上去是以民众为主题的民主，在它的源头发展的时候，实际上却是一个自上而下的过程。 从法国大革命对平民杀贵族的支持，到一代代的民粹倾向，直至现代美国走到极端的“政治正确”，都是源于同样的出发点。在原罪负担之下，承担原罪感的人群往往是不自信的，他们需要他人对自己做出道德上的肯定。结果就是以过激的平民认同和平民倾向，来达到心理和道德需求上的平衡。 民主意识的一个重要来源是人性的觉醒，从而自然地引发出对底层悲惨状况的同情和不平，进而为他们争取权益。正由于这种同情大多发自有比较优越的社会地位、文明程度较高的阶层，或者说发自知识阶层，因此他们的民主意识从起源来说，都是带着原罪负担的。他们非常容易进入的一个误区，就是会不由自主地要美化底层，以平衡自己的原罪意识。他们会在表达对底层苦难同情的时候，在赞美底层的时候，表现得煽情和夸张，以支撑自己的道德感。 知识阶层的所谓道德勇气，一部分应该是表现在对强权的批判上，但更为困难更难做到的，是表现在他不迎合、不取悦于民众上。前者是很容易理解也相对更容易做到的。可是，只有非常少的人，能够有智慧有勇气做到，对强权和民众，都保持应有的独立和批判。这和他是否同情弱者，是否保护弱势人群，其实是两回事。 基于当时的民众水平，康涅狄格州的罗杰·谢尔曼曾经提出，人民和政府之间的联系越少越好，人民总是想知道得多一点，结果知道了反而会迷失。来自马萨诸塞州的杰瑞一针见血指出，“人民非常容易成为被假爱国者欺骗的愚民”。还有人说，根据经验，以往的最大毛病都是因为“过多的”民主。他们几乎都同意，如果说贵族专制是一种恶政，那么，无限制的民主也一样糟糕，也会是恶政。 今天民主进程已经大大深入，知识界对专制的批判已经非常彻底，而对民众的弱点可能导致的暴力和非理性，却常常还是闭着眼睛绕开，或是为其寻找理由。在这个问题上的反省，越来越艰难。因为民主大潮的副产品，就是知识界日益把批判专制、强权，看做是为众人称道的独立精神，而没有勇气悖“民众大潮”而行，持独立思想言论于民众和知识界同行。他们不再有费城制宪者们自然的道德自信。 美国人的政治生活逐渐养成了这样的习惯：他们认识到，社会各个利益集团往往是天然地相互冲突的，所以要让大家在国会都有自己的代表，把各自的要求讲出来，公开地争辩、讨论，最后，各方退让、妥协、达成协议——因为整个社会的成功，还是依赖于各个不同利益集团的合作的。 英、美的制度设置虽然有矛盾的地方，却一样运作有效。你也许会对这种情形感到奇怪，其实，一个很重要的原因还是那句话：制度的设置只是一半，而更重要的是由实践完成的另一半。他们相对在实践中更能自觉维护、完善这个制度，而不是拼命钻它的漏洞。 汉密尔顿把债券看做是政府与个人之间的契约，政府不如约偿债，契约权和财产权就得不到保障。同时，他把收购债券的所谓“投机者”和出售债券者之间的关系，也看做是合法的契约关系。债券在流通，只要是合法的交易，其中一些人的吃亏和得利是客观存在，只要是自愿、合法，就必须尊重契约为先，而必须忽略它的深究一层的道德探讨。股市也一样，只要是公平的，各人也必须承担风险，不能因赔本的个人陷于悲惨境地，就对制度作道德探讨，甚至否定制度。 汉密尔顿的天才，在于他看到了这个趋势，顺应了这样的趋势。可是，对立的观点的存在，使得许多在快速发展中被忽略的问题，永远有人关注和提出来，这其中包括政府的权限、政府的腐败、弱势群体的权利和社会公平等等。因此在建国初期，相互反对着的两种观念，都有它存在的意义，这不是简单的对错关系。 华盛顿在组阁的时候，他的选择标准是好人内阁，而不是和他的执政理念最一致的内阁。他考虑了道德和能力的标准，却没有考虑顾及到对政策看法的一致性。 事实上，选民们都是在投票给与自己的利益和理念接近的政党。他们投票内含的意义，是在投票给执政纲领和理念，而不是投给一个“个人”。 政治家们不再是排在一条队伍里，不再能对他们按照一个标准，判断其高下。不是执政总统所属的党就是“好的”，在野的、对立的党们就是“不好的”。它们只是有不同的倾向，侧重不同阶层的利益，代表不同的理念和偏重不同的政策。 平均财产是一切革命动荡的诉求，是发动群众的最便利口号，却也最容易造成灾难。私人财产权是人类社会最重要的制度之一。在费城制宪会议上，代表们对保障财产权几乎没有一点异议。对当时的美国政治精英来说，财产权即使不能说是神圣的，也至少是毫无疑义受法律保护的。没有一个负责任的人会认可破坏财产权。但是，人有贫富差距，也是一个不争的事实。巨大贫富差距之下，何来人人生而平等？如果没有发展机会的平等，追求幸福权利的平等，来平衡事实上的财产贫富差距，美国人认为他们的自由理想就是不完整的。 民主深化时代的美国和以往不同的是，政治家面对大众说话，你永远无法判断，他是说的真正的心里话，还是在追随大众，讨好大众，或者引导大众。politician，既可以译成政治家，也可以译成政客。政治家和政客合为一体，正是从这个时候开始的。古典的政治家，stateman，渐渐地让位于两面一体的政治家和政客，politician，是民主时代的必然趋势。林肯是美国历史上第一个典型的politician。 在民主政治中，政治家是凭嗅觉来判断气候的变化，来决定自己的公开政治表态的。反奴的气候不到，时机还不成熟，明确的激进反奴立场和表态，对林肯就可能是一种政治自杀。政治家不仅要有自己的良知，有出自这种良知的政治理念，他还必须等待时机，等待民众能够听得进他的话，愿意跟着他走。所以，有时候他不得不保持沉默，甚至言不由衷。这时候政治家的表现就像一个政客。 美国新闻自由的理念，并不是“无边的自由”。它是有约束的。这种约束，首先来自新闻工作者的职业道德的自律，他们必须自我判定，自己的行为在新闻自由的范畴，还是在伤害国家、等同于伤害民众的刑事犯罪的范畴之内。美国法律为保障新闻自由，规定不能对媒体预检，但是，也不意味着，对于真正伤害国家和民众的违法行为，就不予以惩罚。只是，它是在事后惩罚。而判断的标准，并不是政府的行政分支来制定，也就是说，并不是行政分支在所有不愿意让民众知道的文件上，只要盖上“保密”、“绝密”的印章，就成为法律的依据了，就可以把民众的知情权关在门外、就可以以此惩罚公布它的人了。而是需要独立的司法分支，来对文件本身的内容进行判断。假如这些“保密”、“绝密”的图章，只是行政分支在滥用职权，那么，媒体公布这些信息是合法的。 此案涉及新闻自由的分量，已经远远超出了对五角大楼秘密文件内容的重视。此案成为全国最大的新闻，不再是因为它涉及美国的对越政策，而是因为它涉及报纸的新闻自由。他惟一的希望就是此案会激发公众对文件本身的好奇心，当禁制令解除的时候，更多的民众会去读这些文件。 他在意见书里列举了总统和行政分支的无可匹敌的强大权力，然后指出，惟一真正能够对这样强大的行政权力有所约束的是，经过启蒙的、获得充分信息的公民大众，只有获得充分信息的持批评态度的大众意见，能够保护民主政府的价值体系。所以，警觉的、无所不晓的、自由的新闻界本身，对实现宪法第一修正案的目的是最为重要的。他说，“没有一个自由的、获得了充分信息的新闻界，就不可能有脱离蒙昧的人民。” 自由的生命，这是平等的起源。因此，社会管理概念不是从上层权力切入，而是从人的自然权利切入。这样的平等概念，也隐含着一个简单道理：人也都是有弱点的，不论是英雄还是智者，无人幸免。在社会管理中，他们注重制度对人的弱点制约，在他们眼中，政治上层不仅不是天使集中的地方，而且可能是人性弱点的集合、并且被威权催大的地方。所以政府是首先需要制约的地方。 2017.05.22 《我也有一个梦想》近距离看美国之三。南北战争、美国版『一国两制』。废奴旗手本身也是矛盾的，没法以身作则。阿姆斯达看似是反奴隶者胜利，但并未触动宪法根基。反种族隔离，从教育到日常，导火索事件的偶然与必然。非暴力的前提是熟悉游戏规则、知道后果不会产生不可挽回的影响，黑人民权组织领袖的政治考量。《平权法案》不平权，而是作为一种赎罪和补偿。种族歧视成了挡箭牌，而不正视自身的问题。故事很精彩，很长见识，但崇尚自由的精神反映到外交上还是令人感到困惑。 美国警察的面貌是很不相同的。除去个人品质素质的因素，这种面貌的不同往往是有区域性的。我曾经告诉过你，美国绝大多数地方是安闲和宁静的。不要说乡村，那些中小城市的警察，常常都会给你一个『雷峰叔叔』的感觉。在这些地方，实际上警察分为两部分。正儿八经的正宗警察并不多，更多的是地方治安警察。他们也穿警服，在英语里用的是完全不同的词。这些地方治安警察都是当地的老百姓们投票选出来的，更是特别注重和社区居民搞好关系。 我确实喜欢这个说法：皓月当空，万籁俱寂之时，一个坐着的人猿混混噩噩的脑瓜里，突然冒出这么一个百思不得其解的问题“我和其它的动物究竟有什么区别呢？”这时候，他就是『人』了。 奴隶交易和奴隶劳动都产生人类最难以抗拒的诱惑，这就是利益。然而，这块土地的早期经历所形成的奴隶制现实，显然是一个不可忽略的『原始推动』。这也就是为什么北美英属殖民地黑人奴隶泛滥，而英国本土却从来没有卷进去的原因之一。英国本土就没有这样的历史条件形成的借口，所以即使同样被利益驱动想蓄奴的人，也被阻挡在在道德门槛的这一头，难以当众迈出腿去。 北美当然也不乏大量被贫困逼来的『经济移民』，可是，来到这里的『政治移民』 的比例，高得异乎寻常。他们是在英国及欧洲的诸多次宗教迫害和政治动荡中离开故土，来寻找一片自由的土地的。他们中的许多人，在英国的处境远比跑到这里来当难民要好，对于这些人，寻找一块新大陆更多的是一种精神需求。他们需要一块『上帝承诺过的土地』，在那里可以有他们自由信仰的权利。其中『五月花号』上的那一船移民，就非常典型，也是这些『政治移民』中最早的一批。北方，正是大量这样的『政治移民』的集聚地。他们受教育的程度相对更高一些，他们流亡的原因往往是『宗教迫害』为主的政治性原因，所以，他们更习惯于在世俗诱惑的面前，作出理性的思考。他们甚至在尚未完全解决温饱问题的时候，就迫不及待地建立了哈佛大学，并且把哈佛大学所建立的地方叫做『剑桥』。 宗教思考本来就应该是非功利的思考。他们把自己与世俗世界拉开距离之后，探索人与神的深远的哲学问题。这样，任何可能找到的世俗利益的借口，都必须被拒留在宗教的门外。由于北美的生活环境，使得各种宗教的思考内容，也很早就包含了奴隶问题和不同种族如何相处这样的问题。 作为北美思想主导的北方出现的这些早期质疑，形式和深度都并不相同。但是，在人性的普遍原则下，拂去外表，我们发现它们有着一个共同的坚实内核，那就是，新移民纵有万般理由，他们难道就因此真的具有剥夺他人自由的权利吗？这发生在三百多年前的北美开拓初期，他们第一次试图离开自己的困境，离开自己相对优越的地位，站在那些他们还完全无法理解的黑人的立场上，质问这个人类行为的合理性。 并不是你我原来所想象的，奴隶制从兴起到终结的历史，就完全是白人奴隶主和黑人奴隶之间压迫和反抗的对抗史。基于我前面提到过的原因，当时黑人还不可能成为这个舞台上的主角。实际上，从一开始，这就是人类良知和愚恶的角逐。你已经看到，在这一段历史中，这场角逐主要发生在北美殖民地的白人内部。这时，我们发现，原来人类的人性反省是进步的一个最重要的动力。 在当时，黑人作为个人和小的群体，有可能出现偶而的反抗，但是作为整体，不论其人数如何迅速增长，他们在北美注定会在非常长的一个历史阶段里，是几乎没有自己声音的一个极弱势群体。这不仅因为他们被胁迫，同时也因为，黑人还处于他们偶然进入的这个陌生文化系统的蒙昧状态。 美国的诞生，实质上是这块土地被耕耘了一百五十年之后，逐步成熟，开始清理的一个结果。生活在这里的一些人，不再仅仅陷于谋生的劳顿，他们开始问自己，当初他们为什么千辛万苦来到这里？究竟要的是什么？ 其实，这个问题不仅是他们的问题，也是今天的一代代的新移民的问题。在今天的美国，你可以遇到生活状况还相对较差，却心境平和的移民；你也会遇到境遇相对更好，却怨声载道的移民。其原因就在于，他们当初来到这块土地，所寻求的东西就是不同的。 『歧视』二字，在英语中的词义是『区别对待』，『种族歧视』就是在种族问题上的区别对待。它是由差异产生的。事实上，一开始，当人类发生种族相遇的时候，这是非常自然，非常容易发生的一种情况。人类只有在理性的思考下，经历长期的共存，才有可能真正克服这种心理障碍，对『种族差异』以平常心待之。 贵族派头的英国绅士风格也影响了他们对于奴隶制的态度。一方面，他们对于主人和家奴所形成的严格等级制是十分习惯的，甚至是颇为欣赏的。而另一方面，他们良好的教育又迫使他们不可能躲避对于『人性』的思索。因此，有关奴隶制的讨论在这里从未间断。 当1776年夏天，终于下决心宣布独立，杰弗逊起草的《独立宣言》也交付讨论。这时，南方极端的两个殖民地终于意识到，这份宣言的原则，将是这个即将诞生的新国家的根本原则，如果他们再一次服从这个基本潮流，他们所受到的损失，不再是得不到新的奴隶劳力的补充。就连他们现在经济所依靠的奴隶制，也会象在北方正在发生的那样，迅速崩溃。 在美国独立时的十三个州里，大部分州的奴隶制的废除，就是白人，富人，甚至是奴隶主们，经过理性反省，决心通过他们手中的立法权，从法律上解决黑人奴隶问题。也就是亲手通过立法程序，将自己的一份重要财产化为乌有。他们中间哪怕是最激烈地反对奴隶制的代表，都是如此。 这不是我们习惯的少数职业革命家和热血青年，抛家弃产投向革命的故事。这是作为代表整个社会利益集团的立法机构，用立法的手段，仅仅为一个人性反省和道德理由而放弃自身利益的一个行为。 不论是国际间的协议，还是一个国家自己制定的法律，都大致不出乎两种状况。 一种法律来源，是这个国家，地区或者群体，对于一个命题的思考和反省的结果。他们因此制定一个规则，愿意共同遵守。对违规者按法规进行认真惩处。这样的法律逻辑性强，执行的过程也比较清楚。诚然，这样的法律仍然会带有历史的局限性，因为人类在某一个阶段的认识，总是有局限的。但是，它是认识一步走一步，也许前进的脚步缓慢，但却是扎实的。这种法律，我常常用大白话叫它是『真诚的法律』。另一种法律来源，是对外部压力妥协的结果。一些地区，它自身并没有产生与这条法律相适应的认识基础，但是出于种种压力，不得不诞生这样一个法律。在这种情况下，整个系统从一开始就有着“违法”的强烈冲动。这样的法律，它的目标可以定得非常高，看上去可以比那些『真诚的法律』更漂亮。可是一触及现实就会完全面目全非。我把它叫做『虚假的法律』。 哪怕是一个在压力下产生的『虚假法律』，相对于根本『没有法律』来说，也是一个巨大的进步。因为，毕竟可能产生这样的机会，据法力争一个实质性的，哪怕是微小的胜利。 现在看来，这和法西斯的理论差不多，几乎不值一驳。然而，在一百五十年前，这样的『理论』可以振振有辞地提出来，就是因为当时在整个世界范围内，大多数人对于种族差异的认知，都还有着极大的局限性。多元文化的概念还根本没有产生。“南蛮北夷”，“吃人生番”的讲法，在到处都很流行。你一定还记得我讲过的康有为遇到黑人的反应吧？对于种族差异的偏激反应，那个时候在多数地区都出现过，只是冲突的机会大小，程度的深浅不同而已。 对于各州来说，法律我自己定，日子我们自己合计着过。可是一旦出了事儿，跟外头的国家有了什么麻烦，联邦政府你得给我顶着。这就是当时典型的美国联邦局面。令人难以想象的是，维持这样一个局面，居然仅仅就是为了坚持一个与个人自由同步的分治的理想。 他们的着眼点，显然不仅是在这三个女孩和『阿姆斯达』的黑人身上，他们更希望通过这个挑战，整个颠覆在美国南方还存在的一个非人道制度的法律基础。在联邦巡回法庭的汤普生法官的同意下，他们就可以得到一个重要的法庭辩论机会，他们就可以在一个活生生的案例上，让法庭和所有的人注意到他们的论点：人类行为受到的最终的审判，是依据人性与非人性的界限来判断的。一切法律都在『自然法』之下，如果一条法律是非人道的，那么，它终有一天将被废除。 通过这样一个案子，充分讨论了法律与自然法的关系，再一次申扬了『平等自由』的建国原则，最终黑人又取得了胜诉。这样的一个逻辑线索，使人们产生一种强烈的错觉，似乎他们已经在解决『黑奴物化』和黑人争取自由等问题上，有了一个实质性的进展。于是，当他们在此后再遇到合法奴隶的同类案件的时候，在同样法律之下产生的不同审判结果，就会使人们产生倒退和无可容忍的感觉。这个时候，本来其意义就是一份契约的法律，就会由于失去民意基础而走向立法的变革。这个时候，司法挑战的目标，就算是真正达到了。历史也就在这样立法变革的基础上，向前走了一步。 解放奴隶是一回事，可是，一想到那些承继着完全不同的文化，从里到外都和自己有着巨大差异，也不知道到底『野蛮』到什么程度的黑人，一想到要由自己给出判定，给予他们在这个国家完全平等的政治权利，也『一人一票』，甚至在黑人占多数的地方，可能出现黑人当选掌权管白人，大法官们就会觉得，这里肯定是有什么地方不对了。 这些陪审员是普通民众，这就是民众在开始作时代转变的一个信号，因为民意是美国所有的州立法的唯一依据。 这是当时分歧矛盾如此之大的美国各州，他们之间的一个重要共同点。因为所有的州在一开始，就都建立在一个民主制度的基础上。他们的不同，就是各州的多数民众，对于人性这个基本问题的认知程度上，是有相当大的差异的。 直到南北战争，黑人的力量依然没有成长起来，他们还是只有少数的偶发的小规模反抗，根本无法与当时南北两大实体的对峙同日而语。而这个对峙的双方，都是白人。 南方不想在这场僵持中争取占上风了。既然僵持已久还是没有出路，而且按照建国几十年的趋势，只见自行废奴的州越来越多，废奴势力越来越大，林肯的当选，更是印证了美国的这个历史潮流。论理的话，又不占理。干脆，不就是说我们不符合美国的建国理念吗？那我们不做美国人了还不成吗？我们退！ 这是一方想从这个对峙中撤离，而另一方却一把揪住了它的后领，一定要把它拖回来，这才打起来的。 美国从一开始，它的建国理念就是维护草民们的『个人自由』。它的出发点不是『上面』的管理方便，而是『下面』的自由保障。这样自下而上的一个观念的逆向行程，就造成了几乎是从个人开始的，一级级向上的『自治』和『联合』。这种国家概念在当时可以说是完全超越了那个时代的。它的出现，并不是源于一个高明的理论，而是出于一个向往平等自由的人性本能。 南方从未担心过北方会非法地以战争解放奴隶，这不是他们要求分离的原因。他们所要达到的状态，是在奴隶制问题上再也没有合法的司法逼近，再也没有道德上的压力，彻底地『我行我素』。 北方决心攻打南方的态度，也是促使罗伯特·李下决心离开联邦军队的重要原因之一。因为，对当时许多弗吉尼亚精英来说，仅仅因为南方的分离行为，北方就要以武力相威胁，这对于美国建立联邦的精神来说，无论如何是既没有法律基础，也没有道德基础的。 对于弗吉尼亚来说，他们不赞成南方以离开美国的方式解决矛盾，可是并不意味他们认为，一个州就没有离开联邦的合法权利。如果北方动武，就意味着北方偏离了美国的立国精神，他们将立即站到南方一边，以表明他们对此的抗议，因为他们确信，林肯并没有这样的合法权利。 最容易被历史的烟尘所掩没的，就是以弗吉尼亚和南军总司令罗伯特·李为代表的温和南方。他们的本意决不是要离开美国，也不赞同分离。但是，他们认为美国这个联邦的建立原则，就是保障人民的自由，一个地区的人民有权利决定自己的命运。他们认为，州与联邦的关系以及分治的原则，是美国建国原则最重要的组成部分之一。他们更反对联邦以武力胁迫的方式，强行维持联邦整体。他们实际上是一个第三力量。 因为自由是符合最基本人性的状态，不论作为个人还是一个地区，人们的本性在寻求一个自由的状态，以及在这个状态下的互利共存。联邦显然不是依靠爱国主义口号加上枪炮来维系的。这一点，林肯总统是逐步醒悟的，醒悟在怵目惊心的战场上。 林肯为自己找到一个突破口，在南北战争进行到一半的时候，他为战争的目标作了一个主题切换，把联邦对这场战争的诉求从防止联邦的分裂转换为废除奴隶制度解放黑奴。这就是你印象中的南北战争是一场解放奴隶的战争的来由。 正如林肯总统所预见的，随着历史的进步，也随着人们对于超越种族属性的普遍人性的认识越来越清楚，当年『解放奴隶，为自由而战』的道德诉求的份量，也就越来越重。任何一个政治诉求，哪怕有天大的理由，也会在这样的人道诉求面前黯然失色。也正如林肯总统所预见的，在以『平等自由』的人道原则建立起来的美国，只有在『解放奴隶，为自由而战』的人道目标之下，人们才可能在长久的岁月里，认可如此众多的年轻生命的奉献。因此，在美国，人们也普遍接受了林肯总统在他的第二次就职演说中，对于南北战争的解释。而且，就连林肯自己都承认过的武力解放奴隶在这个国家的非法性，都被北方民众有意无意地忽略了。南方在战后的继续辩解，也显得十分苍白。 由于美国的制度，对于一场战争的回顾，发掘和表达，你不可能是由一个人或是一些人定下什么调子，然后照样本宣传。 在北方，人们逐步通过辩论，唤起大多数人的人性觉醒，最后白人自己立法，放弃这样一个对他们应该说是『有利可图』的制度。在这个过程中，一部分人因此放弃或失去了一份对于他们来说是『传统的财产』。从立法通过起，所有的人遵从这个大多数人的决定。 这样一个过程，不仅是加强了民众对于契约社会正常运作方式的认同，更重要的是，这样循序渐进的一个立法过程，也是人们对于一个不人道的制度反省和认识的过程。当这个过程完成，瓜熟蒂落的时候，所得到的成果是有它坚实的社会基础的。 所谓的民主社会，并不是一个完美社会的意思，它只是一个由大多数人在决定风格的一个社会。这些人的认识水平就决定了这个社会的面貌。不论奴隶制是多么不人道，在这里，这就是这个社会的绝大多数人的认识水平。 战争结束以后，没有出现对失败一方的任何惩罚行为。即使是所谓强硬派，没有镇压和清算『叛军』和『叛国贼』，更不要说因此产生的大规模错杀了。 原来有关奴隶及种族问题的人性和道德的劝说，都在南方一片焦黑的家园和死去的无数年轻人面前，无法开口。北方可以高举神圣的『为黑人的自由而战』的旗帜去牺牲，南方却无法接受这样的事实，就是北方人为了给黑人自由，却杀死无数无辜的南方白人青年。战争一起，人道的逻辑就混乱了，双方原来的对话基础完全消失。南方原来在这个问题上的持不同观点的人，也变得一边倒了。从某种意义上来说，战后的南方在理性上呈现了一个巨大的倒退。 『种族文化大熔炉』之类的说法听上去是简单的，甚至给予远距离观望的人一种审美上的幻觉。然而，生活在现实中的『大熔炉』里，却有一个怎么活法的问题。美国人是经过漫长岁月的种族冲突和文化碰撞，才艰难地走到拥有今天这样的进步和认识的。在北方，尽管有着反奴隶制的人道认识和传统，但是，这并不是说，在奴隶制消失之后，人们就能够顺利地面对种族融合的生活，因为这是另一个社会课题。文化差异依然存在，宗教差异依然存在，利益冲突也依然存在。在不同的历史时期，这种差异所形成的社会焦灼，冲突和不安定，会以各种形式表达出来。更何况，这里的人们习惯于自由表达，因此，矛盾也就会很容易地就浮到面层，并且在民众中扩展开来。 北方已经是一个多种族，多宗教，多文化的融合社会，以白人为主的文化，开始受到多种文化的挑战，在工业开始发展的『转型期』的社会，各色人等都有可能在一个平等自由的环境中，以各种方式一试身手，少数民族及新移民的犯罪率也与日具升。这些都会引起原来作为这个国家的主体文化的困惑，更引起处于社会底层的低教育的白人出于本能直觉的不满。你知道历史上美国的KKK都是一些什么样的人参加的吗？都是一些最典型的辛苦劳动的工人和农民。 如果说，这个国家的基本原则是符合人性的，社会的思想主流是在推动这个原则的实现的，思想是不受到禁锢的。那么，即使这个社会还存在一个没有受到公平待遇的群落，那么，他们自身对于自由的追求和主流社会对于公平的呼吁，迟早会汇聚在一起，汇成一股冲毁整个旧堤坝的力量。 在美国的历史深处，这个文化深藏着的是对政府的不信任，尤其是对联邦政府的不信任，其实质是对集权的恐惧，以及对思想控制的恐惧。因此，克林顿总统对于全国统考的提议是从数学语文，这样的基本技能教育作为他预定的突破点的。但是，美国人至今不能接受。其根子在于，美国人不愿意他们最初源于自然法的教育理念被突破。统考显然能够提高教育水平，使国家强大。可是，统考必然导致统一教材，就防不住哪一天政府会向孩子灌输『统一思想』。美国人是自由为先的，他们宁可不那么强大，但是必须有自由。 我们可以开始更清楚地看到，为什么林肯在南北战争后期最关注的，不是以强权统治南方，而是以宽恕『叛乱』一方的南方首领，来换取他们带领整体南方回到美国制度中来。林肯整个思路的意义，正在逐渐显露出来。在作为一个整体的南方，认同这个国家的理念和制度之后，不论南方有怎样的类似KKK的民众，在南北双方对话的时候，在不同的观念讨论的时候，就有了共同的依据和游戏规则。 马丁·路德·金的信念是和这个国家的主流思潮一致的。那就是坚决地合法地争取自己应有的宪法权利，同时作为被侮辱和被损害的一方，以宽容的宗教精神作为自己的精神支撑，以此呼吁社会良心的醒悟和人道支持。他意识到这个制度的可操作性，他寻求的这个国家的制度所能够给予的支撑。这一切，都使得吼叫着的KKK们，在对比之下都显得智力低能。 在南北战争之后，南北双方产生了最长时间的心理阻隔。这是北方民间最没有冲动要干预南方事务的时期。就象你跑到别人家里，想帮助那里寒冷的人们，为他们点一把取暖的火，结果却烧掉了整个房子。下一次你再想做同样的事情，就会犹犹豫豫地不敢再划着那根火柴了。 在极端南方州，黑人的民权运动与当地由白人选出的南方州地方政府行政分支是对立的。但是，南方的黑人可以说始终受到北方民众和美国联邦行政分支的支持。只是，这个国家是分权分治的，在正常的情况下，联邦只能在非常有限的权限之下，给地方的民权运动提供支持。 『民主』是大多数人的意愿，它并不保证少数人的『自由』。所以民主在历史上常常是一个危险的东西。它与不民主的区别，只是由多数人掌局还是由少数人掌局，甚至一个人掌局的区别。相对后者来说，它当然是一个进步，可是，它并不一定是全体民众的自由的保障。假如没有对于人性的醒悟和孜孜不息的对于人道的追求，民主的结果完全可能演变为对于少数人的暴政。美国南方的历史，就向人们作了一个清晰的示范。 在一定的程度上，社会的安定与秩序和个人的平等与自由是互为代价的。要说安定和秩序，南方种族隔离制度下的城镇堪称安定的典范。而取消种族隔离以后的北方大城市，种族差别和种族矛盾不会一夜之间消失，安定和秩序确实受到很大影响。 假如犯罪行为发生了，假如有人被伤害甚至让人给杀了的话，联邦调查局有权来侦查犯罪活动；但是，这是一个调查机构，在犯罪行为没有发生的时候，联邦调查局也无能为力来进行跟踪保护。 假如在一个完全不讲游戏规则的体制下，假如领导『非暴力』运动的领导人，已经明知他领导的『非暴力』运动必然导致对方完全血腥的暴力，在这种情况下，假如他仍然听任事态的发展，甚至推动事态的发展，在可以避免暴力发生的时候不作任何努力，那么，即使『暴力』的使用是对手一方，这样的『非暴力』领袖的作为仍然是可疑的。一个真正的『非暴力』的，以公正和人道为口号的领袖人物，应该以一切手段避免无辜生命的不必要牺牲。 民主制度所推崇和认可的多数人的统治，假如没有人性的反省和追求，假如人道主义得不到高扬，假如不在追求自己的自由同时，也尊重他人的自由，那么，民主大树上所生长的，往往只能是『多数人的暴政』这样的畸形恶果。 一个国家的立国理念，是在呼吁人道，还是在『以革命的名义』和『公众正义的名义』呼吁仇恨，它的人民将走过的路径是不相同的。 在美国，法律制度的逐步完善才是真正巩固的历史进步，民众的人性反省和觉悟，才是这种进步的基础。 2017.05.06 《总统是靠不住的》近距离看美国之二。总统也是人，人都是靠不住的，必须限制和规范人的不可靠行为。尼克松水门这一段很精彩，行政分支对司法和立法分支的首次强力挑战。两党的正面竞选，然而去年的大选看到川希互怼，只能呵呵，世道变啦。克林顿各种门事件（拉链门还没发生之前的各种门）。由自由派和保守派（民主党/共和党）谈到弱党性重观念、堕胎问题、移民问题、拥枪问题。最后又提到了辛普森案子的民事审判，这与上一本书的刑事审判有很大不同。美国和中国的政治思维真的差别太大，互不理解再正常不过了。 在“克林顿政府”作出一个什么外交承诺，或者是作出什么温和外交表态，强调两国的“求同”，尽可能去“存异”，或者说尽量去试图忽略这个“异”之后，往往，属于“美国政府”另一个部分的国会就会通过一项完全不同的决议。在这样的决议中，凸现的常常是总统试图暂时忽略掩盖的“两国之异”。这样，同一个“政府”就几乎是在同时表达不同的信息，这种公然地不顾及自己对外形象的行为， 令人十分不解，尤其令我们这样最重视“脸面”的东方人百思而不得其解。至于对方国家，在短短的时间内，接到“克林顿政府”所发出的这样前后完全不一致的信息，只可能产生一种被欺骗和被愚弄的感觉。于是，抗议和外交上的僵局随之而来。不仅如此，甚至还会激起对方国家的民愤，激起他们的强烈的反美情绪。 与总统相比，属于美国的立法分支的国会， 似乎就更具有美国的主人的味道了。国会的议员们都是从各州直接选出来的“民意代表”。他们管立法，也就是说，大原则是他们给定的，只不过让总统这个“办公室主任”领着他的那套行政班子去执行。对外打交道，当然也是总统领着这班人去干。一旦干得国会不满意了，他们往往当下就不给总统一个好脸色。这种情况，总是由国会通过一项什么决议，表达他们对总统某个做法的愤怒。这时候，总统和国会就表现得完全南辕北辙。这就是我前面所提到的许多外交纠纷的起因。 以前我们常常听到人们把权力结构比作一张网。在这个国家里，从整个权力结构来说，也好象是结成了一张结实的网。但是，这似乎是另外一种性质的网。因为这张网上的各个环节，不仅没有一致地勾结起来，所谓“官官相护”，如渔网般去网罗共同利益，反而不仅互相牵扯，而且都是向着不同的方向牵扯。最后，如一张蛛网一样，势均力敌而达到平衡，各个环节无一漏网地全被扯住，很难有什么特殊举动。谁也不可能就此挣脱出一只手来，居高临下地一手遮天大捞一把，总统当然也不例外。 在实现一场社会革命时，由于它的过程十分漫长而且跌宕起伏，充满艰险充满牺牲。一场革命往往需要数代人的前仆后继。人们经历了无数次的失败后几乎已经近于绝望，每一次几近绝望又强化了一次新的渴求。因此，在许多革命中，在这样的轮番刺激之后，革命不知从什么时候起，就悄悄地从一种实现目标的方式手段，在人们心中变成了目标本身。人们就象痴迷地坐在剧场里看“玩偶之家”一样，别无他求，只求“出走”。 大家此后对于袁世凯“短命皇帝”的嘲讽，我常常怀疑只是一种自我安慰。我可从来不敢低估皇帝的生命力，更不敢低估中国人对于皇上的接受能力，而且，总会有一帮人孜孜不倦地告诉老百姓，这可是一个难得的好皇上。 美国人选总统，并不是在选一个完人，而是在选一个理念。也就是说，每个总统候选人对于美国和这世界给出一种解释，给出一个方向，也给出走向这个方向的一些具体路径。与此同时，总统候选人的个人行为必须基本符合这样的理念。否则，他也就无法说服老百姓，他确实会带领大家向这样一个方向去走。这也就是美国总统通常在竞选时，都标榜自己有一个完美家庭的缘故。这并不意味着大家在选举完人，而是意味着家庭价值至今还是美国人所重视的理念的一部分。 在美国的制度运作中，最起码的一条就是，每个人在执行公务时，都必须以自己的行为对法律负责。出了事儿的话，任何一个人都必须使陪审团相信，他在执行命令时是确信该项命令不违法的，否则，执行者照样有自己的一份法律责任，该坐牢还是得坐牢。在这条规则之下，美国的高层领导就很难在一项违法行为中，任意推动自己的下属。 除了少数政治活动家，个人对于一个政党如果产生认同的话，他基本上只有观点认同，而几乎没有什么组织认同。 不论尼克松犯了多少错误，在最后一刻，他表现出他依然是美国的文化背景中产生的一个民选领导人。他公开向美国全体人民宣告，他愿意认同宪法，服从法律，服从人民。而且，正是由于前面所发生的一切，以及他完全了解自己即将面对的处境和结果，他的服从才具有更深远的历史意义。 在美国很容易做到拥有一个面积较大的私人庄园的事实，以及美国人普遍的迷恋大自然，“忘情山水”的性情，这些看来与政治离题万里的自然和人文环境，都使得政治家更容易还原为本来意义上的常人，而不是异化成一离开政治官位，就惶惶然如丧家之犬的政治动物。而一个稳定的政治制度，都必须具备这种把政治家还原为常人的能力。 权力是诱人的。权力会诱使一些人逾规使用权力，也诱使他们以权力获取更大的权力。而在一个扩展权力欲望的上层集团面前，却时时站着一群象征美国人民的普通陪审员。 美国是一个依靠武力打下江山的新国家，可是，在最初的一刻，他们就理解，这个国家是决不能用武力来管理的，因为这个国家是美国人民的。战争结束了，枪必须交还给人民。我有时候感到吃惊的是，他们，包括华盛顿在内，在这个问题上所表现出来的一致性。不论是出于智慧，还是出于理性，他们对于美国人民的个人自由的尊重远远地超越了对于一个英雄的尊重。 第一个总统诞生之前，他们考虑的首要问题，不是寻找一个伟人，试图赋予他足够的强权，以便控制住美国的局面。相反的，他们考虑如何推选一个称职的管理者，同时限制他的权力，使得总统和政府都无法干涉人民的生活，使得自由自在的美国人依然自由如故。因此，美国和所有的国家一样不乏伟人，但是这里的伟人没有一个与强权有关。也是由于在这个概念之下，当这个总统上任的时候，在美国，没有一个人，包括总统本人，会试图去强调这是一个高瞻远瞩，英明决断的伟人。美国的民众也习惯于对总统没有这样的要求。总统和他的同僚们，至多想证明的是，他们会比别人犯更少的错误，更忠于职守。至于美国民众，他们指望的是推举一个人出来管理公众事务，从没想过要弄一个人出来“镇住”大家。如果他们发现总统有这个倾向的话，他们反而会感到自由受到威胁，会请他下台。这已经成为美国总统与人民之间非常自然的默契了。 这样的制度设计，也许扼杀了一个高瞻远瞩的政治伟人的宏大抱负，也许，也使得美国人民失去了一些“起飞”的历史捷径。但是，他们愿意支付这些代价的原因，是他们不愿意冒险失去他们掌握自己命运的权利。他们依然回到一个最初的忧虑，他们担心政府和公仆的异化，他们担心失去他们的基本权利，那就是，两百年前托玛斯·杰弗逊在“独立宣言”中写到的“生命权，自由权和追求幸福的权利”。 对于任何一个理念，不论是推出这个理念的一方，还是持谨慎态度，甚至持反对态度的一方，他们的争执必须是理念的争执，而不是打着某种旗号的党派之争或政治利益之争。 美国人从来认为，在战争中当军官和士兵们已经尽力而为，并且陷入绝境，那么继续进行抵抗，只是无端地伤害士兵的生命，是不可取的。因此，在这种情况下，投降是正确的选择。没有人认为这样的投降和成为战俘，是一件羞耻的事情。当一些美国人成为战俘之后，所有的人都会为他的生命和处境担忧，当战俘回到祖国和家乡，绝不会有灰溜溜的感觉，他毫无疑问会受到英雄式的欢迎，就和得胜回朝的将军一样。这些现象都是源于美国人对于尊重生命的基本看法。 这种教育和风气超越了人类保护自然是为了保护自己这样功利的宣教。那种宣教似乎使人觉得人类是超越自然的一种特殊力量，为了自己可以“征服自然”，也同样是为了自己才需要“保护自然”。但是，美国对学生环境意识的培养方式是动之于情，使他们对动物和自然界产生很深的感情，使他们增强“人只是自然的一部分”这样的概念。 我的许多自由派的美国朋友，也赞同保守派的许多具体观点。例如一些和过去的平静岁月紧紧相连的道德观念。例如，要维护家庭，反对吸毒，要增强责任感，等等。他们无法接受的，是保守派确认只有一种价值观。在他们的价值观内，就宣称“对就是对的”，出了他们的价值观，就判定“错的就是错的”。不论你所坚持的这种价值观是多么美好，当你要求这个世界只局限于一种价值观的时候，当你的价值观不仅仅表现在严以律己，还发展成苛以待人的时候。这种价值观就可能是禁锢思想的，也可能是危险的。因为它很容易走向极端。 人类的历史就是一部逐渐醒悟，并且逐渐从各种各样的狭窄走向宽容的历史。只是有的地区醒悟得早一些，有的地区醒悟得晚一些罢了。应该说，美国也不例外。只是，宽容是要支付代价的。它的代价就是把价值评判交给每一个个人。它的限度是不得伤害他人。这样，人们有了无穷尽的价值选择，也开始有了痛苦。但是，这种痛苦是在本质上有别于一个“纯净”而狭窄的社会，强加给某一个社会群体的痛苦的。 政教分离的更进一步的意义，就是政治和意识形态的彻底脱离。政府的功能是受人民的委托管理公众事务，而没有任何权力干预或者指导人民的意识形态人类毕竟有许多本原的东西是如金砂一般，在时代变化的水流冲刷下，会依然留在河床的底部。因此，人类在快速发展的过程中受到巨大的冲击，重要的是维持一个反思的功能，而不是在过去的时代抽象出一个“绝对的真理”，更不是荒谬地相信，迫使大家遵从这个“绝对真理”，“过去的美好”就能够在“现在” 被复制。因此，保守派的积极意义应该是从他们的角度和人们一起进行反思。 刑事审判寻求的是“正义”，寻找的是“罪犯”，它的起诉性质是“公诉”，定罪的结果，是剥夺被判有罪者的自由乃至生命。 美国的民事诉讼寻求的唯一目标就是对于受害者或者其家属的“经济赔偿”，它和“寻求正义”的目标有着本质上的不同 于是，这两个貌似截然相反的判决，就合理地联系在一起，合法共存了。它的结论就是，根据对所有证据的衡量，辛普森杀人的可能性是很大的，但是，至今还没有确切无疑的，“超越合理怀疑的证据”，证明百分之一百，肯定就是辛普森杀的人。 归根结底，对于这两种诉讼，一切在设计上的不同，都是源于诉讼当事人的不同。对于美国人来说，人是平等的，因此，个人对个人的诉讼，公正就是意味着一个天平式的证据衡量。而政府对个人决不是平等的，必须严格对证据提出要求，以限制政府利用权势对个人权利的侵犯。 从这些问题中，你仍然可以看到一个美国式的思路，权势是靠不住的，警察是靠不住的，联邦调查局是靠不住的，司法部的检察官是靠不住的，他们的总管美国总统和美国政府都是靠不住的。他们都需要有力量与之平衡，他们都需要制度予以制约。 2017.04.30 《历史深处的忧虑》近距离看美国之一，豆瓣评分高达9.0。本书主要介绍的是美国种族和政治问题，话题其实有一点敏感，之后还有个世纪审判答案详细介绍了美国法庭、律师等，检辩双方交锋后辛普森的无罪释放，大开眼界。我已经把中学学的历史忘得差不多了，看了之后好歹捡回了点芝麻。文章一直将政府描述成弱势的一方，人民是很当家做主的，可以强势维护自己的权利，真的挺难以想象的。btw，Kindle的标注功能不会提醒说您已经摘录超过限制，不科学啊，这篇就只能手打了一波。。。 占美国人口约百分之二十的黑人，通常被认为是相对比较贫穷的，整体文化水平比较低的，甚至有许多人口比例远小于他们的少数民族都看不起他们。但是实际上，他们的爵士乐、摇滚乐以及他们的舞蹈、体育才能，长久以来深刻地影响了整个美国文化，其意义远远超过了文艺、娱乐的范围。只有到了这里，你才会体会到，这些音乐和舞蹈有多么巨大的力量，它几乎完全改变了整个美国的精神面貌。没有非洲文化，就没有今天的美国文化。在今天，已经没有一个美国人能够不受非洲文化的影响。这应该说是美国黑人对于美国文化的整体贡献。移民在各个方面的贡献可以说是美国强大和继续保持强大的必要前提。 美国的建国者在『独立宣言』中，很有意思地否定了他们自己在打下江山之后必定要坐江山的合理性。他们似乎没有看出『打江山』和『坐江山』之间有什么逻辑上的必然联系。 如何制造一个强大的国家机器而人民的自由又不会被它一口吃掉？有一个思路是非常确定的，他们认为，所谓人民的自由不是什么抽象的东西，它就是一个具体的一个一个『个人』的自由，而对于这种自由最大的威胁，就是一个有组织、有财力的、有执法权的巨大力量。因此，如果能限制联邦政府的权力，如果能在联邦政府的巨大威胁之下立法保护每一个具体的美国人的个人自由，那么抽象的『人民自由』就已经实现了。 他们认为，这些自由是基本人权，即这是一个人与生俱来天赋权利。如言论自由，只要是一个人，就有表达自己思想的权利，这跟发表言论的这个人是好人还是恶棍没有关系，这和表达出来的东西是真理还是谬误也毫不相干。哪怕他的思想是彻头彻尾的谬误，哪怕假设有一种方法可以鉴定出他的思想不论过去、现在、将来都是绝对的谬误，他作为一个人也还是有权利说出他的想法。说出来，是合法的。 你也许会问：有些人比如3k党，他们一旦掌权了就会扼杀别人的言论自由，对于这样的人也要给他们言论自由吗？我想说，如果你因为害怕一个不自由的时代，因此就不给他们言论自由的话，那么这个不自由的时代已经开始了。是你自己给它开了个头。 美国人民认为，一个有着极大权力的联邦政府再加上一个强有力的警察机构协助的话，距离控制人民就只有一步之遥了。但是自由和安全、自由和代价，这是一个没有终极的选择。即使在美国，自由也在不断让步。尽管美国人对有可能产生一个沙俄式的秘密警察机构怀有极大恐惧，但是在犯罪的攻击下，国会在1907年还是同意成立一个针对国内犯罪问题的调查局。现在看来，当时国会的顾虑并不是毫无道理的，美国老百姓始终对联邦调查局的忧虑也不是过虑。因为美国建国者在200年前就知道，国家机器是有它的运转机制的，一旦你把它建立起来，就由不得你了。 发生任何一件侵犯公民权利的事件，美国人的态度就是，它如果可以发生在一个美国公民身上，那么它就有机会发生在我们自己身上。所以在美国，对于这一类问题，会有很多人挺身而出。尽管他们和这个公民素不相识，甚至他们并不喜欢这个人。 真正能够对新闻自由构成威胁，真正有可能迫使新闻自由让步的，就是国家利益。在某种意义上，新闻自由和国家利益是互为代价的。美国人始终站在两难之间，安全与自由。 大致来说，美国人的生活是很好的，并且自由自在。他们有相当大比例的人，在关心着各种只有衣食无忧、思想无拘无束的人才会去关心的问题。他们认为，这个社会从根本上的运作正常，才是他们继续这样自由自在生活下去的保障，而新闻监督是整个游戏规则在操作过程中最强有力的约束力量。如果没有这样的约束，一个聚集了大量财富的美国政府，会迅速腐败下去，一个拥有了强大权势的美国政府，回很容易地制造一些借口，轻易地拿走老百姓那点自由。这是200多年来他们真正害怕的东西。 美国人经常说的一句话是：改主意了。你想想看，在一个信息流量那么大的社会，每天人们都要接触那么多新的老的主张和观点，当然经常有人改主意才是正常的。 美国在其特殊的移民背景造成的复杂社会现状下，让它的人民享有这样的自由，这等于把这个国家变成一个风险巨大的世界自由实验室，走进去做一番观察，确实很长见识。但是如果只从一个角度去欣赏它的成功，或者只从另一个角度去嘲笑它的失败，都意义不大。 二战前德国人民也是合法拥有武器的。但是希特勒上台之后，首先高枪支登记，然后设法逐步搞没收枪支。接着，犹太人面对武装的党卫队员，就只有束手待毙的份了。他依据自己在美国的生活经验，坚信时区自卫武器是犹太民族的悲剧原因之一。我们在他家里看到过好几种大大小小的枪，他对我们说：“我也希望永远不要去用这些枪。但是你应该知道，枪不是一种工具，枪是一种权利。”我们也是到了美国以后才注意到，宪法第二修正案之中关于枪的行文很有讲究。他并不是说宪法给了人民拥有武器的权利，而是说，人民拥有和携带武器的权利不可侵犯。这两种讲法是不同的。也就是说，美国的建国者们认为，这种权利，不是任何人给予人民的一种恩赐，而是天赋人权。宪法所做的，只是规定了任何人都无权对这种权利进行侵犯而已。 美国南方和北方的面貌有很大区别，即使在今天，你都可以找到一些非常保守的南方小城镇，更不用说三十年以前了。那些『新潮』和『前卫』的民权运动者们，他们的言行和这些他们想要帮助的人格格不入，前者往往只注意到了自己『助人为乐』的一番好意，而根本没有想过，他们所代表的文化，是多么难以被对方的文化所接收，甚至在一定的情况下，会引起对方多大的反感和憎恶。对于后者来说，他们只是跑来毁坏这里传统的道德、信念以及安宁生活的家伙。 美国政府对于处理一个个人的时候，它必须非常非常小心，这是因为，第一，政府无法隐瞒任何事情。第二，除了差错之后，哪怕十年二十年，总有一定的民权机构，会在人力物力各方面，支持一个哪怕是身无分文的普通公民和政府打官司，不获胜诉绝不会罢休。整个社会也会因此产生极大的关注和压力。因此，公民权利的保障，不是仅仅依靠权利法案的条文，它必须依靠健全独立的司法制度、健康的社会机制、良好觉悟的社会和民众团体。而且，这个社会必须普遍有起码的正义感和公民良知。 我问迈克世纪审判里辛普森可能脱罪吗？他说，也许。这个『也许』，在英语里是『有百分之五十可能性』的意思。 我逐步理解了美国人对于这一类问题的原则，他们一般来说，对刑事案件的审判从来不持有完全『不冤枉一个好人，不放过一个坏人』的乐观态度。他们相信会发生一些情况使大家都难以判别，在这种情况下，我惊讶地发现，他们的原则很简单，就是『宁可放过一千，不可错杀一个』！ 律师到底应该是怎样的一个社会角色呢？我想，律师只是类似于一个咨询加上服务的机构，他只是向客户提供有关法律方面的知识、信息和服务。他和顾客之间只是一个平等的交易过程，顾客付费，律师提供服务，任何一方不满意的话，都可以解除契约。由于律师咨询内容比较特殊，使这一行业比其他技术咨询行业增添了更多的感情色彩和社会内容，但是实际上，把过多的社会责任压在这个角色身上，不仅是不公正的，而且还有可能使这个职业产生畸变。所以说，直接地寻求和追求社会正义，本来就不是一个律师的职责。律师的职责就是，不论他的顾客是什么人，在收取顾客费用的同时，就提供尽善尽美的法律服务，使他的顾客能够最大限度地利用法律保护自己的公民权利。当这个社会上的每一个人，在必要的时候，都能够通过这样的法律服务充分享有了公民权利，真正的社会正义就已经得到实现了。 法庭上『罪名不成立』的解读，是『证据不足，不能定罪』，而不是『此人清白无辜』。因此，它首先寻求的是『公正的审判』。在审理的过程中，检方的『寻找罪犯』、『寻求正义』是不可以放到台面上来的，不能造成任何一方以道义上的强势压过另一方。只要双方在法律的规范下，通过公平抗衡，得出了判决，那么这个制度就是认为这个社会的『正义和公道』得到了伸张。 一个国家的法律是针对它的整体人民的，只有当它对所有的人是公正的时候任何一个『个人』才有可能在任何情况下都收到法律的保护，从而拥有安全感。相反，如果一个社会纵容对一部分大家认为是『坏人』的人草率处罚，表面看起来有可能维护了『好人』的利益，但事实上，在这种情况下，已经隐含了对每一个人的公民权利的威胁。在一定气候下，无视公民权，践踏公民权的细菌，会以人们医疗不到的速度突然迅速生长，危机每一个人，不论好人坏人。 最近，美国最高法院裁定，这种根据种族而给予优惠，几乎总是与宪法精神不符的。但是，这是美国的一个历史包袱，最高法院也不是要求停止这个做法，而是要求执行时不要失之太宽。从这个裁定和简单的逻辑思考中，我们都可以知道，『平权法案』这样的法案，只能是一个历史文件，它的寿终正寝是一件早晚的事情。当历史条件逐步改善之后，每一个移民，每一个少数民族，在这里都必须依靠自己的能力和努力去得到收获。『平权法案』给了所有的少数民族一个调整和提升的机会，抓住这样一个机会是一件明智的事情，否则机会就会过去。 奴隶制是一个社会制度的罪恶，而不是种族的罪恶，只是在美国，在一个历史阶段，它恰与种族相连。当时，奴隶主基本都是白人，奴隶基本都是黑人。但在今天，把这种制度的罪恶过度与种族相连，并不是合理的事情，哪怕是在有这种历史负担的美国。 在美国，一开始如果有一个人想我自我介绍说他是艺术家或者音乐家的话，我总是肃然起敬。后来明白，这个称号仅仅意味着他很穷。在纽约大家都说，如果天上掉下了一个东西砸了谁的脑袋，这个人八成是个艺术家。 美国人特别注重个人意愿、个人生活和个人幸福，因此个人奋斗也就随之而天经地义，因为没有后者就没有前者。繁反之，没有前者也就没有了后者的动力。同时，整个社会，从法律到人们的习惯，都高度尊重个人生命、个人幸福、个人意愿和个人意志，都把个人意志的自由和个人的奋斗看作是高于一切的。这和我们中国人历来把社会利益置于个人利益之上，认为个别人可以为社会而牺牲，个人在伦理上也应该为社会牺牲，有着逻辑上的不同。我们是把社会繁荣置于个人牺牲、天下为公的前提下的。美国人却是把社会的繁荣置于个人自由和个人奋斗的基础上的。他们觉得，如果没有个人意志的自由和个人生活的幸福，谁来奋斗？若无大多数人的奋斗，何来的社会繁荣？ 美国人说是一起吃饭，就是指一起趁这个时间聊聊天的意思，只不过是聊天的地点选在饭馆，与中国人概念中的『请吃一顿』有很大区别。 看人们怎么花钱，以及社会怎么宣扬花钱，可以看出这个社会的风气。美国社会当然是形形色色，见怪不怪。好莱坞的明星们富有而炫耀，他们的职业决定了炫耀是一种策略。真正富有的人却并不炫耀，因为他们知道炫耀在社会上并不光彩，他们犯不着惹人非议。大多数人并不富有，但『衣食足，知荣辱』是普遍的。 2017.04.14 《别对我撒谎》三个澳洲家庭的婚姻危机小说，英文名为The Husband’s Secret，大概是想讨论家庭成员间保有秘密是否理所应当。很奇怪，看的时候很受触动，但看完了反而不知道写什么了。尾记有一个类似于lalaland结尾的flashback，可惜没如果。不过所谓的坦诚相待感觉并不实际，很难做到。婚姻到后期是不是真的变成了一把枷锁，如果没有骨肉作为纽带，有多少人会选择分开？ 她的社交技巧简直完美无瑕。对苔丝而言，这就像观赏提琴表演，眼看着提琴手们拉得那么漂亮，却不知道他们是如何做到的。 你出生时我曾感谢上苍，感恩于自己没生下双胞胎。我想看到你按照自己的意愿过上你想过的生活，用不着和别人攀比竞争。 只有电影中男女青年的调情才是甜蜜美好的，现实生活中只能让观看者不胜折磨。 这是一个循规蹈矩、温文尔雅的丈夫和父亲存在的小缺陷：他的顽固专断在很多时候已让人感到不快，特别是心情本就不佳的时候。每当二人产生争执，鲍·约翰的固执总让塞西莉亚沮丧不已。除此之外，他不修边幅，还总弄丢自己的财物。这些问题看似无伤大雅，再普通不过，然而如今这些缺点一旦属于杀人犯就会大为不同。 “苔丝有些害羞。”她母亲总爱掩着嘴巴小声对朋友们说，“恐怕是从她父亲那儿遗传来的。”苔丝能听出母亲略带羞辱的语气，因此下意识地将害羞定义为错误的品行。事实上你“应该”多参加派对。你“应该”享受被人们簇拥的感觉。 难怪苔丝一直因自己的羞涩感到羞愧难当，好像这是一种无论如何都要隐瞒的身体疾病。 一直以来，瑞秋总假装自己不让罗兰帮忙是因为她是个完美的婆婆。然而事实上，当你拒绝一个女人的帮助，这实际上是在将她拒之门外，拒绝将她看做家人，像是在说：“我没那么喜欢你，不愿让你踏进我的厨房。”这所谓的完美隐藏着彼此的疏离及不认同。 一直以来我都将自己看做你的伴娘，好像我根本不够资格拥有真正的人生。然而随着体重的回落，我发现开始有男人偷瞄我。作为女性，我明白自己不该喜欢这种感觉，然而客观来说，当你奢望过的事情真的变成现实时，它的出现就成了……可卡因。我喜欢这种感觉，它让我充满力量，像电影中的超级英雄们第一次发现自己的超能力一样。于是我开始想，想我是否也能让威尔和其他男人一样注意到我。然后……” 人人都知道第二份爱的情感更为强烈。这根本算不上一场公平的较量。这就是人们婚姻瓦解的原因。这就是人们为何将自己的婚姻看得那么重要，重要到在自己心中建起一道壁垒，阻隔内心真实的想法和情感。你不会让自己的眼神到处乱飘，也不会同异性喝第二杯酒，还时刻计较着自己的语言是否过于轻浮。你绝不会迈出那一步。 年轻时和人谈到“陷入爱里面”，人们总会严肃地看待，把它当做一件值得载入个人历史的大事。然而它事实上是什么？化学反应？荷尔蒙？一个唬人的小把戏？苔丝也可以爱上康纳。这很简单。陷入爱里面算不上什么难事，人人都有爱的本事，难的是如何将爱持续下去。 万一威尔和费莉希蒂才是天定的一对怎么办？万一她和康纳才是彼此的缘分呢？或许这类问题永远不会有答案。或许这世上本没有“命中注定”一说，有的只是人生，只有对错，只有尽力去做到最好。要做个“能屈能伸”的人。 我们身边隐藏着成千上万个带着神经质小秘密的人，都是预料不到的人：能在股东面前高谈阔论的首席执行官却应付不了小小的圣诞节派对，严重害羞的演员，害怕眼神接触的医生。我总觉得应该藏起心中的恐慌，然而我隐藏得越深，它们似乎变得越发可怕。我昨天对费莉希蒂说了这个问题，她却完全不屑一顾。她说：‘去克服它。’听到她的话，我居然感到无比放松。这感觉就像，我终于鼓起勇气从盒子里拿出一只巨大的毛蜘蛛，旁人却指着它说：‘那根本不是蜘蛛。’” 他们夫妻二人是否均在承受一段暂时的精神错乱？这事总会发生在已婚夫妇身上。婚姻从某种意义上来说就是精神错乱：让爱盘旋在怒火之上。 人们可以爱上原本不认识的人，也可以鼓起勇气撕去自己的保护层，把“陌生”的自己展现给对方看，而他们所要展现的绝不仅仅是自己喜欢的音乐类型。在苔丝看来，每个人都应该在他们的终身伴侣面前撕去他们层层包裹的保护层，向对方展露真正的自己。人们很容易假装他们已经没什么需要了解的，假装二人的关系和谐融洽。配偶之间真正的亲密常让人感到尴尬。你怎么可能上一分钟还在用牙线清理牙缝，下一分钟就向人吐露你内心深处的激情以及对平凡生活的恐惧？ 2017.03.26 《魔鬼经济学》有一点点过时的书，主要是因为其中引用的案例感觉比较陌生。不过确实是好书，经济学用到现实中简直无往不摧。其中还提到了教育，教育的影响更多的不在说教，而在于言传身教，在于我本身是个什么样的人。孩子的天性就是模仿，我的优点和缺点都可能被他们学到，挺…可怕的。 很多人，包括很多经济学家，都没有把列维特的研究当成是经济学。可他却让经济学研究回到了自己的本源：解释人们是如何得到自己想要的东西的。 真正导致美国犯罪率下降的并不是枪支控制，也不是强劲的经济增长率，更不是新的巡管政策，而是潜在的罪犯数量的急剧减少。 伦理道德代表了人们希望这个社会运行的方式，而经济学则勾画出了它的实际运行方式。经济学是一门特别讲究分析的科学，它为人们提供了一套强大而灵活的工具，可以让人们对大量的信息进行分析评估，从中找出每个因素可能对其他因素，甚至是整体所产生的影响。 欺骗或许是人类的本性，它无疑是几乎所有人类活动当中最为明显的一个特征。欺骗首先是一种经济行为：用更少的代价换来更多的回报。 三K党的权力就好像政治家、房地产经纪人，或股票经纪人的权力一样，在很大程度上来自于他们所掌握的信息。一旦这些信息落入错误（你也可以认为是适当）的人手上，整个群体的优势就会在瞬间消失。 交易的一方总是会比另一方拥有一些信息优势，这是一种很普遍的现象。用经济学术语来说，这种现象被称为信息不对称。我们知道，资本主义所信奉的一条真理就是：一些人（通常是专家）总是比另外一些人（通常是消费者）知道得更多一些。但到目前为止，各种各样的信息不对称事实上都已经被互联网的发展所削弱。 房地产经纪人的主要工作内容就是说服委托人接受低一些的价格，并同时告诉潜在买家他们完全可以以低于标价的价格买到房子。当然，经纪人不会直接地告诉买家去压低价格，他们完全可以通过一些更加巧妙的办法来达到这一目的。 从信息传播的角度来说，这样的广告语通常比较具体而直接，因此也就非常有用。如果你喜欢花岗石，那么你就可能会喜欢这房子；可即便你不喜欢这房子，这条广告语至少也会给你一种“很实在，不夸张”的感觉。“够档次”和“工艺先进”也是如此，两条广告语实际上都是在告诉买家，这房子确实棒极了。 我们所公开宣称的信息和我们实际拥有的信息之间有着巨大的差距。（或者说：我们说的是一回事，做的却是另一回事。）无论是在私人关系、商务交往，还是在政治活动当中，都是如此。 当很多人愿意竞争同一份工作的时候，这份工作的报酬通常不会太高。这也是决定该工作薪酬水平的4个主要因素之一——决定工作薪酬水平的其他3个因素是：工作所要求的专业技能水平，工作所让人产生的不快感，以及工作本身要求从业人员所付出的服务水平。 关押一名犯人每年的成本是2.5万美元。 毫无疑问，在孩子一生的成长过程当中，父母扮演着非常重要的角色。可问题是，大多数父母都是在孩子出生之后开始学习如何教育孩子的，这时已经为时过晚了。如果父母聪明、勤奋、受过良好教育、有着不错的收入、能够组织良好家庭的话，他们的孩子也很可能会取得成功。但父母对孩子做些什么其实并没有那么重要；关键是父母本身具有怎样的特点，他们是一个怎样的人。从这个角度来说，今天的许多父母们就像我们前面谈到的政治家们一样，他们之所以会拼命地募集选举资金，是因为他们相信金钱可以赢得选举，可事实上，真正能够帮助他们赢得选举的是他们本身的特质，如果选民们不喜欢一个人，无论他投入了多少金钱都无济于事。 那么如果DeShawn改名为Jake或Connor的话，他的生活会有所改变吗？我猜想，那些希望通过改名字来提高自己的收入水平的人往往都比较有上进心，而导致他们最终可能取得成功的，正是他们的这种上进心（而不是名字）。 对于那些正在准备给孩子取一个“聪明”名字的家长来说，我们建议，这样的名字并不能让你的孩子变得更聪明；它只能让你的孩子拥有跟其他聪明孩子一样的名字。 这些父母都是在用孩子的名字传达某种信号。从加利福尼亚的数据当中，我们发现，绝大多数父母都是在用名字传达自己对孩子未来成就的期待。当然，名字本身并不能改变孩子的命运，但那些花费心思给孩子取名字的父母会让自己感到心安，因为他们知道，从孩子一来到这个世界上的时候，他们就已经开始在帮助孩子取得成功。 从本质上来说，本书讨论的是人们在现实世界的行为方式。我们所需要的只是一种新的看待、判断以及衡量这个世界的角度而已。 2017.03.14《单恋》一个融入了性别认同障碍的杀人事件。想起了观海同志任内推出的随意上厕所法案。 哲朗清楚地意识到，他总是按照一般模范家庭中妻子的标准去要求理沙子—牢牢守着家，营造让丈夫舒适的环境。哲朗明白，这只不过是任性的男人们编造出来的美好幻想。所以他一直没说出口，也没想表现出来。他表面上很支持理沙子，心里却盼着她遭受挫折，幻想着她能够为了自己，系上围裙走进厨房。 哲朗觉得到头来他和那些古板的老头子很可能是一类人，开始强烈厌恶自己。口口声声说希望妻子能够独立，内心其实很抵触。自己可能还没察觉到这一点吧。 “人类总是惧怕未知事物，因为恐惧，就要想办法消灭它。所以无论性别认同障碍这个词被关注到什么程度，也无法改变什么。估计今后仍无法传达我们想被社会接受的心情，一厢情愿的状态还是要继续。” 2017.03.11 《你是在恋爱,还是在发神经》作为一个没有经历过恋爱的人，我觉得有必要看看这类书，毕竟这东西是家里学不来的，至少我是没从家庭教育学到什么。这本书指出了我不愿承认的事实，我不是一个足够自信的人，大概是从小担心受到批评、觉得做得不够好有关？亲密关系真是令人向往但又不知如何开启，或许真的是我，想太多？“在大海上航行，没有不受伤的船，除非你不出海。”不过这本书似乎是写给female的。。。 正如我喜欢的萨提亚的这首《我和你的目标》的小诗：我想爱你而不用抓住你欣赏你而不须批判你和你齐参与而不会伤害你邀请你而不必强求你离开你亦无须言歉疚批评你但并非责备你并且 帮助你而没有半点看低你那么 我俩的相会就是真诚的而且能彼此润泽 害怕真实的自己被暴露，而不被喜欢了。这种伤害来自于从小就隐瞒真实的自己，只在别人面前表现自己好的优秀的一面。 第一个男孩，其实想要得到女孩的好，却不能相信女孩的好。他害怕，害怕女孩靠他太近了会发现他很多缺点，从而会抛弃他。既然他会被抛弃，那又何必开始？他很优秀，却从来不认为自己值得被爱。我们如果去探寻他不自信的原因，可以从他的家庭里窥探到一点，他的优秀，是从小被苛求出来的，从小就没被肯定过，没被好好爱过。当男孩愿意去觉察自己内心想法的时候，他可以看到自己害怕的这一部分，当他愿意去分享心底这部分想法的时候，也就很容易释怀。 长大后人们开始发展出超我的部分，超我就是我们强大的理智和道德规范下的自己。本我在人际关系中把别人当成父母，想要得到他们无条件的爱，但是超我又把他们还原为他人，知道我们不该向他们要。所以我们发现在现实生活中，不索取爱的人比索取爱的人有更好的人际关系。 你为什么会爱上爱情？当你的世界里出现一些缺失的时候，就会认为爱情可以填补这个缺失，让你快乐些，所以你会爱上这样一个让你快乐的东西。在本身缺失的时候我们没有太强烈的感觉，但是身边富有的人却总在我们眼前晃来晃去，提醒着我们的缺失，于是感觉更加缺失。于是以为，有一个相爱的人可以填补这个缺失。 当你爱上爱情的时候，恰恰是危险的。当一个人开始满足你这些缺失的时候，你就会对他产生好感和依赖，而无法去判断那是不是爱情。 儿童在早期有两种基本的需要：安全的需要和满足的需要，这两种需要的满足完全依赖于父母，当父母不能满足儿童这两个需要时，儿童就会产生基本焦虑。父母给予孩子的爱、真诚、尊重的程度，决定着孩子对人产生安全感的程度，也直接决定着孩子长大后对人的态度，别人对他建立安全感的容易程度，甚至在一个容易吵架或冷漠的家庭里长大的孩子，对亲密关系建立的安全感就十分微弱。 感情这个东西的力量大到你无法想象，完全可以改变一个人的命运、性格等众多因素。你不必等到所有都确定之后才开始，你可以在开始之后去塑造你想得到的。同时，允许自己失败和受伤。在大海上航行，没有不受伤的船，除非你不出海。 征服首先是好奇，好奇于不被自己控制和了解的东西，然后想通过自己的力量去了解。征服然后是为了占有，将别人的或公众的东西占为己有，成为自己的财富，扩充自己的世界。 自我价值感高就是不依赖自身以外的人、事、物来证明的价值。价值感高的人会觉得自己一直都在被爱，他会很容易看到爱和相信爱，并且认为自己值得，于是他不需要期望别人来爱他，因为他已经看到爱。他对别人没有期待，会包容、接纳别人的一切。他不会敏感和脆弱，可以为自己的行为和感受负责。他接纳别人是有限制的，也接纳自己的有很多不能，但不会因此看不起自己。于是这样的人会吸引到更多的人来爱他，也收获更多的爱。 习得性无助是美国心理学家塞利的重大发现，是你通过学习形成的一种对现实的无望和无可奈何的行为、心理状态。 挑剔有时候不仅仅是完美，还是一种理性。理性是好的，但是过于理性的时候，你会出现择偶困难。你的挑剔不是因为你优秀或不够优秀，不是你看不上或被看不上，而是你想得太多，你甚至使用沉没成本去权衡利弊，而且你总能指出这个人不适合你的地方。于是，你否定了很多人，也否定了很多爱情，渐渐地，你就被剩下了，被单身了。 或许你会说，你没有那么否定你的父母，你依然很尊重他们。但是我要说的是，把父母的身份还给父母，并不是尊重就可以。你的否定里，他们很多事情做错了，这时候你已经把自己放到了比他们高的位置了，因为你想教育他们，告诉他们该怎么做。好像你变得比他们大，位置比他们高一样。 正确的对待父母的方式，就是尊重他们作为你的父母而存在。“父母是大的，孩子是小的。”这是宇宙运行的法则，你只有尊重这个法则，才可能把父母的身份还给父母。你可以否定他们的行为，对他们的行为不满，但是不要否定他们作为你父母的身份。 2017.01.28 《宿命》老实说，畅销君的作品看多了也就没什么感觉了。 晃彦对她说道：“医生和企业站在敌对的立场。”他的口气斩钉截铁，美佐子察觉这是几天前的话题的延续。“企业对人的身体不感兴趣，无视人体健康，日益追求发展。结果医生就得拼命帮企业擦屁股，这就像是一根根地重新种植被推土机摧残的幼苗。” 若从客观角度来看，再没有比这更好的姻缘了。然而，美佐子却感到不知所措，最主要的原因即是她对晃彦的感情绝对称不上爱情。当然，她不讨厌他，甚至尊敬他，却从未因为和他在一起而没来由地雀跃不已，也从未不发一语便能心灵相通。这种心心相印的感觉不正是婚姻中最重要的部分吗?美佐子曾深爱过一个人。当时她还是高中生，或许是因为心智尚未成熟，那种刻骨铭心的感情她是第一次，也是最后一次经历。虽然因为种种偶然因素不能与他结合，但美佐子认为，爱上一个人就应该有当时那种心情，那完全不同于对一个人的广博知识感到的惊叹，或对一个人行动果决而感到的佩服。 2017.01.27 《菊与刀》令人惊叹的一本书。二战后为了尽快确立美国对待日本的政策而快马加鞭的一项研究，作者从未去过日本而能够通过纸质材料、战俘访谈等方式完成对大和民族的剖析，实在是不可思议。在去日本旅行之前看了一波，对了解日本人的性格有很大帮助。BTW，这次笔记开始使用的是Kindle的标注功能，直接复制出来整理一下就可以发了，十分方便。 “菊”本是日本皇家家徽，“刀”是武家文化的象征。但本尼迪克特在以此命名本书时，似乎并未从这种含义出发，而是以“菊”和“刀”来象征日本人的矛盾性格，亦即日本文化的双重性（如爱美而又黩武，尚礼而又好斗，喜新而又顽固，服从而又不驯等等），由此入手，进而分析日本社会的等级制及有关习俗，并指出日本幼儿教养和成人教养的不连续性是形成双重性格的重要因素。 所谓“文化”，其含义既有广义、狭义之分，也有观点不同之别。从历史唯物主义观点看来，文化属于上层建筑，其核心是社会意识形态，它反映经济基础并受经济基础的制约。但文化又有其相对的独立性，各民族的文化各有其历史形成的特点并反作用于经济基础。 日本人与其他东方民族不同，有强烈描写自我的冲动，既写他们的生活琐事，也写他们的全球扩张计划，其坦率实在令人惊异。当然，他们并没有和盘托出。没有一个民族会这样做。日本人描述日本会略去许多重要事情，因为这些对他们太熟悉了，如同呼吸空气一样，习而不察了。 人们在观察事物时，也很难意识到自己是透过镜片观察的。任何民族都把这些视为当然，任何民族所接受的焦距、视点，对该民族来说，仿佛是上帝安排的景物。我们从不指望戴眼镜的人会弄清镜片的度数，我们也不能指望各民族会分析他们自己对世界的看法。当我们想知道眼睛的度数时，我们就训练一位眼科大夫，他就会验明镜片。毫无疑问，有朝一日，我们也会承认，社会科学工作者的任务就是为当代世界各个民族做眼科大夫那样的工作。 他们认为，只要各国拥有绝对主权，世界上的无政府状态就不会结束。日本必须为建立等级秩序而战斗。当然，这一秩序的领导只能是日本，因为只有日本是唯一的真心建立起自上而下的等级制的国家，也最了解“各得其所”的必要性。 美国人把自己的全部生活调节到经常应付挑战上，并且随时准备应战。日本人则把自己的信念建立在万事预先俱有安排的生活方式上，在他们那里，最大的威胁莫过于未曾料到。 日本人的行为则好像是：择定一条道路便全力以赴，如果失败，就很自然地选择另一条道路。 俸禄并不富裕，根据日本学者估计，整个武士阶级的平均俸禄与农民所得相差无几，只够维持最起码的生活。对武士家族来说，如果几个继承人分享这点俸禄，那就伤脑筋了。结果，武士就限制自己的家族规模，对他们来讲，最令人难堪的就是威望取决于财富和外观，所以，他们的信条是，俭朴乃最高的美德。 日本人的格言是：“万物各得其所，各安其分。” 日本修改了“资本主义生产阶段的出发点和正常顺序”。㉘它不是从生产消费品和轻工业起步，而是一开始就兴办关键性的重工业。兵工厂、造船厂、炼钢厂、铁路建设等等都被赋予优先权，飞速达到了高水平的技术和效率。当然，这些企业并没有全部转让给民间财阀，庞大的军事企业仍然掌握在政府官僚手中，并接受政府的特别财政补助。 在政治、宗教、军队、产业等各个领域中，都有十分周到的等级划分，无论是上层还是下层，一逾越其特权范围，必将受惩罚。只要“各得其所，各安其分”得以维持，日本人就会毫无不满地生活下去。他们就感到安全。 “恩”也意味着对所欠恩债的回报，从而就有爱的意思，但其本义是负债。我们美国人则认为爱是不受义务的约束，而是自由给予的。 对日本人来讲，猝然受到生疏者的恩惠是最讨厌的事。因为他们知道，在与近邻和老等级关系打交道中，受“恩”所带来的麻烦。 在日本人看来，还有一个更强烈表示负恩心情的词，就是“かたじけなぃ”（诚惶诚恐）。这个词的汉字写作“辱なぃ”“忝なぃ”，兼有“受辱”与“感激”两层意思。日文辞典解释这个词时说：你受到了特别的恩惠，因而感到羞愧和耻辱，因为你不配接受如此之恩，因而你用这个词表示你受恩时的羞愧感。 人们在受恩时常怀矛盾情绪。在公认的社会人际关系中，“恩”所内含的巨大债感推动着每个日本人竭尽全力以偿还恩债。但是，恩债感又是很难受的，因而也很容易产生反感。 我们认为，一个人应该同情、援助贫困的双亲，不能殴打妻子，必须抚养子女。但是，这些既不能像金钱债务那样斤斤计较，也不能像做生意成功那样获得回报。但在日本，这些却被看作像美国人眼中那种金钱债务一样，其背后有强大的约束力，就像美国人的应付账单或抵押贷款的利息一样。 日本人把恩分为各具不同规则的不同范畴：一种是在数量上和持续时间上都是无限的；另一种是在数量上相等并须在特定时间内偿还的。对于无限的恩，日本人称之为“义务”，亦即他们所说的“难以报恩于万一”。这种义务包括两类：一类是报答父母的恩——孝，另一类是报答天皇的恩——“忠”。这两者都是强制性的，是人人生而具有的。 在美国，自尊心是与自己处理自己的事联系在一起的；在日本，自尊心则是与对施恩者报恩联系在一起的。这两种习俗各有各的难处：我们的难处在于，即使对全国有利的法规，也很难被接受。他们的难处在于，人们一生都处于负恩重压的阴影之下。 “义务”，不论其对个人要求如何艰巨，至少总是指对其骨肉近亲，或者对代表其祖国、其生活方式及其爱国精神的最高统治者所应尽的一系列责任。这种牢固的联系是与生俱来的，因而理应履行。尽管“义务”中的某些特定行为也会使人“不愿意”，但“义务”的定义中绝不会有“不愿意”做的意思。对“义理”的报答则充满内心的不快。在“义理”的领域中，负恩者的难处是无以复加的。 日本人对颂扬复仇和颂扬捐躯尽忠，同样津津乐道。两者都是“义理”。尽忠是对主君的“义理”，对侮辱进行复仇则是对自身名分的“义理”。 一个正派的人对恩惠和侮辱都同样感受强烈，都要认真回报。他们不像我们那样，把两者区别开来，一种称之为侵犯，另一种称之为非侵犯。在他看来，只有“义理”范围之外的行为才能称作侵犯。只要是遵守“义理”，洗刷污名，就绝不能说他犯了侵犯之罪，他只不过是算清旧账。 美国人的最高指示是在同辈竞争中取得优异成绩，而以“恩”为基础的伦理则极少容许竞争的余地。他们的等级制体系有烦琐规定，把直接竞争控制在最低程度。 我们被训练成（实际情况如此）遇到侮蔑家庭名誉或者国家荣誉，就视若污秽或疱疥，必须通过申辩洗刷干净，否则就犹如不能恢复清洁或健康。对日本公私生活中常见的报仇事例，不妨看做是一个喜爱洁净成癖的民族所进行的晨浴。 尽管他们在古代传统中非常崇尚复仇，在现实生活中则和西欧一样，复仇行为很少见，甚至比西欧还要少。这并不意味人们的名誉观念日趋淡薄，而是意味对失败和侮辱的反应已日益成为自卫性的而不是进攻性的。对耻辱仍然看得很重，但已更多地以自我麻痹来代替挑起争斗。 日本人则另外寻找侵略的根据。他们迫切要求在世界上赢得尊敬。他们看到大国是靠军事实力赢得尊敬的，于是力求与这些国家并立。由于资源缺乏，技术落后，他们不能不采用比希律王更加毒辣的手段。他们付出了巨大的努力，还是失败了，这对他们来说，意味着侵略到底不是赢得名誉之路。而“义理”则常有双重同等的含义，一方面是使用侵略手段，另一方面是遵守互敬关系。在战败之际，日本人从前者转向后者，而且显然不觉得心理上对自己有任何压力。目标仍然是为了名誉。 在日语中，“自重再自重”，是最强烈的语气，意思是万分小心，无限谨慎，绝不可轻下结论。它还意味着，必须权衡各种方法和手段，用力不多不少，恰可达到目的。 日本人对自己深重的罪孽有时也像清教徒一样，反应很强烈。尽管如此，上述极端的说法仍然指明了日本重视的是什么：与其说他们重视罪，毋宁说他们更重视耻。 真正的耻感文化依靠外部的强制力来做善行。真正的罪感文化则依靠罪恶感在内心的反应来做善行。羞耻是对别人批评的反应。一个人感到羞耻，是因为他或者被公开讥笑、排斥，或者他自己感觉被讥笑，不管是哪一种，羞耻感都是一种有效的强制力。 真正把人们维系在一起的是他们的文化，即他们所共同具有的观念和准则”。 2017.01.14 《彷徨之刃》现在国内社会出现的各种未成年人犯罪的事情，在日本21世纪初也出现了。东野这部作品是想探讨未成年人罪犯因为年龄而获得减刑是不是公正的法律，从被害人家属、罪犯、甚至警察本身的角度展现了不同的心理活动，但小说最后的结局还是按照法律办事，失去了铲除人渣大快人心的结局。文中还反复出现未成年人犯罪后，他们的家长一昧护犊，可以预见这样的护犊下未成年人渣必然一错再错，反正有人替自己辩护，到头来还能理直气壮地怪罪于家庭教育，自己逃避责任总能蒙混过关，何乐而不为？而法律并不会给他们什么教训，反而会保护未成年人渣让他们重回社会，家长的放纵更是让他们年少时懵懂的恶逐渐固化成深入骨髓的恶。人之初，性本恶。恐怕少子化现象就是因为越来越多人意识到教育风险之大，宁愿不生，这比那些只知道生不知道怎么教育的成年人不知高到哪里去了。 过去发生的几起不合理的案件在长峰脑海中苏醒。凶手并非每次都会被判死刑，不判死刑的案例反而更多。如果凶手未成年，甚至连姓名都不会公布，更不可能判什么死刑。少年法并非为被害人而制定，也不是用来防止犯罪，而是以少年犯罪为前提，为了拯救他们而存在的。从这些法律条文中无法看见被害人的悲伤与不甘，只有无视现状的虚幻道德观而已。 但他并不只希望凶手被捕。他真正的愿望，是让凶手切身体会到自己的憎恨与悲伤。他要告诉他们，绘摹遭到的不幸是多么令人难以接受，让他们彻底明白自己所犯的罪有多重。如果交给警察，这个愿望能实现吗？恐怕不能。正因如此，目前这种不重视被害人家属的司法制度才会问题百出。 “枪这玩意儿有着不可思议的魔力，只要一拿到手上，任何人都想扣下扳机。但是真正和什么东西对峙的时候，人们反而无法扣下扳机，因为知道枪的可怕。射击，就是在和这种恐惧对抗。” 他知道自己没有制裁罪犯的权力。这应该是法院的职责。可法院真的会制裁他们吗？不会。通过报纸和电视，长峰多少知道审判是如何进行的，或是给什么案子判了多重的罪。就他个人的认知，法院不会制裁罪犯。说法院会拯救罪犯其实更恰当。法院会给犯了罪的人重新做人的机会，然后将其藏到憎恨他们的人看不见的地方。这样就是判刑，而且刑期都短得令人惊讶。夺走了别人一生的凶手，其人生却不会被夺走。而那个快儿可能跟敦也一样未成年，只要强调自己并非故意杀死绘摩，或许连入狱服刑都免了。真是岂有此理！那个人渣夺走的不只是绘摩的人生，还给所有爱绘摩的人的人生留下了难以愈合的伤口。 “国际象棋就像人生。一开始我们就拥有所有的棋子。如果能一直这样，就会平安无事，但这是不允许的。要移动、要走出自己的阵地才行。越移动，或许就越能打倒对方，可同时也会失去很多东西。这就和人生一样。国际象棋和将棋不同，从对方那里赢来的棋子不能算是自己的棋子。” 他父母不见得会说实话。如果他们知道儿子的行踪，不管警察怎么追问都会保持沉默。不是想让儿子逃走，而是希望儿子在被警察逮捕之前先自首。不管什么样的小孩，在他父母眼中一定都是可爱的。即使长大后变得罪大恶极，父母也会像那个民宿的女子一样，一心记得他们小时候可爱的模样，甚至扭曲自己的良知。 长峰发现自己对他们充满了嫉妒和欣羡之情。在此之前，他也过着这种自己可以稍微掌控的人生——安定的生活、一成不变的每一天。现在他才体会到这些是多么可贵。他现在身体疲累、心中伤痕累累，即使想回到那时候，也找不到办法了。为什么会发生这种事？就是因为有人把那两个畜生生下来却不管他们吗？ 织部想，这把枪是为了保护菅野，是为了防止长峰绘摩的父亲对杀害女儿的罪犯展开的复仇行动。警察到底是什么？逮捕犯法的人是他们的职责，这样才可以消灭万恶。多么冠冕堂皇的想法！可这样真的能消灭万恶吗？把坏人抓起来然后予以隔离，换个角度看，其实就是在保护坏人。经过一段时间，当社会逐渐淡忘被“保护”的坏人时，他们又可以回到原来的世界，其中有许多人会再度犯法。他们会不会因犯的罪遭到报复，甚至觉得国家回保护自己呢？（note：这段和东野另一部《信》是相反的，《信》中描述的是罪犯及其家人受到社会的排挤，根本不能回到原来的生活。）织部不禁怀疑自己手中的正义之刃是否真的朝着正确的方向。即使方向正确，这把刀又是真的吗？当真具有斩“恶”的能力吗？ 2017.01.08 《怪笑小说》2017年第一本书，东野圭吾的短篇。第一篇就很高能，描述了高峰期私铁车厢内众人的心理，以小见大牵扯到了日本的养老金、老人与年轻人的互相不顺眼、偷瞄的痴汉、为了不让位的各种行径、女性地位、公司分级、中年女性的愤愤、护犊、对熊孩子怒气，简直是社会百态。我一直怀疑文明都知识表面的繁华，人们真的会相敬如宾吗？种族歧视、排外情绪，在文明之都就不存在吗？只是人们都藏在心底不说吧。 这些人怎么这么没常识？个个都装得好像没看见我。爱心专座明明就是给老人家坐的，年轻人有什么资格坐！为什么国家不严厉取缔这种行为呢？就因为没人管，害我老是站得很辛苦。日本能有今天的发展，还不是靠我们这代人的努力，真该好好教育时下的年轻人，对长辈要加倍尊敬。 高须一夫心想，你这老太婆有完没完，就不能往别的地方挪挪？我是不会让座的，要一直坐到下车为止。工作了一天我已经筋疲力尽了，今天的日本就是靠我们的辛劳支撑起来的，在电车里休息一会儿有什么不对？一毛钱也不挣的老年人待在家里就得了，少来妨碍我们这些社会中坚！ 我时常听到这种论调：“因为不希望自己建立的理论遭到破坏，科学家总是对超自然现象视若无睹。”对于那些一手缔造文明的伟大科学家来说，这种看法是何等的无礼。没有人会比科学家更期待推翻既有概念的现象出现，他们总是梦想着将自己信仰的一切彻底颠覆，因为唯有不断推翻与重建，科学才能日新月异。基于这种观念，有时他们也会表现得很冷酷。]]></content>
      <categories>
        <category>Book</category>
      </categories>
      <tags>
        <tag>reading</tag>
        <tag>novel</tag>
        <tag>culture</tag>
        <tag>literature</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闲书摘录2016]]></title>
    <url>%2F2016%2F11%2F07%2Freading_note%2F</url>
    <content type="text"><![CDATA[摘录读书中的片段。2016年冬完结。《谁杀了她》、《麒麟之翼》、《伪东京》、《我杀了他》、《毕业》、《秘密》、《信》、《时生》、《放学后》、《恶意》、《新参者》、《圣女的救济》、《歪笑小说》、《解忧杂货店》、《嫌疑人X的献身》、《毒笑小说》、《黑笑小说》、《白夜行》、《国境以南 太阳以西》、《斯普特尼克恋人》、《舞舞舞》。 2016.12.31《谁杀了她》2016年最后一本书。和前面看过的《我杀了他》类似，分析各种情形、提供各种线索，最后留一个开放式的结尾，我读起来并不舒服，不是很喜欢这样的设计。 园子总抱有这样的想法。她早已预想过，或许这辈子都不会有什么戏剧性的恋爱，只是经过熟人介绍，与相亲对象相互妥协，最后结婚。有时她会觉得，其实这样也没什么不好。她认识的很多夫妇都是这样走到一起的，而她自己也从未把这种事看成一种不幸。她知道绝大多数人此生都注定与电视剧里那种轰轰烈烈的爱情无缘。 园子开始感觉到，不祥的脚步声正渐渐接近自己。她想弄明白润一究竟遇上了什么事。但她故意不闻不问。在她看来，如果开口质问，就相当于拆掉一栋濒临倒塌的房子的支柱。她心里还抱有一丝幻想，觉得只要过上一段时间，即将倒塌的房子或许就会重新变得坚固。 2016.12.28《麒麟之翼》加贺又是通过主角光环一路执着探寻案件真相，洗刷了一人的罪名，及时挽救了三个年轻人的未来。但奇怪的是加贺对于家人的关系似乎处理不妥，总觉得他对父亲有点绝情，明明在处理案件时处处都能透出人情味的他，为什么连父亲最后一面都不见。 悠人的心情复杂极了。一方面，他并不想看报道父亲遇害的新闻。另一方面，他又想知道社会上是怎么报道这起案件的。现在他的心情就像嘴里含着一颗发病的虫牙，一方面知道肯定会疼，另一方面又忍不住想摁一摁它。 “分手的夫人…加贺先生的母亲亡故的时候孤身一人，没能见到独生子，所以自己去世的时候，儿子也不必在身边——你父亲是这么说的吧。”“没错。这是男人间的约定。”登纪子唇边浮现出一丝嘲笑，“真无聊。”“你说什么？”加贺声音低了下去。“我是说，在他身体健康的时候和你定下的约定没有任何意义。加贺先生，你面对过人的死亡吗？”“见过很多次，我都数不过来了。毕竟这也是我的工作。”登纪子轻轻摇了摇头，“你见到的是尸体，不是人。我见过很多即将离世的人。在死亡临近的时候，人们会回归真正的本心，扔掉所有的自尊心、意气用事，直面自己最后的心愿。接受他们发出的信息是生者的义务。加贺先生，你放弃了自己的义务。” “如果记住公式，就能解决很多问题。但是，如果最初记住的就是错误的公式，那就会屡次犯同样的错误。” “够了！说什么不想伤害孩子。你根本不明白自己做错了什么！杉野刺杀了青柳先生以后，为什么不自首，你知道吗？就是因为你把他教错了！即使犯了错误，也能蒙混过关——这就是你三年前教给他们的。所以，杉野会做同样的事情，会犯同样的错误。而青柳先生，看到自己的儿子如此误入歧途，他想告诉儿子什么才是正确的。你如果连这点都不明白，就别当老师！你这样的人，根本没有资格教育别人！” 2016.12.20《伪东京》知乎上说可以在日本旅行途中带一本精致的小书，学日本人路上有空就看书而不是怼手机。这个日籍作者用中文写的小文章还蛮有意思。其实原本知友推荐的是新井一二三的另一本更高分的《我这一代东京人》，但我对人物类的书不太读得下去，弃了，转到这一本更多现象、故事的书。此外还有一本《东京迷上车》，讲的是橙色中央线各站的周边风情，相当于日本人写的东京游记，吃啥看啥玩啥都有写，读完后就记得烧鸟好像很美味的样子。 对台湾今天的年轻人来说，东京大概是很现实的地方了。他们不仅在多部日剧里看过东京各区如台场、原宿、井之头公园，在杂志里看过代官山、六本木、秋叶原的商店，恐怕也去过了。透过媒体的报导萌芽兴趣和憧憬，然后经过亲身经验更产生了亲切感，脑子里就自然会有“如果能居住一段时间就好了”的想法。日本很多这样地方的年轻人，其实也出于同样的想法，离开故乡来东京定居的。但对于台湾年轻人来说，东京毕竟是外国城市。由于语言不通，生活习惯不同，还有经济政治各方面因素，实际上搬过来居住又谈何容易。这一方面是令人遗憾的，同时也是能保持美丽幻想的条件。对他们来说，东京可能就像日式面包店卖的软绵绵的奶油包一样，当零食吃则很理想，至于当饭吃会怎么样，也许从来没有想过。 在越来越加速化的时代环境里，人们普遍失去耐性，太多人感到焦虑。他们认为，只要站在消费者的立场，就有资格大声申诉不满，对方则得乖乖地听，也乖乖地道歉赔罪。有这种思路的并不限于老人一代（指赶不上时代而感到孤独的老人一代，在消费者中心主义的鼓励下，很容易向商店、医院的工作人员发脾气），连在小学儿童的家长中也常常看见。对教师发挥消费者本领的家长被称为“怪物父母”，每年导致许多教育工作者患上忧郁症而请长期病假。 2016.12.19《我杀了他》最让人摸不着头脑的一本，三个有动机的人，都似乎有机会下手，而到底下没下手、最终是谁毒死了渣男，东野是想留给读者去猜去讨论，于是豆瓣上出现了各色哈姆雷特，众说纷纭。不推荐。里面对“人生如戏”的描述，还是挺贴切的，甚至有点恍然大悟。 收养我们的亲戚人非常好，富有爱心，待我就像对待亲生孩子，为了不让我感到自卑，总是细致入微。为了不辜负他们的一番好意，我也尽量表现得和其他家庭成员没有什么区别，不仅时常注意不要过于客气，时不时还撒撒娇，总之就是扮演家人的角色。我甚至想过不能太乖，还适当地犯过小错误，故意让叔叔他们操心。因为我知道，比起那些一直都听话的乖孩子，大人们更喜欢犯点错误然后改过自新的孩子。听我这么说，美和子大吃一惊，因为她的情况也是这样。刚被收养时，她是个不爱说话的孩子，也不跟别的孩子玩，总是一个人躲在角落看书。“当时周围的叔叔们都说，孩子还没有从精神打击中缓过来，得需要一段时间。”随着年龄的增长，性格内向、沉默寡言的少女变得越来越开朗。小学毕业时，已经完全变成了阳光少女。“那一切不过是在演戏。我不过是采取了大人们比较容易理解的行动而已。我也不知道自己为什么那样做，或许是为了活下去，觉得自己只能那样做。” “说实话，我很想按恐吓信的要求去做，也就是把毒胶囊放进去。那封信确实看透了我的心理，刺激了我内心深处对穗高诚的愤恨。正常的话，再恨对方也不会去杀人。但如果是被迫按指示去做，就不存在这种顾虑了。虽然有自己在做异常之事的意识，但因被迫而无可奈何这一借口会压倒良心。” 2016.12.14《毕业》并不算很好看的作品，但是可以作为认识加贺恭一郎的第一本书，窥看他大学最后一年发生的事情，显露出了他做警察的才华。 “要是祥子真把烦恼告诉了你和波香，我想她也不会自杀了。烦恼就是这样，说给别人听，痛苦就减少一分。”“可要是那样，她就应该告诉我们了。”“那可不一定。能告诉你，就说明她心里还有余地。真正的烦恼是无法为外人道的，这时友情也无能为力。” “我找他家人核实了日记，还没找到称得上是动机的信息。我也不是没想到会这样。我觉得日记就是这样一个东西，心里有事不想让别人知道，写的时候又会设想别人正在看自己的心事。” “一个人不管怎么努力，能够集中精力的时间也不超过几分钟。就算你觉得精神是集中的，其实却是在集中和放松两种状态中短时间反复循环。持续地集中精力，涣散必然随之而来。一到那种时候，不管是进攻还是防守，势必会出现纰漏。因此，你需要的并不是长时间地集中精神，而是要让自己处在一种随时都能集中精神的准备状态之中。这就是所谓放松的能力。” “无论你怎么做，想要面面周全多半是不可能的。既然你决心已定，就放手做下去吧。你一个人出去，既想得到令尊的允可，又想得到大家的祝福，那只能是一厢情愿的空想。且不说这个，我觉得单单是征得令尊的同意，就已经是奢求了。”或许是吧，沙都子心想，她选择了自己想走的路，也做好了准备去接受由此带来的考验。她确实希望父亲能够理解她，但那终究只能是自己天真的想法罢了。 每逢岁末，当地的剑道高手都会举行一次交流会，加贺每年都在被邀请之列，但一次都没去过。在他看来，这不过是几个小有名气的剑道同仁相聚一处进行的自娱自乐。不只是剑道，所有的运动都是依靠大多数默默无闻的参与者在底层的支持而延续下来的，如果忘记了这一点，还谈什么交流会！ “我听佳江说，你还是决意要去东京？”“嗯。”“我反对。到现在也是。”“我知道。”“明知这样还是要去吗？你不打算说服我？”“我已经放弃了。”“为什么？”“因为找不到理由。”“你是说，你没有能说服我的理由？”“你会寂寞吗？”“当然会寂寞啊。因为怕寂寞才会不让你去东京。你要明白父亲的私心。”“那你再问一次。”“别去东京了。”“不行！”说完，加都子走出了家门。她如今非常感谢一直反对她的父亲。正因为他的反对，她才有了多次重新审视自己意志的机会。就这样，直到毕业，她也从未迷茫过。现在，她清晰地意识到了这一点。 2016.12.12《秘密》猝不及防看了这个灵魂附身的题材。母亲的灵魂得到了女儿的躯体，相当于人生从五年级重新来过，父亲对女儿纠结的感情，肇事者家庭牵扯出的联系，这几条线穿插还是十分精彩的。有人说，如果人人都能从老到幼反过来经历人生，人人都能活得很幸福。 “难道你对成为我的妻子感到不满意吗？你后悔了吗？”“没有那种事。能够做你的妻子我感到非常满足，也觉得这样很好。我可没说过想抛开家庭主妇的角色痛痛快快地出去工作这样的话。”“但是你不希望藻奈美选择和你一样的生活方式，对吧？”“我不是那个意思。怎么说呢，我认为自立的女性也未尝不可以成为家庭主妇。我所排斥的，是因为不能自立不得已才成为家庭主妇这种情形。即使很讨厌丈夫，由于担心生活不稳定，所以不敢出走，这样的女人也有很多吧？我不希望藻奈美成为那样的女人。难道你不觉得只能靠男人活着的女人是很悲惨的吗？我只是运气好，遇到了你。可是如果我遇到的不是你，而是一个很差劲的男人，那我该怎么办？说到底，我的幸福全掌握在你的手上啊！”“直子的生活很平常，我觉得很平常。”“我从来都没觉得自己比别人悲惨。你说得对，我活得很平常。是不是觉得悲惨这一点因人而异。因此，我决定替藻奈美成为一个能够自立的女性。我想，除了我以外，没有谁还能获得一次人生重来的机会。我不想浪费这次奇迹。” “如果我今天打破了这个规矩，那以后我还会打破第二、第三个规矩，这样下去人生将一步步走向失败。我之前的人生就是这种活法的典型。结果呢？虽然从小学到大专，我在可以称之为学校的地方待了14年，到头来却没有掌握一项能够来意生存的技能。我再也不想重走老路了，打死我也不想再产生一次同样的懊悔了。” 她并没有把学习当成生活的全部。她似乎意识到了注重学习之外事情的重要性。和以前的那个她相比，她读书的范围扩大了很多。她还将布满灰尘的微型组合音响清扫了一下，开始听音乐了。“世界上真的有很多精彩的事物。有很多东西，比如能让你感到幸福的东西、能改变你世界观的东西等等，都不需要话很多钱就能办到。你说，我以前怎么就没注意到呢？” “当爸爸又不是图什么好处。有一天，还没等你明白是怎么回事时，管自己叫爸爸的孩子就出来了。这时候你已经无路可退了，只能去努力做个好爸爸了。” 将从下面获得的信息报告给上面，或者与其他部门进行磋商后将结果再转发出去，每天都有大量的文件从他眼前经过。这些文件和他在生产线上看到的产品与零件完全不同。文件代表的是信息，信息没有实体。也正因为如此，处理起来并不比产品和零件容易。他越来越找不到工作时应有的那种充实感了。“在一线待的时间一长，就没有什么往上爬的想法了。就是想往上挪，我看挪到组长的位置也够了。要是再往上爬的话，加班费没了，工作内容也全变了，我觉得那样没什么好的。”“是啊。”平介坦白地承认。“但那也是没有办法的事啊。公司也是人生游戏的一部分啊。在公司往上爬，就跟人要长岁数一样。歧视，谁都想一直当个孩子。可是，周围人是不会允许你那样做的，他们会不断提醒你，‘你都快当爸爸了，还不抓紧时间努力工作’、‘你都当爷爷了，也该稳重点了’之类的。你想说，你只是个普普通通的男人，但他们不这么想。你逃不过这些现实的。” “考试不仅需要智力，还需要体力。像我这种必须要和男生一起竞争的情况就更如此了。另外，还有一件事爸爸可能不知道。在我们学校，参加俱乐部活动的人比不参加俱乐部活动的人在应届考上志愿大学的比例高。这是因为效率的差距。虽然那些不参加俱乐部活动的人很早就开始准备考试了，可是他们总觉得自己的时间比参加活动的人多，所以在准备过程中常常会放松下来。而相比之下，那些参加俱乐部活动的人都很自觉地抱有落后意识，所以他们一直到考试的前一天都不会松劲儿，从起点到终点一直都在冲刺。当然了，通过俱乐部活动他们也获得了支持他们这样努力的体力。所以，从结果上看，学习效率更高的是参加俱乐部活动这一组的学生。” 2016.12.10《信》讲述了犯罪者的家人遭受的不公平对待一路成长的故事。歧视是普遍存在的，而且是可以理解的，消除歧视完全不可能，只能够在表面上暂时压制住，相敬如宾已经是最理想的状态。 寺尾他们的反应，跟以往直贵曾告诉过刚志事情的别人完全不同，要说表现出露骨的冷淡或者态度突然变化的并不多，但大多数人就像外国风味餐厅店长那样，很快地垒出了一堵墙，只是不同人垒出的墙有厚有薄而已。但在寺尾他们这里没有这种感觉，理由也许是他们心里还需要自己，这件事令人高兴。 别有事没事地来信就好了！这就是强盗杀人犯弟弟的想法。不写回信正是想疏远的意思，你怎么就没有意识呢？自己写的信，对弟弟来讲，是把他束缚在厌恶的过去的枷锁，怎么就不明白呢？ 朝美父亲对直贵说：“你呢，从朝美那受到了什么影响呢？”“和她一起说话的时候，”他舔了一下嘴唇，“会觉得通向自己不熟悉的另一个世界的大门简单地打开了。我以前只知道这个社会最底层的事情，虽然想向上走，可像是走进自己不熟悉的原始森林。她对我来说，就像是指南针、地图一样。”“简单说，是不是跟朝美交往以后，多少可以看到富裕人家的生活了。”“我所说的是精神上的东西。当然也有物质上的。如果可能的话，我也想成为富裕的人，所以对于那些成功人士过的是怎样一种生活也有兴趣，不过，那不一定局限于朝美小姐。” 餐桌上摆了四套松花堂便当，另外还有清汤。直贵一直以为会有自家做的饭菜。大概是很高级的饭店做的，便当盒里都是些好东西，不少是直贵第一次吃到的。不过，他想像着，如果自己不是个穷学生，作为朝美的男朋友，这位母亲肯定会自己动手做些好吃的饭菜来款待的。大概她判断，这个男孩不是值得自己特意动手做饭的对象。也就是说打算不靠诚意而靠金钱来完成今天这个仪式。 真是从心里喜欢朝美，直贵自己感觉。如果他不是富裕家庭里长大的，大概也会喜欢。可是，在梦想和她一起的将来时，不由得会想到她身上附有的一些东西，这也是事实。既没钱也没有力量，只是肩负着人生负债的自己，摇身一变进入上流社会——这种想象使他心里充满躁动。可以使，是把以往所有噩运一扫而光的机会。如果没有这样的事情，自己可能一辈子也不会从这社会的底层浮上来。想到这里，他就感到隐约的恐怖。 “杀人为什么不能容忍呢？因为被杀的人失去了意识，失去了一切。再活下去的欲望也好，生命被夺取的愤慨也好，都没有了。”“所以，要是杀人也可以的话，就会担心自己也可能被杀掉，那样的行为肯定不好。”“不过，这个理由，对于决心要死的人是行不通的。因为就连他自己也觉得被杀掉没什么。对这样的人，应该怎么劝导他呢？”“那样的话…也许他也有亲属或爱他的人，那些人会伤心的，所以别那样做。”“正式这样。人都有着各种关联，有爱情，有友情，谁也不能擅自将它切断。所以绝对不能认可杀人。从这个意义上讲，自杀也是不好的。所谓自杀，是杀掉自己。即便认为自己可以这样做，他身边的人也不一定愿意这样。你哥哥可以说像是自杀一样，他选择了社会性的死亡。但是，他没有考虑留下来的你会因此多么痛苦。靠冲动是不可能解决问题的。包括你现在受的苦难，都是对你哥哥所犯罪行的惩罚。”“如果被歧视对待就生气的话就恨哥哥吧，你是想这样说吧？”“你恨不恨哥哥是你的自由，我只想说，恨我们不合情理。要是稍微深入一点说，我们需要对你区别对待，这也是为了让所有的犯罪者知道，自己要是犯了罪亲属也会痛苦。”直贵看着平野，他脸上的表情很平淡。至今为止一直受到不公平对待，但听到这种行为是正当的看法还是第一次。“大概在小学等地方是不会这样教育的，也许会说犯罪者的家属也是受害者，应该以广阔的心怀接纳他们。不仅是学校，社会上的人们也是这样认识的。我想你哥哥的事情在你工作的地方也被传开了，可因此你受到过什么故意跟你找别扭的对待吗？”“没有。”直贵摇摇头，“倒不如说，大家比过去更客气了。”“你明白是什么理由吗？是因为你可怜？”“不是吧，感觉不是那种气氛。”“是因为怎样跟你相处才好，大家搞不清楚。本来不想跟你有什么瓜葛，可明显表现出那种态度又不道德。所以才格外小心地跟你接触。有反歧视那个说法，就是这样。” “如果误解，我们也感到为难。并不是说你这个人不可信赖，也没有因为你是罪犯的弟弟，有着相通的血脉，有可能会做同样的坏事这种不科学的想法。如果不信任你，就是这个地方也不会把你安置过来。不过，对于公司，重要的不是一个人本性如何，而是他与社会的相容性。现在的你是有欠缺的状态。” 自己现在所受的苦难，正是对刚志所犯下罪行做出惩罚的一部分。犯罪者必须要有这样的思想准备，就是自己犯罪的同时也抹杀了自己亲属在社会上的存在。为了显示这种客观事实，也需要存在歧视。以前直贵根部没想过这样的事情，总觉得自己被别人另眼看待，肯定是周围人的不对，一直诅咒着这是不合理的事情。没准这种想法是对自己的一种宽容。歧视不会没有的，问题是在这个基础上怎么做。想到原以为是自己一直努力过来的，直贵在心里否定着。自己一直是在放弃，只是在扮演着悲剧中的主人公。 2016.12.01《时生》猝不及防地看了一本穿越小说，网上评价都说很感人，确实是这样。时生对于自己在世界上存在的那十七年心存感激，回到过去让自己年轻时的父亲走上正轨、遇到母亲。封底那段话更让人在意：东野周围的朋友都有了孩子，问及生孩子的原因，无非“顺其自然”之类的。但他们能否在孩子面前自信地问“作为我们的孩子，你觉得高兴吗？”孩子是否会回以“我非常庆幸有你们这样的父母”确实永远是个谜，这样的问题也绝对不能问出口。 “真了不起！竹美，真看不出你吃过那么多苦。”“吃了苦就挂在脸上那才叫惨哪。再说，悲观也没有用。谁都想生在好人家，可无法选择父母。发给你什么牌，你就只能尽量打好它。我并不觉得你的牌很坏。” “你不是坏蛋，但完全就是个小孩子。”“什么？”拓实回头瞪着竹美。“打个招呼又怎么了？你们不是有血缘关系吗？”“已经被扔掉了，还谈什么血缘不血缘！”“不能说扔掉吧。那是为你考虑，将你托付给条件好一些的人。”“养不起就别生啊。怎么？这么说不对？”“不生就没现在的你了，这也无所谓吗？”“不出生，有什么好不好的呢？”竹美摇头，叹了口气，“你这个人不可理喻。时生，你别管这个傻瓜了。”“你从没觉得来到这个世界真好吗？”时生说道，“你现在不是喜欢千鹤吗？今后你也会喜欢各种各样的人，正因为活着才能这样。” “你明白面对死亡的人的心情吗？开什么玩笑！当时大火已经烧到眼前，在这种时候，你能说出未来这样的话？确信自己喜欢的人能好好活着，即使面对死亡，也看到了未来。对你父亲来说，你母亲就是未来。人不论在什么时候都会感受到未来。无论是怎样短暂的一个瞬间，只要有活着的感觉，就有未来。我告诉你，未来不仅仅是明天。未来在人心中。只要心中有未来，人就能幸福起来。因为有人教了你母亲这个，她才将你生下来。可你看看自己，整天牢骚满腹，不思进取。你感受不到未来不能怪别人，要怪你自己，因为你是个混蛋！”说完，时生像是突然回过神来一样，睁开了眼睛，半张着嘴松开了抓住拓实的手。“这些话不应该由我说。我再怎么说，你不理解也是徒劳。但是，拓实，我为自己来到这个世界上感到欣慰。” 千鹤微微一笑，眨了眨睫毛：“我是个狡猾的女人，最终会在心里衡量：一边是收入稳定的工薪族冈部，一边是无业的拓实哥，跟谁一起过对自己的将来更有利？我要是跟他说你的事，或许他就真的死心了，可我也想留着他那张牌。”“真的？”“理由太多了。我家穷，上不起护士学校，陪酒挣的钱也要寄回家。一句话，就是累，觉得这样没法过上好日子，人生毫无前途。当时我正苦闷着呢，觉得冈部求婚正是不可多得的良机。”“那就是说我不行？”“要是拓实哥你向我求婚，就最好不过了。如果你肯好好工作、肯要我做老婆的话。”拓实低下了头。他觉得自己没有权利指责千鹤这种不安的想法。千鹤说过很多次，要他好好工作，可他老唱对台戏。他根本没去用心找正经工作，老觉得没有工作并不是自己的错，责任全在于将自己扔掉的人。他还总想一夜暴富，老说一些虚张声势的空话。 2016.11.30《放学后》终于看了这本东野圭吾的成名作，不过还是更喜欢他之后登上巅峰的那些作品。案件本身还是挺让人意外的，但到后面已经可以看出主人公的老婆已经有情况了，结局也就不是那么令人意外了。 我在黑板上列出难解的公式，时而回头看看学生，她们的表情仍那么虚无。一、二年级的学生脸上多少会有“为什么非要学这种东西”或“数学这种东西根本没什么用”之类反抗的神色，到了三年级，她们好像已经不再有那种无意义的疑问，代之以一副“好吧好吧你说你的好了”的表情。 村桥扶了扶眼镜：“大概当女中老师本身就是失败的开始。不管你怎么标榜现在是职业女性的时代，大多数女人还是一结婚就会走进家庭。这所学校里，有几个学生希望将来进入一流企业，干得比男人出色，去出人头地？几乎所有学生都只想升入随便玩玩就能毕业的短期大学或者女子大学，毕业后随便上几天班，一旦找到合适的对象就马上结婚。对这样的学生来说，高中也只是她们的游乐场。拼命教这样的学生做学问…越想越觉得我的人生真无趣…” “我能说的是，我们普通人在决定胜负的紧要关头需要精神支柱，但比赛时孤身一人，无所依靠，拿什么做支柱呢？只有拿事实，就是自己曾付出努力这个事实，相信自己平时舍弃娱乐时间拼命训练，一定会有好结果。” 村桥原来担任的课也分配完毕。我接了三年级A班的课，课程比以前更紧了，但也无可奈何。训导主任由小田接任。对于村桥离世的反应，学生也好，教师也好，都同样在变淡薄。只不过短短几天，一个人就被完全抹杀掉。这让我重新思考自己存在的价值。 大谷点头道：“我也有过好几次经验，知道青少年的心会被一种超越法律和社会规范的强大力量左右，我觉得，这次调查之所以无法克服障碍，原因也在这里。几乎没有目击者或证人，照理说应该会有人知道些什么，却不去积极告知警方。她们并非知道凶手是谁而庇护，而是不管凶手是谁，都不希望她被逮捕，因为她们可能本能地理解凶手的切肤之痛。这是一种同谋。我感觉，清华女中全校上下似乎都在隐瞒真相。” 2016.11.27《恶意》心机男将自己的恶意通过层层伪装释放的故事，采用各种第一人称表述，有比较强的代入感。加贺在这本书中卸下了“完美警探”的外衣，回首了他在当上警察之前的一段较为失败的教师经历。校园暴力应该是各国普遍存在的难题，犯罪低龄化是非常可怕的趋势，『未成年人保护法』成了『未成年人渣保护法』，东野写这本书大概也是有一份唤醒社会关注的意图吧。 “简单来说，现在的父母都不看书了，却一味地逼着小孩去读。可是由于自己没有阅读的习惯，所以也不知道该给孩子看什么书才好，结果只能把政府推荐的图书硬塞给他们。不过那种书通常内容生硬又无趣，只会让孩子更讨厌书本。这种恶性循环应该会周而复始吧。” 野野口老师真的很不喜欢教书这份工作。正因为他不想操心学生的问题，也不想担负额外的责任，才会尽可能冷静处理所有事情。我不知道教师这份职业究竟对他意味着什么，不过有一次他亲口对我说过：“老师和学生的关系建立在一种错觉之上。老师错以为自己可以教学生什么，而学生错以为能从老师那里学到什么。重要的是，维持这种错觉对双方而言都是件幸福的事。因为若看清了真相，反而一点好处都没有。我们在做的事，不过是教育的扮家家酒而已。” 小说里并没有明确说明滨冈何以成为众人欺负的目标。根据滨冈自己的说法，“就好像某天突然被贴上恶魔的符咒一样”，校园暴力事件就这么开始了。这可说是古往今来所有校园暴力的共同点。虽然他不想屈服，但渐渐地，内心终被恐惧与绝望支配。“令他害怕的，并非暴力本身，而是那些讨厌自己的人散发出来的负面能量。他从来没有想象过，在这世上竟然会有这样恶意的存在。” 没错，校园暴力被炒得像是天大的社会问题，但我偷偷告诉你，我以前也常欺负人。嘿嘿，孩子嘛。不过，我觉得那种事也有存在的必要。我不是在找借口，你看，一旦进了社会，就有一大堆讨厌的辛苦差事等着你做，酒吧这种事当作步入社会前的联系不就得了？如果能从中全身而退，也能获得应有的智慧，不是吗？我是这么想的，最近大家未免太小题大做了，只不过就是欺负一下。 校园暴力事件绝不可能销声匿迹，只要当事人都还在学校，就会一直持续下去。你从头到尾都被欺负，只是欺负的形式不同罢了。当老师说“已经没有这类事件”的时候，只不过是他个人的幻想。不难想象，那起强暴案成为你心中难以治愈的伤痛。你恐怕不是因为喜欢才做那种事情的。你心里很清楚，只要违背了藤尾正哉，你又要重新过受尽凌辱的悲惨日子。因为害怕这点，纵使百般不愿，你还是让自己的手沾上这么肮脏的事。一想到当时加在你身上的罪恶感和自我厌恶，我这个局外人也感到十分心痛。仔细一想，你当时所承受的最大暴力，就是被迫成为那场暴行的共犯。 “我就是看他不爽”这句经典台词你应该记得吧。我想你的心境应该也是这样。在你心里深藏着对日高的恶意，这仇恨深得连你自己都无法解释，而它正是造成这次事件的缘由。我非常仔细地调查过你们二人的过去，然而发现没有任何理由足以让你怨恨日高。他是个很好的少年，又是你的恩人。你和藤尾正哉曾经联手欺负他，他却反过来救了你。但我知道这样的恩德反而招致了怨恨。因为在他面前，你不可能没有自卑感。然后你长大成人了，又不得不陷入嫉妒日高的泥淖。这世上你最不想输给他的人，竟然率先一步成了作家。但你还是去拜访他，因为你一心想成为作家，于是你暂时镇封住心底隐藏的恶意。我相信你心底的恶意是在意识到死亡的那一刻解开的。你无法忍受就这样带着对日高的恶意离开人世，而引燃这股恶意的，是日高握有你过去的秘密这一事实。 从你和你母亲过去的言行，我感到你们好像对日高以及当时的邻居存有某种偏见。但我敢说，不论如何丑恶的偏见，它的产生绝对不是历史和地域的错。青少年时期，你之所以讨厌日高，理由之一恐怕就是你母亲不自觉流露出的那份轻蔑。 2016.11.21《新参者》一本让我对加贺系列产生兴趣的书，一个大背景下述说了多个家庭的故事，都特别温暖人心。不过现实中这种争执不和背后，有多少能像书中描述的那样“有自己的交流方式”进行和解？可能就是因为现实中罕见，让这样的描写格外令人感动。凶杀案推理本身没什么可说的，但是一个个人物都特别丰满。强推！（最后那句“加贺，你到底是什么人物”迷之神似柯南） 两人把尚哉夹在中间，你一言我一语地拌嘴。这时他不能替任何一方说话，只好缩着脖子，唯唯诺诺。但那两人不会容忍他的沉默，最终会一起逼过来，同时向他犯案：“你倒是说点什么啊。”“真受不了。”尚哉挠挠头，满脸堆笑地转向她们，“让我想想，总之先吃饭吧。”婆媳俩随后沉默不语，在沉闷的气氛中默默吃饭。这是柳泽家经常出现的场景。尚哉也想不出解决的办法，他向年长的同事咨询。“那不可能。”同事立刻回答，“男人解决不了婆媳间的矛盾。事情没那么简单。你能做的就是倾听各自的说辞。只要默默听就行，一定不要反驳，不然只会火上浇油。听完就做出理解的表情，说她有道理，说得对，然后告诉她会找机会把她的想法转达给另一方。当然，千万不要真去转达。总有一天，她还会责问你，事情办得怎么样了。到时你就忍，让她们把矛头指向你。你能做的只有这些。” “加贺先生，原来你不是在调查案件啊。”“当然在调查啊，但刑警的工作不止这些。有人会因为案件而留下心灵创伤，他们也是受害者。刑警的职责就是寻找能够拯救受害者的线索。”多美子深深鞠了一躬。 上杉再次认识到，所谓的孩子，终究只是这样的生物。他们误以为自己是凭一己之力长大的，很快就会忘记父母曾给予的保护。据说清獭弘毅从大学退学当了演员，但正因为他当时是个大学生，才有闲工夫沉迷于演戏。看到清獭弘毅，上杉觉得这个人还没有长大。他的父母还必须严加监管，以防他走上歪门邪道。一个人到底有没有成熟，和年龄没有关系，需要父母判断。这种判断对孩子的人生来说非常重要，而且只有父母能那么做。他们又调查了清獭弘毅，发现他和一个叫青山亚美的女服务生同居。房子是女方租的，他只是蹭住。果然不出所料，上杉心中嘲笑。根本就不是独立生活，只是换了保护人而已。上杉心想，自己如果是直弘，生拉硬拽也要把弘毅带回家。 加贺探了探身子，“我工作时常想，残忍的凶杀案发生后，我们不仅要将凶手抓获，还有必要彻查案件发生的原因，否则同样的事情可能还会发生。真相中有很多值得我们学习的东i。清獭弘毅就学到了，所以变了。” “我的确疼爱儿子，而且对这点很自信。但疼爱和重视不一样。所谓重视，是考虑孩子的将来，不断为他做出最好的选择，我却没能那么做。我只是为自己有一个可以倾注爱的对象而极其高兴。”上杉又喝口茶。“当然，孩子总有一天会长大，不会永远那么可爱，有时还会闯祸。这种时候，父亲往往会选择逃避。工作一忙，他们更为自己找到一个体面的借口。我也一样。妻子跟我说起儿子时，我只嫌她啰嗦，根本不想跟她一起解决问题。当妻子因此责怪我时，我总会说自己有工作。即便工作不忙，我也总把这句话当武器，将所有麻烦都推给妻子，甚至在听说儿子交了狐朋狗友时，我也并不在意。我乐观地以为，稍微活泼一点的男孩子总有一段时期会这样。实际上，我的乐观只是自欺欺人。” “我没能保护做了错事的儿子，而是将他推向了更坏的方向。我是个不称职的父亲，也是个不称职的警察。即便被孩子恨，父母也要将孩子引导到正确的方向，只有父母能这么做。” 2016.11.15《圣女的救济》说是汤川草薙长篇第二弹。有意思的是第一节和第二节之间看似无缝连接，其实时间跨度很长，这也是犯案的关键所在。这个错觉让我迟迟搞不清楚女主到底是什么时候投的毒。话说回来，东野又描绘了一个心机婊的形象，不论内心还是表面都无比强大，这是不是和他现实经历有所呼应？ “你觉得他太太这人不简单？”草薙问。“虽然现在一切都不好说，但我总觉得她这个人非常聪明。不仅聪明，还很能忍。”薰回答。“所以她连丈夫外遇都忍了？”“她知道即使大闹、大骂一通，也不会得到任何好处。一闹，反而会失去两样宝贵的东西——稳定的婚姻生活和优秀的弟子。”“的确，总不能把丈夫的婚外情对象一直留在身边啊。她这种虚有其表的婚姻生活，又有什么价值呢？”草薙问。薰说：“人的价值观是多种多样的。如果是因为地位而烦恼，还说得过去，但真柴夫妇看起来幸福美满，还能举办家庭派对，至少表面上看起来是如此。在金钱方面，也不需要付出辛劳，她能够专心做她喜欢的拼布。我觉得她并不是一个会因为一时冲动，而让这种生活泡汤的傻瓜。或许她打算等待丈夫和弟子之间的婚外情自然消亡，结果她等于没有失去任何东西。” “犯罪手法和魔术是不同的。当然了，这两者都是有诀窍的，但处理的办法完全不同。魔术的话，演出一旦结束，观众也就失去了识破诀窍的机会。然而对于犯罪手法，警方是能够对作案现场展开充分搜查，直到满意为止的。只要设过陷阱，就必然会留下痕迹。必须将这些痕迹给彻底抹掉这一点，可说是犯罪手法中最为困难的一点了。” 2016.11.07《歪笑小说》又是几个短篇，全部都是讲小说家和出版社的，小说家热海和寒川实在是太搞笑啦，在图书馆拼命憋着不让自己笑出声。 青山想，狮子取的过人之处就在于，什么事他都能脸不红心不跳地做出来。有些事要放在普通人身上，早就因为良知或是羞耻之心而产生动摇，狮子取却能毫不犹豫地付诸行动。即便让其他人大跌眼镜，那有什么关系。他坚信，只要赢得作家好感，就是胜利！ “那伙人可都是因为干不成普通工作才当作家的！那些家伙和小孩没什么两样。暑假作业不到八月三十一日是不肯做的，他们跟小学生一个德行。不，还有比这更恶劣的家伙，满不在乎地完全无视交稿日期，耍着威风不说，还降低原稿质量。连载小说之类的没人读？是啊，一点都没错。这一点那些作家也知道。他们还知道小说杂志亏损得厉害。根本成不了商品，他们也心知肚明。尽管如此，他们依旧装作一无所知，堂而皇之地来夺取稿费。就算这样煞费苦心得来的原稿，也还只是你们刚才所说的那种草稿水平。曼也错漏字不说，自相矛盾讲不通的地方也不罕见。‘老师，这个登场人物在上上回就死掉了呀’‘哦，是吗？那等做单行本的时候再改好啦。’这样的情况比比皆是，要是让他们修改，他们反而会恼羞成怒，甩出一句‘假如这么麻烦，今后我都不跟你出版社合作了’。那些家伙经常把这句话挂在嘴边。无可奈何，我们也只能拼命想办法，竭尽所能地把那种草稿水平的糟糕原稿修改到可读的程度。我们也不想卖有缺陷的商品！所以拼了命地帮那些作家擦屁股。” 2016.11.04《解忧杂货店》这是目前我所看过的东野圭吾作品中最喜欢的一本，因为全程都是温暖和感动，没有那种让我咬牙切齿的人物。书中无数精妙的巧合，时空隧道的设定，编织成这样一个完美的故事。这几天发生的事有点让我焦头烂额，下午去完LN老师那，顺路到图书馆读了这本书，真的很暖。谢谢你，东野圭吾。 “有人肯倾听烦恼就已经很感激了——很多人不都会有这种感受吗？这个人的苦恼没法向周围人倾诉，所以很痛苦，就算我们给不了什么好建议，回上一句‘你的苦恼我已经明白了，请继续努力’，她也会多少哦得到点安慰吧？” 克朗考上了东京某大学的经济学院。其实他很想走音乐之路，但知道父母一定会反对，所以放弃了。继承家里的鱼店，是他从小酒杯规划好的人生路线，父母似乎压根儿没想过他会选择其他的道路，他自己也模模糊糊地觉得自己这辈子应该就这样了吧。大学里有很多音乐社团，但克郎很快就失望了。社员们整天只顾着玩，根本感受不到对音乐的诚意。他们根本不是一路人。此后他也没有加入别的社团。他觉得一个人奋斗更轻松自在。跟没有干劲的人在一起厮混，只会徒增压力。 “不管骚扰还是恶作剧，写这些给浪矢杂货店的人，和普通的咨询者在本质上是一样的。他们都是内心破了个洞，重要的东西正从那个破洞逐渐流失。证据就是，这样的人也一定会来拿回信，他会来查看牛奶箱。因为他很想知道，浪矢爷爷会怎样回复自己的信。你想想看，就算是瞎编的烦恼，要一口气想出三十个也不简单。既然费了那么多心思，怎么可能不想知道答案？所以我不但要写回信，而且要好好思考之后再写。人的心声是绝对不能无视的。” “这么多年的咨询信看下来，让我逐渐明白了一件事。很多时候，咨询的人心里已经有了答案，来咨询只是想确认自己的决定是对的。所以有些人读过回信之后，会再次写信过来，大概就是因为回答的内容和他的想法不一样吧。” 2016.11.02《嫌疑人X的献身》两个全能理工男汤川和石神的对决，智商超高的石神的“痴情而不得”的形象似乎能引起不少现实中理工男的共鸣，再加入一个对理工科敬而远之但对案情真相步步紧逼的草薙，非常精彩。石神的感情和他为此做出的牺牲想必也感动了自己，但仍不足以从靖子那里换来爱情，他为她做了这么多而她却在思考如何摆脱这种被人掌控、不敢背叛的局面，这种心理描写非常真实。 石神对全班说：“数学这门课就是为了这样的人而设的。在此我要声明，我现在教你们的，只不过够你们站在数学这个世界的小小入口。如果不知道哪里是入口，自然无法进入。当然，讨厌数学的人可以不进去。我之所以要考试，只是想确认，你们是否知道入口在哪里。” “之前我去银座的酒廊打听消息时，那里的领班还说，泡沫经济时期每晚报到的人真不晓得现在都在哪里喝酒。原来都流落到这种地方了。”“那可不见得。人一旦尝过奢华的滋味，就很难再降低水准。在这里喝酒的人，肯定和银座一族不同。” “石神这个人很单纯。他寻求的答案，向来很简单。啊绝不会同时追求好几样东西，而他达成目的的手段也很简单。他从不会迟疑，也不会为一点小事轻易动摇。不过，这也意味着他不擅长生存之道，不是赢得全部就是满盘皆输，他的人生随时伴随着这种危险。” 石神并不排斥森冈这种质疑的态度，对于为何要学习某种东西抱有疑问，本事理所当然。唯有疑问解除了，才会产生求知的欲望，才能走上理解数学本质之路。可惜大多数老师不愿回答这种单纯的疑问。不，是答不出。他们也没有真正理解数学，只是按照既定的教材照本宣科，只想着让学生拿到好分数。对森冈提出的这种质疑，恐怕只会觉得不耐烦。而石神也只能自嘲，自己正在让学生接受与数学本质无关、纯粹只为了拿分数的考试。无论是打分还是借此决定及格与否，都与数学无关，也与教育无关。 汤川对学生不满地说：“之前我不是说过吗？所谓考察，就是思考之后仔细省察得到的结论。如果因为实验得到了预期的结果就感到庆幸，那就太浅薄了。更何况，本来就不可能完全如你预期的那样。希望你能从试验中发现一些道理，好好想一想，重写。” 汤川点头道：“你我都不可能摆脱时钟的束缚，彼此都已沦为社会这个时钟的齿轮。一旦少了齿轮，始终就会出乱子。纵然自己渴望率性而为，周遭也不容许。我们虽然得到了安定，但失去自由却也是不争的事实。在游民当中，应该有不少人并不想回到原来的生活。” 身体受到束缚不算什么，只要有纸和笔，就能解数学题。手脚被绑了，思维还能活动。纵使什么都看不见，什么都听不到，也无人能把手伸到他脑子里。对他来说，那里就是无垠乐园，永远沉睡着数学这座矿脉。要把那些矿藏统统挖出来，一生的时间未免太短。 2016.11.01《毒笑小说》也是若干独立的小短篇，前面有几篇讲家庭里的老人/小孩，描写得真的是太搞笑了！ “别看他们都才5岁，他们已经成了‘等待指示族’。因为从小就被教育，无论做什么事情都必须遵照父母和老师的指示，结果没有指示就什么都不会做。”“那不和近来的上班族没两样吗？”钱箱说。“原因是同样的。只不过小孩入学考试难的问题日益低龄化，症状也出现得更早罢了。”“哎，日本快没救了。”老人们继续乘车漫游，观察别的孩子。有个女孩担心衣服弄脏了被妈妈责骂，别说上车玩，连坐长椅都不敢，一直站在一个角落。还有个男孩虽然热切地望着过山车，却不肯自己去坐，原因是“我不太会玩”。显然，他已经被一种强加的观念束缚了手脚，认为任何事情要么不做，要么就做到最漂亮。“怎么搞的，这些小孩一点都没有小孩的天性，简直就是身心俱疲的中年人变来的。”“这么小的孩子就得整天埋头学习，能有什么好的结果？他们的父母丝毫没有发现，其实这些孩子在被我们绑架之前，就已经被绑架了——被学历社会这个妖怪绑架了。” “只要对那颗星球上的统治生物此前的行为模式稍加分析，就能料想到。他们表面上摆出重视其他生物的姿态，骨子里却极端反复无常，任性妄为。是否允许一种生物的存续，全视对自己的利弊而定。他们对待环境的态度也如出一辙，对环境方面的最大追求就是尽量让自己居住得舒适，也因此才会清除放射性物质。” 其中要子最关注的是交友情况。茂秋每天放学回到家，首先要向要子毫无隐瞒地报告学校里发生的事。只要带出一个陌生名字，要子立刻就会问：“那个中村同学，是个什么样的孩子？家里是做什么的？”假如他回答不知道，要子当场就会打电话给班主任，连对方的成绩、学习态度、家庭环境都一一刨根究底。如此了解到相关资料后，要子就会对茂秋今后是否可以和对方交朋友作出判断。很多时候她都会告诫“以后别老和xx玩了。”这样，茂秋只能唯唯答应，之后常常躲到自己房间里哭泣。因为母亲禁止交往的朋友多半都很有魅力，在一起玩得很开心。而要子说“一定要和他好好相处”的孩子，总是既无趣又老实巴交。 为了防止路上有不良诱惑，要子亲自把放学的各条路线都视察一遍，最后选出一条她认为最安全的作为上学路线。她坚决禁止茂秋从其他路线回家，倘若因为某种缘故不能走那条路，茂秋就要打电话由要子指示他如何选择。茂秋当然也想走走别的路线，但他无法付诸行动，只要一想到在母亲面前败露时，会遭到怎样的痛斥，他就无论如何都拿不出勇气。至于“不可能败露”这种想法，从来就没出现在他的脑海里，因为他至今没有一次成功瞒过母亲。此外，茂秋还没有零用钱，有要买的东西就要向要子如实报告，由要子判断能不能买。但实际上茂秋提出的要求寥寥无几，最重要的原因恐怕还是他没有什么想要的东西，更确切地说，就是“完全不知道市面上正在流行什么，也想不出要的”。他对社会的了解，除了唯一的上学路径上的见闻，而他接触的咨询也受到全面控制，一天只允许一小时电视，还必须是NHK。书籍方面，漫画杂志全禁止，现代作家作品不论纯文学还是大众文学一律禁止，音乐也只允许古典音乐。 2016.10.26《黑笑小说》 几个短篇，夸张地讽刺了一些现象和心态，看着让人发笑。前面几篇小说家和出版社的故事特别有意思。 “夏井老师身为文坛泰斗，却对青年作家燃烧着强烈的竞争意识，如果某人的作品会冲击他的读者群，他的观点就变得十分刻薄。而寒川已经不年轻了，作品风格也与他迥异，不会成为他的竞争对手。” 2016.10.25《白夜行》史诗级巨作。悉数登场的几十号人物，亮和雪的迷之关系，令人愤慨心痛的情节，读完心头如同压着一颗巨石。 一成第一眼看到江利子就受到吸引，但究竟是哪一点吸引了他，他却说不清。唯一能够确定的，便是她不是别人为他介绍的，也不是主动接近，而是靠他自己的眼光发现的女孩。仔细想想，这种情况好像不仅止于男女交往。无论是玩具还是衣物，权势别人准备好的。没有一样东西是自己找到、渴望并设法取得的。因为所有东西都已经事先为他准备好，很多时候，他甚至没有想过那些究竟是不是他要的。选择这所大学的经济系，就因为许多亲戚都毕业于同一所大学。选择社交舞协会作为社团活动，也不是他决定的——他父亲以妨碍学业为由，反对他从事社团活动，唯有社交舞或许在社交界有所帮助，才准许他参加。 诚开始因雪穗在股市和楼市的成功而产生淡淡的自卑。他渐渐认为，论生活能力、经营管理能力和大胆果断这几点，他可能都比不上这个女人。他并不清楚她事业上的成绩如何，但可以肯定的是她的服装店业绩蒸蒸日上。相形之下，自己呢？根本没有开创的勇气，只以个性适合为人所用为由，赖在公司不敢走。得天独厚继承的地产也不曾好好利用。还有一事让他抬不起头，那便是当前的股票热。他们家与股票无缘，当然是他因为妻子以股票为中心的生活而发过火，一想到她如何看待这场空前的股市狂飙，他就浑身不自在。 雪穗叹了口气：“真羡慕你。”“啊？”诚看她。“因为你每天可以这么过呀，喝你的酒，看你的职棒报道…”“这有什么不对？”“没什么，就是羡慕你而已。”雪穗掉头走向卧室。“你先别走。你什么意思？你到底想说什么？”雪穗转身面对诚：“我是在想，难道你没有梦想、没有抱负、不求上进吗？难道你打算就这样放弃一切努力，不再磨练自己，每天就这样无所事事地老去吗？” 2016.10.24《国境以南 太阳以西》 在终极本质上我这个人是可以作恶的。诚然我一次也没有动过对谁作恶的念头，然而动机和想法完全是两码事，总之我是可以在必要情况下变得自私变得残忍的，就连本应悉心呵护的对象我也可以找出冠冕堂皇的理由给予无可挽回的决定性的伤害。我看出我自己仍将一直重复相同的错误，同样伤害别人、同时损毁自己。 她诚然漂亮得令人窒息，却又不像是女演员或模特。店里常有这类人出现，但她们总有一种意识，知道自己被人注视，身上总有隐隐漾出自命不凡的氛围。但这个女子极其自然地放松下来，同四周的空气完全融为一体。 2016.10.23《斯普特尼克恋人》 “想的全是烟。根本睡不实，一睡就做恶梦，文章也写不出来。”堇时不时半夜来电话。“这情形戒烟时谁都要碰到，多多少少。”我说。“说别人怎么说都容易。”堇接道，“首先你生来就没吸过烟，不是吗？”“如果说别人都不容易，这个世界可就阴冷透了危险透了。” 我站在讲台上，面向学生讲述和教授关于世界、生命和语言的基本事实，但同时也是通过孩子们的眼睛和思维来向自己本身重新讲述和教授关于世界、生命和语言的基本事实。只消在方法上动动脑筋，即可成为新鲜而又有发掘余地的作业。我也因之得以与班上的学生、同事以及学生家长大体保持良好关系。 同堇见面交谈的时间里，我能够感觉出自己这个人的存在。比之自己开口，我更热心于倾听她的讲述。她问我各种各样的问题，求我给予解答。不回答就表示不满；而若回答不实际有效，又动真格地气恼。在这个意义上，她和其他很多人都不同。堇从内心深处寻求我对其提问的见解。所以，对于她的提问我开始给予一丝不苟的回答，并通过这样的回答来向她（同时也向我本身）袒露更多自己。 敏以沉稳的语气说道：“变强本身并不是坏事。但如今想来，我太习惯于自己是强者这一点了，而不想去理解众多的弱者。太习惯于健康了，而不想去理解不巧不健康的人的痛苦。每当见到凡是焦头烂额走投无路的人，就认为无非是其本人努力不够造成的，将常发牢骚的人基本看成懒汉。当时我的人生观，虽然牢固而又讲究实际，但缺乏广博的温情与爱心，而周围没有任何人提醒我注意这一点。十七岁就不再是处女了，那以后同数量绝不算少的人睡过。但一次也没爱过——打心眼里爱过——哪个人。老实说，没有那种闲工夫。总之满脑子都是当一流钢琴手的念头，绕道和顺路之类从没考虑过。而意识到自己的空白——缺少什么的空白时，早已经晚了。” 2016.10.22《舞舞舞》 顶峰——这东西于我根本不曾有过。回首望去，甚至觉得人生都无从提起。起伏自是有一点，匆匆爬上，草草跑下。如此而已，一无所成，一无所有，既未爱过别人，又未被人爱过。道路平坦之至，场景单调之极。仿佛在电子游戏机荧屏上往来彷徨，偶如大力士那样不断张大嘴巴吃掉迷途中的虚线。途中漫无目的，唯死确凿无疑，迟早罢了。 五反田举着酒杯：“怎么说呢，你看上去好像我行我素，至于别人怎么看怎么想，你好像不大放在心上，只是做自己想做的事情，并设法做的容易一些。就是说，你确保了完整而独立的自己。我呢，总是优等生，从懂事起就是。学习好，人缘好，长相好，老师信赖父母信赖，在班里总当干部，体育又好，搞不清为什么。每次有棒球比赛，大家就来叫我，我不好拒绝。演讲比赛必定让我当代表，老师让我上台，我不能不上，而一上就能拿名次。进学生会我也逃脱不了，大家都以为我肯定出马。考试时大家也都预料我必然名列前茅。从来不迟到。简直就像我自身并不存在，我做得仅仅是我以为自己不做就不妥当的事情。你不认为我的人生像画上画的？”“然而不知有多少人想画还画不了这么巧妙。”我说。“倒也是。幸运这点我承认。但转念一想，又好像自己什么都没选择。半夜醒来时每次想到这点，都感到十分惶恐：自己这一存在到底在什么地方呢？我这一实体又在哪里呢？我只不过是在恰如其分地表演接踵而来的角色罢了，主体上没做出任何选择。” 五反田举着酒杯：“我所处的就是这么一个世界，以为只要把欧洲车、名表拿到手就算一流。无聊透顶！这玩意儿不是自然而然产生的，而是如此人为地制造出来的、捏造出来的，其实无非是把谁也不需要的东西涂上十分需要的幻想色彩。容易得很，只要大量制造信息即可。有一些人总以为只要把这些东西搞到手就高人一等，就与众不同，，却意识不到为其如此才到头来落得个与众相同。”]]></content>
      <categories>
        <category>Book</category>
      </categories>
      <tags>
        <tag>reading</tag>
        <tag>novel</tag>
        <tag>literature</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Note for coursera Princeton Algorithm I]]></title>
    <url>%2F2016%2F11%2F02%2Fcoursera_algorithm1%2F</url>
    <content type="text"><![CDATA[Introduction to Algorithms I. All meterials credit to Princeton. Course Introduction Algorithms + Data Structures = Programs. Union-Find&lt; Dynamic Connectivity Connections are reflexible(p-&gt;p), symmetric(p-&gt;q, q-&gt;p) and transitive. Connected components: Maximal sets of objects that are matually connected. &lt; Quick-Find Data structure: Integer array id[]. p and q are connected iff(if and only if) they have the same id. Find: check if id[p] == id[q]. Union: merge components containing p and q, namely change all entries whose id equals id[p] to id[q]. Implementation &amp; Analysis: Quick-Find is a slow one for UF because the Union operation is O(N). Considering another O(N) for initialization, in total it takes \(N^2\)(quandratic) array accesses to process a sequence of N union commands on N objects.12345678910111213141516171819202122232425// Eager approach for Union-Findpublic class QuickFindUF &#123; private int[] id; public QuickFindUf(int len) &#123; id = new int[len]; for (int i = 0; i &lt; len; i++) &#123; id[i] = i; &#125; &#125; public boolean isConnected(int p, int q) &#123; return id[p] == id[q]; &#125; public void union(int p, int q) &#123; int pid = id[p]; int qid = id[q]; int len = id.length; for (int i = 0; i &lt; len; i++) &#123; if (id[i] == pid) &#123; id[i] = qid; &#125; &#125; &#125;&#125; &lt; Quick-Union Data structure: Integer array id[], but id[i] refers to the parent of i. Find: check if p and q have the same root. Union: merge components containing p and q, namely set the id of p’s root to the id of q’s root. Implementation &amp; Analysis: Quick-Union is still a slow one for UF. Since the tree might get very tall, Find can be really expensive and the Union will reach O(N) in the worst case because it includes Find operation.123456789101112131415161718192021222324// lazy approachpublic class QuickUnionUF &#123; private int[] id; public QuickUnionUF(int len) &#123; id = new int[len]; for (int i = 0; i &lt; len; i++) &#123; id[i] = i; &#125; &#125; private int getRoot(int i) &#123; while (i != id[i]) &#123; i = id[i]; &#125; return i; &#125; public boolean isConnected(int p, int q) &#123; return getRoot(p) == getRoot(q); &#125; public void union(int p, int q) &#123; int i = root(p); int j = root(q); id[i] = j; &#125;&#125; &lt; Improvements Weighted Quick-Union: In Quick-Union, to avoid tall trees, we can track the size of each tree and always link the root of the smaller tree to root of the larger one.-&gt; data structure: Same as Quick-Union, an array storing the parent. Need additional int array sz[] to store the number of objects in each tree.-&gt; Find: Same as Quick-Union, checking if the two items have the same root.-&gt; Union: Need to compare the size of the two trees before merging to make sure the smaller one is linked to the larger one. Don’t forget to update the sz[] afterwards.-&gt; Implementation &amp; Analysis: Tree is balanced by introducing sz[], and the Find takes time proportional to depth (at most \(lgN\) for N objects) of p and q, and Union takes constant time for given roots. 1234567891011121314151617181920212223242526272829303132333435public class WeightedQuickUnionUF &#123; private int[] id; private int[] sz; public WeightedQuickUnionUF(int len) &#123; id = new int[len]; sz = new int[len]; for (int i = 0; i &lt; len; i++) &#123; id[i] = i; sz[i] = 1; // only itself in its tree &#125; &#125; private int getRoot(int i) &#123; while (i != id[i]) &#123; i = id[i]; &#125; return i; &#125; public boolean isConnected(int p, int q) &#123; return root(p) == root(q); &#125; public void union(int p, int q) &#123; int i = getRoot(p); int j = getRoot(q); if (i == j) &#123; return; &#125; if (sz[i] &lt; sz[j]) &#123; id[i] = j; sz[j] += sz[i]; &#125; else &#123; id[j] = i; sz[i] += sz[j]; &#125; &#125;&#125; -&gt; Provement for proposition “Depth of any node x is at most lgN“:The depth of x increases by 1 when its tree T1 is merged to another larger tree T2. Since the size of T2 is larger than T1, the size of T1 at least doubles. The fact is that the tree containing x with size N can double at most \(lgN\) times. We can assume each time the tree containing x is merged, the newly-formed tree gets a doubled size N. So divide the size N by 2 again and again, we can trace back how many times was x added to this tree, which is exactly x’s depth, and obviously it can only be divided at most for \(lgN\) times. Path Compression: Flat the tree simply by adding one line of code to Weighted Quick-Union! Always update the direct parent in the query process.123456789101112131415161718192021public class WQUPC &#123; private int id[]; private int sz[]; public WQUPC(int len) &#123; id = new int[]; sz = new int[]; for (int i = 0; i &lt; len; i++) &#123; id[i] = i; sz[i] = 1; &#125; &#125; public int getRoot(int i) &#123; while (i != id[i]) &#123; id[i] = id[id[i]]; // assign current node to its parent's parent i = id[i]; // If i is not updated, it is id[id[i]]. &#125; return i; &#125; public boolean isConnected(int p, int q) &#123;...&#125; public int union(int p, int q) &#123;...&#125;&#125; Analysis of Algorithms&lt; Introduction Reason to analysis: predict performance, compare algorithms, provide guarantees and understand theoretical basis. More practically, avoid performance bugs. Intrisic estimate: lg(Thousand) is about 10. lg(Million) is about 20. lg(Billion) is about 30. &lt; Observations Timing a program:-&gt; Measuring the running time: manually or use code to automatically trace the elapsed executing time.-&gt; Empirical analysis: Use existing data of running time to estimate the unknown timing with different input scale. Usually we use Data analysis to find the regular between running time T(N) and input size N, which is assumed to be linear in the log-log plot. That is, \(lg(T(N)) = b*lgN + c\). Particularly, the ratio of \(lg(T(N))\) and \(lgN\)(slope in the log-log plot) can be estimated by take the lg value of the ratio of T(2t) and T(t). &lt; Mathematical models We can simply list all the operations in the program and their corresponding time as a function of input N in a table. But we have more choices to simplify the calculations. For example, we can only care about the most expensive part. Cost model: Select the most time-consuming operation to estimate. Among the N + 2, N(N - 1), 1/2(N + 1)(N + 2), the cost model is the largest one N(N - 1). Tilde notation: Ignore the lower order terms. N + 2\(\rightarrow\) ~N, N(N - 1)\(\rightarrow\) ~\(N^2\), 1/2(N + 1)(N + 2)\(\rightarrow\) ~\(\frac{1}{2}N^2\). &lt; Order-of-growth classifications The order-of-growth classifications can be represented by a small set of functions: 1, \(logN\), \(N\), \(NlgN\), \(N^2\), \(N^3\) and \(2^N\), whose log-log plot looks like this: Take a look at binary search. The Princeton version uses at most \(1 + lgN\) compares to search in a sorted array of size N. 12345678910111213141516171819202122232425262728293031323334// Princeton versionpublic static int binarySearch(int[] a, int key) &#123; int lo = 0, hi = a.length - 1; while (lo &lt;= hi) &#123; int mid = lo + (hi - lo) / 2; if (key &lt; a[mid]) &#123; hi = mid - 1; &#125; else if (key &gt; a[mid]) &#123; lo = mid + 1; &#125; else &#123; return mid; &#125; &#125; return -1;&#125;// My versionpulbic static int binarySearch2(int[] a, int key) &#123; int left = 0, right = a.length - 1; while (left &lt; right) &#123; int mid = (left + right) / 2; if (key &gt; a[mid]) &#123; left = mid + 1; &#125; else &#123; right = mid; &#125; &#125; if (a[left] == key) &#123; return left &#125; else &#123; return -1; &#125;&#125; &lt; Theory of algorithms Big Theta: Used to classify algorithms, take the exact order of growth. (term with maximum exponent) Big Oh: Used to develop the upper bounds, where the actual cost should be smaller or equal to the term. Big Omega: Used to develop the lower bounds, where the actual cost should be larger or equal to the term. Tilde: Provide approximate model. Many people mistakenly take Big O() as approximate model. Bags, Stacks and Queues&lt; Separate interface and implementation Client: program using operations defined in interface; Interface: description of data type, basic operations; Implementation: actual code making operations happen; Deciplined design: create modular, reusable libraries. Performance: try to optimize the implementations. Prefer compile-time error and avoid run-time error, so that we can have some confidence that it will work for any client. &lt; Stack LIFO: Last in first out. Implementation Detail:-&gt; Underflow: pop from an empty stack. Throw exception.-&gt; Overflow: resize array in array version stack.-&gt; Null items: Insertion of null items allowed?-&gt; Loitering: Holding a reference to an object when it is no longer needed? 12345678public String pop() &#123; return s[--N]; // the poped item still exists.&#125;public String pop() &#123; String item = s[--N]; s[N] = null; // Avoid Loitering: garbage collector will do the rest return itme;&#125; Resizing array version stack: In array implementation, every grow/shrink need to copy some existing items to new places. Too expensive!-&gt; Grow: Double the size when full.-&gt; Shrink: halve the size when 1/4 full. (1/2 would be too frequent when pop-push flipping) &lt; Queue FIFO: First in first out. Elementery Sorts&lt; Comparable total order-&gt; Antisymmetry: if \(v \le w\) and \(w \le v\), then \(v = w\).-&gt; Transitivity: if \(v \le w\) and \(w \le x\), then \(v \le x\).-&gt; Totality: either \(v \le w\) or \(w \le v\) or both. Callback: reference to executable code.-&gt; Java: Interfaces;-&gt; C++: class-type functors(伪函数，即);-&gt; C: function pointers;-&gt; C#: delegates;-&gt; Python, JavaScript: first-class functions. User-defined comparable types: Implement the Comparable interface for sort123456789101112131415161718public class Date implements Comparable&lt;Date&gt; &#123; private final int month, day, year; public Date(int m, int d, int y) &#123; // Constructor month = m; day = d; year = y; &#125; public int compareTo(Date that) &#123; // return - / 0 / + if (this.year &lt; that.year) return -1; if (this.year &gt; that.year) return +1; if (this.month &lt; that.month) return -1; if (this.month &gt; that.month) return +1; if (this.day &lt; that.day) return -1; if (this.day &gt; that.day) return +1; return 0; &#125;&#125; &lt; Selection Sort Idea: Scan from starting index i to right and select the index j of minimum value. Then swap(a, i, j).1234567891011private void selectionSort(Comparable[] a) &#123; for (int i = 0; i &lt; a.length; i++) &#123; int index = i; for (int j = i + 1; j &lt; a.length; j++) &#123; if (less(a[j], a[index])) &#123; index = j; &#125; &#125; swap(a, i, index); &#125;&#125; &lt; Insertion Sort Idea: Swap each larger item to a[i]’s left where a[0 ~ a-1] is already sorted.1234567private void insertionSort(Comparable[] a) &#123; for (int i = 0; i &lt; a.length; i++) &#123; for (j = i; j &gt; 0 &amp;&amp; less(a[j], a[j - 1]); j--) &#123; swap(a, j, j - 1); &#125; &#125;&#125; &lt; Shell Sort Idea: insertion sort with decreasing increment.1234567891011121314private void shellSort(Comparable[] a) &#123; int h = 1; while (h &lt; a.length / 3) &#123; h = 3*h + 1; &#125; while (h &gt;= 1) &#123; for (int i = h; i &lt; a.length; i++) &#123; for (int j = i; j &gt;= h &amp;&amp; less(a, j, j - h); j -= h) &#123; swap(a, j, j - h); &#125; &#125; h = h / 3; &#125;&#125; &lt; Bubble Sort Idea: Swap smaller value from the tail to the front at finished index i.123456789private void bubbleSort(Comparable[] a) &#123; for (int i = 0; i &lt; a.length; i++) &#123; for (j = a.length - 1; j &gt; i; j--) &#123; if (less(a[j], a[j - 1])) &#123; swap(a, j, j - 1); &#125; &#125; &#125;&#125; Integer SortThese methods can only be applied to integer collections or objects that can be mapped to integers. &lt; Bucket Sort Idea: Mark the items in original collection in the auxillary bucket. Then output the indices that have marks in order.12345678910111213private void bucketSort(int[] a) &#123; int bucket = new int[999999]; for (int i = 0; i &lt; a.length; i++) &#123; bucket[a[i]] ++; &#125; int j = 0, k = 0; while (j &lt; a.length &amp;&amp; k &lt; bucket.length) &#123; while ((bucket[k]--) &gt; 0) &#123; a[j++] = k; &#125; k++; &#125;&#125; &lt; Radix Sort Idea: Sort with each digit, from unit digit to tens, to hundreds, etc.1234567891011121314151617181920212223242526private void radixSort(int[] A, int radix, int maxLength) &#123; int[] temp = new int[A.length]; int[] bucket = new int[radix]; for (int i = 0, devide = 1; i &lt; maxLength; i++) &#123; Arrays.fill(bucket, 0); System.arraycopy(A, 0, temp, 0, A.length); for (int j = 0; j &lt; A.length; j++) &#123; int subKey = (temp[j] / devide) % radix; bucket[subKey]++; &#125; for (int j = 1; j &lt; radix; j++) &#123; bucket[j] = bucket[j] + bucket[j - 1]; &#125; for (int k = A.length - 1; k &gt;= 0; k--) &#123; int subKey = (temp[k] / devide) % radix; bucket[subKey]--; A[bucket[subKey]] = temp[k]; &#125; devide *= radix; &#125;&#125; Merge Sort&lt; Basic Idea: devide and conquer. Let the ordered subsequence merge to the whole ordered sequence123456789101112131415161718192021222324252627282930313233343536373839private void mergeSort(Comparable[] A, int start, int end) &#123; if (start &gt;= end) return; int mid = (start + end) / 2; mergeSort(A, start, mid); mergeSort(A, mid + 1, end); merge(A, start, mid, end);&#125;private void merge(Comparable[] A, int start, int mid, int end) &#123; int left = start; int right = mid + 1; int index = start; Comparable[] temp = new Comparable [A.length]; // the first half of A is in order. So as the second half. while (left &lt;= mid &amp;&amp; right &lt;= end) &#123; if (less(A[left], A[right])) &#123; temp[index++] = A[left++]; &#125; else &#123; temp[index++] = A[right++]; &#125; &#125; // Collect the rest part of A into temp. Only one of the whiles can execute. while (left &lt;= mid) &#123; temp[index++] = A[left++]; &#125; while (right &lt;= end) &#123; temp[index++] = A[right++]; &#125; // copy the merged sequence in temp back to A for (index = start; index &lt;= end; index++) &#123; A[index] = temp[index]; &#125;&#125; &lt; Improvement Insertion sort: When subarray is of small size, use insertion to get them sorted. Check before merge: When a[mid] &lt; a[mid + 1], the two subarray is already in order, so no need to merge.12345678910111213141516private void mergeSort(Comparable[] A, int start, int end) &#123; if (start &gt;= end) return; if (end &lt;= start + CUTOFF - 1) &#123; // CUTOFF MIGHT BE 7 insertSort(A, start, end); return; &#125; int mid = (start + end) / 2; mergeSort(A, start, mid); mergeSort(A, mid + 1, end); if (!less(A[mid+1], A[mid])) // Subarray already in order return; merge(A, start, mid, end);&#125; Switch a[] and aux[]: Elliminate the time to copy from a[] to aux[] by switching the sequence of parameters passing into merge() and sort() each time. &lt; Comparator Comparable and Comparator interface: the former is about sorting using a type’s natural order, and the latter is about sorting using an alternative order. Comparator类似一个外部的比较器，如果不指定，则会调用该类内部的comparable来比较。12345678910111213141516171819202122public class Point2D &#123; public final Comparator&lt;Point2D&gt; POLAR_ORDER = new PolarOrder(); private final double x, y; ... private static int ccw(Point2D a, Point2D b, Point2D c) &#123; double area2 = (b.x-a.x)*(c.y-a.y) - (b.y-a.y)*(c.x-a.x); if (area2 &lt; 0) return -1; // clockwise else if (area2 &gt; 0) return +1; // counter-clockwise else return 0; // collinear &#125; private class PolarOrder implements Comparator&lt;Point2D&gt; &#123; public int compare(Point2D q1, Point2D q2) &#123; double dy1 = q1.y - y; double dy2 = q2.y - y; if (dy1 == 0 &amp;&amp; dy2 == 0) &#123; ... &#125; else if (dy1 &gt;= 0 &amp;&amp; dy2 &lt; 0) return -1; else if (dy2 &gt;= 0 &amp;&amp; dy1 &lt; 0) return +1; else return -ccw(Point2D.this, q1, q2); &#125; &#125;&#125; &lt; Stablity Maintain the original order for equal value. Useless? No! Think about firstly sort by field A and then B, how to guarantee the correct order that is already set in field A when sorting two equal B value? Only stable algorithm can. Stable: Insertion, Merge Instable: Selection, Shell, Quick Quick Sort&lt; Basic Idea: Move the radix to somewhere so that the left-hand sides are all smaller than it and the right-hand sides are greater.12345678910111213141516171819202122private void quickSort(Comparable[] A, int start, int end) &#123; if (start &gt;= end) return; // recursion ending condition. int left = start, right = end; Comparable pivot = A[(start + end)/2]; // take random item as pivot. Here it is the middle. while (left &lt;= right) &#123; while (left &lt;= right &amp;&amp; less(A[left], pivot)) left++; // from left to right to find the first item not smaller than pivot. while (left &lt;= right &amp;&amp; greater(A[right], pivot)) right--; // from right to left to find the first item not greater than pivot. if (left &lt;= right) &#123; swap(A, left, right); // let the greater-than-pivot item swap with the smaller one left++; right--; // continue to &#125; &#125; quickSort(A, start, right); quickSort(A, left, end);&#125; &lt; Improvement Insertion sort: When subarray is of small size, use insertion to get them sorted. Median as pivot: Take sample 3 items to estimate the median of the list, and swap the median to the front as pivot. &lt; 3-way QuickSort Idea: Since quickSort goes quadratic unless partitioning stops on equal keys, in equal-keys-prevail array, put all items equal to the pivot in place by adding lt and gt. &lt; Usage Quick-Selection: Select the kth max/min item. Priority Queues&lt; Binary heaps binary tree: empty or node with links to left and right binary trees. complete tree: prefectly balanced, except for the bottom level. height of complete tree: \(\lfloor lgN \rfloor\) with \(N\) nodes.(???So one-node tree means 0?) binary heap: each parent has a larger key than its children.12345678910111213141516171819private void createMaxHeap(Comparable[] A, int end) &#123; for (int i = (end - 1) / 2; i &gt;= 0; i--) &#123; // Start from the father of the very last child int fatherIndex = i; while (2 * fatherIndex + 1 &lt;= end) &#123; // If the node has at least a left child int biggerIndex = 2 * fatherIndex + 1; if (biggerIndex &lt; end) &#123; // If it also has a right child if (less(A[biggerIndex], A[biggerIndex + 1])) biggerIndex ++; // Select the bigger one between left &amp; right &#125; if (less(A[fatherIndex], A[biggerIndex])) &#123; // If the father is smaller than the bigger child swap(A, fatherIndex, biggerIndex); fatherIndex = biggerIndex; // Continue to compare to the childen after swap &#125; else &#123; break; // father is already the greatest &#125; &#125; &#125;&#125; &lt; HeapSort Idea: Take the root of binary heap and rebuild the heap.12345678private void maxHeapSort(Comparable[] A) &#123; int size = A.length; for (int i = 0; i &lt; size; i++) &#123; createMaxHeap(A, size - 1 - i); swap(A, 0, size - 1 - i); // put the max root at the end &#125;&#125;private void createMaxHeap(Comparable[] A, int end) &#123;...&#125; Binary Search Trees(BSTs)&lt; Basic Definition: A BST is a binary tree with an order where each node’s key is larger than all keys in its left subtrees and smaller than all keys in its right subtree. Node: 4 fields - key, value, reference to left and right subtree. Improvement: Add one more field “int count” to track the size of each subtree at the corresponding root node. Help with rank() and select(); &lt; Operations Floor: get the biggest key that is smaller than the given key. 123456789101112131415161718192021222324252627public Key floor(Key key) &#123; Node x = floor(root, key); if (x == null) &#123; return null; &#125; return x.key;&#125;private Node floor(Node x, Key key) &#123; if (x == null) &#123; return null; &#125; int cmp = key.compareTo(x.key); if (cmp == 0) &#123; return x; &#125; else if (cmp &lt; 0) &#123; return floor(x.left, key); &#125; else &#123; Node t = floor(x.right, key); if (t != null) &#123; return t; &#125; else &#123; return x; &#125; &#125;&#125; Ceiling: get the smallest key that is bigger than the given key. Rank: The number of keys that are smaller than the given one. 12345678910111213private int rank(Key key, Node x) &#123; if (x == null) &#123; return 0; &#125; int cmp = key.compareTo(x.key); if (cmp &lt; 0) &#123; return rank(key, x.left); &#125; else if (cmp &gt; 0) &#123; return 1 + size(x.left) + rank(key, x.right); &#125; else &#123; return size(x.left) &#125;&#125; In-order traversal: Traverse the left subtree before output the current root value; tranverse right subtree after root output. &lt; Deletion Lazy version: Simply set the value of that node to null. But unsatisfying for memory overloaded. DeleteMin: Go left all the way until a node with null left link, and replace that node with its right link. Update the count. 12345678private Node deleteMin(Node x) &#123; if (x.left == null) &#123; return x.right; &#125; x.left = deleteMin(x.left); x.count = 1 + size(x.left) + size(x.right); return x;&#125; Hibbard deletion:-&gt; [0 children]: Set its parent’s corresponding link to null.-&gt; [1 child]: Set its parent’s corresponding link to its only child.-&gt; [2 children]: Find the key and put the minimum key in its right subtree on its spot. 123456789101112131415161718192021222324252627public void delete(Key key) &#123; root = delete(root, key);&#125;private Node delete(Node x, Key key) &#123; // Recursive code!!! if (x == null) &#123; return null; &#125; int cmp = key.compareTo(x.key); if (cmp &lt; 0) &#123; x.left = delete(x.left, key); &#125; else if (cmp &gt; 0) &#123; x.right = delete(x.right, key); &#125; else &#123; if (x.right == null) &#123; return x.left; &#125; else if (x.left == null) &#123; return x.right; &#125; else &#123; Node t = x; x = min(t.right); x.right = deleteMin(t.right); x.left = t.left; &#125; &#125; x.count = 1 + size(x.left) + size(x.right); return x;&#125; Balanced Search Trees&lt; 2-3 search trees Variable number of keys per node-&gt; 2-node: one key, two children. left &lt; key &lt; right.-&gt; 3-node: two keys, three children. left &lt; key1 &lt; mid &lt; key2 &lt; right. Insertion at the bottom:-&gt; 2-node: Simply add the key into it and yields a 3-node.-&gt; 3-node: Add the key and made it temporary 4-node, and then split it by passing the middle key into the parent node, and continue to pass up if necessary. Perfect balance: Every path from root to null link has the same length.&lt; red-black BSTs Idea: represent 2-3 search trees as a BST with two types of links. Null links are black. 123456789private static final boolean RED = true;private static final boolean BLACK = false;private class Node &#123; Key key; Value val; Node left, right; boolean color;&#125; Left-leaning: Force red link leaning to the left as valid glue of a 3-node. Rule:-&gt; No node has two red links connected(which means it’s a 4-node).-&gt; Every path from root to null link has the same number of black links.-&gt; Red links leans left. Search: Implemenation is the same but runs faster than BSTs because of better balance. 1234567891011121314public Val get(Key key) &#123; Node x = root; while (x != null) &#123; int cmp = key.compareTo(x.key); if (cmp &lt; 0) &#123; x = x.left; &#125; else if (cmp &gt; 0) &#123; x = x.right; &#125; else &#123; return x.val; &#125; &#125; return null;&#125; Elementary Operations-&gt; Rotate Left: When right leaning red links occurs, rotate it left. 123456789private Node rotateLeft(Node h) &#123; assert isRed(h.right); Node x = h.right; h.right = x.left; x.left = h; x.color = h.color; h.color = RED; return x;&#125; -&gt; Rotate Right: When a node has consecutive red links, rotate the upper red link right. 123456789private Node rotateRight(Node h) &#123; assert isRed(h.left); Node x = h.left; h.left = x.right; x.right = h; x.color = h.color; h.color = RED; return x;&#125; -&gt; Color flip: When two red links connected to same parent node, flip the color to split this 4-node. 12345678private void flipColors(Node h) &#123; assert !isRed(h); assert isRed(h.left); assert isRed(h.right); h.color = RED; h.left.color = BLACK; h.right.color = BLACK;&#125; Insertion at the bottom:-&gt; 2-node: Color new link red and rotate if right leaning.-&gt; 3-node: Color new link red and rotate and/or flip along the way to the root to keep balance. Pay attention to the order to cope with 3 kinds of situation that break the balance. 1234567891011121314151617181920212223private Node put(Node h, Key key, Value val) &#123; if (h == null) &#123; return new Node(key, val, RED); &#125; int cmp = key.compareTo(h.key); if (cmp &lt; 0) &#123; h.left = put(h.left, key, val); &#125; else if (cmp &gt; 0) &#123; h.right = put(h.right, key, val); &#125; else &#123; h.val = val; if (isRed(h.right) &amp;&amp; !isRed(h.left)) &#123; h = rotateLeft(h); &#125; // NOT elseif !!! if (isRed(h.left) &amp;&amp; isRed(h.left.left)) &#123; h = rotateRight(h); &#125; if (isRed(h.left) &amp;&amp; isRed(h.right)) &#123; flipColors(h); &#125;&#125; Geometric Search&lt; 1D range search Range search: Find all keys between k1 and k2. Range count: Number of keys between k1 and k2. BST RC: Simply use rank to get the range count. 1234567public int size(Key lo, Key hi) &#123; if (contains(hi)) &#123; return rank(hi) - rank(lo) + 1; &#125; else &#123; return rank(hi) &#125;&#125; BST RS:-&gt; Recusively find all keys in left subtree;-&gt; Check key in current node;-&gt; Recusively find all keys in right subtree; &lt; 2D orthogonal range search Range search: Find all keys lying in a 2D range. Range count: Number of keys lying in a 2D range. Data structure: BST using x and y coordinates alternatively. 2D tree RS:-&gt; Check if current node is in range(ractangle);-&gt; Recusively check all keys in left/bottom subtrees;-&gt; Recusively check all keys in right/top subtrees. Nearest neighbour search:-&gt; Check distance from current point to the query point;-&gt; Recusively check left/bottom;-&gt; Recusively check right/top. When getting closer to the query point, some search is pruned.&lt; Interval search trees BST with node storing interval. Use left endpoint as key and store max endpoint of each subtree at root. Insertion: Use left endpoint as key to insert and update max endpoint along the search path. Search:-&gt; If interval in node intersects query interval, return it.-&gt; Else if left subtree is null, go right.-&gt; Else if max endpoint in left subtree is less than lo, go right.-&gt; Else go left.123456789101112131415private Interval get(Key lo, Key hi) &#123; Node x = root; while (x != null) &#123; if (x.interval.intersects(lo, hi)) &#123; return x.interval; &#125; else if (x.left == null) &#123; x = x.right; &#125; else if (x.left.max &lt; lo) &#123; x = x.right; &#125; else &#123; x = x.left; &#125; &#125; return null;&#125; &lt; Rectangle intersection Find all intersections among a set of N orthogonal rectangles. Sweep vertical line method: Triggered by endpoints’ x-coordinates, maintain the y-intervals in BST; Left endpoints trigger interval search for that y-interval and insert, while right endpoints trigger removal of that interval. Hash Tables&lt; Hash function Idea: Save items in key-index table, where index is a hash function of key. Hash in user-defined types: make use of prime numbers and built-in hashCode() for Java classes. 1234567891011121314public final class Transaction implements comparable&lt;Transaction&gt; &#123; private final String who; private final Date when; private final double amount; ... public int hashCode() &#123; int hash = 17; hash = 31*hash + who.hashCode(); hash = 31*hash + when.hashCode(); hash = 31*hash + ((Double) amount).hashCode(); return hash; &#125;&#125; Collision: Two distinct keys hashing to same index. Separate chaining: maintain a chain for the collided keys. Linear probing: find next empty slot.]]></content>
      <categories>
        <category>Course</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>algorithm</tag>
        <tag>coursera</tag>
        <tag>dataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(Suspended)Note for Professional JavaScript for Web Developers (3/4)]]></title>
    <url>%2F2016%2F10%2F15%2Fjavascript_professional_3%2F</url>
    <content type="text"><![CDATA[这本书拖了好久，战线拉太长了…JavaScript高级程序设计（第3版）笔记第三部分，本篇对应9~? 客户端检测 首先要指出的是，不到万不得已，不要使用客户端检测。应当先设计最通用的方案，再使用特定于浏览器的技术增强该方案。 1.能力检测 检测规则: 一是先检测达到某个目的的最常用属性，二是必须直接测试实际要用到的属性。例如要想获取特定ID的元素，就应该先检测document.getElementById再检测document.all，同时你不能检测到了document.all就认为它一定是IE进而使用其他IE特定的方法，你必须要用什么就检测什么。 更可靠的能力检测: 有时候直接通过属性访问并不能保证某个特性真的会按照适当的方式运行，例如你希望通过object.sort来检测该对象能否排序，而其实拥有sort属性时它也会返回true。因此我们应该尽量用typeof操作符来做能力检测。在极品的IE中，有时typeof返回的函数是object而非function，甚至访问ActiveX对象直接用点操作符访问函数也会报错。在浏览器中测试对象的某个特性是否存在应该这样做:12345function isHostMethod(object, property) &#123; var t = typeof object[property]; return t === "function" || (!!(t === "object" &amp;&amp; object[property])) || t === "unknown"; // 其中(!!var1)是为了快速转换成布尔值&#125; 2.怪癖检测 怪癖就是Bug，是个别浏览器独有的。只需要检测对代码有直接影响的怪癖，且最好在脚本一开始就执行这类检测。例如在IE8-中，某实例有与被标记为DontEnum的原型属性同名的属性，它也不会出现在for-in循环中。123456789var hasDontEnumQuirk = function() &#123; var o = &#123;toString: function() &#123;&#125;&#125;; // 实例拥有新的toString for (var prop in o) &#123; if (prop === "toString") &#123; return false; &#125; &#125; return true;&#125; (); 3.用户代理检测 由于各大浏览器厂商都习惯将navigator.userAgent进行伪装spoofing（防止被嗅探而拒绝访问），检测浏览器信息十分困难。 识别呈现引擎: 确切知道浏览器的名字和版本号不如确切知道它使用的是什么呈现引擎。我们主要要检测五大呈现引擎: IE, Gecko, WebKit, KHTML和Opera. 为了不在全局作用域添加多余的变量，我们采用模块增强模式来封装检测脚本，然后依照Opera - WebKit - KHTML - Gecko - IE的顺序来检测（谁最喜欢伪装成别人就先检测谁，即先检测的字符串通常会包含后面检测的字符串） 识别浏览器: 只知道呈现引擎并不能说明存在所需的JavaScript功能，例如同为WebKit引擎，Safari和Chrome却是不同的JavaScript引擎。 识别平台: 不同平台版本的浏览器可能会有不同的行为，主要识别Windows, MacOS, UNIX。 识别Windows版本: 可以这么做，但我看不懂为什么要提取Windows版本… 识别移动设备: 识别iOS、安卓、诺基亚N、WinMobile。 游戏设备: 任天堂Wii和PlayStation都有浏览器，也可以检测出来。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159var client = function() &#123; var engine = &#123; // 呈现引擎 ie: 0, gecko: 0, webkit: 0, khtml: 0, opera: 0, ver: null &#125;; var browser = &#123; // 浏览器 ie: 0, firefox: 0, safari: 0, konq: 0, opera: 0, chrome: 0, ver: null &#125;; var system = &#123; // OS, 移动设备和游戏机 win: false, mac: false, x11: false, iphone: false, ipod: false, ipad: false, ios: false, android: false, nokiaN: false, winMobile: false, wii: false, ps: false, &#125;; var ua = navigator.userAgent; if (window.opera) &#123; // 检测opera engine.ver = browser.ver = window.opera.version(); engine.opera = browser.opera = parseFloat(engine.ver); &#125; else if (/AppleWebKit\/(\S+)/.test(ua)) &#123; // \S为非空格字符 engine.ver = RegExp["$1"]; engine.webkit = parseFloat(engine.ver); if (/Chrome\/(\S+)/.test(ua)) &#123; // 检测Chrome或Safari browser.ver = RegExp["$1"]; browser.chrome = parseFloat(browser.ver); &#125; else if (/Version\/(\S+)/.test(ua)) &#123; browser.ver = RegExp["$1"]; browser.safari = parseFloat(browser.ver); &#125; else &#123; var safariVersion = 1; if (engine.webkit &lt; 100) &#123; safariVersion = 1; &#125; else if (engine.webkit &lt; 312) &#123; safariVersion = 1.2; &#125; else if (engine.webkit &lt; 412) &#123; safariVersion = 1.3; &#125; else &#123; safariVersion = 2; &#125; browser.safari = browser.ver = safariVersion; &#125; &#125; else if (/KHTML\/(\S+)/.test(ua) || /Konqueror\/([^;]+)/.test(ua)) &#123; engine.ver = browser.ver = RegExp["$1"]; engine.khtml = browser.konq = parseFloat(engine.ver); &#125; else if (/rv:([^\)]+)\) Gecko\/\d&#123;8&#125;/.test(ua)) &#123; engine.ver = RegExp["$1"]; engine.gecko = parseFloat(engine.ver); if (/Firefox\/(\S+)/.test(ua)) &#123; // 检测火狐 browser.ver = RegExp["$1"]; browser.firefox = parseFloat(browser.ver); &#125; &#125; else if (/MSIE ([^;]+)/.test(ua)) &#123; engine.ver = RegExp["$1"]; engine.ie = parseFloat(engine.ver); &#125; // 检测IE和Opera browser.ie = engine.ie; browser.opera = engine.opera; // 检测平台 var p = navigator.platform; system.win = p.indexOf("Win") === 0; system.mac = p.indexOf("Mac") === 0; system.x11 = (p === "X11") || (p.indexOf("Linux") === 0); // 检测Windows版本 if (System.win) &#123; if (/Win(?:dows ) ?([^do]&#123;2&#125;)\s?(\d+\.\d+)?/.test(ua)) &#123; if (RegExp["$1"] === "NT") &#123; switch(RegExp["$2"]) &#123; case "5.0": system.win = 2000; break; case "5.1": system.win = "XP"; break; case "6.0": system.win = "Vista"; break; case "6.1": system.win = "7"; break; default: system.win = "NT"; break; &#125; &#125; else if (RegExp["$1"] === "9x") &#123; system.win = "ME"; &#125; else &#123; system.win = RegExp["$1"]; &#125; &#125; &#125; // 移动设备 system.iphone = ua.indexOf("iPhone") &gt; -1; system.ipod = ua.indexOf("iPod") &gt; -1; system.ipad = ua.indexOf("iPad") &gt; -1; system.nokiaN = ua.indexOf("NokiaN") &gt; -1; if (system.win === "CE") &#123; // 针对windows phone system.winMobile = system.win; &#125; else if (system.win === "Ph") &#123; if (/Windows Phone OS (\d+.\d+)/.test(ua)) &#123; system.win = "Phone"; system.winMobile = parseFloat(RegExp["$1"]); &#125; &#125; // iOS版本 if (system.mac &amp;&amp; ua.indexOf("Mobile") &gt; -1) &#123; if (/CPU (?:iPhone)?OS (\d+_\d+)/.test(ua)) &#123; system.ios = parseFloat(RegExp.$1.replace("_", ".")); &#125; else &#123; system.ios = 8; // 这只是猜的 &#125; &#125; // 安卓版本 if (/Android (\d+\.\d+)/.test(ua)) &#123; system.android = parseFloat(RegExp.$1); &#125; // 游戏系统 system.wii = ua.indexOf("Wii") &gt; -1; system.ps = /playstation/i.test(ua); return &#123; engine: engine, browser: browser, system: system &#125;;&#125;(); DOM DOM是针对HTML/XML文档的一个API，其中XML(Extensible Markup Language)是独立于软件和硬件的信息传输（存储）工具，焦点在于数据的内容；而HTML则是控制数据的显示，两者长得比较像。DOM描绘了一个层次化的节点树，能方便地添加、移除和修改页面的某一部分。 1.节点层次 DOM可以将任何HTML/XML文档描绘成多层次节点构成的有根树。 Node类型: 可通过someNode.nodeType访问节点的类型（在IE中无效！），主要有元素节点（1）、属性节点（2）和文本节点（3）。 nodeName和nodeValue: 根据节点类型不同，节点的这两个属性的取值也有不同。例如对于元素节点来说，nodeName就是标签名，nodeValue为null。 节点关系: 树中节点的关系可以挪用到DOM树上，可以通过节点的某些属性方便地访问与之相关联的其他节点。-&gt; childNodes: 每个节点都有一个childNodes属性返回NodeList对象。NodeList是一个类数组对象，但它是基于DOM结构动态执行查询的结果，DOM结构的变化会即时反映到NodeList对象上。可以通过手写函数将NodeList转换为Array，但需要在IE中做特殊处理。-&gt; firstChild/lastChild: 即childNodes[0]和childNodes[someNode.childNodes.length - 1]。-&gt; parentNode: 指向当前节点的父节点。-&gt; previousSibling/nextSibling: 前/后的同侪。-&gt; ownerDocument: 文档节点，对于HTML来说就是最外层的根节点&lt;html&gt;. 123456789101112function convertToArray(nodes) &#123; var array = null; try &#123; array = Array.prototype.slice.call(nodes, 0); &#125; catch (ex) &#123; array = new Array(); for (var i = 0, len = nodes.length; i &lt; len; i++) &#123; array.push(nodes[i]); &#125; &#125; return array;&#125; 操作节点: 前面的节点关系指针都是只读的，不能直接赋值修改。DOM提供了其他操作节点的方法。-&gt; appendChild(): 为当前节点添加一个子节点，成为其lastChild，将新增节点返回。当这个子节点是当前文档中已经存在的节点时，该节点会被挪动到新的位置而不是复制，因为任何DOM节点都不能同时出现在文档中的多个位置上。someNode.appendChild(newNode)-&gt; insertBefore(): 为当前节点根据给定参照节点插入一个子节点，成为参照节点的previousSibling，将新增节点返回。当传入的参照节点为null，则等效于appendChild。someNode.insertBefore(newNode, someNode.firstChild);-&gt; replaceChild(): 将传入的节点替换掉给定的节点，原有的节点关系会被完整复制到新插入的节点，而被替换掉的节点返回后其实仍在文档中，只是没有了位置，可以通过appendChild等操作重新赋予位置。someNode.replaceChild(newNode, someNode.firstChild);-&gt; removeChild(): 删除子节点。someNode.removeChild(someNode.firstChild);-&gt; cloneNode(): 可浅复制（只复制节点本身）或深复制节点（复制节点以及整个子节点树，需传入参数true）。此时获得的节点虽说属于文档但没有与文档产生联系，需要通过appendChild等操作融入文档树。-&gt; normalize(): 整理文档树中的文本节点，清除空文本节点、合并相邻的文本节点。 Document类型: 表示整个文档。在浏览器中，表示整个HTML页面的document对象是HTMLDocument类型的实例，而HTMLDocument是继承自Document类型的。同时document还是window对象的属性。 文档的子节点: 有两个子节点可以快速访问，一是document.documentElement（即HTML页面中的&lt;html&gt;元素），二是document.body（&lt;body&gt;元素的引用）。其余的doctype, childNodes都会因浏览器不同而有所区别。 文档信息: document对象还具有一些标准Document对象没有的属性，如document.title可获取页面的标题（但无法通过对其赋值的方式修改标题）、document.URL获取完整URL（不可设置）、document.domain获取域名部分（只能设置到更具体的子域名）、document.referer获取是从什么URL链接到当前页面的（不可设置）。 查找元素: 获取特定的某个或某组元素的引用。-&gt; getElementById(): 根据ID严格匹配查找，但在IE中有两个quirk，一是不区分大小写、二是将name属性和id属性等价了。-&gt; getElementsByTagName(): 根据标签名严格匹配，返回NodeList，在HTML文档中则是返回HTMLCollection对象，与NodeList相同可访问length属性、可用[index]或item(index)来访问其中的元素，不过HTMLCollection又新增了namedItem(“nameValue”)方法，可以根据集合中元素的name属性获取元素。-&gt; getElementsByName(): 是HTML文档独有的，根据name属性严格匹配，返回HTMLCollection，经常用在获取拥有相同name属性的一组单选按钮. 特殊集合: document对象有一些特殊的HTMLCollection对象。-&gt; document.anchors: 获取所有带name的&lt;a&gt;元素。-&gt; document.links: 获取所有带href的&lt;a&gt;元素。-&gt; document.forms: 获取所有&lt;form&gt;元素。-&gt; document.images: 获取所有&lt;img&gt;元素。 文档写入: 使用write(str)或writeln(str)向文档中该段代码所在位置写入内容。若放在window.onload中执行，这是完全重写页面而不是在指定位置添加。 Element类型: 元素节点，nodeType为1，nodeName/tagName为标签名（大小写不一定，需要用.toLowerCase转换一下再判断标签），nodeValue为null，parentNode可能为Document或Element。 HTMLElement: 继承自Element类型并添加了id, title, className, lang等属性。它具有一系列更具体的子类型，对应诸多HTML元素。需要指出的是，所有的特性attribute都是元素属性property，但二者在使用时具有一定区别。 访问特性attribute: 使用getAttribute()、setAttribute()、removeAttribute()对元素attribute进行操作。特性是不区分大小写的，而自定义的特性按照惯例是要加上data-前缀加以辨识的。但需要指出的是，有两类特性，HTMLElement属性的值和通过getAttribute返回的值不同。style属性是对象、获取style特性则是对应的CSS文本；onclick这类的事件处理程序，在属性中返回一个JavaScript函数、而获取onclick特性则返回对应的代码文本。由于这样的差别，按照惯例我们通常更多使用属性访问，而getAttribute只用于自定义的特性。 设置特性: 使用setAttribute不仅可以设置现有特性，还能创建自定义特性。通过属性的方式创建自定义特性无法通过getAttribute访问，所以不推荐。但在旧版IE中setAttribute对class、style等特性不起作用，因此按照惯例我们推荐通过属性来设置特性，而setAttribute只用于新增自定义特性。 attributes属性: 包含一个NamedNodeMap，与NodeList类似。可用getNamedItem(name)获取指定Name的节点，用removeNamedItem(name)移除，用setNamedItem(node)插入新节点，用item(pos)获取特定位置的节点。这些方式并不方便，通常还是getAttribute、removeAttribute和setAttribute。 创建元素createElement: 根据传入的标签名来新建元素，返回该元素的引用。再调用appendChild添加到指定元素末尾。 1234var myDiv = document.createElement("div");div.id = "myDiv";div.className = "box";document.body.appendChild(myDiv); 元素子节点childNodes: 元素的childNodes属性中包含了它所有的子节点，可以是元素/文本节点/注释等，因此需要利用nodeType属性来判断是否是子元素。 12345for (var i = 0, len = element.childNodes.length; i &lt; len; i++) &#123; if (element.childNodes[i].nodeType == 1) &#123; // 先确认子节点是不是元素类型，再进来做下一步操作。 &#125;&#125; element.getElementsByTagName: 这里的element可以是document，也可以是一个元素节点，可通过给定标签名获得它包含的子孙元素节点。 Text类型: 文本节点，nodeType为3，nodeName为”#text”，nodeValue为所包含的文本，parentNode为Element。可利用nodeValue对所插入的文本进行HTML编码，如div.firstChild.nodeValue = &quot;&lt;strong&gt;sth&lt;/strong&gt;&quot;赋值时，会将字符串中的尖括号、引号等都进行编码，这样就省去了手动编码的麻烦。 document.createTextNode(str): 传入字符串创建文本节点，必须将该节点添加到文档树中已经存在的节点中才会显示出来(appendChild)。 element.normalize(): 若该元素含有多个文本节点，可用此函数合并相邻文本节点。 TextNode.splitText(index): 将所给text节点一分为二，0 ~ index-1和index ~ *. Comment类型: 注释节点，nodeType为8，nodeName为”#comment”，nodeValue为注释的文本内容，parentNode为Document/Element。用法与前面的Text类似，可用document.createComment创建给定文本的注释。注意这些注释必须存在与html标签之间，否则无法访问到。 2.DOM操作技术 前面介绍了很多使用JavaScript动态生成HTML标签的方法，那么很自然地会想到动态插入JavaScript, CSS等内容会产生什么效果。 动态脚本: 类似于静态脚本，也有链接外部文件和直接插入代码两种动态生成脚本的方式。对于外部文件的方式，只有执行到appendChild才会真正下载外部文件。动态脚本会在全局作用域中执行，且这段脚本执行后，动态脚本立即可用。 1234567891011121314var script = document.createElement("script");script.type = "text/javascript";// 以上为共用部分，以下分两个// 1.外部文件script.src = "client.js";document.body.appendChild(script);// 2.直接上码var code = "function sayHi() &#123;alert("hi");&#125;";try &#123; script.appendChild(document.createTextNode(code));&#125; catch(ex) &#123; // 防止IE不允许访问childNode script.text = code;&#125; 动态样式: CSS样式可用link链接外部样式表，也可直接用style嵌入样式代码。动态样式是页面加载完成后动态加载到页面中的。加载外部样式表是异步的，即加载样式与执行JavaScript代码的先后是不确定的。 123456789101112131415161718// 1.外部var link = document.createElemetn("link");link.rel = "sytlesheet";link.type = "text/css";link.href = "basicStyle.css";// 2.上码var style = document.createElement("style");style.type = "text/css";try &#123; style.appendChild(document.createTextNode("body&#123;background-color: white&#125;"));&#125; catch (ex) &#123; style.styleSheet.cssText = "body&#123;background-color: white&#125;";&#125;// 共用部分var head = document.getElementsbyTagName("head")[0];head.appendChild(link/style); // 注意CSS必须插入head中！ 操作表格: 为方便动态构建表格，DOM为&lt;table&gt;, &lt;tbody&gt;, &lt;tr&gt;等元素提供了属性和方法。 123456789101112131415161718var table = document.createElement("table");table.border = 1;table.width = "100%";var tbody = document.createElement("tbody");table.appendChild(tbody);tbody.insertRow(0); // 创建第一行tbody.rows[0].insertCell(0); // 为第一行插入第一个单元格tbody.rows[0].cells[0].appendChild(document.createTextNode("Cell 1, 1"));tbody.rows[0].insertCell(1); // 为第一行插入第二个单元格tbody.rows[0].cells[1].appendChild(document.createTextNode("Cell 2, 1"));tbody.insertRow(1); // 创建第一行tbody.rows[1].insertCell(0); // 为第一行插入第一个单元格tbody.rows[1].cells[0].appendChild(document.createTextNode("Cell 1, 2"));tbody.rows[1].insertCell(1); // 为第一行插入第二个单元格tbody.rows[1].cells[1].appendChild(document.createTextNode("Cell 2, 2")); 使用NodeList: NodeList和NamedNodeMap和HTMLCollection三个集合都是动态的，总是在访问DOM文档时实时进行运行的查询，因此应当尽量将其length属性用变量存起来，避免重复多次访问，也防止length动态变化带来的意外死循环。 DOM Extensions 1.选择符API诸多JavaScript库最常用的功能就是根据CSS选择符访问DOM元素，其中jQuery就是通过CSS选择符查询DOM文档取得元素的引用，绕开了传统的getElementById和getElementByTagName。 element.querySelector: 接受一个CSS选择符，返回匹配元素的引用（若有多个则返回第一个）。若对document类型使用querySelector，则会在整个文档范围内查找匹配元素。 element.querySelectorAll: 用法与上面类似，返回的是NodeList实例，可用方括号或.item(index)逐个访问其中元素。 element.matchesSelector: 用于判断该元素是否符合传入的CSS选择符，但浏览器支持很差。 2.元素遍历API为了弥补浏览器之间的差异（如IE不将元素间的空格作为文本节点）并保持DOM规范，Element Traversal API诞生，提供了如下方法。 childElementCount: 子元素计数，不含文本/注释。 firstElementChild: firstChild的元素版。 lastELementChild: lastChild的元素版。 previousElementSibling: previousSibling的元素版。 nextElementSibling: nextSibling的元素版。 3.HTML5 API element.getElementsByClassName: 传入带有一或多个类名的字符串（以空格隔开），返回给定元素后代中匹配的元素组成的NodeList。由于class属性可用于添加样式又可帮助表示HTML元素的语义，class属性的使用愈发频繁，因此这个方法用得也蛮多。 element.classList属性: 返回该元素所有的类名，存放于一个DOMTokenList实例，与NodeList一样可用方括号或item访问，此外还提供了add(str), contains(str), remove(str), toggle(str)对该元素的类名进行操作。以往要想遍历出所有类名可能需要对className属性的字符串进行split等操作，那样就复杂多了。 document.activeElement属性: 获取DOM文档中当前获得了焦点的元素。 document.readyState属性: 作为指示文档加载完成的指示器，有”loading”和”complete”两个取值。 document.compatMode属性: 区分页面渲染是标准模式还是混杂模式，取值分别为”CSS1Compat”和”BackCompat”。 document.head属性: 类似于document.body，方便直接访问页面中唯一的&lt;head&gt;元素，但只有chrome和safari5支持，所以为了防止出问题应该这么写。 1var head = document.head || document.getElementsByTagName("head")[0]; document.charset/defaultCharset: 获取当前字符集/默认字符集，前者还可通过赋值进行修改。 自定义数据属性: HTML5允许为元素添加非标准的属性，但必须添加前缀data-，强调这是与渲染无关的信息，可能是语义信息补充之类的。添加的自定义数据属性可通过dataset属性访问或赋值。例如对于&lt;div id=&quot;myDiv&quot; data-appId=&quot;1234&quot; data-myName=&quot;Bobo&quot;&gt;，可以这样访问: 123var div = document.getElementById("myDiv");var appId = div.dataset.appId;var myName = div.dataset.myName; 插入标记: DOM操作节点可以创建并插入文档，但对于大量标签的插入/替换，使用字符串的形式直接插入显然更直接划算。-&gt; innerHTML属性: 访问时返回的是调用元素内部所有子节点的HTML标记字符串。而写入时是直接将原本的子节点替换掉成字符串所解析成的DOM子树。不过需要注意大部分浏览器对于innerHTML插入的script并不会执行。-&gt; outerHTML属性: 访问时返回的是调用元素及其内部所有子节点的HTML标记字符串，注意与innerHTML相比包含了调用元素本身。对outerHTML赋值会将调用元素也给替换掉。-&gt; insertAdjacentHTML方法: 传入插入位置和要插入的HTML文本。第一个参数为”beforebegin”(作为当前元素的前一个同辈元素)、”afterend”(作为当前元素的后一个同辈元素)、”afterbegin”(作为当前元素的第一个子元素)和”beforeend”(作为当前元素的最后一个子元素)，第二个参数为合法的HTML可解析字符串。不过以上这些替换子节点的方法可能涉及内存占用问题，例如元素被替换后其绑定的事件处理程序却仍然存在于内存中。同时反复访问innerHTML/outerHTML属性也会降低性能，最好能够将访问次数尽可能限制。 scrollIntoView方法: 对某元素调用这个方法，可以让它所在的容器滚动的时候，将该元素放在视窗顶部。 4.专有扩展 children属性: 返回包含为元素类型的子节点的HTMLCollection实例，childNodes的元素版。 contains方法: 用于判断某个节点是不是另一个节点的后代。 插入文本: 不同于innerHTML/outerHTML被纳入HTML5规范，innerText和outerText就没有。-&gt; innerText: 操作元素中的文本内容，也会完全改变该元素的DOM子树。还有DOM Level3规定的textContent属性。可以这样写: 1234567891011function getInnerText(element) &#123; return (typeof element.textContent == "string") ? element.textContent : element.innerText;&#125;function setInnerText(element, text) &#123; if (typeof element.textContent == "string") &#123; element.textContent = text; &#125; else &#123; element.innerText = text; &#125;&#125; -&gt; outerText属性: 在读取时outerText与innerText一样，在赋值时则是将当前元素整个替换为新的文本节点，包括它里面的子节点。 事件 1.事件流 事件冒泡: 事件开始时从最具体的元素接收，然后逐级向上传播到外层节点。 事件捕获: 与冒泡完全相反，不太具体的节点更早接收到事件，最具体的元素是最后接收到事件，目的在于在事件到达预定目标之前能够捕获它。 DOM事件流: DOM Level2规定的事件流包括三个阶段: 事件捕获阶段、处于目标阶段和事件冒泡阶段。例如点击简单的只含有div的HTML页面来说，事件捕获阶段时事件只会从document到&lt;html&gt;到&lt;body&gt;；在“处于目标”阶段，事件才会在&lt;div&gt;上发生；最后冒泡阶段发生，事件一路传回文档。 2.事件处理程序 HTML事件处理程序: 对于元素支持的事件如click, load, mouseover，都有对应的HTML特性如onclick, onload, onmouseover，通过这些特性可以指定事件处理程序。我们很常用的是在script中创建function然后在onclick中绑定到这个函数上，其实这里还有一些玄机。它会创建一个封装着元素属性的函数，这个函数中有一个局部变量event，这个事件对象可以直接访问对象的其他特性： 1&lt;input type="button" value="Click Me" onclick="alert(event.type)"&gt; 同时这个动态创建的函数还会扩展作用域，不仅可访问该元素本身的成员，还可以访问document的成员。 DOM Level0事件处理程序: 先获取要操作对象的引用，然后将一个函数复制给它的事件处理程序属性。函数中的this就指向当前元素。 1234var btn = document.getElementById("myBtn");btn.onclick = function() &#123; alert(this.id);&#125; DOM Level2事件处理程序: 需要用两个方法来增/删事件处理程序: addEventListener和removeEventListener，他们都接收三个参数，分别是要处理的事件名、作为事件处理程序的函数和布尔值（true则在捕获阶段调用，false则在冒泡阶段调用。）。大多数情况下会选择将处理程序添加到事件流的冒泡阶段，这样可以最大程度地兼容各个浏览器。注意当add的时候是以匿名函数的形式传入的，则无法remove。 123456var handler = function() &#123; alert(this.id);&#125;btn.addEventListener("click", handler, true);...btn.removeEventListner("click", handler, true); IE事件处理程序: 支持与DOM2类似的方法，attachEvent和detachEvent，接受两个参数（与前面相比就是少了最后一个布尔值，因为只支持添加到冒泡阶段），还有就是第一个参数是事件处理程序的名称而不是要处理的事件名，即为”onclick”而非”click”。 跨浏览器方案: 为了保证大多数浏览器能正常运行，需要更关注冒泡阶段。我们将以DOM2 - IE - DOM0的顺序进行事件处理。1234567891011121314151617181920var EventUtil = &#123; addHandler: function(element, type, handler) &#123; if (element.addEventListener) &#123; element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; element.attachEvent("on" + type, handler); &#125; else &#123; element["on" + type] = handler; &#125; &#125;, removeHandler: function(element, type, handler) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, handler, false); &#125; else if (element.detachEvent) &#123; element.detachEvent("on" + type, handler); &#125; else &#123; element["on" + type] = null; &#125; &#125;&#125;; 3.事件对象 触发DOM上的某个事件时会产生一个事件对象event，包含了导致事件的元素、事件类型等相关信息。 DOM事件对象: event对象会传入事件处理程序中，可用type属性确定被触发事件的类型、用target属性确定绑定到了哪个元素、用currentTarget属性确定是哪个元素触发了这个事件。要阻止特定事件的默认行为，可使用event.preventDefault方法，不过只有cancelable=true的事件才能这么阻止。要停止事件在DOM层次中传播，取消进一步的捕获/冒泡，可使用stopPropagation方法。 IE中的事件对象:]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>frontend</tag>
        <tag>js</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring MVC示例项目练手]]></title>
    <url>%2F2016%2F10%2F08%2Ftry_spring%2F</url>
    <content type="text"><![CDATA[之前看的那本《Spring揭秘》内容真多，还是没有全部啃完。现在先用网上一个史上最全最强的SpringMVC示例来练练手好了，感觉书上的罗列介绍都是理论内容，还是不太懂怎么用。所以就借着这个练手项目，把代码背后Spring MVC整理一下好了。好吧其实我看书都还没看到这部分呢，不过没关系，先接触一下到时再回头看看系统的介绍。 创建Spring MVC项目 1.在Eclipse JavaEE中新建工程，New - Other - Web - Dynamic Web Project，命名随便取个spring。 2.在WebContent - WEB-INF - lib目录下放入Spring相关的jar包。jar包是开发时需要引用的通用类，.jar就是一种封装（有点类似.zip，不过会多一个META-INF\MANIFEST.MF文件），用户并不需要知道jar包中有多少.class、不关心它们所属的package，只需要知道如何使用类的属性和方法。 3.在WebContent - WEB-INF目录下新建web.xml文件。web.xml是整个Web应用程序的部署描述文件，这是基于Servlet规范的Web应用程序都要有的。其中DispatcherServlet是Front Controller，负责接收所有的Web请求，并根据不同的处理逻辑委派到下一级控制器去实现。这里的servlet-mapping是一种映射，当Web请求到达了DispatcherServlet，它会寻找具体的HandlerMapping实例，最终获取当前Web请求应该用到的具体处理类。 1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" id="WebApp_ID" version="3.0"&gt; &lt;display-name&gt;spring&lt;/display-name&gt; &lt;!--configure the setting of springmvcDispatcherServlet and configure the mapping--&gt; &lt;servlet&gt; &lt;servlet-name&gt;spring&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; --&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;spring&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 4.在项目的src目录下新建springmvc-servlet.xml文件。前面的web.xml中由DispatcherServlet分配给具体处理类处理好Web请求后，会返回一个ModelAndView实例。Spring提出了基于ViewResolver和View接口的Web视图处理抽象层，选择相应的视图名并显示。 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.1.xsd"&gt; &lt;!-- scan the package and the sub package --&gt; &lt;context:component-scan base-package="testSpring"/&gt; &lt;!-- don't handle the static resource --&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!-- if you use annotation you must configure following setting --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 为了指向WEB-INF中静态的js文件 --&gt; &lt;mvc:resources mapping="/js/**" location="/WEB-INF/js/"/&gt; &lt;!-- configure the InternalResourceViewResolver --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver" id="internalResourceViewResolver"&gt; &lt;!-- 前缀 --&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;!-- 后缀 --&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt; &lt;!-- upload settings --&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="maxUploadSize" value="102400000"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 5.在WEB-INF目录下新建jsp文件夹，专门存放ViewResolver映射的jsp视图。例如新增hello.jsp。 6.为src添加类。例如创建包testSpring，新建MVCController.java，其中用到了Controller和RequestMapping注解。 123456789@Controller // 负责注册一个bean到spring上下文中@RequestMapping("/mvc") // 注解为控制器指定可以处理哪些URL请求public class MVCController &#123; @RequestMapping("/hello") public String hello() &#123; return "hello"; // 返回指定的视图文件名（不含后缀） &#125;&#125; 7.此时在eclipse中启动Tomcat Server，访问localhost:8080/spring/mvc/hello即可访问到hello.jsp。 进一步体验Spring MVC 自动匹配参数: 可以根据变量名来匹配客户端传来的参数，获取各参数的值。在MVCController.java添加如下方法，在访问时加上?name=bobo&amp;age=21即可在控制台看到对应的值。 123456//match automatically@RequestMapping("/person")public String toPerson(String name, double age) &#123; System.out.println(name+" "+age); return "hello";&#125; 自动装箱: 利用类中的属性名或方法名来匹配客户端传来的参数并对应赋值构造出一个实例。神奇的是不论在地址栏中附上的参数顺序如何、名字如何，总能正确映射。例如新建model包，创建Person类型。然后在MVCController.java中重载（但是前面有个RequestMapping注解，不确定算不算重载）toPerson方法： 1234567891011121314151617181920212223242526272829303132public class Person &#123; private String sex; private int age; private String name; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;//boxing automatically@RequestMapping("/person2")public String toPerson(Person p)&#123; System.out.println(p.getName()+" "+p.getAge() + " " + p.getSex()); return "hello";&#125; 使用InitBinder注解: 表示在初始化的时候就会调用的函数，这里将客户端传过来的参数(String类型)转化为Date类型。 123456789101112//the parameter was converted in initBinder@RequestMapping("/date")public String date(Date date)&#123; System.out.println(date); return "hello";&#125; //At the time of initialization,convert the type "String" to type "date"@InitBinderpublic void initBinder(ServletRequestDataBinder binder)&#123; binder.registerCustomEditor(Date.class, new CustomDateEditor(new SimpleDateFormat("yyyy-MM-dd"), true));&#125; 使用Map向前台传递参数/对象: 除了从前台获取参数，还能通过方法传入的参数向前台传递参数。在前台的jsp文件中（其实也就是showPerson方法返回的叫做”show”的jsp文件）通过request.getAttribute(&quot;p&quot;)就可以获取Person实例了。在MVCController.java中继续添加如下方法： 1234567891011121314//pass the parameters to front-end@RequestMapping("/show")public String showPerson(Map&lt;String,Object&gt; map)&#123; Person p = new Person(); p.setAge(20); p.setName("Bobby"); map.put("p", p); return "show";&#125;// 在jsp中可以这样获取p实例（在jsp目录下添加show.jsp）// &lt;% Person p = (Person)request.getAttribute("p"); %&gt;// &lt;p&gt;&lt;%=p.getName() %&gt;&lt;/p&gt;// 使用Ajax获取前台Post传过来的参数: 前面用JQuery提供的Ajax已经玩过几遍了，现在使用Spring其实写出来也差不多。首先在jsp目录下添加ajax.jsp，需要指出的是这里要引用jQuery外部js，但是WEB-INF只对服务端开放，浏览器是不能直接访问到存在这个目录下的文件的，所以需要在springmvc-servlet.xml中配置静态资源访问路径&lt;mvc:resources mapping=&quot;/js/**&quot; location=&quot;/WEB-INF/js/&quot;/&gt;，否则对静态资源的请求会被拦截。然后在MVCController.java中继续添加方法，这里是返回一句问候语字符串，在前台由js弹窗显示。 12345678910111213141516171819&lt;body&gt; &lt;input id="name" type="text" name="name" /&gt; &lt;input id="btn" type="button" value="OK"/&gt; &lt;!-- SpringMVC的jsp无法访问WEB-INF中静态的js文件，但通过添加servletxml文件可映射到特定文件夹 --&gt; &lt;script type="text/javascript" src="../js/jquery-1.6.2.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function() &#123; $("#btn").click(function() &#123; $.post("getPerson", &#123; name: $("#name").val() &#125;, function(data) &#123; alert(data); &#125;); &#125;); &#125;); &lt;/script&gt; &lt;/body&gt; 123456789//pass the parameters to front-end using ajax@RequestMapping("/getPerson")public void getPerson(String name, PrintWriter pw)&#123; pw.write("hello, " + name); &#125;@RequestMapping("/ajax")public String sayHello()&#123; return "ajax";&#125; 在Controller中使用redirect方式处理请求: 使用redirect将路径重定向到新的地址，再由该地址对应的Controller方法去处理并返回视图。继续在MVCController.java中添加: 12345//redirect @RequestMapping("/redirect")public String redirect()&#123; return "redirect:hello";&#125; 文件上传: 首先要导入两个处理文件上传的jar包。在springmvc-servlet.xml配置文件中加入如下bean引用类： 1234&lt;!-- upload settings --&gt;&lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="maxUploadSize" value="102400000"&gt;&lt;/property&gt;&lt;/bean&gt; 在MVCController.java中加入处理文件上传的方法: 123456789101112131415@RequestMapping(value="/upload",method=RequestMethod.POST)public String upload(HttpServletRequest req) throws Exception&#123; MultipartHttpServletRequest mreq = (MultipartHttpServletRequest)req; MultipartFile file = mreq.getFile("file"); String fileName = file.getOriginalFilename(); SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMddHHmmss"); FileOutputStream fos = new FileOutputStream(req.getSession().getServletContext().getRealPath("/")+ "upload/"+sdf.format(new Date())+fileName.substring(fileName.lastIndexOf('.'))); //System.out.println(req.getSession().getServletContext().getRealPath("/")); fos.write(file.getBytes()); fos.flush(); fos.close(); return "hello";&#125; 在hello.jsp中也要相应地加上上传文件的控件： 1234&lt;form action="upload" method="post" enctype="multipart/form-data"&gt; &lt;input type="file" name="file"&gt;&lt;br&gt; &lt;input type="submit" value="submit"&gt;&lt;/form&gt; 使用@RequestParam注解参数的名称: 指定了请求中必须给出该名字的参数值，否则报错。在MVCController.java中加入方法: 1234567// 强制必须传入参数 @RequestMapping(value="/param")public String testRequestParam(@RequestParam(value="id") Integer id, @RequestParam(value="name")String name)&#123; System.out.println(id+" "+name); return "hello";&#125; RESTful风格的SpringMVC: REST(Representational State Transfer)，指的是一组架构约束条件和原则，其中最重要的是客户端和服务器之间的交互在请求之间是无状态的，从客户端到服务器的每个请求都必须包含理解请求所必需的信息。在Spring MVC中，RESTful的查删改增的实现需要用RequestMapping和PathVariable注解来实现，同时需要注意form不支持PUT和DELETE方法，所以需要曲线实现。首先在hello.jsp中加入相关的form控件： 1234567891011121314151617&lt;form action="/spring/rest/user/1" method="post"&gt; &lt;input type="hidden" name="_method" value="PUT"&gt; &lt;input type="submit" value="put"&gt;&lt;/form&gt; &lt;form action="/spring/rest/user/1" method="post"&gt; &lt;input type="submit" value="post"&gt;&lt;/form&gt; &lt;form action="/spring/rest/user/1" method="get"&gt; &lt;input type="submit" value="get"&gt;&lt;/form&gt; &lt;form action="/spring/rest/user/1" method="post"&gt; &lt;input type="hidden" name="_method" value="DELETE"&gt; &lt;input type="submit" value="delete"&gt;&lt;/form&gt; 接着新建RestController类用于映射rest路径并且打印四种方法的字符串： 123456789101112131415161718192021222324252627@Controller@RequestMapping("/rest")public class RestController &#123; @RequestMapping(value="/user/&#123;id&#125;",method=RequestMethod.GET) public String get(@PathVariable("id") Integer id)&#123; System.out.println("get" + id); return "/hello"; &#125; @RequestMapping(value="/user/&#123;id&#125;",method=RequestMethod.POST) public String post(@PathVariable("id") Integer id)&#123; System.out.println("post" + id); return "/hello"; &#125; @RequestMapping(value="/user/&#123;id&#125;",method=RequestMethod.PUT) public String put(@PathVariable("id") Integer id)&#123; System.out.println("put" + id); return "/hello"; &#125; @RequestMapping(value="/user/&#123;id&#125;",method=RequestMethod.DELETE) public String delete(@PathVariable("id") Integer id)&#123; System.out.println("delete" + id); return "/hello"; &#125;&#125; 返回json格式的数据: 还记得之前做bbs小项目的时候ajax+json的数据传递接触得很多了，现在换一批jar包看看。首先导入这些jar包(不过似乎没有什么类有引用到它们诶…)然后新建JsonController类，直接返回Person对象 12345678910111213141516171819@Controller@RequestMapping("/json")public class JsonController &#123; @RequestMapping("/json") public String jsonJSP() &#123; return "json"; &#125; @ResponseBody @RequestMapping("/personJson") public Person get() &#123; Person p = new Person(); p.setName("Bobo"); p.setAge(21); p.setSex("male"); return p; &#125;&#125; 对应地创建json.jsp页面，利用ajax发Get请求到的数据可以直接用点操作符访问值了。不过直接打印data的话并不是一个json字符串，而是[object Object]的形式，所以我得说做了这个json的小实验还是不太懂Spring怎么就通过json格式传输数据了 1234567891011121314151617181920212223&lt;input id="btn" type="button" value="OK"/&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;!-- SpringMVC的jsp无法访问WEB-INF中静态的js文件，但通过添加servletxml文件可映射到特定文件夹 --&gt;&lt;script type="text/javascript" src="../js/jquery-1.6.2.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function() &#123; $("#btn").click(function() &#123; $.ajax(&#123; url: "personJson", type: "get", success: function(data) &#123; var c = $("#container"); c.append("&lt;div&gt;Name:" + data.name + "&lt;/div&gt;"); c.append("&lt;div&gt;Age:" + data.age + "&lt;/div&gt;"); c.append("&lt;div&gt;Sex:" + data.sex + "&lt;/div&gt;"); &#125; &#125;); &#125;); &#125;); &lt;/script&gt; 异常的处理(未验证): 分为在Controller内部处理局部异常、新建对所有Controller异常的处理类。 1234567891011121314151617181920212223242526272829303132333435// 1. 局部异常@ExceptionHandlerpublic ModelAndView exceptionHandler(Exception ex)&#123; ModelAndView mv = new ModelAndView("error"); mv.addObject("exception", ex); System.out.println("in testExceptionHandler"); return mv;&#125;@RequestMapping("/error")public String error()&#123; int i = 5/0; return "hello";&#125;// 2.1 全局异常的处理类@ControllerAdvicepublic class testControllerAdvice &#123; @ExceptionHandler public ModelAndView exceptionHandler(Exception ex)&#123; ModelAndView mv = new ModelAndView("error"); mv.addObject("exception", ex); System.out.println("in testControllerAdvice"); return mv; &#125;&#125;// 2.2 全局异常处理也可以在配置文件中设置，其中error是出错后指向的页面&lt;!-- configure SimpleMappingExceptionResolver --&gt;&lt;bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver"&gt; &lt;property name="exceptionMappings"&gt; &lt;props&gt; &lt;prop key="java.lang.ArithmeticException"&gt;error&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 自定义拦截器: Spring MVC中拦截器的主要作用是拦截用户的请求并进行相应的处理，有点类似于Servlet开发中的filter，但拦截器和过滤器还是有区别的。拦截器可以用来计算PageView、进行权限验证，或者是来判断用户是否登陆，或者是像12306 那样子判断当前时间是否是购票时间。创建自定义拦截器类，实现HandlerInterceptor接口: 12345678910111213141516171819202122public class MyInterceptor implements HandlerInterceptor &#123; @Override public void afterCompletion(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3) throws Exception &#123; System.out.println("afterCompletion"); &#125; @Override public void postHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, ModelAndView arg3) throws Exception &#123; System.out.println("postHandle"); &#125; @Override public boolean preHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2) throws Exception &#123; System.out.println("preHandle"); return true; &#125;&#125; 然后在springmvc-servlet.xml中加入 1234567&lt;!-- interceptor setting --&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/mvc/**"/&gt; &lt;bean class="testSpring.interceptor.MyInterceptor"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 此时访问/spring/mvc/下的页面就会在控制台看到打印的内容，说明拦截器起作用了，可以自定义其中各个过程的操作。 整合SpringIOC和SpringMVC 首先导入部分validation的jar包。包括validation-api-1.1.0.Final.jar, jboss-logging-3.1.3.ga.jar, hibernate-validator-5.0.1.Final.jar。 在testSpring下新建文件夹integrate。创建User类，其中用到了部分用于验证的注解，但奇怪的是似乎没起到作用，例如非空的name不传值也不会报错: 1234567891011121314151617181920212223242526272829303132333435363738public class User &#123; private int id; @NotEmpty private String name; @Past @DateTimeFormat(pattern="yyyy-MM-dd") private Date birth; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Date getBirth() &#123; return birth; &#125; public void setBirth(Date birth) &#123; this.birth = birth; &#125; @Override public String toString() &#123; return "User [id=" + id + ", name=" + name + ", birth=" + birth + "]"; &#125; &#125; 创建UserController类，其中用到了IoC的Autowired注解，表示需要从外部注入依赖对象UserService，而在UserController内部就不用涉及这个属性的实例化了 12345678910111213@Controller@RequestMapping("/integrate")public class UserController &#123; @Autowired // 表示UserController依赖UserService。 private UserService userService; // 用了IoC，可以看到这里并不涉及UserService的实例化。 @RequestMapping("/user") public String saveUser(@RequestBody @ModelAttribute User u) &#123; System.out.println(u); userService.save(); return "hello"; &#125;&#125; 创建UserService类，注意用到了Component注解，表示这个类需要交给容器，然后配合配置文件扫描指定目录下的Component类，注入到需要它的对象中。 12345678910@Componentpublic class UserService &#123; public UserService()&#123; System.out.println("UserService Constructor...\n\n"); &#125; public void save()&#123; System.out.println("save"); &#125;&#125; 修改Spring配置文件: 在src目录下新建applicationContext.xml，关键是用context:component-scan base-package指定到某个包下导入Component到IoC容器中 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd " xmlns:util="http://www.springframework.org/schema/util" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" &gt; &lt;context:component-scan base-package="testSpring.integrate"&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.web.bind.annotation.ControllerAdvice"/&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; 对应地把这个新的xml关联到原来的web.xml中: 12345678&lt;!-- configure the springIOC --&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt; 在原来的springmvc-servlet.xml中也需要对应修改扫描的目录，防止SpringMVC和SpringIOC对同一个对象的管理重合。这一点暂时还不太明白，是因为web.xml同时导入了这两个Xml所以要防止二者定义冲突吗？ 1234567 &lt;!-- scan the package and the sub package --&gt;&lt;context:component-scan base-package="testSpring.integrate"&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;context:include-filter type="annotation" expression="org.springframework.web.bind.annotation.ControllerAdvice"/&gt;&lt;/context:component-scan&gt; 在运行Tomcat的时候，可以看到在加载XML文件的时候，就调用了UserService的构造子，因此UserService的实例化和UserController的实例化解耦合了:访问(http://localhost:8080/spring/integrate/user) ，由于此时没有传入任何User的属性，所以打印出来的都是空（为何不报错？）。附上参数?id=1&amp;name=bobo&amp;birth=2015-05-16后就会正常匹配到User的属性（但是为啥日期的格式和User中定的pattern不同？）: 表单验证与国际化 沿用前面的User类，前面写的非空、日期格式等到这一步才会起作用。例如现在需要显示用户信息。首先新建FormController类: 1234567891011121314151617@Controller@RequestMapping("/form")public class FormController &#123; @RequestMapping(value="/add",method=RequestMethod.POST) public String add(@Valid User u, BindingResult br)&#123; if(br.getErrorCount() &gt; 0) &#123; // 出错则不提交到showUser return "addUser"; &#125; return "showUser"; &#125; @RequestMapping(value="/add",method=RequestMethod.GET) public String add(Map&lt;String,Object&gt; map)&#123; map.put("user", new User()); return "addUser"; &#125;&#125; 这里的逻辑是，第一次请求页面(GET)的时候new一个User对象，并返回addUser的jsp页面。而提交表单时，若发现了错误，则保持在addUser这个页面，若没有错误则跳转到showUser这个jsp页面。错误信息会直接显示在addUser原页面上，而且原来填入的信息不会被清空。 对应地在jsp目录下新建addUser和showUser的jsp。注意要想用form:form标签，需要在最前面添加一句引用&lt;%@ taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot; %&gt;: 12345678910111213&lt;!--addUser.jsp的body部分--&gt;&lt;form:form action="add" method="post" modelAttribute="user"&gt; id:&lt;form:input path="id"/&gt;&lt;form:errors path="id"/&gt;&lt;br&gt; name:&lt;form:input path="name"/&gt;&lt;form:errors path="name"/&gt;&lt;br&gt; birth:&lt;form:input path="birth"/&gt;&lt;form:errors path="birth"/&gt;&lt;br&gt; &lt;input type="submit" value="OK"&gt;&lt;/form:form&gt;&lt;!--showUser.jsp的body部分--&gt;&lt;% User u = (User)request.getAttribute("user"); %&gt;&lt;p&gt;ID:&lt;%=u.getId() %&gt;&lt;/p&gt;&lt;p&gt;Name:&lt;%=u.getName() %&gt;&lt;/p&gt;&lt;p&gt;Birth:&lt;%=u.getBirth() %&gt;&lt;/p&gt; 可以自定义出错提示信息，在src目录下新建locale.properties： 12345NotEmpty.user.name=name cannot be emptyPast.user.birth=birth should be a past valueDateTimeFormat.user.birth=the format of input is wrongtypeMismatch.user.birth=the format of input is wrongtypeMismatch.user.id=the format of input is wrong 效果如下：格式正确后提交后就可以跳转到showUser 国际化: （这个国际化实验暂时没有做成功不知为何…）在src下添加locale_zh_CN.properties 12username=帐号password=密码 locale_en_US.properties 12username=user namepassword=password 新建一个locale.jsp，同时在导入两个jar包，并在jsp最前面加上&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; prefix=&quot;fmt&quot; %&gt; 12&lt;fmt:message key="username"&gt;&lt;/fmt:message&gt;&lt;fmt:message key="password"&gt;&lt;/fmt:message&gt; 再稍微改一下MVCController，加个带有@RequestMapping的方法导向这个jsp，显示效果如下，但浏览器改成英文仍然是中文显示，不知为啥]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>web</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Spring框架入门]]></title>
    <url>%2F2016%2F09%2F22%2Fjava_spring%2F</url>
    <content type="text"><![CDATA[Java Web开发中通常会用到经典的SSH后端框架，其中Spring是一个利用分层模块解决应用程序复杂性的轻量级框架。本篇笔记依然是整合资料的性质，来自Spring官方文档和《Spring揭秘》一书，其中有大多数名词都第一次见，看文档/书看得头大，有些英文表达也不知道对应的中文是什么就先保留了英文原文。 Spring的分层模块 1. Overview Spring框架大致有20个模块，分别归属于Core Container, Data Access/Integration, Web, AOP (Aspect Oriented Programming), Instrumentation, Messaging 以及 Test 六个大类。 2. Core Container Core Container包含了如下模块： spring-core &amp; spring-beans: 提供了最基础的功能，包括IoC控制反转和DI依赖注入。其主要组件BeanFactory是工厂模式的一个实现，可将编程过程中依赖性的配置与实际的程序代码分离开来。 spring-context: 基于前面的Core&amp;Beans模块，用于以框架的方式访问对象，支持internationalization, event propagation, resource loading, 透明化创建contexts，同时支持JavaEE的EJB(Enterprise JavaBean), JMX(Java Management Extensions), remoting等功能。其中的核心是ApplicationContext接口，spring-context-support则提供了集成第三方库如缓存、邮件、调度、模版引擎等。（尴尬，这些名词就没几个知道的…） spring-expression: Spring内置的表达式语言，用于查询和制造对象。 3. AOP and Instrumentation spring-aop: 内置了面向方面的编程，可以让由Spring框架管理的对象支持AOP，为这些对象提供了事物管理的服务。 spring-aspects: 集成了AspectJ。 spring-instrument: 提供了class instrumentation和classloader implementations，在特定的应用服务端使用。其中spring-instrument-tomcat包含了Spring对Tomcat的支持。 4. Messaging spring-messaging: 包含了Message, MessageChannel, MessageHandler等的核心抽象，可为基于消息的应用服务。该模块同时提供了类似于SpringMVC的annotation编程模型，用于将消息映射到对应的方法。 5. Data Access/Integration 包含了JDBC(Java Data Base Connectivity), ORM(Object Relation Mapping), OXM(Object/XML Mapping), JMS(Java Message Service) 以及 Transaction模块： spring-jdbc: 提供了JDBC抽象层，简化了繁杂的数据连接、错误处理的编程。 spring-tx: 管理实现了接口的类以及POJO(Plain Old Java Objects)类。 spring-orm: 提供object-relational mapping API的实现层，可使用JPA, Hibernate等框架完成OM映射。 spring-oxm: 提供Object/XML Mapping的抽象层，支持JAXB, Castor等实现。 spring-jms: 结合spring-messaging实现消息的产生和处理。 6. Web spring-web: 提供了基本的网络编程实现，例如多文件上传、使用Servlet监听器初始化IoC容器，同时也包含了HTTP client和web相关的Spring remoting支持。 spring-webmvc: 又被称作Web-Servlet module，包含了Spring的model-view-controller和REST Web服务框架（强调以资源为中心）。SpringMVC框架将domain model code和web forms清晰地分离开来。 spring-webmvc-portlet: 又被称作Web-Portlet module，对应着mvc的功能在portlet环境中提供服务。 7. Test spring-test: 使用JUnit或TestNG测试单元或整体功能，提供了ApplicationContext类和mock objects完成测试。 Spring核心技术之IoC 1. Inverse of Control概述 控制反转，又称DI（依赖性注入，Dependency Injection），其实就是将对象之间的依赖性重新整理以实现宽松耦合。在面向对象编程中，在实现特定功能时对象之间需要相互通信，尤其是相互之间的方法调用、属性访问，比如在这个过程中很可能会出现对象A内部实例化对象B的情况。下面就是这样的传统控制方式，显然由TopicManager类控制了TopicSaver类实例。123456789class TopicManager &#123; private TopicSaver topicSaver; // 作为成员变量的对象 public TopicManager() &#123; this.topicSaver = new TopicSaver(); // 实例化对象 ... &#125; ...&#125; 而控制反转则允许在外部实例化之后再注入到别的类中，而不需要一开始就在构造函数中写死。在这个例子中TopicManager依赖的TopicSaver对象可以由外部传递给它（依赖注入），或者说TopicManager对TopicSaver对象的绝对控制权不复存在了（控制反转）。更抽象点看，控制反转强调不创建对象，但描述对象的创建方式；不直接让对象与服务连接，但在配置文件中描述哪一个组件需要哪一项服务。在Spring中IoC容器负责完成这项关联工作。 2. 三种依赖注入方式 构造方法注入、setter方法注入、接口注入。由于接口注入的方式具有侵入性（即强制被注入对象实现不必要的接口）现在已经淘汰了。 constructor injection: 被注入对象在其构造函数参数列表中体现有哪些依赖对象，则外部IoC容器就能知道它需要依赖谁。 setter injection: 不是在对象构造完成的同时完成依赖注入，而是在实例化之后使用setter函数显式地把依赖对象注入进去。 interface injection: 被注入对象需要实现某个接口，提供一个注入依赖对象的方法，在这个接口方法的参数中就是依赖对象，外部IoC容器就可以通过接口方法来了解对象之间的依赖关系。 3. IoC的好处 从主动获取依赖关系的方式转变为IoC方式，不单是方向上的改变，还可以帮助我们解耦各个业务对象依赖关系的对象绑定方式。举个例子，我们有个外汇新闻供应类FXNewsProvider，它依赖于IFXNewsListener来抓取新闻、IFXNewsPersister来存储新闻。假设默认是用DowJonesNewsListener和DowJonesNewsPersister来分别实现对应的监听和存储类，那么构造FxNewsProvider时只需传入对应的实例即可。后续如果引入了新的新闻源MarketWin24，则直接实现MarketWin24Listener然后传入即可，而不必因为新闻源更新而写多一个专门针对它的新的NewsProvider类。1234567891011121314public class FXNewsProvider &#123; private IFXNewsListener newsListener; private IFXNewsPersister newsPersister; // 构造方法注入 public FXNewsProvider(IFXNewsListener newsListener, IFXNewsPersister newsPersister) &#123; this.newsListener = newsListener; this.newPersister = newsPersister; &#125;&#125;FXNewsProvider fDowJones = new FXNewsProvider(new DowJonesNewsListener(), new DowJonesNewsPersister());FXNewsProvider f = new FXnewsProvider(new MarketWin24NewsListener(), new MarketWin24NewsPersister()); IoC Service Provider IoC Service Provider是一个抽象出来的概念，可以指代任何将IoC场景中的业务对象绑定到一起的实现方式，可能是一段代码，一组相关的类或者IoC框架或IoC容器实现。前面这个FXNewsProvider例子中，依赖性绑定的相关代码就可以看作是这个场景中的IoC Service Provider。在Spring中，IoC容器就是一个提供依赖注入服务的IoC Service Provider。 1. IoC Service Provider的职责 业务对象的构建管理: 业务对象无需关心所依赖对象如何构建/取到，直接拿来用。因此IoC Service Provider需要将对象的构建逻辑从客户端对象中剥离出来。 业务对象之间的依赖绑定: 业务对象需要及时得到依赖对象的响应。IoC Service Provider通过结合之前构建和管理的所有业务对象，以及各个业务对象间可以识别的依赖关系，将这些对象所依赖的对象注入绑定，从而保证每个业务对象在使用的时候，可以处于就绪状态。 2. IoC Service Provider对对象之间依赖关系的管理 直接编码方式: 大部分IoC容器都支持直接编码，在容器启动之前就可以通过程序编码的方式建被注入对象和依赖对象注册到容器中，明确告知容器它们的依赖关系。如下代码，通过为相应的类指定对应的具体实例，当我们需要这种类型的对象时，IoC容器就会将注册的具体实例返回给我们。 123456IoContainer container = ...;container.register(FXNewsProvider.class, new FXNewsProvider());container.register(IFXNewsListener.class, new DowJonesNewsListener());...FXNewsProvider newsProvider = (FXNewsProvider)container.get(FXNewsProvider.class);newsProvider.someFunc();... 配置文件的方式: 最普遍的方式是通过XML文件来管理对象注册和对象间依赖关系。例如Spring配置文件的方式如下: 1234567891011121314&lt;bean id="newsProvider" class="..FXNewsProvider"&gt; &lt;property name="newsListener"&gt; &lt;ref bean="djNewsListener"/&gt; &lt;/property&gt; &lt;property name="newPersistener"&gt; &lt;ref bean="djNewsPersister"/&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id="djNewsListener" class="..impl.DowJonesNewsListener"&gt;&lt;/bean&gt;&lt;bean id="djNewsPersister" class="..impl.DowJonesNewsPersister"&gt;&lt;/bean&gt; 之后就可以通过newsProvider这个名字从容器中取得已经组装好的FXNewsProvider: 123container.readConfigurationFiles(...);FXNewsProvider newsProvider = (FXNewsProvider)container.getBean("newsProvider");newsProvider.getAndPersistNews(); 元数据方式: 代表是Google Guice，可以直接在类中使用元数据信息来标注各个对象之间的依赖关系，Guice框架将对象组装后交给客户端对象使用（即被注入对象）。具体工作的三个步骤是”使用Guice的Inject注解标注依赖关系加入到被注入类中”、”通过Module指定进一步的依赖注入相关信息”、”从Guice获取并用代码确定最终的注入关系”。 1234567891011121314151617181920212223242526// 使用Guice的注解标注依赖关系后的FXNewsProvider定义public class FXNewsProvider &#123; private IFXNewsListener newsListener; private IFXNewsPersister newPersistener; @Inject // 通过Inject指明通过构造方法注入FXNewsProvider依赖的对象 public FXNewsProvider(IFXNewsListener listener,IFXNewsPersister persister) &#123; this.newsListener = listener; this.newPersistener = persister; &#125; ...&#125;// FXNewsProvider所使用的Module实现public class NewsBindingModule extends AbstractModule &#123; @Override protected void configure() &#123; bind(IFXNewsListener.class).to(DowJonesNewsListener.class).in(Scopes.SINGLETON); bind(IFXNewsPersister.class).to(DowJonesNewsPersister.class).in(Scopes.SINGLETON); &#125;&#125;// 从Guice获取并使用最终绑定完成的FXNewsProviderInjector injector = Guice.createInjector(new NewsBindingModule());FXNewsProvider newsProvider = injector.getInstance(FXNewsProvider.class);newsProvider.getAndPersistNews(); IoC容器之BeanFactory 1. Spring容器概述 Spring的IoC容器除了提供IoC支持，还有AOP框架支持、企业级服务集成、线程管理和对象声明周期管理等。IoC Service Provider是Spring容器的子集。Spring提供了两种容器类型: BeanFactory: 基础类型IoC容器，提供完整的IoC支持。默认是lazy-load，即当客户端对象需要访问容器的某个受管对象时，才对该受管对象进行初始化和注入。适用于资源有限、功能要求不严格的场景。 ApplicationContext: 在BeanFactory的基础上构建（间接继承），除基础功能外，还提供了如事件发布、国际化等特性。默认是容器启动的同时就全部初始化并绑定完成，因此需要更多的系统资源。 2. BeanFactory概述 BeanFactory接受应用所需的所有业务对象，返回组装完成且可用的对象。BeanFactory肯定会提供获取组装完成的对象的方法接口（getBean）等。举回前面FXNews的例子。原本我们需要手动定义FXNewsProvider类以及相应的接口与具体类：123456public class FXNewsProvider &#123;...&#125;public interface IFXNewsListener &#123;...&#125;public interface IFXNewsPersister &#123;...&#125;public class DowJonesNewsListener implements IFXNewsListener &#123;...&#125;public class DowJonesNewsPersister implements IFXNewsPersister &#123;...&#125; 而使用BeanFactory的XML配置方式指定业务对象之间的依赖关系就省去了上面的步骤：1234567891011&lt;beans&gt; &lt;bean id="djNewsProvider" class="..FXNewsProvider"&gt; &lt;constructor-arg index="0"&gt; &lt;ref bean="djNewsListener"/&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index="1"&gt; &lt;ref bean="djNewsPersister"/&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; ...&lt;/beans&gt; 在实例化对象时，Bean方式会负责生产:12345678// 使用前FXNewsProvider newsProvider = FXNewsProvider();newsProvider.someFunc();// 使用后BeanFactory container = new XmlBeanFactory(new ClassPathResource("配置文件路径"));FXNewsProvider newsProvider = (FXNewsProvider)container.getBean("djNewsProvider");newsProvider.someFunc(); 3. BeanFactory的对象注册与依赖绑定方式 BeanFactory需要使用Configuration Megadata来明确管理各个业务对象和它们之间的依赖绑定关系。和前面IoC Service Provider提到的一样，有三种方式来定义。 直接编码方式: 需要写比较完整的代码。使用BeanFactory接口的具体实现来完成Bean的注册和管理工作。而每一个受管对象，容器中都会有一个BeanDefinition（RootBeanDefinition和ChildBeanDefinition是其主要实现类）的实例与之对应，保存了对象的class类型、是否是抽象类、构造方法参数等。当客户端对象向BeanFactory请求相应对象的时候，就会利用这些信息返回完备可用的对象。 123456789101112131415161718192021222324252627public static void main(String[] args) &#123; // BeanFactory只是一个接口，需要一个实现类来取得实例对象 DefaultListableBeanFactory beanRegistry = new DefaultListableBeanFactory(); // 注意这里的DefaultListableBeanFactory同时间接实现了BeanDefinitionRegistry接口才能这样直接传入默认转换类型 BeanFactory container = (BeanFactory)bindViaCode(beanRegistry); FXNewsProvider newsProvider = (FXNewsProvider)container.getBean("djNewsProvider"); newsProvider.getAndPersistNews();&#125;public static BeanFactory bindViaCode(BeanDefinitionRegistry registry) &#123; // 构造BeanDefinition AbstractBeanDefinition newsProvider = new RootBeanDefinition(FXNewsProvider.class,true); AbstractBeanDefinition newsListener = new RootBeanDefinition(DowJonesNewsListener.class,true); AbstractBeanDefinition newsPersister = new RootBeanDefinition(DowJonesNewsPersister.class,true); // 将bean定义注册到容器中 registry.registerBeanDefinition("djNewsProvider", newsProvider); registry.registerBeanDefinition("djListener", newsListener); registry.registerBeanDefinition("djPersister", newsPersister); // 指定依赖关系 // 通过构造方法注入方式 ConstructorArgumentValues argValues = new ConstructorArgumentValues(); argValues.addIndexedArgumentValue(0, newsListener); argValues.addIndexedArgumentValue(1, newsPersister); newsProvider.setConstructorArgumentValues(argValues); return (BeanFactory)registry;&#125; 外部配置文件方式: 需要根据不同的外部配置文件格式给出相应的BeanDefinitionReader实现类，由其读取配置并映射到BeanDefinition，然后注册到一个BeanDefinitionRegistry，再完成Bean的注册和加载。-&gt; Properties配置格式: Spring提供了org.springframework.beans.factory.support. PropertiesBeanDefinitionReader类来读取Properties格式的配置文件。 1234567891011121314151617181920212223242526// Properties内容djNewsProvider.(class)=..FXNewsProvider# ----------通过构造方法注入的时候-------------djNewsProvider.$0(ref)=djListener # ref表示参数按引用传递，否则为String类型注入djNewsProvider.$1(ref)=djPersister# ----------通过setter方法注入的时候---------# djNewsProvider.newsListener(ref)=djListener# djNewsProvider.newPersistener(ref)=djPersisterdjListener.(class)=..impl.DowJonesNewsListenerdjPersister.(class)=..impl.DowJonesNewsPersister// Javapublic static void main(String[] args) &#123; DefaultListableBeanFactory beanRegistry = new DefaultListableBeanFactory(); BeanFactory container = (BeanFactory)bindViaPropertiesFile(beanRegistry); FXNewsProvider newsProvider = (FXNewsProvider)container.getBean(&quot;djNewsProvider&quot;); newsProvider.getAndPersistNews();&#125;public static BeanFactory bindViaPropertiesFile(BeanDefinitionRegistry registry) &#123; // Spring提供的类来处理Properties配置文件 PropertiesBeanDefinitionReader reader = new PropertiesBeanDefinitionReader(registry); reader.loadBeanDefinitions(&quot;classpath:../../binding-config.properties&quot;); return (BeanFactory)registry;&#125; -&gt; XML配置格式: Spring同样为XML格式的配置文件提供了现成的BeanDefinitionReader实现 ，即XmlBeanDefinitionReader。它负责读取Spring指定的XML格式配置文件，解析映射到BeanDefinition，然后加载到BeanDefinitionRegistry（DefaultListableBeanFactory）中。 1234567891011121314151617181920212223242526272829303132// XML部分：&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE beans PUBLIC &quot;-//SPRING//DTD BEAN//EN&quot; &quot;http://www.springframework.org/dtd/spring-beans.dtd&quot;&gt;&lt;beans&gt; &lt;bean id=&quot;djNewsProvider&quot; class=&quot;..FXNewsProvider&quot;&gt; &lt;constructor-arg index=&quot;0&quot;&gt; &lt;ref bean=&quot;djNewsListener&quot;/&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index=&quot;1&quot;&gt; &lt;ref bean=&quot;djNewsPersister&quot;/&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=&quot;djNewsListener&quot; class=&quot;..impl.DowJonesNewsListener&quot;&gt; &lt;/bean&gt; &lt;bean id=&quot;djNewsPersister&quot; class=&quot;..impl.DowJonesNewsPersister&quot;&gt; &lt;/bean&gt;&lt;/beans&gt;// Java部分：public static void main(String[] args) &#123; DefaultListableBeanFactory beanRegistry = new DefaultListableBeanFactory(); BeanFactory container = (BeanFactory)bindViaXMLFile(beanRegistry); FXNewsProvider newsProvider = (FXNewsProvider)container.getBean(&quot;djNewsProvider&quot;); newsProvider.getAndPersistNews();&#125;public static BeanFactory bindViaXMLFile(BeanDefinitionRegistry registry) &#123; XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(registry); reader.loadBeanDefinitions(&quot;classpath:../news-config.xml&quot;); return (BeanFactory)registry; // 或者直接 //return new XmlBeanFactory(new ClassPathResource(&quot;../news-config.xml&quot;));&#125; -&gt; 注解方式: 使用@Autowired告知Spring容器需要为当前对象注入哪些依赖对象，标注出的是依赖对象的类。@Component需要结合Spring2.5中的classpath-scanning功能使用，标注出的是需要添加到容器中的所有类。如下面的配置文件中，&lt;context:component-scan/&gt;会到给定的package中把标注了@Component的类加入容器， 12345678910111213141516171819202122232425262728293031323334353637383940414243// Java各个类@Componentpublic class FXNewsProvider &#123; @Autowired private IFXNewsListener newsListener; @Autowired private IFXNewsPersister newPersistener; public FXNewsProvider(IFXNewsListener newsListner,IFXNewsPersister newsPersister) &#123; this.newsListener = newsListner; this.newPersistener = newsPersister; &#125; ...&#125;@Componentpublic class DowJonesNewsListener implements IFXNewsListener &#123;...&#125;@Componentpublic class DowJonesNewsPersister implements IFXNewsPersister &#123;...&#125;// 配置文件：使用classpath-scanning功能&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd&quot; &gt; &lt;!-- 以下这句 --&gt; &lt;context:component-scan base-package=&quot;cn.spring21.project.base.package&quot;/&gt;&lt;/beans&gt;// 应用程序中使用加载好的客户端对象public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;配置文件路径&quot;); FXNewsProvider newsProvider = (FXNewsProvider)container.getBean(&quot;FXNewsProvider&quot;); newsProvider.getAndPersistNews();&#125; 4. BeanFactory的XML配置详解 XML格式的容器信息管理方式是Spring最顶的方式。所有注册到容器的业务对象，在Spring中称之为Bean。所以，每一个对象在XML中的映射也自然而然地对应一个叫做&lt;bean&gt;的元素，多个&lt;bean&gt;也就组成了&lt;beans&gt;。 &lt;beans&gt;: XML的最顶层元素，具有default-lazy-init, default-autowire, default-dependency-check, default-init-method 和 default-destroy-method 等属性，可以方便地为所包围的&lt;bean&gt;元素做统一设置。 &lt;description&gt;, &lt;import&gt;, &lt;alias&gt;: 分别为配置文件做描述、导入其他配置文件、为bean提供外号（比如为了偷懒少打点字）。 &lt;bean&gt;: 每个bean由id属性唯一标识，可添加name属性赋予别名。同时每个Bean都需要class属性指定其类型。接下来介绍的都是包围在bean元素内部的子（孙）元素。 &lt;constructor-arg&gt;: 告诉IoC容器要通过构造函数的方式为当前业务对象注入其所依赖的对象，所包含的ref元素（或简写为ref属性）指明了依赖对象的类名。此外还可以利用constructor-arg的type属性指定当前业务对象构造函数要传入参数的类型、value属性确定参数值、index属性确定参数传入位置 12345678&lt;bean id="djNewsProvider" class="..FXNewsProvider"&gt; &lt;constructor-arg&gt; &lt;ref bean="djNewsListener"/&gt; &lt;/constructor-arg&gt; &lt;constructor-arg&gt; &lt;ref bean="djNewsPersister"/&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; &lt;property&gt;: 告诉IoC容器用setter的方式为当前业务对象注入依赖对象，用法和constructor-arg类似，用ref元素（或简写为ref属性）指定为name=xx的属性注入bean=xx的对象。 12345678&lt;bean id="djNewsProvider" class="..FXNewsProvider"&gt; &lt;property name="newsListener"&gt; &lt;ref bean="djNewsListener"/&gt; &lt;/property&gt; &lt;property name="newPersistener"&gt; &lt;ref bean="djNewsPersister"/&gt; &lt;/property&gt;&lt;/bean&gt; constructor-arg和property的内嵌元素们: &lt;value&gt;可为主体对象注入简单数据类型；&lt;ref&gt;用于引用容器中其他对象实例；&lt;idref&gt;为当前对象注入所依赖对象的名称；内部&lt;bean&gt;为当前对象定义私有的对象；&lt;list&gt;按次序对应注入以collection形式声明的依赖对象；&lt;set&gt;则是无序注入一些值；&lt;map&gt;是注入键值对，以&lt;entry&gt;元素的属性key/key-ref给出键、以&lt;entry&gt;的子元素&lt;value&gt;给出值；&lt;props&gt;是朴素版的map，只支持String类型的键和值，以key属性给出键、props包围的字符为值；&lt;null /&gt;当需要指定为null值的时候使用的特殊符，因为直接留空其实传入的是空字符串而不是null. bean的depends-on属性: 要求容器在初始化自身实例之前首先实例化给定的类，根据id来确定具体是什么bean. bean的autowire属性: 默认取值为no，即不进行自动绑定；byName则是根据客户端类定义中依赖对象的属性名来找匹配到id属性的bean；byType则是根据依赖对象类型找匹配到class属性的bean；constructor是根据客户端的构造函数参数类型来匹配class；autodetect是优先采用constructor再用byType把剩余属性绑定上，只适用于”原生类型、String类型以及Classes类型以外”的对象类型。若觉得为每个bean单独设置相同的autowire麻烦，可以在beans设置default-autowire属性。 bean的dependency-check属性: 对bean所依赖的对象做检查，与自动绑定结合使用，确认当自动绑定完成后，每个对象所依赖的对象是否按照预期的那样被注入了。 bean的lazy-init属性: 前面说过ApplicationContext在启动时会将容器中所有对象实例化，而lazy-init设为true就可以在不违反依赖性的情况下滞后实例化。 bean的parent属性: 根据parent属性指定的id确定类之间的继承关系。此外还有abstract属性。 bean的scope: BeanFactory容器还需要管理对象的生命周期。配置中的bean定义可以看作是模板，容器用这个模板来构造对象，但构造多少、存活多久，就需要scope确定。-&gt; singelton: 容器可保证这种类型的bean在同一个容器中只存在一个共享实例，且从它首次被请求实例化后到容器销毁，该单例都会一直存在。-&gt; prototype: 对于那些不能让请求方共享的对象类型，应当用prototype scope的bean定义，容器在收到这种类型对象的请求时，每次会重新生产实例返回给请求方，然后由请求方负责其后续生命周期管理工作。-&gt; request: 只适用于Web应用程序。可视作prototype在Web中的特例，XmlWebApplicationContext会为每个HTTP请求创建独立的对象供当前请求使用。-&gt; session: 只适用于Web应用程序，对应于Web中的session。与前面的request十分类似，可能实例会比request的bean会长一些。-&gt; global session: 只适用于基于Portlet的Web应用程序，它映射到portlet的global范围的session。 5. 工厂模式和FactoryBean 面向接口编程: 对象通过声明接口来避免对特定接口实现类的过度依赖，满足现实中接口”即插即用”的特性，下层只向上层暴露接口功能，上层对下层仅仅是接口依赖。使用接口的动机就是多态（即从某个更广的角度上看，对原本不同类事物不加区别的对待而统一处理），对于不稳定的问题领域，不在乎它究竟是个什么东西，直接通过接口定义的行为来认知它，规定了其子类应当实现的一组规则；而抽象类相较于接口，其描述的问题领域更为稳定，是从一般到特殊的关系。 关联: 虽说使用接口是为了降低耦合，但总得有一种方式将声明依赖接口的对象与接口实现类关联起来。但我们不应该直接将该对象new出接口的实现类对象，而应当使用工厂模式。如果该类是我们设计开发的，那我们至少还能通过依赖注入让容器帮我们解除接口和实现类之间的耦合性；但若是第三方库，需要实例化其中的相关类，接口与实现类的耦合性需要用工厂模式来解除，即提供一个工厂类来实例化具体的接口实现类。如此一来，主体对象只需要依赖工厂类，具体使用的实现类有变动的话只需要对应修改工厂类，不用动主体对象了。 12345678910public class Foo &#123; private BarInterface barInstance; public Foo() &#123; // 不要直接这样 instance = new BarInterfaceImpl(); // 应该这样 barInstance = BarInterfaceFactory.getInstance(); // 或 barInstance = new BarInterfaceFactory().getInstance(); &#125;&#125; 静态工厂方法: 将工厂类作为正常的bean写入配置文件注册到容器中。若需要传参，可用&lt;constructor-arg&gt;来指定。 123456789101112public class StaticBarInterfaceFactory &#123; public static BarInterface getInstance() &#123; return new BarInterfaceImpl(); &#125;&#125;&lt;bean id=&quot;foo&quot; class=&quot;..Foo&quot;&gt; &lt;property name=&quot;barInterface&quot;&gt; &lt;ref bean=&quot;bar&quot;/&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;bar&quot; class=&quot;..StaticBarInterfaceFactory&quot; factory-method=&quot;getInstance&quot;/&gt; 非静态工厂方法: 客户端对象还是一样注册到bean中，但工厂方法factory-method不直接注册到工厂类的bean中了，而是分成两步。先指定非静态工厂类实例，然后利用factory-bean指定工厂方法所在的工厂类实例。 12345678910111213public class NonStaticBarInterfaceFactory &#123; public BarInterface getInstance() &#123; return new BarInterfaceImpl(); &#125;&#125;&lt;bean id=&quot;foo&quot; class=&quot;..Foo&quot;&gt; &lt;property name=&quot;barInterface&quot;&gt; &lt;ref bean=&quot;bar&quot;/&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;barFactory&quot; class=&quot;..NonStaticBarInterfaceFactory&quot; /&gt;&lt;bean id=&quot;bar&quot; factory-bean=&quot;barFactory&quot; factory-method=&quot;getInstance&quot; /&gt; FactoryBean: 它是一种可以扩展容器对象实例化逻辑的接口，与容器名称BeanFactory区分！我们可以实现接口中规定的三个方法来实现自定义FactoryBean类。而在XML文件中，配置bean并没有什么特别之处。特别的在于，在客户端的Java类中，声明依赖对象的类型不是XML中class给出的NextDayDateFactoryBean类，而是FactoryBean生产出的DateTime类。也就是说FactoryBean类型的bean定义，通过正常的id引用，容器返回的是FactoryBean所“生产”的对象类型，而非FactoryBean实现本身。 123456789101112131415161718192021222324252627import org.joda.time.DateTime;import org.springframework.beans.factory.FactoryBean;public class NextDayDateFactoryBean implements FactoryBean &#123; public Object getObject() throws Exception &#123; return new DateTime().plusDays(1); &#125; public Class getObjectType() &#123; return DateTime.class; &#125; public boolean isSingleton() &#123; return false; &#125;&#125;public class NextDayDateDisplayer &#123; private DateTime dateOfNextDay; // 相应的setter方法 // ...&#125;&lt;bean id=&quot;nextDayDateDisplayer&quot; class=&quot;...NextDayDateDisplayer&quot;&gt; &lt;property name=&quot;dateOfNextDay&quot;&gt; &lt;ref bean=&quot;nextDayDate&quot;/&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;nextDayDate&quot; class=&quot;...NextDayDateFactoryBean&quot; /&gt; 6. Spring的IoC容器启动过程 总的来看，容器加载Configuration Metadata、绑定整个系统的对象、组装成可用系统的这些过程，可以分为两个阶段。 容器启动阶段: 借助某些工具类对配置信息进行解析和分析，将所有的bean定义信息都通过BeanDefinition的方式注册到了BeanDefinitionRegistry中。 Bean实例化阶段: 当某个请求方通过容器的getBean方法明确地请求某个对象，或者因依赖关系容器需要隐式地调用getBean方法时，会触发容器检查初始化、根据注册信息实例化并注入依赖，最后返回给请求方。 IoC容器之ApplicationContext ApplicationContext支持前面BeanFactory的所有功能，还进一步扩展了基本容器的功能，如特殊类型bean的自动识别、容器启动后bean实例的自动初始化、国际化、容器内事件发布等。Spring为ApplicationContext提供了几个基本实现如FileSystemXmlApplicationContext, ClassPathXmlApplicationContext, XmlWebApplicationContext. 1. 统一资源加载策略 URL: Uniform Resource Locator，基本上只限于网络形式发布的资源的查找和定位，而且资源查找和资源的表示的界限不清晰，导致资源返回时的形式多样而不是查找者希望的一个统一的接口。 Resource: Spring定义的所有资源的抽象和访问的接口，提供了一些简单的实现类如ByteArrayResource, ClassPathResource, FileSystemResource等。 ResourceLoader: 资源查找定位策略的统一抽象，具体的策略由实现类给出。例如DefaultResourceLoader实现类就是依次检测classpath, url路径来查找资源。 2. 国际化信息支持 让应用程序为世界各地的人们提供对应语言文字、货币形式、、日期时间格式等，在原声JavaSE中主要涉及两个类，而Spring在此基础上进一步抽象了国际化访问接口。 java.util.Locale: 不同的Locale代表了不同的国家和地区，使用zh_CN、en_US等内置静态常量代码，可帮助程序判断地区信息。 java.util.ResourceBundle: 用于保存特定于某个Locale的信息，通常会管理一组具有统一basename的信息序列，例如用一组properties文件分别保存不同国家地区的信息。 MessageSource接口: 统一了国际化信息的访问方式，传入Locale、资源的key、相关参数便能拿到国际化的信息，而不必从Locale到ResourceBundle再去查询了。有三个实现类，如ResourceBundleMessageSource。 Spring核心技术之AOP (TBC) 1.Aspect Oriented Programming 软件开发的目的最终是为了解决各种需求，包括业务需求和系统需求。运用OOP我们可以对业务需求等普通关注点进行很好的抽象和封装，并使之模块化。但是对于系统需求，例如在后期对系统进行监控需要打印log，或由于权限限制需要进行安全检查，这些系统需求就无法运用OOP“一个需求对应一个实现”这么方便就能集成到现有系统中去了，因为这些需求可能遍及所有的业务对象，因此OOP无法解决系统需求的实现散落在各处的问题。AOP则可以对类似Security和Logging等系统需求进行模块化的组织，简化系统需求和实现之间的对比关系，以模块化的形式对系统中的横切关注点(cross-cutting concern)进行封装。Aspect之于AOP，就如Class之于OOP。 2.Spring AOP Spring AOP实现机制: 属于第二代AOP，采用动态代理机制和字节码生成技术实现，在运行期间为目标对象生成一个代理对象，将横切逻辑织入到这个代理对象，交由系统使用。 动态代理模式: 为指定的接口在系统运行期间动态地生成代理对象，由Proxy类和InvocationHandler接口实现。例如现在的系统需求是在0~6点拒绝访问，要为ISubject和IRequestable两种类型提供相同横切逻辑的代理对象。来实现一个InvocationHandler: 1234567891011121314151617181920212223public class RequestCtrlInvocationHandler implements InvocationHandler &#123; private static final Log logger = LogFactory.getLog(RequestCtrlInvocationHandler.class); private Object target; public RequestCtrlInvocationHandler(Object target) &#123; this.target = target; &#125; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if (method.getName().equals("request")) &#123; TimeOfDay startTime = new TimeOfDay(0, 0, 0); TimeOfDay endTime = new TimeOfDay(5, 59, 59); TimeOfDay currentTime = new TimeOfDay(); if (currentTime.isAfter(startTime) &amp;&amp; currentTime.isBefore(endTime)) &#123; logger.warn("service is not available now"); return null; &#125; return method.invoke(target, args); &#125; return null; &#125;&#125; 然后就可以使用Proxy类使用上面这个RequestCtrlInvocationHandler的横切逻辑，为ISubject和IRequestable两个类提供相应的代理对象: 1234567ISubject subject = (ISubject)Proxy.newProxyInstance(ProxyRunner.class.getClassLoader(), new Class[]&#123;ISubject.class&#125;, new RequestCtrlInvocationHandler(new SubjectImpl()));subject.request();IRequestable requestable = (IRequestable)Proxy.newProxyInstance(ProxyRunner.class.getClassLoader(), new Class[]&#123;IRequestable.class&#125;, new RequestCtrlInvocationHandler(new RequestableImpl()));requestable.request(); AspectJ注解（这部分先不动了。。。） Spring MVC 1.Servlet与JSP Servlet: 是一个Java类，运行于Web容器中，提供了Session和对象声明周期管理等功能，可直接调用Java平台上的各种服务，如用JDBC进行数据访问。但最初没有JSP的时候，Servlet一人承担了太多的职责，流程控制逻辑、视图显示逻辑、业务逻辑、数据访问逻辑混杂在一起，使得后期维护十分困难。 JSP: JSP的出现让Servlet中的视图渲染逻辑能以标准化视图的形式输出，避免了在Servlet中写一堆out.print。由于JSP最终是编译成Servlet执行的，JSP拥有比其他1通用模板更强大的功能，例如可以直接在JSP中写Java代码，几乎任何逻辑都可以写入JSP，这让本该行使简单视图渲染功能的JSP也变得复杂。 Servlet与JSP的分工合作: JSP只负责视图的渲染工作，Servlet只负责请求处理流程的控制以及业务层的交互，而业务层逻辑交给JavaBean，最终形成了MVC三足鼎立的局面。 MVC雏形: JSP model2已经具有了Web应用架构的雏形。-&gt; 控制器: 接受视图发送的请求并处理，根据请求条件去通知模型进行应用程序状态的更新，然后选择合适的视图返回给客户端。-&gt; 模型: 封装了应用的逻辑以及数据状态。当控制器来通知模型进行状态更新的时候，模型内封装的逻辑就会被调用，执行完成后会通过事件机制通知视图状态更新完毕，从而让视图能显示最新的数据状态。-&gt; 视图: 面向用户的接口。当用户通过视图发起某种请求的时候，视图会将请求转发给控制器。经过控制器、模型的处理后，视图最后会收到状态更新的事件通知，视图就会结合模型提供的数据更新自身的显示。但是对于Web应用来说，受限于协议和使用场景，现在的Web MVC其实是由控制器从模型中Pull数据给视图，而不是模型直接Push数据给视图。 2.Spring MVC的处理控制器 引入了Front Controller和Page Controller的概念来分离流程控制逻辑与具体的Web请求处理逻辑。在Spring MVC框架中，Front Controller对应DispatcherServlet，负责接收并处理所有的Web请求，针对不同的处理逻辑委派给下一级Page Controller去实现，即servlet.mvc.Controller。这个部分在练手项目中有涉及。 HandlerMapping: Web请求的处理协调人。DispatcherServlet作为FrontController，注定要服务一组Web请求，而不能一个请求对应一个Servlet。通常Web请求与处理类之间的映射通过“掐头去尾”的方式匹配。 org.springframework.web.servlet.Controller: Web请求的具体处理者。处理完成后会返回ModelAndView实例，包含了视图逻辑名称、模型数据等信息，DispatcherServlet可以开始渲染视图了。 HttpServletResponse输出视图步骤: 获取Model数据、获取视图模版文件（.jsp, .vm, *.xls等）、结合视图模板和模型数据，使用相应的视图API生成最终视图结果。其中这个API需要依赖ViewResolver来处理逻辑视图名和具体View实例之间的对应关系。 3.Spring MVC项目结构 （可参考练手项目） WebContent-{[*.jsp] &amp; [“WEB-INF”-(web.xml &amp; controller-servlet.xml &amp; applicationContext.xml …)] &amp; [lib] &amp; [classes]}。 web.xml: 整个Web应用程序的部署描述符文件，是所有基于Servlet规范的Web程序都有的。大致内容如下 123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app ...&gt; &lt;display-name&gt;xxxxx&lt;/display-name&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;servlet&gt; &lt;servlet-name&gt;controller&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;/servlet&gt;&lt;/web-app&gt; ContextLoaderListener与applicationContext.xml: ContextLoaderListener负责为整个Web程序加载顶层WebApplicationContext，其中注册了数据源定义DS、数据访问对象DAO定义等。而它正是由applicationContext.xml配置文件。不过通常会将这个配置文件进行分割细化，因此需要在web.xml中加入 1234&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/applicationContext.xml, /WEB-INF/applicationContext-module1.xml&lt;/param-value&gt;&lt;/context-param&gt; DispatcherServlet与XXX-servlet.xml: DispatcherServlet相当于struts中的ActionServlet，需要从配置文件中读取Spring MVC框架处理Web请求过程中涉及的各种组件，如HandlerMapping, Controller, ViewResolver的定义等。这个配置文件名称与web.xml中&lt;servlet-name&gt;一致。DispatcherServlet根据这个配置文件构建特定于自己的WebApplicationContext，将前面的顶层WebApplicationContext作为父容器。同样的，XXX-servlet.xml也可以拆分成多个模块: 12345678&lt;servlet&gt; &lt;servlet-name&gt;controller&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/controller-servlet.xml, /WEB-INF/module1-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt; 其他参考资料credit tohttps://www.zhihu.com/question/21142149https://www.ibm.com/developerworks/cn/java/wa-spring1/https://www.ibm.com/developerworks/cn/java/j-lo-spring-principle/http://www.iteye.com/blogs/subjects/springmvc-explorehttps://zhuanlan.zhihu.com/p/20618651https://zhuanlan.zhihu.com/tianmaying?topic=Spring]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>web</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Note for Professional JavaScript for Web Developers (2/4)]]></title>
    <url>%2F2016%2F09%2F10%2Fjavascript_professional_2%2F</url>
    <content type="text"><![CDATA[JavaScript高级程序设计（第3版）这本书的内容真的有点多，笔记得分成几个部分，不然挤在一篇里面就太长了不方便看。这是第二篇笔记，得加快点进度了。本篇对应6~8章。 面向对象的程序设计 JavaScript中的对象 ECMA定义: 对象是无序属性的集合，其中属性可以包含基本值、对象或者函数。每个对象都基于一个引用类型值创建。由于ECMAScript中没有类的概念，这里说的对象也就和那些基于类的语言不太一样了。 创建对象: 可以采用new Object()的形式；但更常用的是对象字面量的形式。 数据属性: 每个property都有各自的attribute，描述了property的配置信息。-&gt; configurable: 能否通过delete来重新定义属性、修改属性的特性等。默认为true.-&gt; enumerable: 能否通过for-in循环返回属性。默认为true.-&gt; writable: 能否修改属性的值。默认为true.-&gt; value: 存储这个属性的数据值。默认为undefined.要想修改property的attribute，必须使用Object.defineProperty()静态方法。 123456789101112131415var person = &#123;&#125;;Object.defineProperty(person, "name", &#123; writable: false, value: "Bobby"&#125;);// 此时name属性是只读的。person.name = "JB"; // 在strict模式下修改只读属性会报错，正常模式则直接忽略此句Object.defineProperty(person, "name", &#123; configurable: false,&#125;);// 此时name不可配置。无法修改除了writable的其他attribute。所以无法再把config改回true了。delete person.name; // 无法删除name属性 访问器属性: 不包含数据值属性。含有一对getter和setter函数，不过倒也不是必须含有的。除了configurable和enumerable，访问器属性还有get和set两个属性。只能使用Object.defineProperty()静态方法来定义和修改访问器属性。-&gt; get: 读取属性时调用的函数。默认为undefined.-&gt; set: 写入属性时调用的函数。默认为undefined. 12345678910111213141516var book = &#123; _year: 2014, // 以下划线开头就表示这个变量必须通过对象方法来访问和修改 edition: 1&#125;Object.defineProperty(book, "year", &#123; get: function() &#123; return this._year; &#125;, set: function(newYear) &#123; if (newYear &gt;= 2014) &#123; this._year = newYear; this.edition = (newYear - 2014); // 这不是书上的源码，我感觉中文版有错，不知原书如何。 &#125; &#125;&#125;); 修改多个属性的特性: 为了方便同时修改多个properties的attributes，ECMAScript 5引入了Object.defineProperties()方法，用法与Object.defineProperty类似。 读取属性的特性: ECMAScript 5提供了Object.getOwnPropertyDescriptor()来取得给定属性的描述符，接受两个参数:对象名+属性名。 创建对象 前面提到了Object构造函数和对象字面量两种方式来创建单个对象，但是使用同一个接口会创建出很多对象，产生大量重复代码。 工厂模式: 抽象出了创建具体对象的过程，用函数封装以特定接口创建对象的细节。这个方法解决了多个相似对象代码重复的问题，但是无法解决对象类型识别问题。 123456789101112function createPerson(name, age, job) &#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function() &#123; alert(this.name); &#125;; return o;&#125;var person1 = createPerson("A", 18, "driver"); 构造函数模式: 利用ECMAScript的函数声明提升特性，创建自定义的构造函数，在代码运行之前就存在于环境中。注意在构造函数中没有显示地创建对象，自然也就不需要return具体对象了。创建对象会经历一下四个阶段:(1)new出一个新对象；(2)将构造函数的作用域赋给新对象（this也会指向它）；(3)执行构造函数代码；(4)返回新对象。事实上任何函数在前面加个new操作符，都可看作构造函数。构造函数的不足就在于每个方法都会在每个对象实例中重新创建一遍，每个对象的函数都是不同的函数对象（即便代码一模一样）。解决的办法是把函数代码放到构造函数外，相当于全局函数，而在对象内部只是赋予一个引用。这样暂时解决了重复函数对象的问题，但又导致封装型被破坏。 1234567891011121314151617function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; o.sayName = function() &#123; alert(this.name); &#125;;&#125;// 当构造函数使用var person1 = new Person("A", 18, "driver");// 当普通函数使用，此时只是将其中的属性和方法添加到全局环境，即window中Person("A", 18, "driver");// 在另一个对象的作用域中调用var o = new Object(); Person.call(o, "A", 18, "driver"); 原型模式: 每个函数都有prototype属性，指向一个原型对象。使用原型对象让所有对象实例共享它包含的属性和方法。原型对象会自动获得一个constructor属性，指向的就是”指向这个原型对象”的函数。可使用obj.isPrototypeOf(obj)来判断前者是否是后者的原型对象。对于每一个对象实例来说，都是可以访问到原型对象的属性的，但是不能通过实例去修改对应的原型对象中的属性。对实例添加同名的属性和方法时，对于这个实例会暂时将原型对象的同名属性和方法屏蔽掉，直到使用delete。可使用obj.hasOwnProperty()来判断属性来自实例本身还是它的原型。in操作符则是只要属性能访问到，无论是本身还是原型，都返回true。原型对象有动态性，我们对原型对象做的任何修改都会立刻从各个实例上体现出来。但是需要指出，如果是直接对prototype整个进行重新赋值，那就相当于切断了构造函数与最初原型之间的联系。在这种情况下，更新的原型就不会体现在原有的实例上了，它们指向的还是原来的原型对象。实例中的指针仅指向原型，而不指向构造函数。原型模式存在的问题也就在于它共享的本性，尤其是对于引用类型的属性，例如Array数组在某一实例中的修改会体现在另外的实例中，这显然是不可接受的。 12345678910111213141516171819202122232425262728function Person() &#123;&#125; // 即便构造函数是空的也能正常工作，因为实例访问属性和方法时会不断向上搜索直到原型对象。Person.prototype.name = "Bobby";Person.prototype.age = 21;Person.prototype.job = "???"; // 只是为了演示才把属性也放到原型中。讲道理，这么写不合常理。Person.prototype.sayName = function() &#123; alert(this.name);&#125;;// 更简洁的写法看这里，但是这相当于重建了Person的原型，这会导致constructor不再指向Person。// 不过你也可以手动添加constructor: Person, 只不过会把enumerable改成true。而默认是不可遍历的。/*Person.prototype = &#123; name: "Bobby"; age: 18; job: "???"; sayName = function() &#123; alert(this.name); &#125;&#125;;*/var person1 = new Person();var person2 = new Person();// 可结合hasOwnProperty和in操作符判断属性是否在原型对象中function hasPrototypeProperty(object, propertyName) &#123; return !object.hasOwnProperty(propertyName) &amp;&amp; (propertyName in object);&#125; 组合使用构造函数模式和原型模式: 这是目前使用最广泛、认同度最高的用法。构造函数模式用于定义实例属性，原型模式用于定义方法和少量共享的属性。这样可以保证每个实例都拥有自己独立的实例属性（包括引用类型），同时又共享了对方法的引用，节省了内存。 12345678910111213function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.friends = ["A", "B"];&#125;Person.prototype = &#123; constructor: Person, sayName: function() &#123; alert(this.name); &#125;&#125; 动态原型模式: 由于上面的组合模式将构造函数和原型独立开来，可能会造成困扰。而动态原型模式就把这两个都封装到了构造函数中，也保持了混合模式的优点。 1234567891011121314function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.friend = ["A", "B"]; // 共享方法放到条件语句中。注意不能用对象字面量来重写原型了。 // 在已经创建实例的情况下直接重写会完全斩断已有实例和新原型的联系，无法保证改动即时反映到所有实例中。 if (typeof this.sayName != "function") &#123; Person.prototype.sayName = function() &#123; alert(this.name); &#125;; &#125;&#125; 寄生构造函数模式: 可用于在特殊情况下为对象创建构造函数，例如创建一个具有特殊方法的数组。其实和工厂模式没什么区别。所以无法用instanceof操作符确定对象的类型。 123456789101112function SpecialArray() &#123; var values = new Array(); values.push.apply(values, arguments); // 将传入的值添加进去 values.toPipedString = function() &#123; return this.join("|"); &#125; return values; // 和工厂模式一样有返回&#125;// 和工厂模式不同的是要用new操作符var colors = new SpecialArray("red", "blue", "green"); 稳妥构造函数模式: 稳妥durable指的是没有公共属性、且其方法也不引用this、不使用new操作符调用构造函数。 继承 传统的继承: 通常OO语言支持两种继承方式，即接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。 ECMAScript中的继承: 由于函数没有签名，故JavaScript中没有接口继承，只有实现继承。实现方式主要是通过原型链。 原型链: 利用原型让一个引用类型继承另一个引用类型的属性和方法。不妨回忆一下构造函数、原型与实例之间的关系。每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例则包含一个指向原型对象的内部指针。实现的本质是重写原型对象，代之以一个新类型的实例。 确定原型和实例之间的关系: ins instanceof Object使用instance操作符测试实例与构造函数，只要构造函数在它的原型链中出现过就为true.还可以使用Object.prototype.isPrototypeOf(ins)判断该实例是否是该原型链派生。 子类重写超类型中的方法: 必须在用父类new出来的实例替换掉子类的prototype后再重新定义方法。而且只能通过name.prototype.methodName = function(){}的形式来重写，不能用对象字面量的方式。 123456789101112131415161718192021222324function SuperType() &#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function() &#123; return this.property;&#125;;function SubType() &#123; this.subproperty = false;&#125;SubType.prototype = new SuperType();SubType.prototype.getSubValue = function() &#123; return this.subproperty;&#125;;SubType.prototype.getSuperValue = function() &#123; return false;&#125;;var instance = new SubType();alert(instance.getSuperValue()); // 弹出false; 原型链的问题:(1) 超类型实例中的引用类型会为所有子类共享，子类实例对其修改是全局可见的；(2) 在创建子类型的实例时，不能向超类型的构造函数中传递参数。 借用构造函数constructor stealing: 在子类型构造函数的内部调用超类型的构造函数。毕竟函数只不过是在特定环境中执行代码的对象，因此通过apply或call也可以在新创建对象上执行构造函数。 1234567891011function SuperType(countryName) &#123; this.flagColors = ["red", "yellow"]; this.countryName = countryName;&#125;function SubType() &#123; SuperType.call(this, "China"); this.age = 67;&#125;var instance = new SubType(); 借用构造函数的问题: 无法避免构造函数本身的问题，即每个实例都会创建一个方法副本，函数复用根本无从谈起。 组合继承: 将原型链和借用构造函数组合起来，使用原型链实现对原型属性和方法的继承，使用借用构造函数实现对实例属性的继承。 1234567891011121314151617function SuperType(countryName) &#123; this.flagColors = ["red", "yellow"]; this.countryName = countryName;&#125;function SubType(countryName, age) &#123; SuperType.call(this, countryName); // 借用构造函数。第二次调用超类型构造函数。 this.age = 67;&#125;SubType.prototype = new SuperType(); // 第一次调用超类型构造函数。SubType.prototype.sayAge = function() &#123; // 原型链 alert(this.age);&#125;;var instance = new SubType(); 组合继承的问题: 无论什么情况下，都会调用两次超类型构造函数: 一次在创建子类型原型的时候，另一次是在子类型构造函数内部。 原型式继承prototypal inheritance: 可手写一个object函数或使用ECMAScript 5定义的Object.create函数实现继承，其中Object.create()除了接受原型对象实例，还可以传入额外的属性对象。但用原型式继承的方式，超类型实例中的引用类型属性又是共享的了。 1234567891011121314151617function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;var person = &#123; name: "Bobby", friends: ["A", "B"] &#125;;var anotherPerson = object(person);var yetAnotherPerson = Object.create(person, &#123; name: &#123; value: "C" &#125;&#125;); 寄生式继承: 创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后返回这个对象。 123456789function createAnother(original) &#123; var clone = object(original); clone.sayHi = function() &#123; // 增强对象，也就是加点料 alert("hi"); &#125;; return clone;&#125;var anotherPerson = createAnother(person); 寄生组合式继承: 首先要指出，这是引用类型最理想的继承范式。前面提到组合继承需要调用两次超类型的构造函数，所以这里的思路是不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。我们可以使用寄生式继承来继承超类型的原型，然后将结果指定给子类型的原型。它的高效性体现在只调用一次超类型的构造函数、避免了创建不必要的冗余属性。它仍保持了原型链，故instanceof和isPrototypeOf都能正常使用。 12345678910111213141516171819202122232425262728293031function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;function inheritPrototype(subType, superType) &#123; var prototype = object(superType.prototype);// 创建超类型原型的一个副本 prototype.constructor = subType; // 弥补因重写原型而失去的默认的constructor属性 subType.prototype = prototype; // 将副本赋值作为子类型的原型&#125;function SuperType(name) &#123; this.name = name; this.colors = ["red", "yellow"];&#125;SuperType.prototype.sayName = function() &#123; alert(this.name);&#125;;function SubType(name, age) &#123; SuperType.call(this, name); this.age = age;&#125;inheritPrototype(SubType, SuperType);SubType.prototype.sayAge = function() &#123; alert(this.age);&#125;; 函数表达式 ECMAScript中的函数如前面所提，函数声明有两种方式。一是正常的函数声明，二是函数表达式（赋值）。前者具有函数提升的特性，保证在执行代码之前，所声明的函数都是可用的。 递归如前面所提，函数声明的形式实现递归，可能导致无法正确引用原函数的问题。一个解决方法是使用arguments.callee，但在strict模式下不能用。所以最好用函数表达式+重命名内部函数来实现。 1234567891011var factorial = (function f(n) &#123; if (n &lt;= 1) &#123; return 1; &#125; else &#123; return n * f(n - 1); &#125;&#125;);var anotherFac = factorial;factorial = null;alert(anotherFac(4)); 闭包 闭包的概念: 指有权访问另一个函数作用域中变量的函数。创建闭包的常见形式，就是在一个函数内部创建另一个函数。当函数返回了一个闭包时，这个函数的作用域将会一直存在于内存直到闭包不存在为止。 以下面这个“创建比较函数”的代码为例。在createCmp内部创建的匿名函数中访问了外部的变量propertyName，即使内部函数已经被返回、离开了createCmp的执行环境、且创建的内部函数是在其他地方被调用，也仍然可以访问到createCmp的变量。这是因为在函数内部定义的函数会将包含它的函数（即外部函数）的活动对象添加到它的作用域链中，当createCmp函数返回后，它的活动对象不会被销毁，因为它包含的匿名函数的作用域链仍在引用它的活动对象。 123456789101112131415161718function createCmp(propertyName) &#123; return function(object1, object2) &#123; var value1 = object1[propertyName]; var value2 = object2[propertyName]; // 访问外部函数的变量 if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125; &#125;;&#125;var cmpNames = createCmp("names");var result = cmpNames(&#123;name: "A"&#125;, &#123;name: "B"&#125;);cmpNames = null; // 匿名函数在此时才销毁，手动通知释放内存 谨慎使用闭包: 由于闭包会携带包含它的函数的作用域，所以会比正常的函数占用更多内存。 闭包与变量: 闭包只能取得外部包含它的函数的任何变量的最终值。这是由于闭包保存的是外部活动对象这个整体，而不是具体的某个变量。在下面的例1中，每个匿名函数都保存着同一个createFunctions函数的活动对象，它们引用的是同一个i，也是最终状态的i。而例2则创建多了一个匿名函数并立即执行，将结果返回给数组 12345678910111213141516171819202122232425// 例1function createFunctions() &#123; var result = new Array(); for (var i = 0; i &lt; 10; i++) &#123; result[i] = function() &#123; return i; &#125;; &#125; return result; // 全都是10&#125;// 例2function createFunctions() &#123; var result = new Array(); for (var i = 0; i &lt; 10; i++) &#123; result[i] = function(num) &#123; return function() &#123; return num; // 访问num的闭包 &#125;; &#125;(i); // 立即执行匿名函数 &#125; return result; // 1, 2, 3, ..., 10&#125; 闭包中的this: this对象是在运行时基于函数的执行环境而定的。由于匿名函数的执行环境具有全局性，其中的this对象通常指向window.每个函数在调用时，其活动对象都会自动取得this和arguments两个特殊变量，内部函数在搜索这两个变量时，只会搜索到它自己的活动变量为止，不可能直接访问外部函数的这两个变量。如下面的例子所示，调用可写作(object.(sayName())())，先执行里面一层，再执行后面一层的匿名函数。既然闭包能够访问的是在包含函数中特意用var声明的变量，那我们就可以先用一个that变量将包含函数的this保存起来，这样即使调用时第一层的函数返回了，that也保持着对object的引用，这样匿名函数就能正常访问到object内定义的name了。 1234567891011121314151617181920212223var name = "The Window";var object = &#123; name: "The Object", sayName: function() &#123; return function() &#123; return this.name; &#125;; &#125;&#125;;alert(object.sayName()()); // 在非strict模式下弹出The Window// 用闭包让匿名函数能访问到外部函数的thisvar object = &#123; name: "The Object", sayName: function() &#123; var that = this; return function() &#123; return that.name; &#125;; &#125;&#125;;alert(object.sayName()()); // 弹出The Object 防止内存泄漏: 如果闭包的作用域链中保存着一个HTML元素，该元素无法正常销毁。如例1中为element的onclick事件创建了处理程序的闭包，而匿名函数又保持了对assignHandler函数中活动对象的引用，这导致无法减少element的引用数而无法被回收。所以我们需要养成好习惯，将DOM元素的某些属性单独拎出来存入单独的变量，然后在匿名函数后面手动将DOM操作的元素变量赋值为null解除对DOM元素的引用。如果没有这一步，即使闭包不直接引用element，闭包引用的包含函数的整个活动对象仍会保存着element的引用。 123456function assignHandler() &#123; var element = document.getElementById("someElement"); element.onclick = function() &#123; alert(element.id); &#125;&#125; 用匿名函数模仿块级作用域 块级作用域: 在JavaScript中是没有块级作用域的，在块语句中定义的变量，实际上在外部依然可以访问，只要作用域没有销毁。 123456function outputN(n) &#123; for (var i = 0; i &lt; count; i++) &#123; alert(i); &#125; alert(i); // 仍然可以访问&#125; 匿名函数cosplay块级作用域: 在匿名函数内定义的任何变量，都会在执行结束时销毁。那么我们可以在声明一个匿名函数后立即执行，则其中的变量就会自然而然地销毁了。这个特性可以在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数。 123456(function() &#123; var now = new Date(); if (now.getMonth() == 0 &amp;&amp; now.getDate() == 1) &#123; alert("Happy new year!"); &#125;&#125;)(); // 对应传入参数，立即执行 私有变量 私有变量的概念: 任何在函数中定义的变量都是私有变量，因为不能在函数的外部访问到这些变量。私有变量包括函数的参数、局部变量和函数内部定义的其他函数。（注意说的不是私有属性！JavaScript的所有属性都是公有的！） 特权方法privileged method: 有权访问私有变量和函数的公有方法。利用私有和特权成员，可以隐藏那些不应该被直接修改的数据。在构造函数中，在定义方法前加this即可，利用的是“初始化未经声明的变量，总会创建一个全局变量”。但缺点是每个实例都会创建同样的一组方法。 123456789101112function MyObject() &#123; var privateVar = 10; function privateFunc() &#123; return false; &#125; // 特权方法。但在strict模式下给未经var声明的变量赋值会报错 this.publicMethod = function() &#123; privateVar++; return privateFunc(); &#125;;&#125; 静态私有变量: 私有变量和函数由实例共享，变量的修改牵一发而动全身。 12345678910111213141516171819(function() &#123; var name = ""; Person = function(value) &#123; name = value; &#125;; Person.prototype.getName = function() &#123; return name; &#125;; Person.prototype.setName = function(value) &#123; name = value; &#125;; &#125;) ();var p1 = new Person("A");var p2 = new Person("B");alert(p1.getName()); // Balert(p2.getName()); // B 模块模式module pattern: 为单例singleton创建私有变量和特权的方法。单例指的是只有一个实例的对象，JavaScript中的对象字面量可以很方便地创建单例对象。如果必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有数据的方法，就可以用模块模式。注意每个单例的类型用instanceof都只能得出是Object类型，作为全局变量存在。 1234567891011121314151617var application = function() &#123; // 私有变量和函数 var components = new Array(); components.push(new BaseComponent()); // 初始化，例如丢进一些组件 // 公共 return &#123; getComponentCount: function() &#123; return components.length; &#125;, registerComponent: function(component) &#123; if (typeof component == "object") &#123; components.push(component); &#125; &#125; &#125;;&#125; (); 增强版模块模式: 在返回对象之前加入对其增强的代码，即返回的是一个特定类型的对象实例同时对其添加了属性和方法进行增强。 123456789101112131415161718192021var application = function() &#123; // 私有变量和函数 var components = new Array(); components.push(new BaseComponent()); // 初始化，例如丢进一些组件 // 创建指定类型的局部副本 var app = new BaseComponent(); // 公共接口 app.getComponentCount = function() &#123; return components.length; &#125;; app.registerComponent = function(component) &#123; if (typeof component == "object") &#123; components.push(component); &#125; &#125;; return app; // 将特定类型的实例返回&#125; (); BOM window对象 BOM: 浏览器对象模型，是JavaScript能在Web中使用的关键。BOM提供了很多对象，用于访问浏览器的功能，而与页面无关。 window: BOM的核心对象，是浏览器的实例。它既是通过JavaScript访问浏览器窗口的一个接口、又是ECMAScript规定的Global对象。 全局作用域: 所有在全局作用域中声明的变量、函数都会变成window对象的属性和方法。不过直接定义到window上的属性和全局变量还是有一点区别的，前者可以用delete操作符从window中删除，后者不行。window还能提供一个”属性查询”的功能: 123var newValue = oldValue; // 若oldValue没有定义，会报错var newValue = window.oldValue; //这是一次属性查询，newValue获得值undefined frame中的window: 在HTML中使用frameset+frame可以在同一个浏览器窗口中显示多个独立的小方框显示不同的页面。虽然现在已经很少用frame了，不过不妨了解一下在使用frame的情况下如何获取各个独立页面的window对象。每个frame都有独立的window对象，存储在frames集合中，可通过索引或名称的方式访问，即top.frames[0]或top.frames[&quot;topFrame&quot;]。其中top对象始终指向最外层框架，即浏览器窗口，而如果用window对象访问frames集合，可能指向的是某个框架的特定实例而不是顶层的窗口。与top对象相对应地，parent对象始终指向当前框架的上层 12345678910111213141516&lt;html&gt;&lt;head&gt; &lt;title&gt;Frameset Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;frameset rows="100,*"&gt; &lt;frame src="frame.html" name="topFrame"&gt;&lt;/frame&gt; &lt;frameset cols="50%, 50%"&gt; &lt;frame src="anotherFrame.html" name="leftFrame"&gt;&lt;/frame&gt; &lt;frame src="anotherFrameset.html" name="rightFrame"&gt;&lt;/frame&gt; &lt;/frameset&gt; &lt;/frameset&gt;&lt;/body&gt;&lt;/html&gt;其中的anotherFrameset.html包含一个新的frameset，这里就不列出来了。 窗口位置: 使用screenLeft和screenTop（或screenX和screenY）可取得窗口的位置信息，但可能无法跨浏览器获得窗口左边和上边的精确坐标，而且可能无法获取frame的坐标。而移动窗口到指定位置可以用window.moveTo和window.moveBy完成，不过可能被浏览器默认禁用。 123456// 跨浏览器获取页面左边和上边的位置var leftPos = (typeof window.screenLeft == "number")? window.screenLeft: window.screenX;var topPos = (typeof window.screenTop == "number")? window.screenTop: window.screenY;window.moveTo(0, 0); // 移动窗口到左上角window.moveBy(-50, 100); // 左移50，下移100 窗口大小: 使用innerWidth, innerHeight, outerWidth, outerHeight可以获取页面视图大小和外层浏览器本身的尺寸，但外层尺寸不一定可以跨浏览器获取。此外，还可以通过document属性的方式来获取。调整窗口可以使用window.resizeTo和window.resizeBy，也可能会被浏览器禁用。 1234567891011121314151617// document方式获取窗口大小var pageWidth = window.innerWidth, pageHeight = window.innerHeight;if (typeof pageWidth !== "number") &#123; if (document.compatMode === "CSS1Compat") &#123; pageWidth = document.documentElement.clientWidth; pageHeight = document.documentElement.clientHeight; &#125; else &#123; pageWidth = document.body.clientWidth; pageHeight = document.body.clientHeight; &#125;&#125;// 调整到100 * 100window.resizeTo(100, 100);// 调整到200 * 50window.resizeBy(100, -50); 打开窗口: 使用window.open可以导航到特定URL或打开一个新的浏览器窗口，接收4个参数：目标URL、target、特性字符串和是否取代当前页历史记录的boolean。其中第二个参数会优先查找并打开在URL中是否有该名称的窗口或框架，其次可以选择_self, _parent, _top, 或_blank，最后若确实没有找到该名称，则会根据第三个参数打开新窗口。window.open会返回一个指向新窗口的引用，可存入一个变量中对该窗口进行其他操作。新窗口还会用opener指向原始窗口，但原窗口并不会记录自己打开了哪些新窗口。有些浏览器会有弹出窗口屏蔽的功能，我们有时需要检测弹出的窗口是否被封杀。 123456789101112window.open("http://xxx.com", "newWindow", "height=400, width=400, top=20, left=0, resizeable=yes");// 检测封杀var blocked = false;try &#123; var newWin = window.open("http://xxx.com", "_blank"); if (newWin === null) &#123; blocked = true; &#125;&#125; catch (ex) &#123; // 有些封杀后会抛出异常 blocked = true;&#125; 超时调用与间歇调用: setTimeout(function, timems)可控制延时多少ms再执行函数，可利用返回的id结合clearTimeout取消掉。setInterval(function, timems)则是设置每间隔多少ms就执行一次函数。在真正开发时，间歇调用很少用上，因为后一个间歇调用很可能在前一个间歇调用结束之前启动。完全可以用超时调用来模拟间歇调用避免间歇调用的混乱。 12345678910111213141516171819202122232425262728var timeoutId = setTimeout(function() &#123; alert("Hey, girl!")&#125;, 1000);clearTimeout(timeoutId);var tick = 0, max = 10;var intervalId = null;function tickIncre() &#123; tick++; if (tick === max) &#123; clearInterval(intervalId); alert("tick Done!"); &#125;&#125;intervalId = setInterval(tickIncre, 500);// 用超时调用模拟间歇调用var tick = 0, max = 10;var intervalId = null;function tickIncre() &#123; tick++; if (tick &lt; max) &#123; setTimeout(tickIncre, 500); &#125; else &#123; alert("tick Done!"); &#125;&#125;setTimeout(tickIncre, 500); 浏览器对话框: 对话框样式由浏览器定义，与网页无关。打开的对话框都是同步和模态的，弹出时代码会暂停执行，等用户操作反馈后才会恢复执行。alert()弹出只有“确定”按钮的对话框；confirm()则有“确定”和“取消”两个按钮，会根据用户的选择返回布尔值；prompt()与confirm相比又多了一个文本输入框，点击确定则会返回这个字符串、否则返回null。 1234var result = prompt("What do you mean?", "hint text");if (result !== null) &#123; alert("Welcome, " + result);&#125; location对象location对象既是window的属性，又是document的属性。location保存着当前文档的信息，还将URL分割成独立的片段，可通过不同属性访问这些片段。 查询参数: 在URL后接参数（以?开头）可以传递参数，使用location.search可以访问这一串参数，但是没法把每个参数拆分开来。不妨手动实现一发，直接用返回对象的属性的形式来访问各个参数，十分方便。 1234567891011121314151617181920function getQueryStringArgs() &#123; var qs = (location.search.length &gt; 0 ? location.search.substring(1) : "", args = &#123;&#125;, items = qs.length ? qs.split("&amp;") : []; item = null, name = null, value = null; for (var i = 0, len = items.length; i &lt; len; i++) &#123; item = items[i].split("="); name = decodeURIComponent(item[0]); value = decodeURIComponent(item[1]); if (name.length) &#123; args[name] = value; &#125; &#125; return args;&#125; 地址跳转: 使用assign方法、设置window.location、修改location.href属性是三种等价的方式可以进行地址跳转。而使用replace方法就是直接替换地址（即无法后退）。使用reload方法可以重新加载页面。 1234567891011// 浏览器地址跳转location.assign("http://xxx.com");window.location = "http://xxx.com";location.href = "http://xxx.com";// 替换location.replace("http://xxx.com");// 重加载location.reload(); // 重新加载，可能用到缓存location.reload(true); // 从服务器重新加载 navigator对象用于识别客户端浏览器，拥有一大堆属性帮助检测浏览器。 检测插件: 对于非IE浏览器可通过navigator.plugins来获取插件的集合，然后进行字符串搜索就可以知道是否安装给定的插件。而IE得使用ActiveXObject尝试创建一个实例来检测是否有给定的插件。通常会针对不同插件编写不同的函数，保证跨浏览器都能检测。 123456789101112131415161718192021222324252627function hasPlugin(name) &#123; name = name.toLowerCase(); for (var i = 0, len = navigator.plugins.length; i &lt; len; i++) &#123; if (navigator.plugins[i].name.toLowerCase().indexOf(name) &gt; -1) &#123; return true; &#125; &#125; return false;&#125;// IE专属function hasIEPlugin(name) &#123; try &#123; new ActiveXObject(name); return true; &#125; catch (ex) &#123; return false; &#125;&#125;function hasQuickTime() &#123; var result = hasPlugin("QuickTime"); if (!result) &#123; result = hasIEPlugin("QuickTime.QuickTime"); &#125; return result;&#125; 注册处理程序: navigator.registerContentHandler()和navigator.registerProtocolHandler()可以让站点指明它所能处理特定类型的信息。使用history.length还可以得知当前窗口的记录数量，可用于判断本页面是否为用户打开的第一个页面。 screen对象包含浏览器外部显示屏的信息，例如availWidth, availHeight。 history对象包含用户的上网记录，每个窗口都有history属性。虽然不能获取用户的历史记录，但可以用go函数实现前进、后退等跳转。12345history.go(2); // 前进2页history.go(-1); // 后退1页history.back();history.forward();]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>frontend</tag>
        <tag>js</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Note for Ducumentation of jQuery MiniUI]]></title>
    <url>%2F2016%2F09%2F05%2Fjquery_miniui%2F</url>
    <content type="text"><![CDATA[那本厚厚的JavaScript高级程序设计还没看完，先开动jQuery。早就听说jQuery的强大，这个jQuery MiniUI是基于它的，强于处理表格数据，提供了方便的API，可以研究一波。 概述 MiniUI 在MiniUI官网下载对应版本的MiniUI。不过其实开发前端只用到里面的几个js文件和miniui文件夹而已。对于我下载的这个mini_java版本而言，就是WebContent\scripts中的miniui文件夹、boot.js、jquery-1.6.2.min.js、tongji.js。这里的tongji其实是个空文件，暂时不知用途。 其他开发环境配置 除了前端的MiniUI，事实上这边还需要用Java的maven来构建ssh框架。为此安装了jdk-6u20-windows-i86, mysql-5.0.22-win32, Eclipse Java EE Indigo。暂时还没有学这些。 表格(CRUD) CRUD增查改删 C-create, R-retrieve, U-update, D-delete，对应到数据库中最常用的四个操作“增查改删”。在MiniUI中，主要是以表格的形式呈现数据的，MiniUI提供了对这些数据的可视化CRUD操作。在MiniUI文档中，主要介绍了4种方式来update数据。 单元格编辑 直接在数据列表中，点击每个单元格直接进行修改，不需要二级界面。在MiniUI中为div添加class=&quot;mini-datagrid&quot;属性即可使用内置的数据表格样式。而设置单元格点击编辑其实十分简单，首先为mini-datagrid的div添加allowCellEdit=&quot;true&quot;和allowCellSelect=&quot;true&quot;，然后在对应的div列的单元格添加input标签并添加property=&quot;editor&quot;属性。具体如下:1234567891011121314151617&lt;div id="datagrid" class="mini-datagrid" allowCellEdit="true" allowCellSelect="true" multiSelect="true" allowResize="true" pageSize="20" url="../data/AjaxService.aspx?method=SearchEmployees"&gt; &lt;div property="columns"&gt; &lt;div type="checkcolumn"&gt;&lt;/div&gt; &lt;div field="loginname" width="120" headerAlign="center" allowSort="true"&gt;员工帐号 &lt;input property="editor" class="mini-textbox" style="width:100%;"/&gt; &lt;!--此外class还有mini-combobox, mini-spinner, mini-datepicker, mini-textarea等选择，对应不同的输入内容--&gt; &lt;/div&gt; &lt;div field="gender" width="100" headerAlign="center" align="center"&gt;性别 &lt;input property="editor" class="mini-combobox" data="Genders" /&gt; &lt;/div&gt; &lt;div field="age" allowSort="true"&gt;年龄 &lt;input property="editor" class="mini-spinner" minValue="0" maxValue="200" value="25" /&gt; &lt;/div&gt; ...... &lt;/div&gt;&lt;/div&gt; 在demo中顶部有三个按钮控制数据操作，对应的JavaScript也需要在前端进行处理，不过有现成的grid的API方法可以直接调用。12345678910111213141516171819202122232425262728293031323334// 增加行function addRow() &#123; var newRow = &#123; name: "New Row" &#125; grid.addRow(newRow, 0); //addRow ( row, index )&#125;// 删除行function removeRow() &#123; // 不需要传入参数，只需要在后面调用API获得勾选项目即可 var rows = grid.getSelecteds(); if (rows.length &gt; 0) &#123; grid.removeRows(rows, true); // removeRows ( rows, autoSelect )，表示是否自动勾选下一项 &#125;&#125;// 保存function saveData() &#123; var data = grid.getChanges(); var json = mini.encode(data); grid.loading("这是弹窗显示的内容..."); $.ajax(&#123; url: "../data/AjaxService.aspx?method=SaveChangedEmployees", data: &#123;data: json&#125;, type: "post", success: function(text) &#123; grid.reload(); &#125;, error: function(jqXHR, textStatus, errorThrown) &#123; alert(jqXHR.responseText); &#125; &#125;);&#125; 注意上面的post方法就是指明了要修改服务端的数据。在前面用到的SaveChangedEmployees方法如下，不过我暂时不太明白这个看着像是Java的程序怎么在aspx文件中工作。其中用到的TestDB是Java定义的一个类。1234567891011121314151617public void SaveChangedEmployees() &#123; String json = Request["data"]; ArrayList rows = (ArrayList)PluSoft.Utils.JSON.Decode(json); foreach(Hashtable row in rows) &#123; String state = row["_state"] == null? "": row["_state"].toString(); if (state == "added") &#123; row["createTime"] = DateTime.Now; new TestDB().InsertEmployee(row); &#125; else if (state == "removed" || state == "deleted") &#123; String id = row["id"].ToString(); new TestDB().DeleteEmployee(id); &#125; else if (state == "modified") &#123; new TestDB().UpdateEmployee(row); &#125; &#125;&#125; 行编辑 在每一行的最前面有三个控制按钮，New, Edit, Delete.增和删与前面一个例子相同，而改则不是通过点击各个单元格修改，而是点击Edit后整行都变为可编辑的input输入框（需设置property=&quot;editor&quot;）。行编辑器html定义如下：1234567891011121314151617181920&lt;div id="datagrid1" class="mini-datagrid" url="../data/DataService.aspx?method=SearchEmployees" &gt; &lt;div property="columns"&gt; &lt;div name="action" width="120" headerAlign="center" align="center" renderer="onActionRenderer" cellStyle="padding:0;"&gt;#&lt;/div&gt; &lt;div field="loginname" width="120" headerAlign="center" allowSort="true"&gt;员工帐号 &lt;input property="editor" class="mini-textbox" /&gt; &lt;/div&gt; &lt;div field="gender" width="100" allowSort="true" renderer="onGenderRenderer" align="center" headerAlign="center"&gt;性别 &lt;input property="editor" class="mini-combobox" style="width:100%;" data="[&#123;id:1, text:'男'&#125;, &#123;id:2, text: '女'&#125;]"/&gt; &lt;/div&gt; &lt;div field="age" width="100" allowSort="true"&gt;年龄 &lt;input property="editor" class="mini-spinner" minValue="0" maxValue="200" value="25" style="width:100%;"/&gt; &lt;/div&gt; &lt;div field="birthday" width="100" allowSort="true" dateFormat="yyyy-MM-dd"&gt;出生日期 &lt;input property="editor" class="mini-datepicker" style="width:100%;"/&gt; &lt;/div&gt; &lt;div field="createtime" width="100" headerAlign="center" dateFormat="yyyy-MM-dd" allowSort="true"&gt;创建日期&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 而开始编辑的JavaScript代码也是用到grid对象的API方法，非常方便:1234567891011121314151617181920// 触发编辑grid.beginEditRow(row); // row通过grid.getSelected()获得// 取消编辑grid.cancelEdit();// 提交数据var rowData = grid.getEditRowData(row);grid.loading("保存中，请稍后......");var json = mini.encode([rowData]);$.ajax(&#123; url: "../data/DataService.aspx?method=SaveEmployees", data: &#123; employees: json &#125;, success: function (text) &#123; grid.reload(); &#125;, error: function (jqXHR, textStatus, errorThrown) &#123; alert(jqXHR.responseText); &#125;&#125;); 表单提交/弹出面板提交 反正基本套路就是这样，CRUD还有两种内置提供方式可以编辑数据。 表单编辑的html是使用一个隐藏的table表格作为编辑面板，然后利用grid的方法获取原数据，生成表单并嵌入原详细行下方。123456grid.hideAllRowDetail();gird.showRowDetail(row);var td = grid.getRowDetailCellEl(row); // 获取DOM对象td.appendChild(editForm);editForm.style.display=""; // 取消隐藏 需要将原行的数据加载到的动态插入的表单中123456789101112131415var form = new mini.Form("editForm1");if (grid.isNewRow(row)) &#123; form.reset();&#125; else &#123; form.loading(); $.ajax(&#123; url: "../data/DataService.aspx?method=GetEmployee&amp;id=" + row.id, success: function (text) &#123; var o = mini.decode(text); form.setData(o); form.unmask(); &#125; &#125;);&#125; 弹出窗口的html是用class=”mini-window”的div作为弹出面板来编辑，这就不涉及嵌入原数据行下方的操作了，直接获取原数据填入面板即可。12345678910111213141516// 加载面板数据var editWindow = mini.get("editWindow"); // get的是ideditWindow.show();var form = new mini.Form("#editform");form.loading();$.ajax(&#123; url: "../data/DataService.aspx?method=GetEmployee&amp;id=" + row.id, success: function (text) &#123; var o = mini.decode(text); form.setData(o); form.unmask(); &#125;, error: function () &#123; alert("表单加载错误"); &#125;&#125;); 这两个方法实际上都用到了form表单，所以提交数据可用mini内置对form的处理:12345678910111213141516171819// 提交数据var form = new mini.Form("#editform");var o = form.getData();grid.loading("some message...");var json = mini.encode([0]);$.ajax(&#123; url: "../data/DataService.aspx?method=SaveEmployees", data: &#123; employees: json &#125;, success: function (text) &#123; grid.reload(); &#125;, error: function (jqXHR, textStatus, errorThrown) &#123; alert(jqXHR.responseText); &#125;&#125;);editWindow.hide(); 表单控件 数据绑定 前面CRUD中的update时，要想让更新后的数据实时反映在原数据中（不是真的保存到数据库，只是修改显示的数据），就可以使用databinding将表单/控件的数据与原表格绑定。12345678910// API// 绑定表单：bindForm(formnamestr, grid)// 绑定控件：bindField(controlname, grid, fieldnamestr)//绑定表单var db = new mini.DataBinding();db.bindForm("editForm1", grid);//绑定控件db.bindField(textbox, grid, "username"); 表单 创建表单: 只要你在html中为div设置好了id，就可以利用这个id创建JavaScript中的表单对象。var form = new mini.Form(&quot;#form1&quot;); 加载表单: 使用到了jQuery的$.ajax方法。$.ajax(option)是jQuery最底层的Ajax实现。所谓最底层是相对于$.load(), $.get(), $.post(), $.getJSON(), $.getScript()这些方法来说的，用$.ajax可以实现所有方法，较为全能。该方法只有一个对象参数，这个对象包含了$.ajax()方法所需的请求设置和回调函数等信息，以键:值的形式给出url(发送请求过去的地址)、type(GET或POST)、data（要传送的键值对形式数据）、success（请求成功后的回调函数）等等参数。下面这里虽然用到的是POST，不过其实是抓数据的，所以没有要上传的data。 12345678$.ajax(&#123; url: "../data/FormService.aspx?method=LoadData", type: "post", success: function (text) &#123; var data = mini.decode(text); //反序列化成对象 form.setData(data); //设置多个控件数据 &#125;&#125;); 提交表单: 必然用到POST，与上面例子相比就需要data来上传了。 123456789101112//提交表单数据var form = new mini.Form("#form1"); var data = form.getData(); //获取表单多个控件的数据var json = mini.encode(data); //序列化成JSON$.ajax(&#123; url: "../data/FormService.aspx?method=SaveData", type: "post", data: &#123; submitData: json &#125;, success: function (text) &#123; alert("提交成功，返回结果:" + text); &#125;&#125;); 清除表单: form.clear(); 重置表单: form.reset(); 表单验证: 在input控件中加入onvalidation=&quot;onUserNameValidation&quot;属性，然后手动编写验证函数绑定过去。当然也可以使用mini-textbox内置的vtype=&quot;email&quot;属性来验证，包括了email、url、int、float、maxLength、minLength、rangeLength、rangeChar、range、date等规则。这些都只是基于控件的验证，随后提交表单时还可以进行一波验证。12345678910111213141516// 绑定validation事件function onUserNameValidation(e) &#123; if (e.isValid) &#123; if (isEmail(e.value) == false) &#123; e.errorText = "必须为合法的邮箱地址"; e.isValid = false; &#125; &#125;&#125;// 验证表单var form = new mini.Form("#form1");form.validate();if (!form.isValid()) &#123; alert("表单验证失败！");&#125; 弹出选择表格 使用mini.open弹出子页面，这里就用于弹出带有选择按钮的表格，该子页面存放在url指向的html中。1234567891011121314151617181920212223mini.open(&#123; url: bootPATH + "../demo/CommonLibs/SelectGridWindow.html", title: "选择列表", width: 650, height: 380, onload: function () &#123; //弹出页面加载完成 var iframe = this.getIFrameEl(); var data = &#123;&#125;; //调用弹出页面方法进行初始化 iframe.contentWindow.SetData(data); &#125;, ondestroy: function (action) &#123; if (action == "ok") &#123; var iframe = this.getIFrameEl(); var data = iframe.contentWindow.GetData(); data = mini.clone(data); //必须拷贝数据(why???) btnEdit.setValue(data.id); btnEdit.setText(data.name); &#125; &#125;&#125;); 小部件 这一部分包含了很多控件，多数都是细节，直接查看样例就好了，就不做笔记了。 Button：按钮 ButtonEdit：按钮输入框 TextBox：文本输入框 ComboBox：下拉选择框 ComboBox：联动选择 DatePicker：日期选择框 Spinner：数字输入框 TreeSelect：树形选择框 AutoComplete：输入智能提示框 TextBoxList：多选输入智能提示框 CheckBox：复选框 ListBox：列表控件 CheckBoxList：复选框组 RadioButtonList：单选框组 FileUpload：文件上传控件 树形控件 创建树 实际上都是使用ul实现的，为ul添加class=&quot;mini-tree&quot;属性就可以使用内置的树形控件了。而根据数据树中显示的数据来源，又分为以下四种实现方式。 树形结构: 首先是建立ul控件并添加class=&quot;mini-tree&quot;。设置url指明树显示的内容来源，拿到的数据就是树形结构的数据。 1234567891011121314151617181920&lt;ul id="tree1" class="mini-tree" url="../data/tree.txt" showTreeIcon="true" textField="text" idField="id"&gt;&lt;/ul&gt;抓回来txt中的树形结构大致如下[ &#123;id: "base", text: "Base", expanded: false, children: [ &#123;id: "ajax", text: "Ajax"&#125;, &#123;id: "json", text: "JSON"&#125;, &#123;id: "date", text: "Date"&#125;, &#123;id: "control", text: "Control"&#125;, &#123;id: "messagebox", text: "MessageBox"&#125;, &#123;id: "window", text: "Window"&#125; ] &#125;, more nodes...] 列表结构: 与上面的树形结构的区别在于数据来源的格式以及ul部分属性的微调。注意下方的拿回的txt数据格式以及ul中到底parentField、resultAsTree属性。id与pid是父子关系，拥有pid的元素是子，对应的id是父元素。 123456789101112&lt;ul id="tree2" class="mini-tree" url="../data/listTree.txt" showTreeIcon="true" textField="text" idField="id" parentField="pid" resultAsTree="false" &gt;&lt;/ul&gt;抓回来txt中的列表结构大致如下，比前面的树形结构更直观好懂一些[ &#123;id: "base", text: "Base", expanded: false&#125;, &#123;id: "ajax", text: "Ajax", pid: "base"&#125;, &#123;id: "json", text: "JSON", pid: "base"&#125;, ......] 本地JSON: 不需要设置url拿数据，而是通过JavaScript以JSON的格式设置树中要显示的数据，这个格式与树形结构的txt是一样的，区别只在于不是url中txt定死的，而是JavaScript来加载。 123&lt;ul id="tree3" class="mini-tree" style="width:300px;padding:5px;" showTreeIcon="true" textField="text" idField="id" &gt; &lt;/ul&gt; 123456789101112131415161718var tree3 = mini.get("tree3");tree3.loadData([ &#123; id: "lists", text: "Lists", expanded: false, children: [ &#123; id: "datagrid", text: "DataGrid" &#125;, &#123; id: "tree", text: "Tree" &#125;, &#123; id: "treegrid", text: "TreeGrid " &#125; ] &#125;, &#123; id: "layouts", text: "Layouts", expanded: false, children: [ &#123; id: "panel", text: "Panel" &#125;, &#123; id: "splitter", text: "Splitter" &#125;, &#123; id: "layout", text: "Layout " &#125; ] &#125;]); HTML创建: 这个方法是最原始最直接的想法，用HTML标签把树拼出来。但从下面可以看出来，这个方式就像是普通的无序列表的HTML了，不够简洁。12345678910111213141516171819202122232425262728293031323334353637383940&lt;ul id="tree4" class="mini-tree" style="width:200px;padding:5px;" showTreeIcon="true"&gt; &lt;li&gt; &lt;span&gt;MiniUI&lt;/span&gt; &lt;ul&gt; &lt;li&gt; &lt;span expanded="false"&gt;Form&lt;/span&gt; &lt;ul&gt; &lt;li&gt;ComboBox&lt;/li&gt; &lt;li&gt;DatePicker&lt;/li&gt; &lt;li&gt;Spinner&lt;/li&gt; &lt;li&gt;TreeSelect&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;span expanded="false"&gt;Lists&lt;/span&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="../datagrid/datagrid.html" target="_blank" style="color:Blue;text-decoration:underline;"&gt;DataGrid&lt;/a&gt;&lt;/li&gt; &lt;li&gt;Tree&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;span expanded="false"&gt;Layouts&lt;/span&gt; &lt;ul&gt; &lt;li&gt;Panel&lt;/li&gt; &lt;li&gt;Splitter&lt;/li&gt; &lt;li&gt;Layout&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;span expanded="false"&gt;Navigations&lt;/span&gt; &lt;ul&gt; &lt;li&gt;Tabs&lt;/li&gt; &lt;li&gt;NavBar&lt;/li&gt; &lt;li&gt;Menu&lt;/li&gt; &lt;li&gt;Pager&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; 树的懒加载 只有当用户点击了展开才会加载当前树节点的子孙。点击”+”图标时，当前节点的id就会传到后台，不过可以在前台利用onbeforeload在传递之前做一些额外操作再交给后台去加载子孙。服务端则根据Request获取的节点id来搜索数据库取出子节点123&lt;ul id="tree1" class="mini-tree" url="../data/TreeService.aspx?method=LoadNodes" style="width:300px;height:200px;padding:5px;" showTreeIcon="true" textField="name" idField="id" onbeforeload="onBeforeTreeLoad" &gt;&lt;/ul&gt; 123456789// 在加载节点之前，在前端执行的操作function onBeforeTreeLoad(e) &#123; var tree = e.sender; //树控件 var node = e.node; //当前节点 var params = e.params; //参数对象 //可以传递自定义的属性 params.myField = "123"; //后台就可以用request对象获取"myField"字段了&#125; 12345678910111213141516171819202122232425262728// 服务端程序，根据节点id拿子节点String id = Request["id"];if (String.IsNullOrEmpty(id)) id = "-1";//获取下一级节点String sql = "select * from plus_file where pid = '" + id + "' order by updatedate";ArrayList folders = DBUtil.Select(sql);//判断节点，是否有子节点。如果有，则处理isLeaf和expanded。for (int i = 0, l = folders.Count; i &lt; l; i++)&#123; Hashtable node = (Hashtable)folders[i]; String nodeId = node["id"].ToString(); String sql2 = "select * from plus_file where pid = '" + nodeId + "' order by updatedate"; ArrayList nodes = DBUtil.Select(sql2); if (nodes.Count &gt; 0) &#123; node["isLeaf"] = false; node["expanded"] = false; &#125;&#125;//返回JSONString json = PluSoft.Utils.JSON.Encode(folders);Response.Write(json); 树的操作 提供了增删改移的内置操作。1234567891011121314151617// 增加节点var tree = mini.get("tree1");var node = tree.getSelectedNode();var newNode = &#123;&#125;;//addNode ( node, index, parentNode )tree.addNode(newNode, "before", node);// 删除节点var node = tree.getSelectedNode();tree.removeNode(node);// 编辑节点var node = tree.getSelectedNode(); tree.beginEdit(node); // 移动节点tree.moveNode(node, targetNode, "before"); 为树创建右键菜单 除了利用工具栏按钮的形式操作树的节点，还可以直接在节点上右键弹出菜单进行操作，称之为ContextMenu。ContextMenu的HTML其实就是ul+li的列表，然后要想让右键点击树能够弹出这个ContextMenu，则需要为树的HTML标签添加contextMenu属性。123456789101112131415161718192021&lt;ul id="treeMenu" class="mini-contextmenu" onbeforeopen="onBeforeOpen"&gt; &lt;li iconCls="icon-move" onclick="onMoveNode"&gt;移动节点&lt;/li&gt; &lt;li class="separator"&gt;&lt;/li&gt; &lt;li&gt; &lt;span iconCls="icon-add"&gt;新增节点&lt;/span&gt; &lt;ul&gt; &lt;li onclick="onAddBefore"&gt;插入节点前&lt;/li&gt; &lt;li onclick="onAddAfter"&gt;插入节点后&lt;/li&gt; &lt;li onclick="onAddNode"&gt;插入子节点&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li name="edit" iconCls="icon-edit" onclick="onEditNode"&gt;编辑节点&lt;/li&gt; &lt;li name="remove" iconCls="icon-remove" onclick="onRemoveNode"&gt;删除节点&lt;/li&gt;&lt;/ul&gt;而对于树而言只需要把contextMenu属性赋上这个contextMenu的id值即可完成绑定。&lt;ul id="tree1" class="mini-tree" url="../data/tree.txt" style="width:200px;padding:5px;" showTreeIcon="true" textField="text" idField="id" contextMenu="#treeMenu" &gt; &lt;/ul&gt; 123456789101112131415161718192021222324252627282930在contextMenu中的onbeforeopen属性绑定的函数是：function onBeforeOpen(e) &#123; var menu = e.sender; var tree = mini.get("tree1"); var node = tree.getSelectedNode(); if (!node) &#123; e.cancel = true; &#125; // 若点击的是Base，不弹出 if (node &amp;&amp; node.text == "Base") &#123; e.cancel = true; //阻止浏览器默认右键菜单 e.htmlEvent.preventDefault(); return; &#125; var editItem = mini.getbyName("edit", menu); var removeItem = mini.getbyName("remove", menu); editItem.show(); removeItem.enable(); // 防止之前的禁用效果无法恢复 if (node.id == "forms") &#123; editItem.hide(); // 隐藏编辑选项 &#125; if (node.id == "lists") &#123; removeItem.disable();// 禁用删除选项 &#125;&#125; 导航 MiniUI提供了很多内置方式实现页面切换，如toolbar、菜单、ContextMenu、Tabs选项卡、OutlookBar折叠面板、OutlookMenu折叠菜单、OutlookTree折叠树、Pager分页。 Toolbar工具栏 其实就是div+a的组合，只不过对应地加上MiniUI的class就可以用内置的CSS显示为导航栏。123456789101112&lt;div class="mini-toolbar"&gt; &lt;a class="mini-button" iconCls="icon-add"&gt;增加&lt;/a&gt; &lt;a class="mini-button" iconCls="icon-edit"&gt;修改&lt;/a&gt; &lt;a class="mini-button" iconCls="icon-remove"&gt;删除&lt;/a&gt; &lt;span class="separator"&gt;&lt;/span&gt; &lt;a class="mini-button" plain="true"&gt;增加&lt;/a&gt; &lt;a class="mini-button" plain="true"&gt;修改&lt;/a&gt; &lt;a class="mini-button" plain="true"&gt;删除&lt;/a&gt; &lt;span class="separator"&gt;&lt;/span&gt; &lt;input class="mini-textbox" /&gt; &lt;a class="mini-button" plain="true"&gt;查询&lt;/a&gt;&lt;/div&gt; 要复杂点的话可以加入table表格控制内部小按钮靠左靠右(例如用width: 100%)。 菜单 类似于Windows顶部的菜单栏，直接用ul结合url定出菜单中的内容。12345678910111213141516171819202122&lt;ul id="menu1" class="mini-menubar" style="width:100%;" url="../data/listMenu.txt" idField="id" parentField="pid"&gt;&lt;/ul&gt;其中txt文件的格式和之前建树的类似，利用id和pid确定父子关系。既然和建树类似，那必然就有类似的[原始HTML构建菜单方式](http://www.miniui.com/docs/tutorial/menu_html.html)。[ &#123; id: "1", text: "文件(F)"&#125;, '-', &#123; id: "2", text: "新建", iconCls: "icon-new", pid: "1"&#125;, &#123; id: "3", text: "文件", pid: "2"&#125;, &#123; id: "4", text: "文件夹", pid: "2"&#125;, &#123; id: "5", text: "打开", iconCls: "icon-folderopen", pid: "1"&#125;, &#123; id: "6", text: "保存", pid: "1"&#125;, &#123; id: "7", text: "关闭", pid: "1"&#125;, &#123; id: "8", text: "编辑(E)"&#125;, &#123; id: "9", text: "剪切", iconCls: "icon-cut", pid: "8"&#125;, &#123; id: "10", text: "复制", pid: "8"&#125;, &#123; id: "11", text: "粘贴", pid: "8"&#125;, &#123; id: "12", text: "查看(V)"&#125;, &#123; id: "13", text: "帮助(H)", iconCls: "icon-help"&#125;] ContextMenu 这是右键点击，根据上下文弹出的菜单。前面已经提到了在树的节点上可以实现右键弹出菜单，只需要把contextMenu的id绑定到对应的树就可以了。而这里构建菜单也是类似的，先用ul+li把菜单建起来，然后用JavaScript把菜单绑定到右键点击事件。123456789101112131415&lt;ul id="contextMenu" class="mini-contextmenu" &gt; &lt;li&gt; &lt;span &gt;操作&lt;/span&gt; &lt;ul&gt; &lt;li iconCls="icon-new" onclick="onItemClick"&gt;新建&lt;/li&gt; &lt;li class="separator"&gt;&lt;/li&gt; &lt;li iconCls="icon-add" onclick="onItemClick"&gt;增加&lt;/li&gt; &lt;li iconCls="icon-edit" onclick="onItemClick"&gt;修改&lt;/li&gt; &lt;li iconCls="icon-remove" onclick="onItemClick"&gt;删除&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class="separator"&gt;&lt;/li&gt; &lt;li iconCls="icon-open" &gt;打开&lt;/li&gt; &lt;li iconCls="icon-remove" &gt;关闭&lt;/li&gt;&lt;/ul&gt; 123456789101112function onItemClick(e) &#123; // 点击某项后的操作 var item = e.sender; alert(item.getText()); &#125;window.onload = function () &#123; // 将contextMenu绑定到指定元素 $("#region1").bind("contextmenu", function (e) &#123; var menu = mini.get("contextMenu"); menu.showAtPos(e.pageX, e.pageY); return false; &#125;);&#125; Tabs选项卡 使用div，然后加入class=&quot;mini-tabs&quot;属性即可。每个tabs里面可以是静态1的div定义，也可以使用外部txt来懒加载。每个tab都有很多内置属性可以使用。123456789101112&lt;div id="tabs1" class="mini-tabs" activeIndex="0" style="width:350px;height:200px;" url="../data/tabs.txt"&gt;&lt;/div&gt;txt中保存的格式，每个子页面的内容都由新的url定义。[ &#123;title: "Tab1", url: "../tabs/pages/page1.html", refreshOnClick: true&#125;, &#123;title: "Tab2", url: "../tabs/pages/page2.html", showCloseButton: true&#125;, &#123;title: "Tab3", url: "../tabs/pages/page3.html"&#125;, &#123;title: "Tab4", url: "../tabs/pages/page4.html"&#125;, &#123;title: "Tab5", url: "../tabs/pages/page5.html"&#125;] Outlook面板系列 OutlookBar折叠面板: 为div加入class=&quot;mini-outlookbar属性即可。面板内部的内容直接通过子div提供。 OutlookMenu折叠菜单: 为div加入class=&quot;mini-outlookmenu属性，然后提供url导入菜单中要显示的内容即可。 OutlookTree折叠树: 为div加入class=&quot;mini-outlooktree属性，然后提供url导入树中要显示的内容即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!--折叠面板，直接提供内部div的内容--&gt;&lt;div id="outlookbar1" class="mini-outlookbar " activeIndex="0" style="width:180px;height:250px;" autoCollapse="true"&gt; &lt;div title="权限管理"&gt; 1 &lt;/div&gt; &lt;div title="用户管理"&gt; 2 &lt;/div&gt;&lt;/div&gt;&lt;!--折叠面板中的菜单--&gt;&lt;div class="mini-outlookmenu" url="../data/outlookmenu.txt" onitemselect="onItemSelect" idField="id" parentField="pid" textField="text"&gt;&lt;/div&gt;其中url提供的内容格式和前面通过外部文件定义菜单的方式类似[ &#123; id: "user", text: "用户管理"&#125;, &#123; id: "addUser", pid: "user", text: "增加用户", iconCls: "icon-add", url: "../navbartree/navbartree.html" &#125;, &#123; id: "editUser", pid: "user", text: "修改用户", iconCls: "icon-edit", url: "../buttonedit/openwindow.html" &#125;, &#123; id: "removeUser", pid: "user", text: "删除用户", iconCls: "icon-remove", url: "../datagrid/datagrid.html" &#125;, &#123; id: "right", text: "权限管理"&#125;, &#123; id: "addRight", pid: "right", text: "查询权限", iconCls: "Note", url: "../navbartree/navbartree.html", iconPosition: "top" &#125;, &#123; id: "editRight", pid: "right", text: "操作权限", iconCls: "Reports", url: "../buttonedit/openwindow.html", iconPosition: "top" &#125; ]&lt;!--折叠面板中的树--&gt;&lt;div id="leftTree" class="mini-outlooktree" url="../data/outlooktree.txt" onnodeselect="onNodeSelect" textField="text" idField="id" parentField="pid"&gt;&lt;/div&gt;其中url提供的树的txt内容格式与前面提过的类似，通过id和pid确定父子关系。[ &#123;id: "user", text: "用户管理"&#125;, &#123;id: "lists", text: "Lists", pid: "user" &#125;, &#123;id: "datagrid", text: "DataGrid", pid: "lists"&#125;, &#123;id: "tree", text: "Tree" , pid: "lists"&#125;, &#123;id: "treegrid", text: "TreeGrid " , pid: "lists"&#125;, &#123;id: "layouts", text: "Layouts", expanded: false, pid: "user"&#125;, &#123;id: "panel", text: "Panel", pid: "layouts"&#125;, &#123;id: "splitter", text: "Splitter", pid: "layouts"&#125;, ] Pager分页 为div加入class=&quot;mini-pager&quot;属性即可。可以为onpagechanged属性提供JavaScript函数进行额外处理。12345&lt;div class="mini-pager" style="width:600px;background:#ccc;" totalCount="123" onpagechanged="onPageChanged" sizeList="[5,10,20,100]" showTotalCount="true" &gt; &lt;/div&gt; 这篇博客其实可能以后都不会怎么看了，因为人家官网写得也足够详细了，直接参考官方文档就行了。而且大多都是一些控件什么的，用一用就会了，用不着写个博客总结什么思想，弃坑啦。]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>frontend</tag>
        <tag>js</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Note for Professional JavaScript for Web Developers (1/4)]]></title>
    <url>%2F2016%2F08%2F26%2FjavaScript_professional%2F</url>
    <content type="text"><![CDATA[之前发现了一个前端技术栈的图，今天又听人介绍了这本JavaScript高级程序设计（第3版），之前大菜鸭也推荐了这本书的pdf，所以我决定再用这本书系统地过一遍JavaScript。从零开始学前端就得把前人啃过的书跟着啃一遍，特别是这样被反复推荐的经典书。开学再看看能不能跟着前端团队做些东西出来，实际操练一下，目前的简历一看就知道没写过多少前端代码，得让简历丰富起来才行。本篇对应1~5章。 JavaScript简介 JavaScript的诞生起初JavaScript是Netscape公司为了改善浏览器处理表单验证的用户体验而设计的客户端语言。之后由于微软JScript的对峙，JavaScript语言的标准化语法和特性需要得到统一，欧洲计算机制造商协会ECMA完成了这个工作，所以日后人们通常把JavaScript和ECMAScript划了等号。但是JavaScript的含义其实比ECMA要多。 JavaScript的三个组成部分； ECMAScript: ECMAScript本身和Web浏览器没有依赖关系，浏览器、Node、Adobe Flash都可以作为宿主环境，宿主环境还能提供扩展以便语言和宿主之间对接交互。ECMAScript定义了语言的基础如语法、类型、语句、关键字、保留字、操作符、对象等，在此基础之上可以构建更完善的脚本语言。 DOM: Document Object Model文档对象模型是我看的前一本书的主题，它是针对XML但经过扩展用于HTML的应用程序编程接口，由DOM将文档映射成一个多层节点的抽象结构。利用DOM提供的API可以对页面中节点进行增删改查的各种操作，掌握了控制页面内容和结构的主动权。 BOM: Browser Object Model浏览器对象模型可以访问和操作浏览器窗口，控制显示的页面以外的部分，如新建、缩放、移动、关闭窗口、浏览器对象navigator、页面信息对象location、显示器对象screen、cookies支持、XMLHttpRequest等。BOM本身没有统一的标准，各个浏览器有不同的对象、属性、方法。而HTML5则将许多BOM写入正式规范。 在HTML中使用JavaScript &lt;script&gt;元素 页面内嵌: 直接在标签之间插入JavaScript代码，会按照代码顺序执行。 12345&lt;script type="text/javascript"&gt; function show() &#123; alert("&lt;\/script&gt;"); &#125;&lt;/script&gt; 包含外部JavaScript文件: 利用src属性加载外部独立的.js文件，且按照顺序依次加载，只有前一个js代码解析完成后才会开始下一个。 12345&lt;!--在XHTML和HTML中均可使用。此时前后标签之间的代码将被忽略--&gt;&lt;script type="text/javascript" src="js/xxx.js"&gt;&lt;/script&gt;&lt;!--也可以省略结束标签，但不符合HTML规范--&gt;&lt;script type="text/javascript" src="js/xxx.js" /&gt; &lt;script&gt;的位置由于浏览器在遇到&lt;body&gt;时才会开始呈现页面内容，如果把script引用的位置放到head中，只有当所有JavaScript代码都被下载、解析和执行完成后才会显示页面。所以&lt;script&gt;还是应当放到所有内容的后面、&lt;/body&gt;之前。 &lt;script&gt;的属性async, charset, defer, src, type（和已废弃的language）。 defer: 用于延迟脚本，只是用于外部脚本，下载后直到浏览器遇到&lt;/html&gt;才会真正开始执行脚本。若多个脚本同时加入defer属性，HTML5规范中是要求脚本它们不一定会按照文档出现顺序执行。 async: 异步脚本也只用于外部脚本，控制页面不等待脚本的加载和执行，可以异步加载其他内容，这种情况下js代码中应尽量不涉及DOM操作。 &lt;noscript&gt;元素当浏览器不支持JavaScript（现在不会了）或浏览器的JavaScript被停用时，需要让页面平稳退化，此时在&lt;noscript&gt;元素中的内容会显示出来。JavaScript正常的情况下，&lt;noscript&gt;元素中的内容不会显示。 文档模式文档模式从IE5.5开始引入，通过切换DOCTYPE实现。目前的文档模式有混杂模式、标准模式和准标准模式，区别在于CSS样式的呈现和部分JavaScript的解释执行。 基本概念 严格模式&quot;use strict&quot;;: 使用严格模式可以为JavaScript定义一种不同的解析与执行模型，消除语法中本身的不合理、不严谨部分，防止不确定行为带来的潜在危害，还能一定程度提高执行效率。 分号与代码块 虽然解析器可以帮助补充行末被省略的分号，但我们还是应当为每个语句加上分号，这样可以放心地删除多余的空白来压缩代码，同时也不用在解析时花时间推测在哪里插入分号、减轻了解析器的负担。 虽然在多语句的情况下才必须使用花括号，但我们还是应当总是加上花括号形成代码块，这样便于清晰地展示编程意图，也方便修改代码块中的语句。 变量 ECMAScript中的变量是松散类型的，即不指定变量类型，变量可以保存任何类型的数据。可以使用typeof操作符来确定给定变量的类型，返回的是对应类型的字符串形式如”string”, “number”。 Undefined类型: 当变量没有声明或声明后没有被赋值时，使用typeof返回的类型都是undefined. Undefined类型的值只有undefined一个。 Null类型: Null类型的值也只有null一个，null值表示一个空对象指针，使用typeof(null)将返回object，因为null本身就指代一个对象指针。 Number类型: 整型默认是十进制，以0x开头为十六进制，以0开头为八进制，进行算术运算时都会转化为十进制。浮点数的小数点后必须为非零数，否则仍会解析为整型，同时浮点数的计算精确度不如整型，无法测试特定的浮点数值。使用e可以用科学计数法表示10次幂。当数值超过JavaScript定义的最大数值，会转化为Infinite值，该值将不会参与后续计算。而NaN值表示一个本来应该返回数值的操作未返回数值的情况，NaN参与的运算结果都是NaN，且NaN与任何值都不相等。 String类型: ECMAScript中的字符串值是不可变的，所谓的改变字符串值其实是将原字符串销毁后再创建一个新的字符串填充该变量。 Object类型: ECMAScript中Object是所有更具体对象的基础。每个Object实例都具有Constructor, hasOwnProperty(name), isPrototypeOf(obj), propertyIsEnumerable(name), toLocaleString(), toString(), valueOf()等属性和方法。 将变量转为数字: 可用Number(s)（不支持八进制）, parseInt(s)（支持十进制、八进制、十六进制，当然也可以提供第二个参数base来确定进制；不支持任何字符，从有效数字开始遇到非数字字符就停止parse返回整型）, parseFloat(s)（只有十进制，忽略前导的所有0；从非零有效数字开始向后parse，只允许出现一个小数点；若小数点后全为0则返回整型）。 将变量转为字符串: 可用x.toString()（除了null和undefined都可使用，对string使用则返回一个当前字符串的副本；可传入base参数指定进制，支持二进制、八进制、十进制、十六进制）, String(x)（转型函数对所有变量都可使用，若传入变量支持toString()则直接调用，否则直接返回字面值如”null”, “undefined”）。 操作符 一元加: 放在数值前面不会有什么变化，但放在非数值之前就会像Number()转型函数一样进行转换。 位操作符: ~(NOT，按位非)，&amp;（AND，按位与），|（OR，按位或），^（XOR，按位异或），&lt;&lt;（左移，不影响符号位）、&gt;&gt;（有符号右移，不影响符号位）、&gt;&gt;&gt;（无符号右移，影响符号位）。 语句 for语句: for(var i = 0; i &lt; sum; i++)中声明的变量i也可以在循环外部访问到，这是因为ECMAScript没有块级作用域，所以循环内部的变量依然存在于外部。 for-in语句: 精准迭代语句，用于枚举：for (property in expression) ... label语句: label: statement 为代码块添加标签，以便将来使用，通常会结合break或continue。12345678910outer:for (var i = 0; i &lt; 10; i++) &#123; for (var j = i; j &lt; 10; j++) &#123; if (xxx) &#123; break outer; &#125; count++; ... &#125;&#125; with语句: with(expression) {statement}将代码的作用域设置到一个特定的对象中，可以简化多次编写同一个对象的工作。但是在strict模式下不允许使用。 函数 基本语法:123function foo(arg0, arg1, arg2, ...) &#123; statements;&#125; 参数: ECMAScript的函数并不介意传入参数的个数、类型。在函数内部有一个arguments对象存储着传入的参数数组（只是类似于Array但不是Array的实例），若列表中的命名参数在调用时没有被赋值，则默认值是undefined。 返回值: ECMAScript的函数在定义时并不需要指定是否有返回值，默认总是返回undefined。在实操中推荐维持一种编程习惯，要么所有函数都显示地return，要么全都不要返回值。否则会给调试带来很大不便。 没有重载: 由于ECMAScript的函数的参数由零或多个值的数组来表示，所以函数签名（接受参数的类型和数量）不存在，就不可能为同名函数根据不同签名设置不同行为。不过在函数内部可以利用arguments来模仿重载的效果。 变量类型、作用域和内存 两种变量类型 基本类型值: 简单的数据段，前面提到的Undefined, Null, Boolean, Number和String都是基本数据类型。可以直接操作存储在变量中的实际的值，所以是按值访问。 引用类型值: 保存在内存中的对象，JavaScript不允许直接访问内存中的位置，所以操作对象时实际是按引用访问。 变量类型对比 动态的属性: 对于基本类型，无法添加属性或方法（尽管不报错），访问属性、方法时也是undefined；对于引用类型则可以添加属性和方法。 123var person = new Object();person.name = "Bobby";alert(person.name); 复制变量值: 对于基本类型，将变量赋值给另一个变量会创建一个新值并把原值复制到新对象分配的位置上，两者互补干扰；对于引用对象，将变量赋值给另一个变量同样会创建一个新值并进行复制，但是由于这个副本其实是同一个对象的引用，所以两个变量其实指向的是同一个对象。 参数传递: ECMAScript中所有函数参数都是按值传递，本质是在函数中创建局部变量，将传入的值按照复制变量值规则将传入的变量值复制给这些局部变量。因此完全可以将函数的参数看作函数体的局部变量。对于基本类型，按值传递较好理解；对于引用类型对象，确实是可以修改函数外传入的对象，这个现象很容易让人认为是按引用传递，但必须指出这依然是按值传递，可能要用下面的例子比较好理解: 12345678910function setName(obj) &#123; obj.name = "Bobby"; obj = new Object(); obj.name = "liujb";&#125;var person = new Object();setName(person); // 执行结果是Bobby，因为在函数内部修改引用值本身其实是对函数内部的局部引用类型变量修改// 而这个局部变量在退出函数时会销毁，当然不会让函数外的引用变量指向新的对象。 类型检测: 使用操作符result = typeof x检测基本数据类型，使用result = x instanceof Constructor判断引用变量是否是某类对象的实例。 执行环境与作用域 执行环境Execution context: 定义了变量或函数有权访问的其他数据，决定各自的行为。 变量对象: 每个执行环境都有一个对应的变量对象，环境中定义的所有变量和函数都保存在这个对象中。 全局执行环境: 最外围的一个执行环境，不同的宿主环境对应的变量对象也不一样。对于web浏览器，全局执行环境是window对象，所有全局变量和函数都是window对象的属性和方法。当全局环境所处的应用程序终止后，全局执行环境才会销毁。 函数执行环境: 每个函数都有自己的执行环境，当代码执行到一个函数时，函数的环境就会推入一个环境栈中，执行结束后会将函数环境弹出，将控制权换给之前的执行环境。 作用域链scope chain: 当代码在一个环境中执行时便会创建变量对象的作用域链，保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的顶端是当前代码所在环境的变量对象，例如当这个环境是函数，则变量对象就是活动对象（activation object），一开始只有arguments变量。全局执行环境的变量对象是作用域链的最后一个对象。 作用域链的延长: 在以下两种情况下会加长作用域链:-&gt; try-catch语句的catch块会在作用域链顶端创建一个变量对象用于包含抛出的错误对象的声明；-&gt; with语句将指定对象添加到作用域链顶端。 没有块级作用域: JavaScript变量的创建和销毁是以执行环境为载体的，而不是由类C语言的花括号代码块。只要变量所依存的执行环境还存在，变量就能够正常被访问和修改。但需要注意的是，变量如果不用var声明而直接使用，这个变量会默认添加到全局环境中，形成全局变量（这在strict模式下是不允许的）。对于下面的例1，创建变量color的执行环境就是全局环境，所以在出了if语句后依然可以访问到。对于例2，变量sum是在函数中声明的，属于函数的局部环境，当函数执行完成后，这个局部环境会被销毁，就无法访问到sum了。对于例3，在非strict模式下，省去var声明直接使用变量sum会将其创建到全局环境中，所以离开函数后仍能访问到。 123456789101112131415161718192021// 例1if (true) &#123; var color = "green";&#125;alert(color); // green// 例2function add(num1, num2) &#123; var sum = num1 + num2; return sum;&#125;var result = add(10, 20);alert(sum); // 报错，找不到变量// 例3function add(num1, num2) &#123; sum = num1 + num2; return sum;&#125;var result = add(10, 20);alert(sum); // 30 查询标识符: 当某个环境遇到一个标识符（变量名）时，必须通过搜索确定它代表的是什么，搜索顺序从局部环境开始一直向外部环境延展，直到全局执行环境。一旦查找到对应变量值，就直接采用，这意味着局部环境中的同名标识符会暂时屏蔽掉父环境的标识符。 垃圾回收 自动垃圾回收机制: JavaScript执行环境会负责管理代码执行过程中使用的内存，垃圾收集器会周期性地找出不再使用的变量并释放所占内存。 两个GC策略:-&gt; 标记清除mark-and-sweep: 当变量进入环境/离开环境时进行不同的标记。垃圾回收器在运行时会先将所有变量统一加上标记，然后抹去环境中的变量和被引用到的相关变量的标记，最后将仍有标记的值销毁，回收内存。-&gt; 引用计数reference counting: 跟踪记录每个值被引用的次数，不太常用。当值被赋给一个变量时则+1，当这个变量取了另一个值的时候则-1。当引用次数降为0，则会在下一周期被回收。但是这个方法存在循环引用的问题，这回导致两个值的引用计数一直不是0，永不被回收导致内存泄漏。 管理内存: 由于分配给web浏览器的内存通常比桌面程序少（防止运行JavaScript的网页耗尽资源导致系统崩溃），所以编程时应尽量优化内存占用，即只保留必要的变量和数据、在不用时设为null解除引用。这个做法是对全局变量和全局对象的属性而言，对于局部变量会在退出局部环境时自动销毁。 引用类型 引用类型值与类 引用类型和类常被混为一谈，但必须指出虽然ECMAScript是面向对象的语言，但不具备传统面向对象语言所支持的类和接口等结构，因此不能把二者划上等号。 引用类型的实例就是对象（或引用类型的值）。 引用类型是一种数据结构，用于将数据和功能组合在一起。 Object类型 Object: 使用最多的一个类型，大部分引用类型值都是Object类型的实例。 创建Object实例的方式: new操作符 和 对象字面量。其中用对象字面量定义对象时，不会调用Object构造函数。更常用的是对象字面量法。 1234567891011121314151617181920212223242526272829// new操作符var person = new Object();person.name = "Bobby";person.state = "single";// 对象字面量: var person = &#123; name: "Bobby", state: "single" &#125; ``` * 访问属性:点表示法 和 方括号表示法。其中方括号表示法允许通过字符串变量来访问属性，字符串中还可以包含空格等特殊字符，这在点表示法中是办不到的。不过除非特殊字符，通常还是用点表示法更直观。 ```JavaScriptalert(person.name); var propertyName = "first name";alert(person[propertyName]); ``` 3. Array类型 * Array:使用频率仅次于Object，与其他语言的数组的重大区别是，ECMAScript的数组中的每一项可以是不同类型的。同时数组的大小是可以自动增长来容纳新增数据。 * 创建数组的方式: Array构造函数 和 数组字面量表示法。使用数组字面量表示法也不会调用到数组的构造函数。```JavaScript// 构造函数。其中的new可以省略不写。var colors = new Array(20);var colors = new Array("red", "blue", "green");// 字面量var colors = ["red", "blue", "green"]; length属性: 数组的length属性不是只读的，可以通过修改length值删除末尾元素或手动增加数组长度（新增位的值为undefined）。通过给arr.length位置赋值也可以方便地向数组末尾插入一个新项。 数组对象的判别: instanceof操作符 和 Array.isArray()方法。 12345// ECMAScript 3+if (value instanceof Array) // ECMAScript 5+if (Array.isArray(value)) toString, join, toLocaleString和valueOf方法: 所有对象都具有这三个方法。对数组使用valueOf()返回的仍是数组；对数组使用toString()相当于对每一项分别使用toString()后再用逗号拼接起来；使用join()可自定义连接符返回字符串，如arr.join(&quot;~&quot;);，若不传入任何字符则默认是逗号。 栈方法:-&gt; push(): 可接受任意个参数并逐个添加到数组末尾，返回修改后的数组长度；-&gt; pop(): 从数组末尾移除一项，返回被移除的值。这些操作都发生在末尾（栈顶），使得数组的行为与栈LIFO非常类似。 队列方法:-&gt; push(): 同栈方法push。-&gt; shift(): 从数组的最前端取出项，并将该值返回，数组长度减1.结合使用上述两种方法可以正向模拟队列。-&gt; unshift: 向数组的最前端插入项，返回修改后的数组长度；-&gt; pop(): 同栈方法pop。结合这两种方法可以从相反的方向模拟队列。 逆序: 直接使用arr.reverse();将数组倒转。 排序: 使用arr.sort();会将原数组的每一项都使用toString()后再进行升序排序，即使每一项都是数值。我们可以定义一个比较函数作为参数传入sort函数。 123456789function cmp(value1, value2) &#123; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125;&#125; 拼接: 使用arr.concat(arg1, ...);将给定内容拼接到当前数组的副本后面，若所给是数组，则会取出数组中的每一项插到最后。concat执行后不会影响原数组，返回的是新创建的数组。 切片: 使用arr.splice(start, end);将给定范围（不包括结束尾；或者可以不传入结束位）的子数组创建出来，不影响原数组。 全能操作方法splice:-&gt; 删除: splice(start, length)指定第一项开始删除的索引和总共删除的项数。-&gt; 插入: splice(pos, 0, insertItems...)指定要插入的位置、要删除的项数和对应要插入的项。-&gt; 替换: splice(pos, deleteNum, insertItems...)指定起始位置、要删除的项数和要插入的项。splice执行后会影响原数组，并始终都会返回一个包含了所删除项的数组。 查找元素位置:-&gt; arr.indexOf(item, start): 指定要查找的项和查找的起始索引。-&gt; arr.lastIndexOf(item, start): 与上面相似，只是会从后往前进行查找。 迭代方法:-&gt; every(func): 对数组的每一项执行给定函数，结果全为真才返回true.-&gt; some(func): 对数组的每一项执行给定函数，结果有一项为真就返回true.-&gt; forEach(func): 对数组的每一项执行给定函数，无返回值。-&gt; map(func): 对数组的每一项执行给定函数，返回每一项的运行结果组成新的数组。-&gt; filter(func): 对数组的每一项执行给定函数，将结果为false的元素过滤掉后将剩余元素组成新数组返回。 缩小方法: reduce()和reduceRight()都用于缩小，区别只是方向是正向还是逆向。接受1~2个参数，分别是要调用的函数和作为缩小基础的初始值。所传入的函数接受4个参数，分别是前一项值、当前值、项的索引和数组对象。该函数的返回值会作为第一个参数传入下一次执行。1234// 对数组values进行求和var sum = values.reduce(function(prev, cur, index, array) &#123; return prev + cur;&#125;); Date类型 Date: 在早期Java中的java.util.Date基础上构建。以毫秒为单位保存从1970.1.1的前后285616年的日期。 创建Date实例:-&gt; 不传参时会自动获取当前日期和时间: var now = new Date();-&gt; 指定日期可传入Date.parse()或Date.UTC()解析出的毫秒数。 12345// 2017.5.20 0:00:00var hopefully = new Date(Date.parse("Tue May 20 2017 00:00:00 GMT-0700"));// 2015.5.5 17:55:55 注意月份从0开始计（这是军用方式...反人类啊）var another = new Date(Date.UTC(2015, 4, 5, 17, 55, 55)); Date实现计时器: 在ECMAScript 5中添加了Date.now()方法获取当前毫秒数；而在不支持的浏览器中，简单地使用一个+操作符即可将Date对象转换成数值，也能达到计时效果: 1234567891011// 方法1var start = Date.now(); ...var stop = Date.now();var time = stop - start;// 方法2var start = +new Date(); ...var stop = +new Date();var time = stop - start; Date的格式化输出: 除了继承的toString, toLocaleString, valueOf, 还有toDateString, toUTCStirng, toTimeString等。 RegExp类型 RegExp: 创建正则表达式，为var exp = /pattern/ flags; 其中flags有三种:-&gt; g: 全局模式，发现第一个匹配项后不停止，继续应用于后续字符串。-&gt; i: 匹配时忽略大小写。-&gt; m: 遇到换行时不停止，继续向后查找是否有匹配项。 创建RegExp类型实例: 字面量定义 和 RegExp构造函数。构造时接受两个参数，即需要匹配的字符串模式和标志位。不过需要注意的是由于字符串中可能需要很多转义，所以用起来不如字面量方便。 12345var exp1 = /[bc]at/i;var exp2 = new RegExp("[bc]at", "i");var exp3 = /\d.\d&#123;1, 2&#125;/;var exp4 = new RegExp("\\d.\\d&#123;1, 2&#125;"); 常用的正则表达方法:-&gt; 若直接给出字符，则是精确匹配。对于特殊符号如-和_等，需要加上转义符\。-&gt; \d匹配一个数字，\w匹配一个字母或者数字，\s匹配一个空格或其他空白符，.匹配任意一个字符。-&gt; 上面只能针对一个字符进行匹配，若要指定数量，*表示任意个字符（包括0），+表示至少一个字符，?表示0或1个字符，{n}表示n个字符，{n, m}表示n~m个字符。-&gt; []可以给定范围，例如[0-9a-zA-Z\_]可以匹配一个数字、字母或下划线。可以利用上一点中的符号来指定匹配数量，如[0-5a-eA-E]+。-&gt; ^可以指定开头符号，如^\d可指定以数字开头。-&gt; $可以指定结尾符号，如\d$可指定以数字结尾。 RegExp实例的方法:-&gt; exec(): 传入需要核对样式的字符串，返回包含匹配项信息的数组。这个数组除了Array实例都有的属性，还有index属性（表示匹配项在字符串中的位置）和input属性（应用正则表达式的字符串，即传入exec的那个字符串）。若没有匹配则返回null；若正则表达式中含有小括号括起来的捕获组，则会依次放入数组的后续项中；若无捕获组，则数组只有第一项完全匹配的。-&gt; test(): 传入需要核对样式的字符串，根据是否匹配返回布尔值。在只需要知道字符串是否符合某种规则而不需要提取内容时，使用test很方便。12345678910111213141516171819202122// execvar text = "mom and dad and baby";var pattern = /mom( and dad( and baby)?)?/gi;var matches = pattern.exec(text);// 由于存在捕获组，故返回的数组matches含有三项// [0]="mom and dad and baby"// [1]=" and dad and baby"// [2]=" and baby"// 若exec的正则表达式不是全局模式，它始终只能找到第一个匹配项var text = "cat, hat, bat, fat";var pattern1 = /.at/;var pattern2 = /.at/g;var matches1 = pattern1.exec(text); // 执行多少次都只有catvar matches2 = pattern2.exec(text); // 执行一次得到cat，再执行依次得到hat bat fat// testvar text = "123-45-6789";var pattern = /\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/;if (pattern.test(text)) &#123; ...&#125; Function类型 Function: 在ECMAScript中，函数也是对象，每个函数都是Function类型的实例。 创建Function类型实例: 使用 函数声明语法 、函数表达式 和 构造函数来定义。由于使用构造函数来定义会导致多一次解析（除了JS代码解析，还需要解析字符串取出参数等），影响性能，而且不直观，所以不推荐第三种方式。 123456789function sum( num1, num2 ) &#123; return num1 + num2;&#125;var sum = function( num1, num2 ) &#123; return num1 + num2;&#125;var sum = new Function("num1", "num2", "return num1 + num2"); 没有重载: 函数是对象，函数名是指针。因此对相同的函数名进行新一轮的赋值，赋予了另一个函数的地址，那么原来的那个函数就无法通过这个函数名（变量）访问了，因此JavaScript没有重载。 函数声明提升function declaration hoisting:解析器会率先读取函数声明，保证函数在执行任何代码之前能用（accessible）；而函数表达式的方式，即将函数赋值给变量的方式必须等到解析器执行到所在的代码行才会真正解析执行。1234567891011// 函数声明方式，可以正常运行alert(sum(10, 10));function sum(num1, num2) &#123; return num1 + num2;&#125;// 函数表达式方式，报错，未声明的函数alert(sum(10, 10));var sum = function(num1, num2) &#123; return num1 + num2;&#125; 作为值的函数 function as value 既然函数名可以作为变量，那么也就可以作为参数传入另一个函数，构建一个通用型的函数（不过暂时还没有体会到这个技术有什么厉害的…）。 123456789function callSomeFunction(someFunction, someArgument) &#123; return someFunction(someArgument);&#125;function add10(num) &#123; return num + 10;&#125;var result = callSomeFunction(add10, 50); 也可以将一个函数作为另一个函数的返回值。例如我们想为sort构造一个比较函数，我们需要一个函数来指明根据哪个属性来比较排序，这样就可以通过传入不同的属性名获得不同的比较函数。 12345678910111213141516171819function createCmp( propertyName ) &#123; return function( object1, object2 ) &#123; var value1 = object1.propertyName; var value2 = object2.propertyName; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125; &#125;;&#125;// 在排序时cmp就可以现做现用var data = [&#123;name: "a", age: 8&#125;, &#123;name: "b", age: 18&#125;];data.sort(createCmp("name"));data.sort(createCmp("age")); 函数内部属性（or内部对象） arguments: 前面有提到，这是一个类数组对象，保存着函数执行时传入的所有参数。它还有一个callee属性，callee指针指向拥有这个arguments对象的函数。但在strict模式下访问arguments.callee会报错！ 12345678910111213141516171819202122// 经典的阶乘函数，与函数名耦合性很强function factorial(n) &#123; if (n &lt;= 1) &#123; return 1; &#125; else &#123; return factorial(n - 1) * n; &#125;&#125;// 如果将函数起个新名字（赋值给另一个变量）然后销毁，这个函数就不能正常工作了var newFactorial = factorial;factorial = function &#123; return 0;&#125;// 解除这种耦合就可以使用arguments.calleefunction factorial(n) &#123; if (n &lt;= 1) &#123; return 1; &#125; else &#123; return arguments.callee(n - 1) * n; &#125;&#125; this: 引用的是函数据以执行的环境对象，是什么环境调用函数，该函数就可以通过this访问存在于该环境对象的属性、方法等。需要指出的是下面代码中sayColor只有一个，函数名只是函数的指针，即使由不同的环境对象执行，也调用的是同一个函数。 12345678910window.color = "red";var o = &#123; color: "blue"&#125;;function sayColor() &#123; alert(this.color);&#125;o.sayColor = sayColor;sayColor(); // 访问的是window对象的coloro.sayColor(); // 访问的是o对象的color caller: 在ECMAScript 5中加入，保存调用当前函数的函数引用；若是在全局作用域中调用当前函数，则值为null。但在strict模式下，caller同样不可用，以防止第三方脚本窥探环境中的其他代码。 12345678function outer() &#123; inner();&#125;function inner() &#123; alert(arguments.callee.caller);&#125;outer(); // 弹窗中会显示outer函数的源码 函数的属性和方法 length属性: 函数定义中接收的命名参数的个数。 prototype属性: 对于ECMAScript的引用类型而言，prototype是保存他们所有实例方法的真正所在，只不过是通过各自对象实例去访问而已。在创建自定义引用类型以及实现继承时，prototype很有用。 apply()方法: 在特定的作用域中调用函数，等于设置函数体内this对象的值，这样一来对象就不需要与方法有耦合关系。接受两个参数，一是其中运行函数的作用域，然后是参数数组（arguments对象或Array实例都可以）。注意在strict模式下，若没有指定环境对象直接调用函数，则this值不会转型为window，除非明确把函数添加到某个对象或调用apply或call。 12345678910function callSum1(num1, num2) &#123; return sum.apply(this, arguments);&#125;function callSum2(num1, num2) &#123; return sum.apply(this, [num1, num2]);&#125;alert(callSum1(10, 10));alert(callSum1(20, 20)); call()方法: 作用与apply相同，都是为了在特定作用域中调用函数、扩充函数赖以运行的作用域。与apply的区别只是传入第二个参数时，不能使用数组，必须将所有参数拆开来依次传入。 12345678910window.color = "red";var o = &#123; color: "blue"&#125;;function sayColor() &#123; alert(this.color);&#125;sayColor.call(this); // 指向window对象的colorsayColor.call(window); // 显式指向window对象的colorsayColor.call(o); // 显式指向o对象的color bind()方法: 定义于ECMAScript 5，会创建一个函数的实例，其this值会被绑定到传入bind函数的值上，最后将这个绑定完成的函数返回。 123456789window.color = "red";var o = &#123; color: "blue" &#125;;function sayColor() &#123; alert(this.color);&#125;var objectSayColor = sayColor.bind(o);objectSayColor(); // 已绑定到o，故显示blue. 基本包装类型 特殊的引用类型: 为了便于操作基本类型值，ECMAScript还提供了Boolean, Number和String。每当读取一个基本类型值时，后台都会创建一个对应的基本包装类型对象。讲道理，基本类型值不是对象，不应该有方法，所以为了能方便我们调用方法，后台实际上为我们创建了对应的基本包装类型对象。 引用类型与基本包装类型的区别: 对象的生存期不同。-&gt; 使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都会一直存在，我们可以在作用域内放心地添加、访问属性和方法；-&gt; 自动创建的基本包装类型对象只存在于代码执行的那一瞬间，执行后立即销毁，所以不能在运行时添加属性和方法。 Boolean类型: 与布尔值对应的引用类型。永远不要用Boolean对象！因为布尔表达式中的所有对象都会被转化为true，这意味着即便声明时用var falseObject = new Boolean(false);，在判断时都会被转化成true，因此falseObject &amp;&amp; true的结果是true。 Number类型: 与数字值对应的引用类型。提供了若干将数字格式化地转化为字符串的方法。-&gt; toString(base): 可根据基数转为特定进制的数字字符串。-&gt; toFixed(bit): 按照指定的小数位返回数字字符串，具有四舍五入的特性。-&gt; toExponential(bit): 按照指定的小数位返回科学计数法的数字字符串。-&gt; toPrecision(bit): 可能返回fixed也可能返回exponential格式，传入的bit包括所有数字的位数而不只是小数点之后的位数。 String类型: 与字符串对应的引用类型。提供了取字符、比较、拼接、切割、取子串、位置方法、大小写转换、正则匹配、查找等方法。-&gt; charAt(pos), charCodeAt(pos): 接受字符位置index，返回单个字符的字符串/字符码（ECMAScript没有字符类型）。在ECMAScript 5中还可以用方括号来访问。-&gt; String.fromCharCode(): 静态方法，直接通过类名调用（虽然ECMAScript中没有类，不过就先这么理解吧）。传入一系列字符编码，返回由这些编码对应的字符组成的字符串。-&gt; localeCompare(): 传入一个字符串，根据字母表的顺序，若应排在字符串参数之后为正数、之前为负数、相等为0.-&gt; concat(): 传入若干字符串，将一个或多个字符串拼接到原字符串后面，返回新字符串，不会影响原字符串。在实践中直接使用+号来拼接字符串更方便直观。-&gt; slice(), substring(): 传入起始index和结束index（可选，不包含），返回子字符串，不会影响原字符串。-&gt; substr(): 传入起始index和截取长度（可选），返回子字符串，不会影响原字符串。-&gt; split(): 基于指定的分隔符或正则表达式将一个字符串分割成子字符串并存入数组中返回。-&gt; indexOf(), lastIndexOf(): 从字符串中搜索给定的子字符串，返回第一次出现位置，若无则为-1。二者区别只在于是从前往后搜索还是从后往前搜索。可选择传入第二个参数指定起始位置。-&gt; trim(): 将原字符串开头和结尾的空格全部删除，返回新建的字符串，不会影响原字符串。-&gt; toUpperCase(), toLowerCase()及二者Locale版: 返回大小写转换后的字符串，不会影响原字符串。-&gt; match(): 传入正则表达式或RegExp对象，返回匹配数组。本质上与调用RegExp对象的exec()方法相同，只是这个的执行者变成了字符串。-&gt; search(): 传入正则表达式或RegExp对象，返回字符串中第一个匹配项的索引。-&gt; replace(): 传入RegExp对象或一个字符串和一个字符串或函数这两个参数。其中当第二个参数为函数时，对于只有一个匹配项，这个函数会接受到三个参数——模式的匹配项、模式匹配项在字符串中的位置和原字符串；对于正则表达式中含有多个捕获组的情况，这个函数会接收到模式的匹配项、第一个捕获组的匹配项、第二个…和模式匹配项在字符串中的位置和原字符串。123456789101112131415161718192021var text = "cat, hat, bat, fat";var result = text.replace("at", "ond"); // 得到"cond, hat, bat, fat"var result = text.replace(/at/g, "ond");// 得到"cond, hond, bond, fond"function htmlEscape(text) &#123; return text.replace(/[&lt;&gt;"&amp;"]/g, function(match, pos, originalText)) &#123; switch(match) &#123; case: "&lt;" return "&amp;lt;"; case: "&gt;" return "&amp;gt;"; case: "&amp;" return "&amp;amp;"; case: "\"" return "&amp;quot;"; &#125; &#125;); &#125; 此外字符串类型还有一些HTML方法，便于使用JavaScript动态格式化HTML。这里就不写了。其实这个方法感觉并不使用，设置粗体、斜体等不应该通过HTML来做，应该交给CSS。 单体内置对象 内置对象的定义: 由ECMAScript实现提供的、不依赖于宿主环境的对象。不需要显示地实例化内置对象，它们在程序执行之前就已经实例化了。前面的Object, Array, String都是内置对象。此外还有两个单体内置对象: Global和Math。 Global: 最保底的对象，所有不属于任何其他对象的属性和方法，最终都是Global对象的例如isNaN(), isFinite(), parseInt(), parseFloat()，此外还有一些方法也是Global的。-&gt; URI编码方法: 对uniform resource identifiers通用资源标识符进行编码，可使用encodeURI()和encodeURIComponent()，防止无效字符在浏览器中无法识别。encodeURI()主要应用于整一个URI，除了空格会处理其余字符都不会改变；encodeURIComponent()主要用于其中某一段，会对任何非标准字符进行转换，在实践中我们更常用到它来对查询字符串参数进行编码。-&gt; URI解码方法: decodeURI()和decodeURIComponent()。-&gt; eval()方法: 在strict模式下eval会受很大限制。正常模式下，eval接收一个完整的JavaScript语句，被eval包围的语句会被当作真实的JavaScript语句来执行，在eval中可以定义变量和函数并在外部访问到，而strict模式下不允许，这就防止了代码注入。-&gt; window对象: 在浏览器中，window对象可视为Global对象。 Math:保存了一些常用的数学特殊值和数学方法。-&gt; 属性: Math.PI, Math.E(自然对数), Math.LN10(ln10), Math.LN2(ln2), Math.SQRT2(2的平方根等)。-&gt; 数学方法: Math.abs(n), exp(n), log(n), pow, sqrt, acos等。-&gt; Math.min()/max(): 传入任意个参数，取最小/最大值。而对于数组，可以利用apply来设置this值:var max = Math.max.apply(Math, arr);-&gt; Math.ceil()/floor()/round(): 向上、向下和四舍五入方法。-&gt; Math.random(): 生成一个0-1之间的随机数（不含0和1）。例如生成某个范围[a, b]的数，可以写成一个固定的函数:1234567891011function generateRandomNum(a, b) &#123; var lower = a, upper = b; if (lower &gt; upper) &#123; var temp = lower; lower = upper; upper = temp; &#125; var choices = upper - lower + 1; return Math.floor(Math.random() * choices + lower);&#125; To be continued…]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>frontend</tag>
        <tag>js</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fundamental of JavaScript]]></title>
    <url>%2F2016%2F08%2F17%2Fjavascript%2F</url>
    <content type="text"><![CDATA[完成了CSS/HTML的学习，接下来是第二本书《JavaScript DOM编程艺术（第2版）》。这本书被很多大神推荐，但是就我看完的感觉，不是很明白这本书为什么会这样受到热捧。这份笔记还结合了一部分廖雪峰的JavaScript教程，因为光凭这本书可能对JavaScript的基础语法还是没法很全面地掌握。后面还有几本JavaScript的pdf书，到时再作补充。 JavaScript基本语法 比较运算符==和=== ==会自动转换数据类型再做比较，例如false == 0结果为真； ===不做数据类型转换，直接比较，若类型不一致会直接返回false，例如false === 0为假；在Javascript相等判断时坚持使用===来比较。 NaNNot a number，只能通过isNaN(value)来判断，直接比较NaN === NaN结果为假。 浮点数比较由于计算机的浮点数计算误差，使用Math.abs()相减的绝对值小于一个很小的值来判断浮点数的相等。 1Math.abs(1 / 3 - (1 - 2 / 3)) &lt; 0.0000001; 数组 JavaScript中的Array可以包含不同的元素。 1var arr = [1, 2.2, 'xxx', true, null]; JavaScript中的Array可以越界存取，越界存时会引起length的扩大，越界取则取出undefined而不是报错终止运行； indexOf(sth)：可以用来搜索某个值的下标，若不存在则为-1； slice(start, end)：类似于substring，复制出子数组。若不指定开始和终止下标，默认将完整数组复制出来； push和pop：向数组末尾加入若干或吐出一个元素，会更改length；若吐到没得吐了，返回undefined； unshift和shift：向数组头部加入若干或吐出一个元素，会更改length；若吐到没得吐了，返回undefined； splice：修改数组的万金油，可在指定位置删除、添加若干元素； 1arr.splice(index, deleteNum, insertContent1, insertContent2, ...); concat：将若干数组合并，复制到一个新的数组中而不是修改原数组。 1arr.concat(1, 2, [3, 4]); join：将当前数组的元素用给定字符连接起来，返回连接后的字符串。默认直接打印的数组以逗号连接。 for循环 for(var i = 0; i &lt; length; i++)循环最常用在遍历数组。 for...in用于将对象的所有属性依次遍历出来：12345for (var key in o) &#123; if (o.hasOwnProperty(key)) &#123; alert(key); // 'name', 'age', 'city' &#125;&#125; Array数组也是对象，使用for…in来遍历数组的时候，每个元素的索引被视为对象的属性（此时索引的类型被视为String） 12345var a = ['A', 'B', 'C'];for (var i in a) &#123; alert(i); // '0', '1', '2' alert(a[i]); // 'A', 'B', 'C'&#125; for…of：针对iterable类型（Array, Map, Set）在EC6中加入，只循环遍历出集合本身的元素，而不是属性。12345var a = ['A', 'B', 'C'];a.name = 'Hello';for (var x of a) &#123; alert(x); 'A', 'B', 'C'&#125; 此外对于iterable集合，还可以直接使用forEach函数。 123array.forEach(function (元素, 索引, 本身) set.forEach(function (元素, 本身) map.forEach(function (值, 键, 本身) JavaScript的函数 函数的定义 函数的方式：类似于c++/java的定义函数。 123function abs(x) &#123; ...&#125; 变量的方式：利用赋值将一个函数定义赋值给一个变量，注意末尾的分号。 123var abs = function(x) &#123; ...&#125;; 函数的调用JavaScript中的函数传入参数数目不符合定义不会报错。-&gt;若传入的参数多于定义，只会从左到右取参数，取够为止；-&gt;若传入参数不足，则不足的参数位置传入undefined，造成return的可能是NaN。所以为了防止参数是undefined，可以在函数开头处加上参数类型验证： 12if (typeof x !== 'number') throw 'Not a number'; arguments关键字在函数内部使用的所有传入参数的集合，用法类似Array但不是Array。可用arguments.length来获得传入参数个数。 rest伪参数在定义函数时，在参数列表最后加上try(a, b, …rest)就可以把多余的参数存入数组rest，方便在函数内部使用。 this在’use strict’模式下，若this不是直接出现在函数内部，则会指向undefined。在非strict模式下则指向window全局对象。 apply和call 使用apply方法指定函数中的this指向哪个对象，传入需要this绑定的对象和对应的参数列表。 call方法也是用于绑定this，与apply区别在于参数是按顺序传入而不是打包传入。12Math.max.apply(null, [3, 5, 4]);Math.max.call(null, 3, 5, 4); 高阶函数一个函数接收另一个函数作为参数。 map: 定义在JavaScript的Array中，可将传入的函数作用于数组的每一个元素，得到一个新的数组。 1234function pow(x) &#123; return x * x;&#125;var result = arr.map(pow); reduce: 定义在JavaScript的Array中，将传入的函数依次作用在数组的元素上，这个函数必须接受两个参数，把结果继续和序列的下一个元素累积运算，保存到一个新的数组。 1234// 使用reduce求和var result = arr.reduce(function (x, y) &#123; return x + y;&#125;); filter: 定义在JavaScript的Array中，将传入的函数作用于数组的每一个元素，根据返回的布尔值是true还是false来决定保留还是舍弃该元素，最后将剩余元素返回，保存到一个新的数组。 1234// 将arr中的空字符串删掉var result = arr.filter(function (s) &#123; return s &amp;&amp; s.trim(); // 注意：IE9以下的版本没有trim()方法&#125;); sort: 定义在JavaScript的Array中，默认是将元素转为String再根据ASCII进行排序。可根据传入的函数（必须为两个参数）定义排序规则。排序结果直接影响原数组。 12345678910// 倒序排序arr.sort(function (x, y) &#123; if (x &lt; y) &#123; return 1; &#125; if (x &gt; y) &#123; return -1; &#125; return 0;&#125;); 闭包 高阶函数不但可以将函数作为参数，还可以将函数作为结果值返回。当调用该高阶函数时，每次都会返回一个新生成的函数，这些函数之间的执行互不影响。 闭包：将相关参数和变量都保存在返回的函数中。闭包可以用来返回一个函数并延迟执行，或封装一个私有变量，或将多参数函数变为单参数。(参考源)123456789function make_pow(n) &#123; return function (x) &#123; return Math.pow(x, n); &#125;&#125;// 由make_pow创建两个新函数:var pow2 = make_pow(2);var pow3 = make_pow(3); 匿名函数与箭头函数 匿名函数：无需赋予名字，定义后立即使用并只用一次。 1(function (x) &#123; return x * x &#125;) (3); 箭头函数：ES6加入，类似于匿名函数并简化了函数定义。但是箭头函数和匿名函数的区别在于箭头函数内部的this是词法作用域（外层调用者）。 12345(x, y) =&gt; x * x + y * y; // 相当于function squareSum(x, y) &#123; return x * x + y * y;&#125; generator 定义方式：语法和函数很像，只不过多了个星号function* foo(x) { ... }。除了return，中途还可以使用yield来返回多次。 调用：直接用“函数名(参数列表)”的方式并不是调用，有两种方式调用。第一种是next()方法，每次遇到yield就返回一个对象{value: x, done: true/false}，当done为真时意味着执行到最后的return了。第二种是用for…of的方式循环迭代generator对象，for(var x of fib(5))会把每次yield的value传给x直到结束。 JavaScript的对象 对象是由属性和方法组合构成的数据实体。其中属性property：属于某个特定对象的变量。方法method：某个特定对象才能调用的函数。 对象和实例实例之间各不相同，是对象的具体个体。为对象创建实例使用new关键字。其实我个人感觉实例和对象说的是一回事，类才是更抽象的一级。但是JavaScript中似乎没有提到类这个概念，所以就强行把对象和实例分开解释了？我一直觉得书里面说的对象，换成类也能说得通。（2016.8.15更新）实际上，在JavaScript中不区分类和实例的概念，而是通过原型来实现面向对象编程。在JavaScript中，所有对象都是实例，没有class的概念，所谓的继承关系也只是把一个对象的原型指向另一个对象而已。Bobby.__proto__ = Person;但应该避免通过直接修改对象的原型实现继承关系。可以通过原型对象来创建实例对象： 123456789101112131415// 原型对象:var Student = &#123; name: 'Robot', height: 1.2, run: function () &#123; console.log(this.name + ' is running...'); &#125;&#125;;function createStudent(name) &#123; // 基于Student原型创建一个新对象: var s = Object.create(Student); // 初始化新对象: s.name = name; return s;&#125; 用户自定义对象 键值无序集合 1234567var person = &#123; firstname: "Bill", lastname: "Gates", age: 56, eyecolor: "blue", hasCar: true &#125;; 定义并创建对象的实例 12345678person = new Object();person.firstname="Bill";person.lastname="Gates";person.age=56;person.eyecolor="blue";// 或使用对象literalsperson = &#123;firstname:"John",lastname:"Doe",age:50,eyecolor:"blue"&#125;; 使用函数来定义对象，然后创建新的对象实例。一定要使用关键词new才是调用构造函数，它绑定的this会指向新创建的对象，默认返回this（不要手动多加了return）。 123456function Person(firstname,lastname,age,eyecolor) &#123; this.firstname=firstname; this.lastname=lastname; this.age=age; this.eyecolor=eyecolor;&#125; 构造对象时用new的方式var myFather=new Person(&quot;Bill&quot;,&quot;Gates&quot;,56,&quot;blue&quot;);注意这种情况下每个对象内如果定义了函数，这些函数虽然代码是相同，但属于不同的对象，浪费内存。解决方式是将各个对象共有的函数向上挪，挂到上一级的原型链上，例如Person.prototype.foo = function() {...};这样。 原型继承继承原本的含义是扩展一个已有的class，但是JavaScript中没有类的概念，这里的继承需要通过以下方式实现。(1) 定义新的构造函数，并在内部用call()调用希望继承的构造函数，并绑定this. 12345// PrimaryStudent构造函数:function PrimaryStudent(props) &#123; Student.call(this, props); this.grade = props.grade || 1;&#125; (2) 借助空中间函数F实现原型链继承，最好通过封装的inherits函数完成可隐藏F。 123456function inherits(Child, Parent) &#123; var F = function () &#123;&#125;; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child;&#125; (3) 继续在新的构造函数的原型上定义新方法。 1234// 绑定其他方法到PrimaryStudent原型:PrimaryStudent.prototype.getGrade = function () &#123; return this.grade;&#125;; Class继承从ES6开始引入class，让JavaScript引擎去实现原来需要我们自己编写的原型链代码。使用class继承和java相似，使用extends关键字： 12345678910class PrimaryStudent extends Student &#123; constructor(name, grade) &#123; super(name); // 记得用super调用父类的构造方法! this.grade = grade; &#125; myGrade() &#123; alert('I am at grade ' + this.grade); &#125;&#125; 内建对象 Javascript提供一些预先定义好的对象，拿来就用。例如数组，在var nuggets = new Array();的时候就是在创建一个Array对象的实例。而Math对象可以不实例化直接使用里面的方法var num = Math.round(8.245); 但是其他包装对象不推荐使用，如new Number(), new String(), new Boolean()，这种情况下使用===会造成很大麻烦，所以还是直接用它们对应的普通类型比较好。 宿主对象由运行环境提供的对象，对于Web应用来说，运行环境就是浏览器，浏览器会提供Form, Image, Element, document, window等对象。 浏览器与DOM（Document Object Model文档对象模型） 浏览器提供的对象 window: 可获取浏览器窗口的尺寸，innerWidth, innerHeight等。 navigator: 可获取浏览器应用程序信息，如navigator.appName浏览器名, appVersion浏览器版本, platform操作系统, userAgent字段, language等。其中appName不是内核名称，根据W3C HTML5的规范，navigator对象的appName要么返回Netscape，要么返回浏览器的全名，这是为了兼容性而考虑的。 screen: 可获取设备屏幕信息，如screen.width, height, colorDepth颜色位数。 DOM D: 浏览器加载网页时，将html网页文档转化为文档对象。 O: 用户定义user-difined &amp; 内建native &amp; 宿主host三种对象。 M: 模型Model或地图Map。DOM代表这加载到浏览器窗口的当前网页，我们需要通过模型或地图来读取这个网页的组件。Xhtml文档节点树就是一种地图。 节点 元素节点：DOM的原子是element node，就是节点树中的一个个元素，由标签定义。 文本节点：文本内容。在html文档中，文本节点总是包含在元素节点的内部。 属性节点：对元素进行更具体的描述，总是放在起始标签里。 DOM方法获取元素节点 document.getElementById(“IdName”): 返回与给定id相同的唯一元素对象。是document对象特有的函数。 element.getElementsByTagName(“tagName”): 返回符合给定标签的元素的数组，不只有document可以调用，其他元素都可以调用，例如先使用ID拿到指定ul元素中的所有元素：var shopping = document.getElementById(“purchases”);然后再从这个ul元素中拿它包含的所有元素对象：var items = shopping.getElementsByTagName(“*”); element.getElementsByClassName(“className”): 返回包含给定类名的元素的数组，给定的类名可以有多个，也是各种元素对象都可以调用的。但是必须指出HTML5 DOM才引入了这个方法，所以有时必须重载一个类似功能的方法用在旧的浏览器中，但是只能查询单一个类名： 1234567891011121314function getElementsByClassName(node, classname) &#123; if (node.getElementsByClassName) &#123; return node.getElementsByClassName(classname); &#125; else &#123; var results = new Array(); var elems = node.getElementsByTagName(“*”); for (var i = 0; i &lt; elems.length; i++) &#123; if (elems[i].className.indexOf(classname) != -1) &#123; results[results.length] = elems[i]; &#125; &#125; return results; &#125;&#125; document.querySelector(‘selector’): 使用CSS选择器来获取节点。 element.querySelelctorAll(‘selector’): 与上面类似，不过返回的是所有符合条件的节点。 DOM方法获取和设置元素属性 object.getAttribute(“attrName”): 返回给定属性的值，若找不到该属性，返回null。不能通过document调用，只能通过元素对象调用。 object.setAttribute(“attrName”): 对给定属性的值进行修改，若找不到该属性，会先创建该属性然后赋值。不能通过document调用，只能通过元素对象调用。如果不用DOM的方式来设置属性，可以直接通过object.attr = value;来赋值，但用途不如DOM广。 其他DOM属性 node.childNodes: 没有参数，直接获取元素的所有子元素的NodeList，返回保存着各种类型节点的数组（不仅仅是元素节点）。 element.children: 获取的是HTMLCollection，类似于上面的NodeList，区别在于children只能是element的属性，得到的仍是element；而childNodes则是Node的属性（只不过Element是Node的一种所以也可以使用childNodes属性），得到的是各种Node而不光是element。 node.nodeType: 返回数字值，指代该节点的类型，1-元素节点，2-属性节点，3-文本节点。 node.nodeName: 返回节点的标签名称，纯大写字母。 node.nodeValue: 可以获取或改变一个节点的值。注意对于例子&lt;p id=”description”&gt;Choose an image.&lt;/p&gt;，若通过getElementById拿到p元素，此时直接调用nodeValue得到的是null，要想改变文本，其实需要通过childNodes[0]拿到第一个子元素，即文本元素，然后直接通过对nodeValue赋值进行修改。 node.firstNode: 完全等价于前面写的node. childNodes[0]. node.lastNode: 代表childNoes数组的最后一个元素，等价于node.childNodes[node.childNodes.length - 1]; node.parentElement: 获取父元素节点。 node.firstChild/lastChild: 获取的是Node，需要判断一下nodeType才能确定能否正确拿到元素节点。另有firstElementChild/lastElementChild可直接获取元素节点。 node.nextSibling/previousSibling/nextElementSibling/previousElementSibing: 与上面类似。 删除DOMnode.removeChild(node): 直接删除，注意一旦删除就会对原有DOM产生影响，如果是用下标等方式来做要注意下标变化。 JavaScript操作表单和文件 表单控件包括了input输入框和select单选下拉框，前者又包括type=”text”文本框，”password”密码框，”radio”单选框，”checkbox”复选框，”hidden”隐藏携带文本。HTML5还加入了type=”date”，”datetime”，“datetime-local”，”color”。 获取/修改表单值使用value属性或checked属性。对于HTML5的标准控件，value一定是具有标准格式字符串。 提交表单 使用form的submit()方法: 在HTML中，&lt;form&gt;之间的表单通过响应按钮控件的onclick事件实现表单提交，但这会干扰浏览器对form的正常提交。正常情况下浏览器默认点击submit类型的button来提交表单，或者在最后的input按回车键提交表单。 12345678910111213&lt;form id="test-form"&gt; &lt;input type="text" name="test"&gt; &lt;button type=”button” onclick=”doSubmitForm()”&gt;SUBMIT&lt;/button&gt;&lt;/form&gt;&lt;script&gt;function doSubmitForm() &#123; var form = document.getElementById('test-form'); // 可以在此修改form的input... // 提交form: form.submit();&#125;&lt;/script&gt; 响应form的onsubmit事件：在form标签后添加onsubmit响应事件。 12345678910111213&lt;form id="test-form" onsubmit="return checkForm()"&gt; &lt;input type="text" name="test"&gt; &lt;button type="submit"&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;script&gt;function checkForm() &#123; var form = document.getElementById('test-form'); // 可以在此修改form的input... // 继续下一步: return true;&#125;&lt;/script&gt; 上传文件在HTML表单中，只有&lt;input type=”file”&gt;可以控制上传文件，且只能由用户手动操作选择文件来上传，使用JavaScript对value赋值是没有效果的，且JavaScript也无法获得用户选择文件所在的真实路径。JavaScript可以在提交表单时对文件扩展名进行检查，防止文件格式不匹配。 123456var f = document.getElementById('test-file-upload');var filename = f.value; // 'C:\fakepath\test.png'if (!filename || !(filename.endsWith('.jpg') || filename.endsWith('.png') || filename.endsWith('.gif'))) &#123; alert('Can only upload image file.'); return false;&#125; HTML5文件操作FileAPIFile API允许JavaScript读取文件内容，提供了File和FileReader两个对象获得文件信息。例如对于一个图片上传并预览的页面： 12345678 &lt;form method="post" action="http://localhost/test" enctype="multipart/form-data"&gt; &lt;p&gt;图片预览：&lt;/p&gt; &lt;p&gt;&lt;div id="test-image-preview"&lt;/div&gt;&lt;/p&gt; &lt;p&gt; &lt;input type="file" id="test-image-file" name="test"&gt; &lt;/p&gt; &lt;p id="test-file-info"&gt;&lt;/p&gt;&lt;/form&gt; 可以用JavaScript来检查文件是否选择、格式是否匹配图片、获取文件大小、修改时间等信息： 123456789101112131415161718192021222324252627282930313233var fileInput = document.getElementById('test-image-file'), info = document.getElementById('test-file-info'), preview = document.getElementById('test-image-preview');// 监听change事件:fileInput.addEventListener('change', function () &#123; // 清除背景图片: preview.style.backgroundImage = ''; // 检查文件是否选择: if (!fileInput.value) &#123; info.innerHTML = '没有选择文件'; return; &#125; // 获取File引用: var file = fileInput.files[0]; // 获取File信息: info.innerHTML = '文件: ' + file.name + '&lt;br&gt;' + '大小: ' + file.size + '&lt;br&gt;' + '修改: ' + file.lastModifiedDate; if (file.type !== 'image/jpeg' &amp;&amp; file.type !== 'image/png' &amp;&amp; file.type !== 'image/gif') &#123; alert('不是有效的图片文件!'); return; &#125; // 读取文件: var reader = new FileReader(); reader.onload = function(e) &#123; var data = e.target.result; // 'data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...' preview.style.backgroundImage = 'url(' + data + ')'; &#125;; // 以DataURL的形式读取文件: reader.readAsDataURL(file);&#125;); 其中使用了异步操作来读取文件内容。由于JavaScript是单线程执行，在执行多任务时需要异步调用，这里的reader.readAsDataURL(file)就发起了一个异步操作。它不会持续等待函数执行完毕才向后执行，而是利用前面的回调函数reader.onload = function(e);，读取文件成功后就是通过这个回调函数来安全地获取文件属性和内容。 Ajax异步执行网络请求（详见七•3）由于一次http请求对应取一个页面，如果当用户点击了submit跳转到新的页面而由于网速太慢会造成404找不到网页。要想让用户停留在当前页面的同时发送http请求，就需要用到JavaScript来发送请求，并根据返回的数据时对当前页面进行更新。用JavaScript写Ajax需要注意请求是异步执行的，需要通过回调函数获得响应。PS: 这里的markdown语法用到了页内跳转，在后面加个span并给的id，这里就像添加链接一样[xx](#id)。 最佳实践 平稳退化graceful degradation正确地使用JavaScript使得当访问者在题目拿到浏览器不支持JavaScript或手动关闭了js功能的情况下仍能顺利浏览网站。例如使用window.open(“url”, “name”, “features”)创建弹出窗口，使用JavaScript构建一个函数： 123function popUp(winURL) &#123; window.open(winURL, “popup”, “width=320, height=480”);&#125; 在html中使用这个函数可以用三种方法： 伪协议： &lt;a href=”javascript:popUp(“http://xxx/”);”&gt;xxxxxx&lt;/a&gt;。这样的语句在支持JavaScript伪协议的浏览器中可以正常工作，但是旧的或关了js的就不行了。 内嵌事件处理函数：&lt;a href=”#” onclick=”popUp(“http://xxx/”); return false;”&gt;xxxxx&lt;/a&gt;一样无法支持不执行JavaScript的浏览器。 合法链接backup：&lt;a href=”http://xxx/” onclick=”popUp(this.href); return false;”&gt;xxxxx&lt;/a&gt;这样会优先执行JavaScript，失败后仍可以直接打开URL，虽然无法保留在当前页面弹窗打开，但至少不会点击了没有反应。 分离JavaScript类似于CSS样式与html元素分离，对于元素的事件也可以通过外部js文件加入到元素标签中：element.event = action。需要注意的是将JavaScript代码放到外部文件后，里面的document.getElement...函数可能无法正常工作，因为引用JavaScript时DOM模型可能还没有成型，浏览器还没有把所有元素都加载进来，那么可能尚且找不到对应的元素。为了让HTML加载完再触发js，添加一个window.onload来确保DOM已经成型。 12345678910111213141516window.onload = prepareLinks;function prepareLinks() &#123; var links = document.getAttributeByTagName(“a”); for (var i = 0; i &lt; links.length; i++) &#123; if (links[i].getAttribute(“class”) == “popup”) &#123; links[i].onclick = function() &#123; popUp(this.getAttribute(“href”)); return false; &#125; &#125; &#125;&#125;fucntion popUp(winURL) &#123; window.open(winURL, “popup”, ”width=320, height=480”);&#125; 共享onload事件可以利用一个addLoadEvent函数，传入打算在页面加载完毕立即执行的函数的名字，绑定到onload事件上。若onload已经绑定有函数，则先执行完先前的函数再执行当前函数。若持续调用，则会为这一系列函数建队列，排队依次执行： 123456789function addLoadEvent(func) &#123; var oldOnload = window.onload; if (typeof window.onload != ‘function’) &#123; window.onload = func; &#125; else &#123;oldOnload();func(); &#125;&#125; 向后兼容 对象检测直接检测对象是否可用，即用if语句发现该方法无法使用，就不继续执行了。 12345window.onload = function() &#123; if (!document.getElementsByTagName) return false; var links = document.getElementsByTagName(“a”); ....&#125; 浏览器嗅探检测浏览器种类和版本来判断函数是否可用。我感觉这个方法不如直接检测对象有用。 性能考虑 尽可能少访问DOM，例如多用变量存储节点而不是反复getElementsxxx。 合并脚本，尽量减少加载页面时发送的请求数量，不用总是请求小js文件。 脚本引用标签script放在文档末尾、body结束之前，因为HTTP规范中浏览器同时只能从同一域名下载两个文件，若放在head中则浏览器在下载脚本期间不会下载任何其他文件（即使是不同域名），这可能阻塞其他资源的加载严重影响性能。 压缩脚本，即保存一份xxx.min.js的文件把里面所有的空格、注释、换行都删除。但我觉得这个有点反人类，万一改出错了想纠正会特别困难。按照这本书的说法，需要保存两份代码，一份是人类能看的，一类是经过工具压缩的代码。 动态创建元素 传统方法回顾 document.write: 使用JavaScript代码向HTML中动态创建、插入元素。例如在JavaScript中使用document.write(“&lt;p&gt;sth&lt;/p&gt;”);插入元素。这违背了“行为与表现分离”的原则，在想要插入的地方需要借助script标签才能调用相应的代码。将html和js的代码混在一起是很糟糕的做法。 innerHTML属性: 用于读写给定元素里的HTML内容。例如document.getElementById(“testdiv”).innerHTML就可以获得HTML文件中id为testdiv元素内部的HTML纯文本内容；documnet.getElementById(“testdiv”).innerHTML = “&lt;p&gt;New content&lt;/p&gt;”就可以修改里面的HTML纯文本，实现动态修改元素，当原元素为空时可以实现插入元素。这种方法可以把js代码和html分离开来。 innerText/textContent属性：会自动对文本内容进行html编码，无法插入新标签。而读取时前者不返回隐藏标签，后者返回所有文本。 DOM方法DOM方法的本质是在改变文档节点树。具体来讲，首先需要创建一个新元素，然后将该元素插入现有文档节点树中，接着根据需要追加插入文本节点。 document.createElement(“nodeName”)：调用后会创建一个孤立的元素（文档碎片，document fragment），但是并没有连接到DOM节点树上。 parent.appendChild(child)：会将变量child作为子节点插入到parent节点下面，真正连到DOM文档中。 document.createTextNode(“text”)：创建文本节点，可结合上一个函数插入到现有元素的子节点完成文本插入。 parentElement.insertBefore(newElement, targetElement)：在现有元素之前插入新元素，其中parentElement不必真的去找出来，可以直接调用targetElement.parenetNode获得父节点。 在现有元素之后插入新元素：DOM其实并没有提供，但是完全可以自己编写：12345678function insertAfter(newElement, targetElement) &#123; var parent = targetElement.parentNode; if (targetElement == parent.lastChild) &#123; parent.appendChild(newElement); &#125; else &#123; parent.insertBefore(newElement, targetElement.nextSibling); &#125;&#125; Ajax异步加载 以往点击某个链接刷新局部信息时，请求发送到服务器，然后服务器根据操作返回完整的新页面，这十分浪费资源。而Ajax可以只刷新加载网页的局部，对页面的请求以异步的方式发送到服务器，服务器会在后台处理请求，用户仍然可以继续浏览页面并进行交互。但Ajax必须依赖javascript；而且Ajax相应地也缺少状态记录，无法按照用户习惯进行后退、收藏等操作。同时只更新部分区域可能也会影响用户预期，所以Ajax响应必须给出明确的提示。 异步请求的特点：脚本发送XMLHttpRequest请求之后，即调用send函数后仍会继续执行后续脚本，不会一直等待响应返回。响应返回后，所有依赖于服务器响应的操作才会执行。 XMLHttpRequest对象：以往请求都由浏览器发出，而如今javascript可以利用这个对象自己发送请求、处理响应，这个对象充当浏览器脚本（客户端）和服务器之间的中间人的角色。 var request = getHTTPObject(): 获取XMLHttpRequest对象，需要考虑浏览器版本兼容问题。 12345678910111213function getHTTPObjecct() &#123;if (typeof XMLHttpRequest == “undefined”) XMLHttpRequest = function() &#123; try &#123; return new ActiveXObject(“Msxml2.XMLHTTP.6.0”); &#125; catch (e) &#123;&#125; try &#123; return new ActiveXObject(“Msxml2.XMLHTTP.3.0”); &#125; catch (e) &#123;&#125; try &#123; return new ActiveXObject(“Msxml2.XMLHTTP”); &#125; catch (e) &#123;&#125; return false; &#125; return new XMLHttpRequest();&#125; getNewContent: 手写函数，利用XMLHttpRequest对象的open方法指定服务器上要访问的文件、指定请求类型GET, POST, SEND，并指定是否以异步方式发送和处理请求；接着利用onreadystatechage属性来指定处理响应的函数；最后将请求异步发送，直接调用send。 123456789101112131415161718function getNewContent() &#123; var request = getHTTPObject(); if (request) &#123; request.open(“GET”, “xxx.txt”, true); request.onreadystatechange = function() &#123; if (request.readyState == 4) &#123; var para = document.createElement(“p”); var txt = document.createTextNode(request.responseText); para.appendChild(txt); document.getElementById(“new”).appendChild(para); &#125;; request.send(null); &#125; else &#123; Alert(“Sorry, your browser doesn\’t support XMLHttpRequest”); &#125; &#125;&#125;addLoadEvent(getNewContent); 其中request.onredaystatechange是获取readyState属性的函数，有五个取值，0-未初始化，1-正在加载，2-加载完毕，3-正在交互，4-已完成，我们在上面函数中拿到4就说明可以访问服务器返回来的数据了。返回的数据可以使用两个函数来处理，一是request.responseText属性，它保存了文本字符串的数据；二是request.responseXML属性，它保存了Content-Type头部中指定为”texxt/xml”的数据。 Hijax由于Ajax要求必须启用JavaScript才能正常使用Ajax访问内容，这会导致网站可用性和可访问性的问题。最好的做法是先构建一个常规的网站，然后Hijax它，拦截正常发往服务器的请求并转交XMLHttpRequest对象处理。Hijax的意思是“渐进增强地使用Ajax”.Ajax应用依赖后台服务器，因为是后台服务器的脚本完成了大部分的工作。XMLHttpRequest对象作为浏览器与服务器之间的“中间人”只负责不阻塞地传递请求和响应而已。在不支持Ajax的浏览器上，这个中间人挪开应该有传统方式保证相似的请求和响应仍能正常工作，只不过不是异步、局部请求而已，耗时稍长但不至于不可用。 CSS-DOM 网页是三层信息构成的共同体 结构层：由html或xhtml标记语言创建，对网页的语义含义做出描述，但标签并不包含任何关于内容如何显示的信息。 表示层：由CSS描述页面内容如何呈现。 行为层：决定内容应该如何响应事件，由javascript+DOM控制。 分离与交叉：正常来说，应该严格选择最恰当的工具去解决问题，在网页设计中这意味着用html搭建文档结构、用CSS设置文档呈现的效果、用DOM脚本实现文档的行为。但是三者之间存在着重叠的区域，例如CSS利用伪类:hover, :focus也可以控制触发元素样式改变，js-DOM也可以给元素设置样式。 style属性 获取style属性：每个元素节点都有style属性，需要注意的是用element.style返回的是一个style对象，如果要访问font-family属性，需要element.style.fontFamily这样的驼峰命名方式来访问或修改。但style属性只能获取内嵌样式，即在元素标签内带有style属性指明的样式才能拿到，否则就是Null，而我们知道结构应与样式分离，所以用DOM方式来获取样式其实没有多少实用价值。 修改style属性：部分DOM属性如previousSibling, nextSibling, parentNode, firstChild, lastChiild都是只读的，而style属性则是可以赋值的。element.style.property = “value”，值必须用引号包围，否则就相当于变量了。 在什么情况下才选择使用DOM脚本设置样式 根据元素在节点树中的位置来设置样式：由于CSS无法根据元素之间的相对位置关系找出某个特定元素进行设置（虽然CSS3有一些位置选择器不过浏览器不一定支持），可以用DOM找出文档中指定元素。 根据某种条件反复设置某种样式：例如使table表格行与行之间交替显示不同颜色，在CSS3的nth-child(even/odd)选择器用不了的时候，如果非要用CSS实现就必须为奇数和偶数行分别加class再设置样式，万一表格很大又要修改那就悲剧了。而使用DOM就可以动态找出奇数偶数行。 用样式响应事件：CSS中a标签可以用hover控制鼠标悬停的样式，但对于其他元素要想设置悬停样式就得用DOM方式的onmouseover来实现了。 className属性既然使用DOM直接修改样式不是好的工作方式，那么我们可以修改class，依然由CSS去决定样式。凡是元素节点都有className属性，若是直接element.className=value赋值，则原有的CSS样式将完全被新的class指定的样式覆盖（而不是叠加）。要想叠加类名，则应该先判断原先有没有class，若有则应当把空格+新类名追加到className上： 12345678910function addClass(element, value) &#123; if (!element.className) &#123; element.className = value; &#125; else &#123; var newClassName = element.className; newClassName += “ “; newClassName += value; element.className = newClassName; &#125;&#125; 对函数的抽象把一个具体的东西改进为一个较为通用的东西的过程叫抽象。例如为h1元素添加intro这个类，编写的函数为： 12345678function styleHeaderSiblings() &#123; if (!document.getElementsByTagName) return false; var headers = document.getElementsByTagName(“h1”); var elem; for (var i = 0; i &lt; headers.length; i++) &#123; elem = getNextElement(headers[i].nextSibling); addClass(elem, “intro”);&#125; 这个函数就不够抽象。抽象的函数具有普适性，上面这个函数完全可以把h1和intro分别作为参数传入这个函数，这样就可以应用到其他情况。 Javascript实现动画 利用javascript按照预定的时间间隔重复调用一个函数，从而让某个元素的样式随着时间的推移不断改变。这是CSS无能为力的。例如让一条message在屏幕上渐渐移动： 123456789101112131415161718192021function moveElement(elementID, final_x, final_y, interval) &#123; if (!document.getElementById) return false; if (!document.getElementById(elementID)) return false; var elem = document.getELementById(elementID); var xpos = parseInt(elem.style.left); var ypos = parseInt(elem.style.top); if (xpos == final_x &amp;&amp; ypos == final_y) return true if (xpos &lt; final_x) xpos++; if (xpos &gt; final_x) xpos--; if (ypos &lt; final_y) ypos++; if (ypos &gt; final_y) ypos--; elem.style.left = xpos + “px”; elem.style.top = ypos + “px”; var repeat = “moveElement(‘” + elementID + “’,” + final_x + “,” + final_y + “,” + interval + “)”; movement = setTimeout(repeat, interval);&#125; 需要指出的是，上面的函数调用了elem.style来获取元素当前位置，这意味着该元素必须通过内嵌样式style属性或已经通过DOM植入了style属性，否则无法获取位置。 实际中的动画Javascript有些臭名昭著就是因为加入的动画引起访问者的反感，导致可访问性问题。除非浏览器允许用户停止移动的内容，否则就应避免让内容在页面中移动。实际中用得比较多的动画并不是元素在屏幕上移动，而是例如加载一个多图标的完整图片，根据用户鼠标的位置在图标框中显示不同的内容（有点类似spirte图）。]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>frontend</tag>
        <tag>js</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fundamental of HTML5 and CSS]]></title>
    <url>%2F2016%2F08%2F04%2Fhtml5_css%2F</url>
    <content type="text"><![CDATA[大菜鸭推荐了几本前端学习书籍pdf给我，这本《HTML5与CSS3基础教程（第8版）》是我看的第一本。虽然大三上的时候选修了移动Web应用开发这门课，当时觉得这门课性价比真高，除了HTML/CSS/JavaScript三件套，还学了Java, JSP, MySQL等等，但都只是涉猎，并没有很全面地学。虽然我这样看书可能也不见得能学得多系统，不过一步步来吧。 网页的构造块 网页包含的内容 文本内容(text content): 纯文字; 对其他文件的引用(references to other files): 由引用加载图像音视频、引用CSS层叠样式表控制页面显示效果、引用javascript为页面添加行为; 标记(markup): 对文本内容进行描述并确保引用正确工作. 网页等成分都由纯文本构成，用纯文本格式可以跨平台在浏览器上显示。 HTML思想：HTML通过标签来描述元素内容，而不关心内容的样式。 元素：开始标签+内容+结束标签。标签中可能含有属性+值。属性的值可能是无限制的，可能是需要枚举的，还可能是boolean的。一旦出现布尔属性，则该属性为真。例如required，或写作required=&quot;required&quot;. URL: uniform resource locator，统一资源定位符包含了文件存储位置和浏览器应如何处理它的信息。 语义化HTML semantics 使用最恰当的HTML元素进行标记。当然HTML5没有给所有可能的内容都配备对应元素，在100种元素中通常只会用到少量核心元素。 语义化HTML的优点：(1) 提升可访问性和互操作性，方便无障碍访问；(2) 提升搜索引擎优化SEO效果；(3) 使维护代码和添加样式更容易；(4) 代码更少、页面加载更快。 编写网页 HTML页面分为两部分，head和body。DOCTYPE出现在每个页面开头，告诉浏览器本页面是HTML5.head：指明页面标题title，提供搜索引擎所需页面本身的信息、加载样式表、加载javascript（不过在body结束之前加载JS会更好）。除了title，其余head中的信息对于浏览者都是不可见的。body：包含浏览者可见的正文、图像、音视频、表单。 title元素每个HTML页面都必须有title元素，简要概括文档内容，提升搜索引擎带来的流量。 分级标题h1~h6对任何页面来说，分级标题可以说是最重要的元素，因为它们与搜索关键词匹配得越多，排序越靠前。分级标题通常都是粗体且上下行距会略大。这不是HTML带来的效果，这是浏览器默认的CSS制造的样式。 创建页眉headerheader元素标记一块含介绍性、导航性内容的区域。通常含有标题、标识、导航、搜索框等。若使用h1~h6可以满足要求，则不必引入header将它们包起来。Header不能代替h1~h6，他们各自有语义目的。 标记导航navHTML5引入nav来把一组重要链接标记为导航。 标记页面主要区域mainHTML5引入main标签来标记文档的主要区域。 标记文章articleHTML5引入article表示页面中独立的容器，可嵌套使用。内容可包含任意数量的元素，如段落、列表、音视频、图像等。 定义区块sectionHTML5引入section代表一组具有相似主题的内容区块。Section虽说是通用的区域块，但不能与div混用，section指出了特定主题的区域，而div没有这样的语义。如果只是因为要添加样式而要对特定内容加个容器，直接用div. 指定附注栏asideHTML5引入aside表明页面中一组和主题内容相关性不是很强的部分，如引述、侧栏、友情链接、广告、商品列表等。若aside嵌入到正文中，则应当与这部分内容密切相关。 创建页脚footerHTML5引入footer表示所在区块的附录、索引、版权等信息。 通用容器div不带有任何语义的块级元素，只是为了方便添加样式或javascript效果。同前面的header, footer, main, article, section, aside, nav, h1~h6一样，默认都是另起一行显示。 role属性（ARIA改善可访问性）使用role属性，为元素添加landmark role，帮助用户识别页面区域。ARIA并不会改变任何样式，只用于提升辅助设备上的浏览体验。 role=”banner”对应放在页面级header元素中； role=”navigation”对应nav元素或其他包含导航型链接群的容器； role=”main”对应main元素或其他表示主体内容的元素； role=”complementary”对应aside； role=”contentinfo”对应footer。 class/id属性通常为了添加样式会在html元素中添加class=”xx-xxxx”””属性，每个元素可以有多个class。而id则是用于为元素添加javascript效果的，每个元素至多有一个id，且id在该页面中唯一。 title属性使用title也可以提升无障碍访问体验，title中的内容可以朗读出来，或鼠标悬停在该元素时显示的提示。注意和前面的title元素区分！ 文本编辑元素 段落pHTML会忽略文本编辑器中的回车与空格，故另起一段文字应用p标签包裹。 细则small行内文本的一小块，表示免责声明、注意事项、注解等短语。这并不意味着small包裹的内容就一定是小号字。 强调重要性strong/emstrong标记重要文本（以粗体显示），em着重强调一部分内容（以斜体显示）。em是表示强调的唯一元素，strong表示重要程度，可嵌套提升重要性。注意HTML5强调标签的语义而非表现样式，HTML5中的粗体标签b和斜体标签i只是顺应样式上的惯例。（如书名用斜体，而不能用em实现这种斜体的效果） 图片figure+figcaption一个fugure中不论有多少个&lt;img src=”xxx” /&gt;，都只能在开头或结尾出现一个figcaption。 1234&lt;figure&gt; &lt;figcaption&gt;&lt;b&gt;xxx&lt;b&gt;&lt;/figcaption&gt; &lt;img src="xx" width="180" height="143" alt="this is what" /&gt; &lt;/figure&gt; 引用cite 1&lt;cite&gt;引用的参考源&lt;/cite&gt; 引述文本blockquote/qblockquote是块级引述，可带有cite属性给出url链接；q是行内引述，也可带有cite, lang等属性。cite与blockquote/q的区别是，cite表明的是引言的来源，而blockquote/q是本身引用的内容片段。 指定时间time（HTML5新增）time中包含的内容会显示在页面上，若没有datetime属性，则必须是机器可读的格式如YYYY-MM-DDThh:mm:ss；若前面附上datetime=” YYYY-MM-DDThh:mm:ss”，则后面的内容就不必严格遵守格式。 解释缩写词abbr在abbr标签的title属性中写出后面缩写词的全称，方便访问者理解。其实针对触摸屏的用户，直接使用括号解释缩写词更方便。 定义术语dfn包围要定义的专用术语，dfn元素必须和它的定义内容在一起。 上下标sup/subsup通常用于为脚注标号，sup元素位置会稍高导致扰乱行间距。Sub下标类似。 作者联系信息address用于定义与页面或其中某一部分有关的相关人士的联系方式。 标记编辑或不再正确的文本ins/del/s标记添加内容的ins元素和标记已删除内容的del元素，它俩既可以包围块级也可以包围行内内容。而s则只可以标记行内的已删除内容。 标记代码code在行内插入一段代码，代码中&lt;和&gt;符号需要用&amp;lt和&amp;gt代替。若想单独成段且保持每行一段代码，需要使用pre元素保持原有代码格式。 预格式化pre保持文本编辑器中的文本的排版，保留空格、回车。 突出显示文本markHTML5引入mark提醒读者对特定文本段的注意。 换行br强制文字换行。确保br是最后的选择，例如控制段落间距时用margin去调而不是添加几个br。因为br元素将表现样式带到了HTML中，应该尽量将呈现样式的任务交给CSS。 span无语义（如同div），包围行内的字词、短语，非常适合给行内一小块内容添加样式或补充一些属性如class, dir, id, lang, title等。无语义元素应当作为最后的选择。 图像 格式与下载速度 jpeg: 有损的格式，不支持透明。合理压缩使图片体积变小，加载速度快，而压缩后丢失的信息无法还原。照片和插图通常选择jpeg方便加载。 png: 无损的格式，支持透明（分为基本透明、alpha透明两档）。也带有压缩算法，但文件尺寸依然较大。 gif: 无损格式，只支持基本透明。压缩算法不如png，文件更大。 webp: 既支持有损压缩，也支持无损压缩，产生文件远小于jpeg和png，同时支持alpha透明。但浏览器支持较少。 颜色Gif, png-8支持256色。Jpeg, png-24, png-32支持1600万+。 大小尺寸网页上的图片应控制在几百像素宽，控制好尺寸才能减少加载时间。SVG可缩放矢量图形不论如何缩放都不会影响显示品质，不论页面中显示的大小如何，文件体积都是固定的。 透明度索引色透明是binary value，一个像素要么透明要么不透明；(gif)Alpha透明是渐变的，可以控制透明程度，从而边缘更平滑、锯齿较少。互联网上大多数alpha透明的图片都是png-32的，虽然png-8也支持alpha透明。 动画使用图像表现动画需要保存为gif。 插入图像img&lt;img src=”xxx” alt=”xxx” width=”300” height=”350”&gt;。其中alt可以在图像无法显示的时候作为文字说明显示在对应位置，而且可以提供无障碍访问。定义宽度和高度可以帮助浏览器预留出图像的位置，是图像更快地显示出来。默认单位是像素，属性这里的宽度和高度不一定要反映图片真实的尺寸，可以适当缩放，这在retina屏幕上会有更锐利的视觉效果。但注意加载速度仍不变，毕竟还是同一个图像文件，要想加速还得用PS修一下图真正改变尺寸。 网站图标favicon16*16的favicion.ico文件，放在网站的根目录，浏览器会显示在标签栏中。 链接 链接的组成由目标destination和标签label组成。目标文件需要有正确的路径。 行内链接元素a&lt;a href=”xxx.html”&gt;label content&lt;/a&gt;。对于指向外部其他网站的链接，推荐加入属性rel=”external”。Title属性也是作为一种鼠标悬停提示。 块级链接元素a即在a之间的标签加入p等块级元素，甚至可以包含h1, img等。不过需要注意标签内容还是尽量少比较好。 a的target属性控制链接在新窗口或标签页打开，target=”window name”，但不推荐使用，因为在浏览器中有这样的选项，所以完全可以将这种操作权交给用户。 用锚跳转到网页特定区域&lt;a href=”xxx.html#anchor-name”&gt;，其中anchor-name对应页面文件xxx.html中的某元素的id，若直接href=”#anchor-name”的话必须是当前页面。 其他链接如文件：href=”https://www.xxx.com/bbb.txt”邮件：href=”mailto: sb@xxx.com”电话：href=tel:+8612345678900。 CSS构造块 样式表定义了网页外观的规则。每一条规则由选择器selector和声明块declaration block组成。 注释Html中是&lt;!-- blablabla--&gt;，CSS是/*Blablabla*/。 继承inheritance根据元素的包含关系（或者画出树形结构）确定谁是后代谁是祖先。 样式层叠当多条规则定义同一元素的同一属性，会根据以下方式来确定样式： 特殊性（specificity，越具体规则性越强，例如id选择器就大于继承来的样式）； 顺序（order，晚出现的优先级更高）； 重要性（在样式声明块末尾加上!important强调，不推荐）。 样式属性值 Inherit：显示地指出该元素继承祖先的样式。 预定义的值：如none, left, right，不带引号。 长度：必须带有单位。em表示当前字号长度，受font-size设置的影响，这属于响应式web设计；px像素，很难准确度量像素的实际大小；百分数则是相对于父元素的。 URL：指定另一个文件（如图像）的url，如·background-image: url(file.png)。 CSS颜色：最常用的是hex十六进制#5900FF；还有rgb(r, g, b)。CSS3引入了RGBA（引入alpha透明rgba(r, g, b, a)，alpha=0为透明、1为不透明）、HSL（色相hue、饱和度saturation、亮度lightness）、HSLA（引入了alpha） 操作样式表 外部样式表这是最佳选择，让各个页面有类似的样式设置，不会出现很多重复代码。同时使用外部样式表可以充分利用浏览器的缓存功能，不需要重复请求css文件。在html的head中使用&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot;&gt;，在实践中最好将css放在单独子目录中。 嵌入样式表在html的head包围中，加入&lt;style&gt; img{border: 2px solid red;} &lt;/style&gt;这样的样式，只会作用于这个页面。 内联样式将style作为各个元素的属性进行设置，它严重违背了html的宗旨（将内容和表现分离）。要想改变一点点样式就需要大量的检查，很麻烦。当然可以作为简单的测试，合适后搬移到外部css文件中。 指定媒体在link的属性中加上media=”screen”或“print”来规定什么情况下使用该样式。或者直接在css文件中的对应选择器之前加上一个大包围123@media print &#123; xxxx &#125; 定义选择器 编写CSS的一个重要目标是使选择器尽可能简单，仅保持必要的特殊性。应充分利用样式的层叠特性，让后代继承祖先的样式。善于利用通用设计元素，便于共享样式。 基本选择器 标签选择器：直接用元素名称。P{font-size: 14px;} ID选择器：#idname. 由于id的唯一性使id选择器的样式不能在其他元素上复用，且它的特殊性很高，在覆盖样式时不容易控制。Id属性应尽量只用于javascript。 类选择器：.classname; 复合选择器 派生选择器：祖先后加空格，再接后代的选择器。p span{}选择p的所有子孙元素中的span元素。 子女选择器&gt;：只能选出直接后代，父元素后加&gt;接子元素。p&gt;span{}选择p元素所有直系子女中的span元素。 组合选择器：直接并在一起写就可以了，表示且&amp;&amp;。p#start{}，选择id为start的p元素。 群组选择器,：用逗号隔开且最好换行分别列出来，表示或||。em, .even{}会选择em或类名为even的元素. 相邻兄弟选择器+：用+连接，紧跟的同辈元素符合要求才会选中。h1+p{}当h1元素后紧跟的兄弟元素是p才会被选中。 后续兄弟选择器~：用~连接，所有后续同辈元素都会被选中。h1~p{}。 否定选择器not：p:not(#start)选择p元素中id不为start的。注意这里的冒号含义是“p元素中”，这与后面的单个孩子选择器中的冒号有区别。 属性选择器 img[alt]{}：选择具有属性alt的img元素。 img[alt=”value”]：选择属性alt的值为value的元素。 img[alt^=”val”]：选择属性alt的值以val开头的元素。 img[alt$=”lue”]：选择属性alt的值以lue结尾的元素。 img[alt*=”5-”]：选择属性alt的值包含字符串5-的元素。（CSS3新增） img[alt~=”val”]：选择属性alt的值完全匹配单词val的元素，单词指以空格分开。 单个孩子选择器伪类中所有的冒号都不表示从属关系，而是表示“作为…身份”。 p:first-child{}：表示作为第一个孩子的p元素，即p的双亲的第一个孩子为p时选中。 p:last-child{}：表示作为最后一个孩子的p元素，即p的双亲的最后一个孩子为p时选中。 p:nth-child(5){}：表示作为第五个孩子的p元素，即p的双亲的第五个孩子为p时选中。 p:nth-child(even/odd){}：表示作为偶数/奇数位孩子的p元素，即p的双亲的偶数/奇数位孩子为p时选中。 p:nth-child(3n+1){}：表示作为第1、4、7…个孩子的p元素，即p的双亲的3n+1位孩子为p时选中。 子女类型选择器与单个孩子选择器不同在于，参与计数的孩子只算上规定类型的元素。 p:first-of-type{}：表示作为第一个p元素的p元素，即选中p的双亲的第一个p元素。 p:last-of-type{}：表示作为最后一个p元素的p元素，即选中p的双亲的最后一个p元素。 nth-of-type(5){}：表示作为第五个p元素的p元素。 nth-of-type(even/odd/3n+1)：类似。 伪元素选择器在CSS3中将单冒号改为双冒号，这是为了与伪类区别开来（不过IE8不支持）。伪元素是在html中并不存在的元素，即没有对应标签，它们只是元素的一部分。 p:first-letter：选择p元素的第一个字母。 p:first-line：选择p元素的第一行。 p:after{content:”…”}：在p元素内容后面加上…。 p:before{content:”---”}：在p元素内容前面加上—。 伪类选择器伪类的意思是不必为了应用于一组元素特地创建一个类来标记它们，伪类相当于内置类。例如根据连接的状态设置样式，记住设置顺序一定是LVFHA。 a:link{}：没有访问过的链接。 a:visited{}：已访问过的链接。 a:focus{}：通过键盘选择的、即将访问的链接。 a:hover{}：光标指向链接时。 a:active{}：光标点下时的链接。 文本样式 字体font-family：可以多设置几个备选。 斜体font-style：italic; 取消则用normal。 粗体font-weight：bold; 取消则用normal。 字体大小font-size：可用px, em, %, rem。尽量使用em这样的相对单位，便于适应各种尺寸的显示设备。 关于px：使用像素会定死字体大小，浏览器内置的字体调节都不行。 关于em：根据父元素的字体大小按比例缩放。先在body元素上加一个基准{ font-size: 100%; }，（通常是系统默认的是16px，各个浏览器都可以由用户自行设置），利用font-size的继承性传递到各个子元素。接下来在各个子元素中再计算一个比例，你要放大到2倍就用2em，缩小到0.8就0.8em。通常设计网页时，使用em比px好，原因是em是相对单位，有更大的灵活性，而且对定义页面中特定的设计部件（边距、空白）的尺寸有帮助。 关于rem：根据root根元素（即html元素）的字体大小按比例缩放，在CSS3引入。 行高line-height每行之间的距离，通常直接用数字设置行高，解析时会与字体大小相乘得出行高。line-height: n; 或者使用em，百分数。 统一设置font使用font简写属性同时设置体样式、粗细、变体、大小、行高和字体系列，其中必须显示声明字体大小和字体系列。行高如果出现只能写在字体大小后接横杠加行高。 文本颜色color使用#rrggbb（若为重复值可简写为#rgb），rgb(r, g, b)，rgb(r%, g%, b%)，hsl(h, s, l)，rgba(r, g, b, a)，hsla(h, s, l, a)。 文本背景background其实background也是简记法，包括了background-color：颜色。background-image: url(image.png)background-repeat: repeat/repeat-x/repeat-y/no-repeatbackground-attachment: fixed表示随滚动固定在浏览器上background-position: x y表示距离左上角的距离或百分数，也可用关键字。 单词间距word-spacing：接带单位数字em, px，控制单词之间距离。 字母间距letter-spacing：接带单位数字em, px，控制字母之间距离。 缩进text-indent：接带单位数字em, px，只能对块级元素（或强制display:block/inline-block的元素）预留缩进。 对齐text-align：后接left左对齐、right右对齐、center居中、justify文本两端对齐。同样只对块级元素起作用。 指定大小写text-transform：capitalize首字母大写、uppercase、lowercase、none取消继承值。 迷你大写font-variant: small-caps可让大写字母与小写字母一样大。 装饰线text-decoration：underline下划线、overline上划线、line-through删除线。 保留空白回车white-space：pre显示原文本中空格/回车、nowrap取消自动换行、normal默认。再次强调尽量少用html中的br元素，html应尽量少插手样式设置。 用CSS布局 布局分为两种 固定布局fixed：每个元素都是固定宽度，不论任何设备显示都是固定的。 响应式页面responsive（fluid, liquid）：使用百分数定义宽度，会随着环境变化、调整尺寸 为不支持html5的浏览器添加样式的两种方法 在每个页面的head元素中加入一段javascript（通常JS最好放在页面结束的位置，但这个必须放在最开始才起作用），这是html5shiv剃刀，防止IE8-浏览器忽略原声不支持元素的CSS. 12345678&lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;Le Journal&lt;/title&gt; &lt;link rel="stylesheet" href="css/lejournal.css" /&gt; &lt;!--[if lt IE 9]&gt; &lt;script src="https://html5shiv.googlecode.com/svn/trunk/html5.js"&gt;&lt;/script&gt; &lt;![endif]--&gt;&lt;/head&gt; HTML5剃刀将html5shiv的文件放到网站服务器上并在head之间导入该js脚本。 123&lt;!--[if lt IE 9]&gt; &lt;script src="js/html5shiv.js"&gt;&lt;/script&gt;&lt;![endif]--&gt; 还需要注意的是由于大多数浏览器对无法识别的元素都当作行内元素处理，所以还需要加入一句CSS强制以块级显示html5元素 123article, aside, figcaption, figure, footer, header, main, nav, section &#123; display: block;&#125; 对默认样式进行重置或标准化使得在不同浏览器中外观相似 使用CSS重置开始主样式表http://meyerweb.com/eric/tools/css/reset/ 使用normalize.css开始主样式表。 盒模型 默认处理方式CSS中设置的宽度只是padding里面的内容的宽度，真正显示的宽度还需要加上padding和边框的大小。 border-box方式这种方式更直观，CSS中设置的参数就是显示的参数，包含除了margin以外的内容+padding+border。需要在元素中显示指明123box-sizing: border-box;-webkit-box-sizing: border-box; -moz-box-sizing: border-box; 后二者是为了在旧的android和ios和firefox上也能识别。 控制元素显示类型和可见性displaydisplay: block; 可以将行内元素设为块级显示display: inline; 将块级元素设为行内显示；display: inline-block; 设为行内显示但是又可以用到块级元素的样式如width, height, margindisplay: none; 直接完全消失，元素原本所处的位置也不会留出来。可见性还可以用visibility: hidden控制，这种情况下元素还是会在文档流中留有位置。 元素宽高weight: w; 设置元素内容的宽度，w可以为带单位px, em的长度，也可是父元素的百分比。height: h; 设置元素内容到底高度，h可以为带单位px, em的长度，也可是父元素的百分比。若没有显示设置宽高，默认都是auto。以width为例，auto值就是包含块的宽度减去元素的padding、border和margin计算出来的。而包含块的宽度指的是父元素留出来的宽度。若手动设置了width同时将左右margin都设为auto，相当于左右外边距将父元素留出来的宽度平分，则元素会居中。 paddingpadding: n; 会将设置的值应用于四个方向；padding: n1 n2; 将n1用于top&amp;bottom，n2用于left&amp;right。padding: n1 n2 n3; 将n1用于top，n2用于left&amp;right，n3用于bottom。padding: n1 n2 n3 n4; 按照TRouBLe的顺时针顺序用于上右下左。值的单位可以是px, em, rem或百分比。 borderborder: 宽度 样式 颜色;样式有可以是 none、dotted（点线）、dashed（虚线）、solid （实线）、double（双线）、groove （槽线）、ridge（脊线）、inset（凹边）或 outset（凸边）。可以指定某个方向的border进行设置，如border-top这样。 margin相邻元素的margin值不会叠加，只取较大者。使用margin: 0 auto;的方式实现居中，必须依赖于width手动设置好固定值。em单位用于padding和margin时，它的值是相对于元素的字体大小的。 浮动元素float可以使得设置了宽度的元素浮在第二层，其他第一层元素的内容环绕着它显示，注意只是内容环绕显示，对于height, width都是按第一层文档流计算的。若不希望某第一层元素的内容环绕在其他浮动元素周围，可强制使用clear: left/right/both;强行下挪直到该元素左/右/两边都没有浮动元素之后才显示。但是这样做也有问题，如果浮动元素的父元素中包含的全部都是浮动元素，那这个父元素的高度是0，它设置的背景色之类的样式就无法显示了。解决办法是加入clearfix类，给浮动元素的父元素添加class=”clearfix”即可。 1234567891011.clearfix:before,.clearfix:after &#123; content: " "; display: table;&#125;.clearfix:after &#123; clear: both;&#125;.clearfix &#123; *zoom: 1;&#125; 还可以用overflow创建自清除浮动元素，对浮动元素的父元素使用overflow: hidden; 相对定位position: relative;表示相较于原本的自然位置的偏移。具体偏移量需要指定。top: 6px; 另有right、bottom、left，后接带单位的数字。 绝对定位指定它们相对于 body或最近的已定位祖先元素，绝对定位的元素会脱离正常文档流，但是又和浮动元素不一样，因为别的元素内容不会感知到它而环绕着显示，重叠了就是重叠了。对于重叠的元素，可以使用z-index指定叠放顺序，值越大越高。此外还有一种position: fixed;可以让元素随着滚动而固定不动，但它在移动设备上效果不佳，一般不用。 overflow处理元素溢出盒子overflow: visible;直接显示出来；hidden隐藏掉；scroll不管用不用都会强行加上滚动条；auto仅在需要时加上滚动条。 垂直对齐行内元素vertical-align: middle;-父元素中央；baseline-父元素基准线；sub-父元素下标；super-父元素上标；text-top-顶部对齐父元素；text-bottom-底部对齐父元素；top-对齐当前行中最高元素顶部；bottom-对齐当前行中最低元素的底部。 鼠标形状cursor: default箭头、pointer手指、crosshair十字架、move挪动框、wait沙漏、help带问号、text输入的I字形、process箭头带沙漏。 响应式web设计 响应式网页基于三点 图像和媒体尺寸均以百分比定义； 基于网格的流式布局，所有width都以百分比定义 媒体查询，可根据设备进行调整适配。 可自动伸缩的图像 在HTML中的img标签必须省略width和height； 在CSS中为该图像加上max-width: 100%;样式，使图像缩放的可用空间是由其父元素建立的内容区域（除去padding的）。 width: 100%;也可以缩放，但是它有可能会因为超过图像本身的宽度而强行填充容器，比较难看。 弹性布局网络创建弹性布局需要使用百分数宽度，并将它们应用于页面里的主要区域。元素的百分数宽度基于其父元素（即包含该元素的容器）提供的可用空间。设置width: p%;形成弹性宽度。可结合max-width: 1000px;来限制最大宽度。可以使用box-sizing: border-box;来限定盒模型计算方式，直观很多。 媒体查询media query 指向外部样式表的链接&lt;link rel=&quot;stylesheet&quot; media=&quot;logic type and (feature: value)&quot; href=&quot;your-stylesheet.css&quot; /&gt;其中logic值是可选的，可为only或not；type是媒体类型，如screen, print；(feature: value)组合是可选的，一定要用括号括起来。例如样式中插入一段针对480px屏幕的外部css 1&lt;link rel="stylesheet" media="only screen and (min-width: 480px)" href="styles-480.css" /&gt; 位于样式表中的媒体查询： 123@media logic type and (feature: value) &#123; /* 目标 CSS 样式规则写在这里 */&#125; 例如 123456@media only screen and (min-width: 480px) &#123; p &#123; color: red; font-weight: bold; &#125;&#125; 组合可伸缩图像、弹性布局、媒体查询 在html中添加&lt;meta name= &quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;/&gt; 遵循移动优先，先提供基本样式，再根据媒体查询为不同尺寸的屏幕定义样式。 逐步完善布局，使用媒体查询为页面中的每个断点（breakpoint，内容需作适当调整的宽度临界值）定义样式。注意为其中的元素使用百分比宽度。 测试响应式页面可以多缩放浏览器窗口。http://lab.maltewassermann.com/viewport-resizer/ 多倍屏可能也需要使用媒体查询，例如使用更锐丽的sprite图：123456@media (-o-min-device-pixel-ratio: 5/4), (-webkit-min-device-pixel-ratio:1.25), (min-resolution: 120dpi) &#123; .your-class &#123; background-image:url(sprite-2x.png); background-size: 200px 150px; &#125;&#125; 针对无法媒体查询的处理IE8以前都无法使用媒体查询，所以可以对低版本IE新建一个CSS，把媒体查询相关语句去掉，在html的head标签之间加入： 123456&lt;!--[if gt IE 8]&gt;&lt;!--&gt; &lt;link rel="stylesheet" href="css/styles.css" /&gt;&lt;!--&lt;![endif]--&gt;&lt;!--[if lt IE 9]&gt; &lt;link rel="stylesheet" href="css/old-ie.css" /&gt;&lt;![endif]--&gt; 或者为低版本IE使用特殊的js，这样IE就能理解min-width了 123&lt;!--[if lt IE 9]&gt; &lt;script src="js/respond.min.js"&gt; &lt;/script&gt;&lt;![endif]--&gt; 使用Web字体 有点杂，略过。 使用Google fonts(1) 在google fonts中找到喜欢的字体，复制&lt;link href=&quot;http://fonts.googleapis.com/css?family=Lato:300|Open+Sans:700&quot; rel=&quot;stylesheet&quot; /&gt;到head之间。(2) 在CSS中直接可以使用font-family了。 使用CSS3进行增强 渐进增强强调创建所有用户都能访问（无论使用什么样的 Web 浏览器）的基本层面的内容和功能，同时为更强大的浏览器提供增强的体验。这意味着网站在不同 Web 浏览器中的外观和行为不一样是完全可以接受的，只要内容是可访问的。 polyfillpolyfill用于填补旧浏览器与新的Web技术之间的差异。polyfill通常使用JavaScript 实现，它可以为较弱的浏览器提供一定程度的对HTML5和CSS3的API和属性的支持，同时，当浏览器本身就具有相应的能力时，会不动声色地退而使用官方的支持。关于IE，Jason Johnston的CSS3 PIE是一种最为常见的polyfill. 厂商前缀每个主流浏览器都有其自身的前缀。使用时将前缀放在 CSS 属性名的前面，我们一般只需要-webkit 前缀。-webkit- （Webkit/Safari/ 旧版本的 Chrome）-moz- （Firefox）-ms- （Internet Explorer）-o- （Opera） 创建圆角border-radiusborder-radius: 10px 20px 0 30px;/ 将左上方圆角半径设为10px，右上方圆角半径设为20px，右下方圆角半径设为0，左下方圆角半径设为30px /border-radius: x / y;为椭圆形圆角。同 border 、 margin 和 padding 属性一样，border-radius 属性也有长短两种形式的语法。只有当你想在旧版本的 Android、Mobile Safari 和 Safari 浏览器中显示相应效果的时候才使用 -webkit 前缀。为了防止背景透过圆角，在最后加上background-clip: padding-box; 文本阴影text-shadowtext-shadow: x-offset y-offset blur-radius color;若想为同一个元素加入多个阴影样式，可以用逗号分隔，继续输入。text-shadow: 2px 2px white，6px 6px #aaa; 元素阴影box-shadow-webkit-box-shadow: 2px 2px 3px 5px #333 inset;box-shadow属性接受六个值：带长度单位的 x-offset 和 y-offset 、可选的带长度单位的 blur-radius 、可选的 inset 关键字(将阴影显示在内部)、可选的带长度单位的 spread 值及 color 值。如果不指定 blur-radius 和 spread 的值，则设为 0。为兼容旧版 Android、Mobile Safari和Safari浏 览器，使用-webkit-box-shadow。 颜色+图片混合背景（CSS3引入） 1234background-color: blue;（备用背景色）background-image: url(stars.png); background-position: 0 -150px; （对于每一个url都应该有一个pos，成对的x-offset和y-offset）background-repeat: repeat-x/repeat-y/no-repeat; 渐变背景（CSS3引入）线性渐变background: linear-gradient(方向/角度值，指定颜色)如background: linear-gradient(to top left, aqua, navy);形状渐变background: radial-gradient(形状 尺寸 开始位置, 指定颜色)如background: radial-gradient(30px 30px at 65% 70%, yellow, lime, red); 设置不透明度opacity: o; 其中o越大，越不透明。 生成内容generated content使用:before和:after伪元素，与content属性结合使用，可生成CSS内容。生成内容可以添加符号、 创建用于添加样式的空内容元素如为链接&lt;a href=&quot;victoria.html&quot; class=&quot;more&quot;&gt; Read More&lt;/a&gt;添加后面的箭头，可用 123.more:after &#123; content: " »"; &#125; Spirte拼合图像将多个图像拼合到一张图里，再使用background-position来定位找到图片。例如为每一个文件链接前加上文件类型的图标。 12&lt;li&gt;&lt;a href="expenses.xls" class="icon"&gt; Business expenses&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="user-manual.pdf" class="icon"&gt;User Manual&lt;/a&gt;&lt;/li&gt; 在CSS中的icon类，使用before伪类 1234567891011121314.icon:before &#123; background-image: url(sprite.png); content: " "; display: block; height: 16px; /* 图标高度 */ position: absolute; width: 16px; /* 图标宽度 */&#125;a[href$=".xls"]:before &#123; background-position: -17px 0;&#125;a[href$=".docx"]:before &#123; background-position: -34px 0;&#125; 列表 有序列表 123&lt;ol&gt; &lt;li&gt;&lt;/li&gt;&lt;/ol&gt; 有序列表的每一个list item左边都会有标号，可以用CSS控制标号样式。list-style-type: decimal（数字123）、upper-alpha（大写字母ABC）、lower-alpha（小写字母abc）、upper-roman（大写罗马字母I II III IV）、lower-roman（i ii iii iv）。也可以使用后面无序列表的标记，但这样ol标签的语义就被违背了。 正确的列表嵌套次序为 I（罗马数字）、A、1、a（此后交替使用 1 和 a 编号方案） 可以在html中为ul标签添加start=”2”属性强制从2开始递增。或者在某个li标签中添加value=”5”属性，则后续的标号也会根据这个值计算。 无序列表 123&lt;ul&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; list-style-type: disc（圆点）、circle（圆圈）、square（方块）。当然也可以选用前面的数字标记。 自定义列表标记 list-style-type:none;取消官方标记 在每个li的目标CSS样式中，加入background: url(image.png); 为每个li适当调整行高line-height: 1.5em;并用padding把文本向右挪动padding-left: x; 标记位置内缩list-style-position: inside; 简写列表样式 123ul &#123; list-style: circle inside;&#125; 嵌套列表实现下拉式导航使用CSS，让每个子菜单仅在访问者鼠标停留在其父元素的列表项目上时显示出来。 12345678910/* 子菜单的默认状态 */.nav .subnav &#123; left: -999em; /* 将子菜单移出屏幕 */ position: absolute; z-index: 1000;&#125;/* 当鼠标停留在父元素li上时子菜单的状态 */.nav li:hover .subnav &#123; left: auto; /* 让子菜单回到自然状态 */&#125; 描述性列表专门描述成组出现的术语及对应值的列表。 1234&lt;dl&gt; &lt;dt&gt;Title&lt;/dt&gt; &lt;dd&gt;Description&lt;/dd&gt;&lt;/dl&gt; 表单 表单的组成部分 页面上可视的控件、标签、按钮。 用于获取信息并转化为可读取或计算的格式的处理脚本。 HTML5对表单的改进引入新的表单元素、输入类型和属性，增强了表单行为如对必填字段、电子邮件地址、URL 以及定制模式的验证。&lt;input type=”email”&gt; 另有search, tel, url, date, number, rangeRyanseddon可为旧版浏览器提供模仿html5表单行为的js。 创建表单form 1234&lt;form method="post" action="show-data.php"&gt; 各种说明标签、控件和按钮。 &lt;input type="submit" value="Create Account" class="btn" /&gt;&lt;/form&gt; 可在form标签中加入novalidate关闭html5的表单验证功能。 Get和Post的区别 Get: 表单提交后，表单中的数据会显示在浏览器的地址栏里。通常，如果你希望表单提交后从服务器得到信息，就使用get。例如搜索引擎提交关键词，由于数据出现在 URL 中，因此用户可以保存搜索查询，或者将查询发给朋友。 Post: 提交表单后，表单中的数据不会显示在浏览器的地址栏里，这样更为安全。同时，比起get，使用post可以向服务器发送更多的数据。通常，post用于向服务器存入数据，而非获取数据。因此，如果需要在数据库中保存、添加和删除数据,就应选择post。 如果不确定使用哪一种，就使用 post ，这样数据不会暴露在 URL 中。 用脚本处理表单脚本根据表单收集的信息，在服务器进行相应处理如存入服务器数据库、转发到别的邮箱等。常用的脚本语言有php, Django, Ruby on Rails, ASP.NET, JavaServer Pages.服务器端脚本有一个重要功能是表单验证，检查用户输入的信息是否符合预期格式。而元素内置的检查功能或者javascript提供的验证 服务器端与客户端 php是服务器端server-side语言，运行于为网页服务的计算机（称为服务器）。脚本必须上传到服务器上才能发挥作用，这通常跟你托管网页、图像等用的是同一个服务器。 html/css是客户端client-side语言，在查看网页的访问者的计算机的浏览器上运行，可以在完全不与服务器交互的情况下执行很多任务。JavaScript也是一种客户端语言. 将表单中相关元素组合起来 在form标签下，加入&lt;fieldset&gt;标签开始包裹相关元素。 紧跟着fieldset下方输入&lt;legend&gt;提供起注释标签功能的文本。 文本框type=”text”的input。 name属性必须为每个文本框设置，脚本会通过name获取文本框中的值。 value属性是文本框默认值，会预先填入。 placeholder起到提示的作用，鼠标点击后就消失，与value不同。 required=”required”会强制用户输入才能提交。 autofocus=” autofocus”会自动获取焦点。 size设置文本框的宽度，以字符为单位。 maxlength设置最大字符数，以字符为单位。 autocomplete=”off”可以关闭历史填充信息的保存，保护文本框隐私如银行卡等。 为表单组件添加说明标签 12&lt;label for="first-name"&gt;First Name:&lt;/label&gt;&lt;input type="text" id="first-name" name="first_name" class="field-large" /&gt; label中使用for属性，若for 的值与一个表单字段的id 的值相同，该label 就与该字段显式地关联起来了。这可以提升可用性和可访问性。还可以将一个表单字段放在一个包含标签文本的label内，就不需要使用for和id了。但不经常这样做的原因是分离开来比较容易加样式。 密码框相比文本框就把type=”password”即可。 html5新增类型框邮件 type=”email”网址 type=”url”电话 type=”tel”加入pattern 属性用于定制的验证规则，它使用正则表达式对用户在框中输入的内容进行限制。 单选按钮对input元素设置type=”radio”即可。name=”xxx”用于服务器识别数据，同时用于将多个单选按钮联系在一起，同一组中最多只有一个被选中。id=”idxx”每一个独立的选项都会有唯一的id，可用于后面label的for属性进行关联。value=”data”是单选按钮被选中时要发送给服务器的文本。checked=”checked”可以默认勾选。 多选按钮对input元素设置type=”checkbox”即可。name=”xxx[]”，加入[]可以让php自动创建一个包含复选框值的数组。value=”data”是复选框被选中时要发送给服务器的文本。 文本区域textarea&lt;textarea id=&quot;bio&quot; name=&quot;bio&quot; cols=&quot;40&quot; rows=&quot;5&quot; class=&quot;field-large&quot;&gt;&lt;/textarea&gt; 下拉选择由select和option标签组成。通常select中设置name属性，option中设置value属性。 123456&lt;label for="state"&gt;State:&lt;/label&gt;&lt;select id="state" name="state"&gt; &lt;option value="AL"&gt;Alabama&lt;/option&gt; &lt;option value="AK"&gt;Alaska&lt;/option&gt; ...&lt;/select&gt; 可以对option进行分组，加入分别包围起来即可。 上传文件 1234&lt;form method="post" action="show-data.php"enctype="multipart/form-data"&gt; &lt;label for="picture"&gt;Picture:&lt;/label&gt;&lt;input type="file" id="picture" name="picture" multiple=”multiple”(表示可上传多个)/&gt;&lt;/form&gt; 服务器端必须有处理文件上传的脚本才行。 隐藏字段type=”hidden”的input，它的值（name, value）也会一同提交到服务器，但不会显示在浏览器中，但通过开发者工具还是可以看到这个标签的。想设置为只读input，可用readonly=”readonly”。想完全禁用，使用disabled=”disabled”。 提交按钮 12&lt;input type="submit" value=" submit message " /&gt; message是显示在按钮上的文本。&lt;input type="image" src=" image.url " width=”168” height=”22” alt="description" /&gt; 将文本与图片的按钮相结合，应使用button元素： 12&lt;button type="submit" class="btn"&gt;&lt;img src="check.png" width="21" height="21" alt="" /&gt; Create Profile&lt;/button&gt; 使用伪类根据状态调整表单样式:focus:checked:disabled:enable:required:optional:invalid:valid 插入音视频和多媒体 html5的改变在html5之前，添加多媒体必须通过插件如adobe, quicktime。而html5提供了原生的多媒体，由浏览器负责解析而不需要插件，同时为不支持某些格式的浏览器提供flash备选方式。为什么不喜欢flash等插件？一是兼容性，在某个浏览器中插入视频的代码不一定能在另一个浏览器上起作用，没有标签包围的优雅实现方式；而是用户体验，插件会占用计算资源，是浏览器卡顿甚至崩溃。html5原生的多媒体速度更快，降低了对插件的依赖。但html5对文件格式进行了规范，这意味着可能需要提供多种格式才能满足要求。 视频 Html5视频支持的格式包括.ogg, .ogv, .mp4, .m4v, .webm。 插入视频直接使用video标签即可：&lt;video src=”xxx.webm” &gt;&lt;/video&gt; 其他属性autoplay 加载完自动开始播放controls 添加控制按钮muted 视频静音loop 循环播放poster 指定视频上显示的图像，而不是默认的第一帧。widthheightpreload=”none”关闭自动加载 ”metadata”只加载元数据 “auto”自动加载当视频不是页面主要元素或播放可能性不大，很有用，特别是为移动设备节省流量。 防止视频格式不兼容的备择方案，使用source元素而非src属性。其中p元素是为旧浏览器配置的，当视频不能显示出来就会显示p中的文本，不过必须保证这些元素都被video标签包围。12345&lt;video width="369" height="208" controls&gt; &lt;source src="paddle-steamer.mp4" type="video/mp4"&gt; &lt;source src="paddle-steamer.webm" type="video/webm"&gt; &lt;p&gt;&lt;a href="paddle-steamer.mp4"&gt;Download the video&lt;/a&gt;&lt;/p&gt;&lt;/video&gt; 音频 html5音频支持的格式包括.ogg, .mp3, .wav, .aac, .mp4, .opus。其中mp4既可对视频编码也可对音频编码。 插入音频直接使用audio标签即可 其他属性autoplaymuted 默认静音loop 循环播放preload 参考前面视频 防止浏览器不兼容html5的备择方案，使用source。12345&lt;audio controls&gt; &lt;source src="piano.ogg" type="audio/ogg"&gt; &lt;source src="piano.mp3" type="audio/mp3"&gt; &lt;p&gt;Your browser doesn't support HTML5 audio, but you can &lt;a href= "piano.mp3"&gt;download the audio file&lt;/a&gt; (MP3, 1.3 MB).&lt;/p&gt;&lt;/audio&gt;. type属性对于音频文件来说，其值总是”audio/格式”。 使用flash作为备择方案使用MediaElement.js自动选择让浏览器使用HTML5原生播放系统还是Flash播放器。使用其中的build文件夹，拷贝到服务器中。在html的head标签里加入 123&lt;script src="build/jquery.js"&gt;&lt;/script&gt;&lt;script src="build/mediaelement-and-player.min.js"&gt;&lt;/script&gt;&lt;link rel="stylesheet" href="build/mediaelementplayer.min.css" /&gt; 在正文中可正常添加html5的video或audio标签。在最底下、body结束之前，加入 123&lt;script&gt; $('video').mediaelementplayer();/$('audio').mediaelementplayer();&lt;/script&gt; html5额外功能canvas: 使用 canvas 元素及相应的 JavaScript API可以在网页上描制并创建动画。SVG: Scalable Vector Graphic，使用XML定义图形和图像，浏览器则对其进行解释和使用，从而描绘出真正的图形。使用SVG创建的图像也是基于矢量而不是基于光栅的。这意味着它们可以很好地适应缩放，因为浏览器只是简单地依照绘制说明，根据所需的尺寸，将图形绘制出来。 表格 基本结构 1234567891011121314&lt;table&gt; &lt;caption&gt;表格标题&lt;/caption&gt; &lt;tr&gt; （每一行的开始标签）&lt;th scope=”col”&gt;列标题&lt;/th&gt;&lt;th scope=”col”&gt;列标题&lt;/th&gt;&lt;th scope=”col”&gt;列标题&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th scope=”row”&gt;行标题&lt;/th&gt; &lt;td&gt;单元格内容&lt;/td&gt; &lt;td&gt;单元格内容&lt;/td&gt; &lt;td&gt;单元格内容&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 结构化代码引入thead, tbody, tfoot来标记表格的第一行、主体、最后一行。这些只是显示地指出表格内容的布局，但不会真正影响样式。 合并单元格将th或td跨越一个以上的单元格。使用下列两个属性。colspan=”n”横向合并。rowspan=”n”纵向合并。如&lt;td colspan=&quot;2&quot;&gt;Celebrity Hoedown&lt;/td&gt; 加载javascript 加载脚本 类比外部CSS，直接src而不用rel, href等属性。但是注意不应该在head中使用script标签，而是尽量在最底下&lt;/body&gt;之前。 12&lt;link rel="stylesheet" href="css/global.css" /&gt;&lt;script src="behavior.js"&gt;&lt;/script&gt; 内部嵌入脚本则不能带有src属性： 1&lt;script&gt; ...Code... &lt;/script&gt; 性能最佳化通常浏览器按照html出现次序依次下载脚本文件，然后解析、执行。在处理脚本的过程中，浏览器相当于挂起，既不会下载当前script标签之后的内容，也不会呈现那些元素。除了html5剃刀，其余脚本加载都应该放到最下面，防止这样的阻塞行为blocking behavior.]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>frontend</tag>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linear Algebra]]></title>
    <url>%2F2016%2F07%2F15%2Flinear_algebra%2F</url>
    <content type="text"><![CDATA[In my first year of SYSU, I took this course about Linear Algebra introduced by Dr Wang CD. It’s the foundation for the study in computer science and I would use this post to summarize some basic concepts in it. Linear Equations Linear Systems Linear equation: For variables \(x_1, …, x_n\), linear equation can be written as $$a_1x_1 + a_2x_2 + … + a_nx_n = b$$ Linear System: A collection of one or more linear equations involving same group of variables. The set of all possible solutions for the system is called solution set. Two linear systems are equivalent if they have the same solution set. Consistency: A consistent linear system has one or infinitely many solutions. An inconsistent linear system has no solution. Matrix notation: Coefficient matrix only includes the coefficients of each variable. Augmented matrix also includes the right-side constants. Solving linear system: Use three elementary row operations – replacement(replace one row by the sum of itself and a multiple of another), interchange(switch two rows), scaling(multiply whole row with a nonzero constant). These row operations are reversible. Two matrices are row equivalent if one can be changed to the other by a sequence of elementary row operations. Echelon form Leading entry: the leftmost nonzero entry of a row. Echelon form: Nonzero rows are all above the all-zero rows; Each leading entry in a row is to the right of the leading entry in the row above; All entries beneath a leading entry in a column are zeros. Reduced echelon form: The leading entry is 1 for all nonzero rows; For each column containing a leading entry, the other entries are 0.Each matrix is row equivalent to exactly one reduced echelon form matrix. Pivot: The leading entry of the reduced echelon form matrix. Row reduction algorithm: Use row interchange to move the row with most nonzero entries to the top. Select the pivot row, use row replacement to make the entries below pivot become 0. (add each row below with some multiple of pivot row) Continue… Start with the right-most pivot and use row replacement to make the entries above it become 0. Scale each row to make the pivots become 1. Existence of solution: For augmented matrix, if the right-most column is not pivot column, the linear system is consistent. Vector equations A vector equation \(x_1{\bf{a_1}} + x_2{\bf{a_2}} + … + x_n{\bf{a_n}} = \bf{b}\) has the same solution set as the linear system \(\begin{bmatrix}\bf{a_1} &amp; \bf{a_2} &amp; … &amp; \bf{a_n} &amp; \bf{b}\end{bmatrix}\). SPAN {\({\bf{v_1}}, {\bf{v_2}}, …, {\bf{v_n}}\)}: All the possible linear combination of vectors \({\bf{v_1}}, {\bf{v_2}}, …, {\bf{v_n}}\), where these vectors are nonzero and noncolinear(unparallel). Matrix equations Existence of solution: For matrix equation \(A{\bf{x}} = {\bf{b}}\), its solution exists if and only if \({bf{b}}\) is a linear combination of matrix A’s column vectors, which means \({\bf{b}}\) is in SPAN {\({\bf{a_1}}, {\bf{a_2}}, …, {\bf{a_n}}\)}. Solution sets of linear systems Homogeneous linear systems: \(A{\bf{x}} = {\bf{0}}\). It always has a trivial solution \({\bf{x}} = {\bf{0}}\). It has a nontrivial solution if and only if it has at least one free variable(corresponding to the column without leading entry). Solution of Nonhomogeneous systems: \(A{\bf{x}} = {\bf{b}}\)’s solutions can be obtained by adding a vector \({\bf{p}}\) to the solutions of \(A{\bf{x}} = {\bf{0}}\), where \({\bf{p}}\) is one particular solution of \(A{\bf{x}} = {\bf{b}}\). If \(A{\bf{x}} = {\bf{0}}\) has no free variable: \({\bf{0}}\) -&gt; SPAN {\({\bf{0}}\)}; 1 free variable: A line through origin -&gt; SPAN {\({\bf{v}}\)}; 2 free variables: A plane through origin -&gt; SPAN {\({\bf{u}}, {\bf{v}}\)}. Linear Independence Linearly independent: For a set of vectors {\({\bf{v_1}}, {\bf{v_2}}, …, {\bf{v_n}}\)}, \({x_1\bf{v_1}}, {x_2\bf{v_2}}, …, {x_p\bf{v_p}} = {\bf{0}}\) has only trivial solution \({\bf{0}}\). If there is a set of c such that \({c_1\bf{v_1}}, {c_2\bf{v_2}}, …, {c_p\bf{v_p}} = {\bf{0}}\), these vectors are linearly dependent. In other words, if there is a least one free variable, there is nontrivial solution and thus the vectors are linearly dependent. Linear Transformation Linear transformation for vector x, T\(({\bf{x}})\): In \(A{\bf{x}} = {\bf{b}}\), \({\bf{R}}^n\) is the domain of T (columns of A and rows of \({\bf{x}}\)) and \({\bf{R}}^m\) is the codomain of T (rows of A and rows of \({\bf{b}}\)). Judgement of linear transformation: T\(({\bf{u}} + {\bf{v}})\) = T\(({\bf{u}})\) + T\(({\bf{v}})\); T\((c{\bf{u}})\) = cT\(({\bf{x}})\).Matrix transformations are all linear transformation but linear transformation is not constrained to matrix trans. Image: For the \({\bf{x}}\) in \({\bf{R}}^n\), T\(({\bf{x}})\) is the image of \({\bf{x}}\) in \({\bf{R}}^m\). Matrix in linear transformation: There is a unique matrix A such that T\(({\bf{x}}) = A{\bf{x}}\) for \({\bf{x}}\) in \({\bf{R}}^n\), where A = \(\begin{bmatrix}T(\bf{e_1}) &amp; T(\bf{e_2}) &amp; … &amp; T(\bf{e_n}) \end{bmatrix}\) and \({\bf{e}}_j\) is the jth column of indentity matrix in \({\bf{R}}^n\). Onto: A mapping T from \({\bf{R}}^n\) to \({\bf{R}}^m\) is said to be onto \({\bf{R}}^m\) if each \({\bf{b}}\) in \({\bf{R}}^m\) is the image of at least one \({\bf{x}}\) in \({\bf{R}}^n\). One-to-one: A mapping T from \({\bf{R}}^n\) to \({\bf{R}}^m\) is said to be one-to-one if each \({\bf{b}}\) in \({\bf{R}}^m\) is the image of at most one \({\bf{x}}\) in \({\bf{R}}^n\). Matrix Algebra Matrix operations Matrix multiplication: For \(m \times n\) matrix A and \(n \times p\) matrix B, A·B = A·\(\begin{bmatrix}\bf{b_1} &amp; \bf{b_2} &amp; … &amp; \bf{b_p}\end{bmatrix}\) = \(\begin{bmatrix}A·\bf{b_1} &amp; A·\bf{b_2} &amp; … &amp; A·\bf{b_p}\end{bmatrix}\). Row-Column rule: \(row_i(AB) = row_i(A)·B\); \(col_j(AB) = A·col_j(B)\); Transpose of matrix: The rows and columns in \(A\) are the columns and rows in \(A^T\) with \(A{ij} = {A^T}{ji}\). It follows a reverse order rule in \({(AB)}^T = A^T + B^T\). Inverse Inverse of matrix: Only the matrices with rows and columns equal have inverse, where \(A·A^{-1} = I\). It the inverse exists, it is called a nonsingular matrix. Existence of inverse of \(2 \times 2\) matrix: For matrix \(A = \begin{bmatrix}a &amp; b\\ c &amp; d\end{bmatrix}\), its determinant is \(det(A) = ad - bc\). If det(A) == 0, it is not invertible. Or its inverse is \(A^{-1} = \frac{1}{ad - bc}·\begin{bmatrix}d &amp; -b\\ -c &amp; a\end{bmatrix}\). Elementary matrix \(E\): Generated after one row transformation from identity matrix. If the same row transformation is conducted on matrix \(A\), \(A’ = E·A\). Note that E should be to the left of A. Computation of \(A^{-1}\): Do row transformation on augmented matrix \(\begin{bmatrix}A &amp; I\end{bmatrix}\). If A is invertible, the result is \(\begin{bmatrix}I &amp; A^{-1}\end{bmatrix}\). 高估了自己的耐性，原本打算把每门课都整理出来的，不过写博客真的是非常花时间，在JIE面试之前我还是尽量把所有课过一遍而不是花太多时间整理博客。之后有空再搞完这些基础课的笔记整理吧，至少有了博客就会逼着自己时不时放点干货上来[嘿嘿]。 好吧，我要弃坑了。目前得多体验一下业界，多面向应用去有针对性的学习。这种general的东西，不见得会对实操有多大帮助吧。]]></content>
      <categories>
        <category>Course</category>
      </categories>
      <tags>
        <tag>freshman</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Backend on Aliyun: Webpy + MySQL]]></title>
    <url>%2F2016%2F07%2F14%2Faliyun%2F</url>
    <content type="text"><![CDATA[这个后台主要是LKY大神的作品，当时我们一起做安卓课程淘宝宝(TBB)，一款名字山寨了淘宝、界面山寨了微信的app。现在昱神把他那的后台关了，所以我打算迁移到我的阿里云上，也许还能改动一波，总之先试试自己部署一个python(webpy + mysql)的后台。顺便提一句，标题里的冒号是通过引号的方式解决的1title: &quot;xx:x&quot; Aliyun Environment Setting mysql阿里云买了一年的学生优惠机，本身是CentOS-7，捣鼓了半天都没装上mysql，试了community的mysql也不行。后来一狠心就重装成Ubuntu-14.04-64bit了，一开始也是死活装不上mysql，识别不出mysql的package之类的。后来经历了换源和aptitude大法才强行装上了mysql。1$ sudo aptitude install mysql-server mysql-client libmysqlclient-dev 安装过程中会提示说有dependencies的问题，会提供几种解决方案，第一种安不上就点no跳过它往后试。我貌似是在第二种就安装上了的。 git 安装git 1$ apt-get install git 首先设置Git提交时显示的用户名和邮箱： 12$ git config --global user.name "AliyunUbuntu" $ git config --global user.email "xxx@gmail.com" 为阿里云Ubuntu创建SSH。生成的SSH密钥会存放在~/.ssh文件夹中，可用cd进入确认是否已经生成过SSH密钥。若有则需备份后（cp ）再继续生成： 1$ ssh-keygen -t rsa -C "xxx@gmail.com" 密钥生成后在主目录下的.ssh文件夹中就有私钥id_rsa和公钥id_rsa.pub两个文件。vi打开pub公钥中，把内容都复制粘贴到你的github账户SSHKey即可。在putty中用vim复制：直接按下ctrl+v后就进入”viewing block”模式，鼠标拖选后再按下y即可按照该格式复制出来。 从github仓库抓取TBB的代码到Aliyun。 1$ git clone git@github.com:bobbyliujb/TBB.git Python 安装webpy轻量级web框架，参考官方安装指南：1$ sudo apt-get install python-webpy 不过按官网的说法，这种方法不能获取最新版本的webpy。 接下来安装MySQLdb，用pip方式安装就再次碰到package损坏的问题了。但是直接用下面的就可以了：1$ apt-get install python-mysqldb Programming LKY大神的描述：后台搭建在阿里云上，采用Python语言进行开发，使用web.py服务器框架，云端部署Git环境，方便版本控制。后台的稳定运行使用nohup指令，Git版本更新需要忽略pyc文件和nohup.out文件。客户端请求方式统一为POST，可以通过在POST请求中加入键值对参数传参；服务器返回的信息格式为JSON，使用Python可以轻松将字典（键值对集）转换成JSON压入返回信息中。 webpy是一个轻量级Python web框架，它简单而且功能强大。具体使用参看web.py 0.3新手指南。目前我只是把代码迁移到云上，先建好tbb database，再用source tbb.sql语句执行建表。在vi中将dbop.py全文中LKY的数据库root密码换成我自己的:1:%s/oldword/newword/g 建立好一切所需文件夹（../head &amp; ../picture）后，即可运行。先把更新后的代码推送到远程仓库：12345$ git status$ git add dbop.py$ git commit -m "mysql password changed"$ git remote add origin git@github.com:bobbyliujb/TBB.git (若已存在则不会再次创立origin远程库)$ git push (-u) origin master (首次推送才需要参数-u将本地与远程的master分支关联起来) Run the Server nohup可以保持程序在后台执行，不会因为终端关闭就hang up:1$ nohup python server.py 6060 (myout.out 2&gt;&amp;1) 真正要关闭时需要得到进程的ID，强行kill掉：12$ ps -ef | grep server.py (ps命令可显示所有进程PID)$ kill -9 &lt;PID&gt;]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>aliyun</tag>
        <tag>cloud</tag>
        <tag>mysql</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Guidance to create Github blog]]></title>
    <url>%2F2016%2F07%2F12%2Fhello_world%2F</url>
    <content type="text"><![CDATA[这是啵啵的第一篇博客日志，就记录一下这个博客是怎么利用github和Hexo静态博客框架搭建起来的吧。 This is the first blog of Bobby. This guthub page is built under the perfect guidance from Sunwhut’s blog. Here I just mention some key steps to create this blog with Windows7 + Gitbub + Hexo. All the instructions and software have been tested on my Windows7. Software The official Node.js and Github desktop: https://nodejs.org/en/ https://desktop.github.com/ The offline installers are available on CSDN: http://download.csdn.net/download/shshwzs/8038675 http://download.csdn.net/download/lyg468088/8723039 Github Github SSH keyLaunch Git Shell on Windows. Type1$ ssh -T git@github.com When it’s done, this OS is authenticated to the github repository. Create blog repoEach Github account can set exactly one corresponding blog repo. For user tony, his github page repo should be named tony.github.io. Hexo Hexo InstallationLaunch Git Shell on Windows. Type in 1npm install hexo-cli -g to install the Hexo. The npm should work with Node.js. Hexo DeploymentNow we are going to create a workspace for our blog. Firstly we can shift from disk C to D with1$ d: Now create the workspace named Hexo with1$ hexo hash Hexo Enter the workspace and install the blog content with12$ cd Hexo$ npm install Hexo Theme NexT.MistThe default theme of Hexo is landscape, which looks umm… There are a lot of themes provided in Hexo Themes. Take NexT.Mist for example. In the workspace Hexo, download the NexT theme with1git clone https://github.com/iissnan/hexo-theme-next themes/next In the workspace Hexo, edit file _config.yml and search for keyword theme:1theme: next To apply the Mist style of NexT, enter the NexT folder at D:\Hexo\themes\next, edit file _config.yml and search for keyword scheme: 1234# Schemes#scheme: Musescheme: Mist#scheme: Pisces Don’t forget the space after the colon. With this _config.yml, we can also modify the menu with1234567menu: home: / #categories: /categories #about: /about archives: /archives tags: /tags #commonweal: /404.html Note that corresponding page is required. For more information about the settings of NexT theme, please visit iissnan’s official guide. Blog post Create a new postLaunch Git Shell and enter the workspace.1$ hexo new "My New Post" More info: Writing It’s OK to simply create a new .md file at D:\Hexo\source_posts. The markdown file will be transformed into html. The grammar of MD can refer to Introduction to Markdown and note for markdown. We can use Online markdown tool to preview .md file. Note that if you do not want an .md file to be transformed into html, like README.md on github, you can simply rename it as README.MDOWN. Preview the postTo preview the post, firstly generate all the related static files with1$ hexo generate More info: Generating Then run the local server at localhost on port 4000:1$ hexo server More info: Server Now we can preview the static post by visiting http://localhost:4000/ If you want to regenerate the files, use1$ hexo clean to clear all the deprecated files. Deploy to remote sitesWhen everything is done and generated, we need to deploy it to the remote github.io. Edit the _config.yml at workspace Hexo and search for keyword deploy: 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/yourname/yourname.github.io.git branch: master Deploy to the github page with 1$ hexo deploy If ERROR occurs try to install the deploy-git with 1$ npm install hexo-deployer-git --save Then clean - generate - deploy. Comment Service This part is deprecated. See update below. Comment added following the official guide this guidance. Since the Hexo is a static blog based on Node.js, the comment function has to be introduced from third-party comment service such as Duoshuo and Disqus. ~~~~* Create a new account at Duoshuo. Edit the _config.yml at workspace *Hexo12# Commentduoshuo_shortname: tonyShortName Edit the _config.yml* at theme NexT12345duoshuo_info: ua_enable: true admin_enable: true user_id: yourDuoshuoUserID admin_nickname: (Author) The Duoshuo userID can get in this way: Visit http://dev.duoshuo.com/. Then click your account at the top right and select “My home page” in the slide bar. The string of numbers at the end of the link is your userID in Duoshuo. Duoshuo also provides a share system, which can simply activated by set the value of keyword duoshuo_share to true in the _config.yml in the folder of theme NexT. The blog url should also be set correctly in the _config.yml of the workspace Hexo(search for keyword url). 12# Shareduoshuo_share: true 123456# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://bobbyliujb.github.ioroot: /permalink: :year/:month/:day/:title/permalink_defaults: Picture Service I am using sina weibo picture service on chrome extension, but I don’t think sina will keep this service available for free.1![tuchuang](http://ww1.sinaimg.cn/mw690/006nWDLfgw1f5s1ijhh7pj30m80femyk.jpg) Pictures can also be added by path. Put the pictures into folder workspaceOfHexo\themes\next\source\images or workspaceOfHexo\themes\next\source\uploads. The settings for example can be set with 12avatar: /uploads/avatar.png avatar: /images/avatar.png in the Hexo’s _config.yml file. Page View Count Credit to Doublemine’s blog Create an account at LeanCloud. Create a new application and name it as you like. Create a new class whose name must be Counter. Get the App ID and App Key and add them into the configuration file _config.yml of the NexT theme folder (search for keyword leancloud). ========2016.12.01========= Show the update of each post Credit to this deleted but cached page Edit ...\Hexo\themes\next\layout\_macro\post.swig, search for tag &lt;div class=&quot;post-meta&quot;&gt; and add the following tags next to &lt;span class=&quot;post-time&quot;&gt;: 12345678&#123;%if post.updated and post.updated &gt; post.date%&#125; &lt;span class=&quot;post-updated&quot;&gt; &amp;nbsp; | &amp;nbsp; &#123;&#123; __(&apos;post.updated&apos;) &#125;&#125; &lt;time itemprop=&quot;dateUpdated&quot; datetime=&quot;&#123;&#123; moment(post.updated).format() &#125;&#125;&quot; content=&quot;&#123;&#123; date(post.updated, config.date_format) &#125;&#125;&quot;&gt; &#123;&#123; date(post.updated, config.date_format) &#125;&#125; &lt;/time&gt; &lt;/span&gt;&#123;% endif %&#125; The class post-updated is used to retreive the corresponding value in the language configuration. Edit ...\Hexo\themes\next\languages\xx.yml. For the en.yml, search for keyword “post”: 1234post: ... updated: Updated on ... Edit workspaceOfHexo\Hexo\themes\next\_config.yml and add a line at the bottom: 1display_updated: true Now each time you update your existing post, add “updated xxxx-xx-xx xx:xx:xx” below the “date xxxx-xx-xx xx:xx:xx” to manually set the updated date. Actually, once you modify the post, it would be displayed on the post. ========2017.04.13=========The DuoShuo Comment Service is going to be closed in June, 2017. An alternative system named JiaThis/YouYan seems to be a good choice, though Hexo does not initially add support for it. Reference to this guidance. Register at YouYan and remember you uid. Create youyan.swig at workspaceOfHexo\themes\next\layout\_scripts\third-party\comments: 123456789101112131415&#123;% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname and not theme.disqus_shortname %&#125; &#123;% if theme.youyan_uid %&#125; &#123;% set uid = theme.youyan_uid %&#125; &#123;% endif %&#125; &#123;% if page.comments %&#125; &lt;!-- UY BEGIN --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;//v2.uyan.cc/code/uyan.js?uid=&#123;&#123;uid&#125;&#125;&quot;&gt;&lt;/script&gt; &lt;!-- UY END --&gt; &#123;% endif %&#125;&#123;% endif %&#125; Edit workspaceOfHexo\themes\next\layout\_scripts\third-party\comments.swig and add include for youyan.swig: 123&#123;% include &apos;./comments/duoshuo.swig&apos; %&#125;&#123;% include &apos;./comments/disqus.swig&apos; %&#125;&#123;% include &apos;./comments/youyan.swig&apos; %&#125; Edit workspaceOfHexo\themes\next\layout\_partials\comments.swig and add element for YouYan comment: 123&#123;% elseif theme.youyan_uid %&#125; &lt;div id=&quot;uyan_frame&quot;&gt; &lt;/div&gt; Add your uid at theme config file workspaceOfHexo\themes\next\_config.yml: 12# youyanyouyan_uid: UID_numbers... Unfortunately, the YouYan comment count is still unable to show the statistics in the row right below the Topic. The Duoshuo Share is also replaced by JiaThis share. Enable it at theme config file workspaceOfHexo\themes\next\_config.yml: 1234# Sharejiathis: enable: true id: UID_numbers... Modify the JiaThis Share style by editing jiathis.swig at workspaceOfHexo\themes\next\layout\_partials\share: 1234567891011121314151617181920212223242526&lt;!-- JiaThis Button BEGIN --&gt;&lt;div&gt; &lt;a class=&quot;jiathis_like_tsina&quot; data=&quot;width=120&quot;&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;jiathis_style&quot;&gt; &lt;span class=&quot;jiathis_txt&quot;&gt;ShareTo: &lt;/span&gt; &lt;a class=&quot;jiathis_button_tsina&quot;&gt;Weibo&lt;/a&gt; &lt;a class=&quot;jiathis_button_weixin&quot;&gt;Wechat&lt;/a&gt; &lt;a class=&quot;jiathis_button_douban&quot;&gt;Douban&lt;/a&gt; &lt;a class=&quot;jiathis_button_fb&quot;&gt;Facebook&lt;/a&gt; &lt;a class=&quot;jiathis_button_twitter&quot;&gt;Twitter&lt;/a&gt; &lt;a class=&quot;jiathis_button_googleplus&quot;&gt;Google+&lt;/a&gt; &lt;a class=&quot;jiathis_button_tumblr&quot;&gt;Tumblr&lt;/a&gt; &lt;a href=&quot;//www.jiathis.com/share?uid=xxx&quot; class=&quot;jiathis jiathis_txt jtico jtico_jiathis&quot; target=&quot;_blank&quot;&gt;&lt;/a&gt; &lt;a class=&quot;jiathis_counter_style&quot;&gt;&lt;/a&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;var jiathis_config = &#123; data_track_clickback: true, hideMore: false&#125;;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;//v3.jiathis.com/code/jia.js?uid=xxx&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;&lt;!-- JiaThis Button END --&gt; Unfortunately again, YouYan does not support HTTPS. Since github page uses https, request for http resources is blocked, which means YouYan is not able to show off on blog, even though this method is locally feasible. So let turn to another system Disqus, which is blocked in mainland. Firstly, recover Duoshuo share by modifying workspaceOfHexo\themes\next\_config.yml: 1234# Shareduoshuo_share: trueduoshuo_shortname: xxx Since we don’t want to use Duoshuo comment, we need to put config of disqus in front of duoshuo in workspaceOfHexo\themes\next\layout\_partials\comments.swig Add disqus shortname in workspaceOfHexo\themes\next\_config.yml. Theoratically done, but seem to be blocked in mainland… ========2016.12.01========= Sort the posts by last update Referred to this guide. Modify node_modules/hexo-generator-index/lib/generator.js like the following: 123456789101112131415161718192021//var posts = locals.posts.sort(config.index_generator.order_by);var posts = locals.posts; posts.data = posts.data.sort(function(a,b)&#123; if (a.updated) &#123; if (b.updated) &#123; if (a.updated == b.updated) &#123; return b.date - a.date; &#125; else &#123; return b.updated - a.updated; &#125; &#125; else &#123; return -1; &#125; &#125; else &#123; if (b.updated) &#123; return 1; &#125; else &#123; return b.date - a.date; &#125; &#125; &#125;); AddThis Share Referred to this post. Go to AddThis to register and customize your own sharing buttons. Get AddThis ID in Profile Options - General and paste it into workspaceOfHexo\Hexo\themes\next\_config.yml. Supports HTTPS, though not stable.]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
