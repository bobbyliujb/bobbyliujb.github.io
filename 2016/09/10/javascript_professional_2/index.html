<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"bobbyliujb.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"hide","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="JavaScript高级程序设计（第3版）这本书的内容真的有点多，笔记得分成几个部分，不然挤在一篇里面就太长了不方便看。这是第二篇笔记，得加快点进度了。本篇对应6~8章。">
<meta property="og:type" content="article">
<meta property="og:title" content="Note for Professional JavaScript for Web Developers (2&#x2F;4)">
<meta property="og:url" content="https://bobbyliujb.github.io/2016/09/10/javascript_professional_2/index.html">
<meta property="og:site_name" content="Bob&#39;s Blog">
<meta property="og:description" content="JavaScript高级程序设计（第3版）这本书的内容真的有点多，笔记得分成几个部分，不然挤在一篇里面就太长了不方便看。这是第二篇笔记，得加快点进度了。本篇对应6~8章。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2016-09-10T19:43:55.000Z">
<meta property="article:modified_time" content="2016-09-11T00:41:20.000Z">
<meta property="article:author" content="Bob">
<meta property="article:tag" content="frontend">
<meta property="article:tag" content="js">
<meta property="article:tag" content="DOM">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://bobbyliujb.github.io/2016/09/10/javascript_professional_2/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://bobbyliujb.github.io/2016/09/10/javascript_professional_2/","path":"2016/09/10/javascript_professional_2/","title":"Note for Professional JavaScript for Web Developers (2/4)"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Note for Professional JavaScript for Web Developers (2/4) | Bob's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-118868735-1"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-118868735-1","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js" defer></script>








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Bob's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.</span> <span class="nav-text">面向对象的程序设计</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">2.</span> <span class="nav-text">函数表达式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#BOM"><span class="nav-number">3.</span> <span class="nav-text">BOM</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Bob"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Bob</p>
  <div class="site-description" itemprop="description">I'm a Software Engineer!</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">50</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://bobbyliujb.github.io/2016/09/10/javascript_professional_2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bob">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bob's Blog">
      <meta itemprop="description" content="I'm a Software Engineer!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Note for Professional JavaScript for Web Developers (2/4) | Bob's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Note for Professional JavaScript for Web Developers (2/4)
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2016-09-10 12:43:55 / Modified: 17:41:20" itemprop="dateCreated datePublished" datetime="2016-09-10T12:43:55-07:00">2016-09-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Tech/" itemprop="url" rel="index"><span itemprop="name">Tech</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2016/09/10/javascript_professional_2/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/09/10/javascript_professional_2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p><a target="_blank" rel="noopener" href="http://book.douban.com/subject/10546125/">JavaScript高级程序设计（第3版）</a>这本书的内容真的有点多，笔记得分成几个部分，不然挤在一篇里面就太长了不方便看。这是第二篇笔记，得加快点进度了。本篇对应6~8章。</p>
<span id="more"></span>

<h1 id="面向对象的程序设计"><a href="#面向对象的程序设计" class="headerlink" title="面向对象的程序设计"></a>面向对象的程序设计</h1><hr>
<ol>
<li>JavaScript中的对象</li>
</ol>
<ul>
<li>ECMA定义: 对象是无序属性的集合，其中属性可以包含基本值、对象或者函数。每个对象都基于一个引用类型值创建。由于ECMAScript中没有类的概念，这里说的对象也就和那些基于类的语言不太一样了。</li>
<li>创建对象: 可以采用<code>new Object()</code>的形式；但更常用的是对象字面量的形式。</li>
<li>数据属性: 每个property都有各自的attribute，描述了property的配置信息。<br>  -&gt; configurable: 能否通过delete来重新定义属性、修改属性的特性等。默认为true.<br>  -&gt; enumerable: 能否通过for-in循环返回属性。默认为true.<br>  -&gt; writable: 能否修改属性的值。默认为true.<br>  -&gt; value: 存储这个属性的数据值。默认为undefined.<br>  要想修改property的attribute，必须使用Object.defineProperty()静态方法。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">	<span class="attr">writable</span>: <span class="literal">false</span>,	</span><br><span class="line">	<span class="attr">value</span>: <span class="string">&quot;Bobby&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 此时name属性是只读的。</span></span><br><span class="line"></span><br><span class="line">person.<span class="property">name</span> = <span class="string">&quot;JB&quot;</span>;   <span class="comment">// 在strict模式下修改只读属性会报错，正常模式则直接忽略此句</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">	<span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 此时name不可配置。无法修改除了writable的其他attribute。所以无法再把config改回true了。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person.<span class="property">name</span>;   <span class="comment">// 无法删除name属性</span></span><br></pre></td></tr></table></figure>
<ul>
<li>访问器属性: 不包含数据值属性。含有一对getter和setter函数，不过倒也不是必须含有的。除了configurable和enumerable，访问器属性还有get和set两个属性。只能使用Object.defineProperty()静态方法来定义和修改访问器属性。<br>  -&gt; get: 读取属性时调用的函数。默认为undefined.<br>  -&gt; set: 写入属性时调用的函数。默认为undefined.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">	<span class="attr">_year</span>: <span class="number">2014</span>,	<span class="comment">// 以下划线开头就表示这个变量必须通过对象方法来访问和修改</span></span><br><span class="line">	<span class="attr">edition</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(book, <span class="string">&quot;year&quot;</span>, &#123;</span><br><span class="line">	<span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_year</span>;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">newYear</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (newYear &gt;= <span class="number">2014</span>) &#123;</span><br><span class="line">			<span class="variable language_">this</span>.<span class="property">_year</span> = newYear;</span><br><span class="line">			<span class="variable language_">this</span>.<span class="property">edition</span> = (newYear - <span class="number">2014</span>);	<span class="comment">// 这不是书上的源码，我感觉中文版有错，不知原书如何。</span></span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>修改多个属性的特性: 为了方便同时修改多个properties的attributes，ECMAScript 5引入了Object.defineProperties()方法，用法与Object.defineProperty类似。</li>
<li>读取属性的特性: ECMAScript 5提供了Object.getOwnPropertyDescriptor()来取得给定属性的描述符，接受两个参数:对象名+属性名。</li>
</ul>
<ol start="2">
<li>创建对象</li>
</ol>
<ul>
<li>前面提到了Object构造函数和对象字面量两种方式来创建单个对象，但是使用同一个接口会创建出很多对象，产生大量重复代码。</li>
<li>工厂模式: 抽象出了创建具体对象的过程，用函数封装以特定接口创建对象的细节。这个方法解决了多个相似对象代码重复的问题，但是无法解决对象类型识别问题。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name, age, job</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">	o.<span class="property">name</span> = name;</span><br><span class="line">	o.<span class="property">age</span> = age;</span><br><span class="line">	o.<span class="property">job</span> = job;</span><br><span class="line">	o.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="title function_">createPerson</span>(<span class="string">&quot;A&quot;</span>, <span class="number">18</span>, <span class="string">&quot;driver&quot;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>构造函数模式: 利用ECMAScript的函数声明提升特性，创建自定义的构造函数，在代码运行之前就存在于环境中。注意在构造函数中没有显示地创建对象，自然也就不需要return具体对象了。创建对象会经历一下四个阶段:(1)new出一个新对象；(2)将构造函数的作用域赋给新对象（this也会指向它）；(3)执行构造函数代码；(4)返回新对象。事实上任何函数在前面加个new操作符，都可看作构造函数。构造函数的不足就在于每个方法都会在每个对象实例中重新创建一遍，每个对象的函数都是不同的函数对象（即便代码一模一样）。解决的办法是把函数代码放到构造函数外，相当于全局函数，而在对象内部只是赋予一个引用。这样暂时解决了重复函数对象的问题，但又导致封装型被破坏。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>) &#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line">	o.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当构造函数使用</span></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;A&quot;</span>, <span class="number">18</span>, <span class="string">&quot;driver&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当普通函数使用，此时只是将其中的属性和方法添加到全局环境，即window中</span></span><br><span class="line"><span class="title class_">Person</span>(<span class="string">&quot;A&quot;</span>, <span class="number">18</span>, <span class="string">&quot;driver&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在另一个对象的作用域中调用</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="title class_">Person</span>.<span class="title function_">call</span>(o, <span class="string">&quot;A&quot;</span>, <span class="number">18</span>, <span class="string">&quot;driver&quot;</span>); </span><br></pre></td></tr></table></figure>
<ul>
<li>原型模式: 每个函数都有prototype属性，指向一个原型对象。使用原型对象让所有对象实例共享它包含的属性和方法。原型对象会自动获得一个constructor属性，指向的就是”指向这个原型对象”的函数。可使用obj.isPrototypeOf(obj)来判断前者是否是后者的原型对象。<br>  对于每一个对象实例来说，都是可以访问到原型对象的属性的，但是不能通过实例去修改对应的原型对象中的属性。对实例添加同名的属性和方法时，对于这个实例会暂时将原型对象的同名属性和方法屏蔽掉，直到使用delete。可使用obj.hasOwnProperty()来判断属性来自实例本身还是它的原型。in操作符则是只要属性能访问到，无论是本身还是原型，都返回true。<br>  原型对象有动态性，我们对原型对象做的任何修改都会立刻从各个实例上体现出来。但是需要指出，如果是直接对prototype整个进行重新赋值，那就相当于<strong>切断了构造函数与最初原型之间的联系</strong>。在这种情况下，更新的原型就不会体现在原有的实例上了，它们指向的还是原来的原型对象。<strong>实例中的指针仅指向原型，而不指向构造函数</strong>。<br>  原型模式存在的问题也就在于它共享的本性，尤其是对于引用类型的属性，例如Array数组在某一实例中的修改会体现在另外的实例中，这显然是不可接受的。</li>
</ul>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;  <span class="comment">// 即便构造函数是空的也能正常工作，因为实例访问属性和方法时会不断向上搜索直到原型对象。</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;Bobby&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">21</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">job</span> = <span class="string">&quot;???&quot;</span>;	<span class="comment">// 只是为了演示才把属性也放到原型中。讲道理，这么写不合常理。</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更简洁的写法看这里，但是这相当于重建了Person的原型，这会导致constructor不再指向Person。</span></span><br><span class="line"><span class="comment">// 不过你也可以手动添加constructor: Person, 只不过会把enumerable改成true。而默认是不可遍历的。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Person.prototype = &#123;</span></span><br><span class="line"><span class="comment">	name: &quot;Bobby&quot;;</span></span><br><span class="line"><span class="comment">	age: 18;</span></span><br><span class="line"><span class="comment">	job: &quot;???&quot;;</span></span><br><span class="line"><span class="comment">	sayName = function() &#123;</span></span><br><span class="line"><span class="comment">		alert(this.name);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可结合hasOwnProperty和in操作符判断属性是否在原型对象中</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hasPrototypeProperty</span>(<span class="params">object, propertyName</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> !object.<span class="title function_">hasOwnProperty</span>(propertyName) &amp;&amp; (propertyName <span class="keyword">in</span> object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>组合使用构造函数模式和原型模式: 这是目前<strong>使用最广泛、认同度最高</strong>的用法。构造函数模式用于定义实例属性，原型模式用于定义方法和少量共享的属性。这样可以保证每个实例都拥有自己独立的实例属性（包括引用类型），同时又共享了对方法的引用，节省了内存。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>) &#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">friends</span> = [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">	<span class="attr">constructor</span>: <span class="title class_">Person</span>,</span><br><span class="line">	<span class="attr">sayName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>动态原型模式: 由于上面的组合模式将构造函数和原型独立开来，可能会造成困扰。而动态原型模式就把这两个都<strong>封装到了构造函数</strong>中，也保持了混合模式的优点。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>) &#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">friend</span> = [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 共享方法放到条件语句中。注意不能用对象字面量来重写原型了。</span></span><br><span class="line">	<span class="comment">// 在已经创建实例的情况下直接重写会完全斩断已有实例和新原型的联系，无法保证改动即时反映到所有实例中。</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span>.<span class="property">sayName</span> != <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">		<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">			<span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>寄生构造函数模式: 可用于在特殊情况下为对象创建构造函数，例如创建一个具有特殊方法的数组。其实和工厂模式没什么区别。所以无法用instanceof操作符确定对象的类型。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SpecialArray</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> values = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">	values.<span class="property">push</span>.<span class="title function_">apply</span>(values, <span class="variable language_">arguments</span>);  <span class="comment">// 将传入的值添加进去</span></span><br><span class="line">	values.<span class="property">toPipedString</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">join</span>(<span class="string">&quot;|&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> values;	<span class="comment">// 和工厂模式一样有返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和工厂模式不同的是要用new操作符</span></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="title class_">SpecialArray</span>(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>稳妥构造函数模式: 稳妥durable指的是没有公共属性、且其方法也不引用this、不使用new操作符调用构造函数。</li>
</ul>
<ol start="3">
<li>继承</li>
</ol>
<ul>
<li>传统的继承: 通常OO语言支持两种继承方式，即<strong>接口继承</strong>和<strong>实现继承</strong>。接口继承只继承方法签名，而实现继承则继承实际的方法。</li>
<li>ECMAScript中的继承: 由于函数没有签名，故JavaScript中没有接口继承，只有实现继承。实现方式主要是通过原型链。</li>
<li>原型链: 利用原型让一个引用类型继承另一个引用类型的属性和方法。不妨回忆一下构造函数、原型与实例之间的关系。每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例则包含一个指向原型对象的内部指针。实现的本质是<strong>重写原型对象，代之以一个新类型的实例</strong>。</li>
<li>确定原型和实例之间的关系: <code>ins instanceof Object</code>使用instance操作符测试实例与构造函数，只要构造函数在它的原型链中出现过就为true.还可以使用<code>Object.prototype.isPrototypeOf(ins)</code>判断该实例是否是该原型链派生。</li>
<li>子类重写超类型中的方法: 必须在用父类new出来的实例替换掉子类的prototype后再重新定义方法。而且只能通过<code>name.prototype.methodName = function()&#123;&#125;</code>的形式来重写，不能用对象字面量的方式。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">property</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getSuperValue</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">property</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">subproperty</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>();</span><br><span class="line"></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getSubValue</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">subproperty</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getSuperValue</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> <span class="title class_">SubType</span>();</span><br><span class="line"><span class="title function_">alert</span>(instance.<span class="title function_">getSuperValue</span>());	<span class="comment">// 弹出false;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>原型链的问题:<br>  (1) 超类型实例中的引用类型会为所有子类共享，子类实例对其修改是全局可见的；<br>  (2) 在创建子类型的实例时，不能向超类型的构造函数中传递参数。</li>
<li>借用构造函数constructor stealing: 在子类型构造函数的内部调用超类型的构造函数。毕竟函数只不过是在特定环境中执行代码的对象，因此通过apply或call也可以在新创建对象上执行构造函数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">countryName</span>) &#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">flagColors</span> = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;yellow&quot;</span>];</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">countryName</span> = countryName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, <span class="string">&quot;China&quot;</span>);</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">67</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> <span class="title class_">SubType</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li>借用构造函数的问题: 无法避免构造函数本身的问题，即每个实例都会创建一个方法副本，函数复用根本无从谈起。</li>
<li>组合继承: 将原型链和借用构造函数组合起来，使用原型链实现对<strong>原型属性</strong>和<strong>方法</strong>的继承，使用借用构造函数实现对<strong>实例属性</strong>的继承。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">countryName</span>) &#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">flagColors</span> = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;yellow&quot;</span>];</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">countryName</span> = countryName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params">countryName, age</span>) &#123;</span><br><span class="line">	<span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, countryName);	<span class="comment">// 借用构造函数。第二次调用超类型构造函数。</span></span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">67</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>();	<span class="comment">// 第一次调用超类型构造函数。</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;	<span class="comment">// 原型链</span></span><br><span class="line">	<span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> <span class="title class_">SubType</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li>组合继承的问题: 无论什么情况下，都会调用两次超类型构造函数: 一次在创建子类型原型的时候，另一次是在子类型构造函数内部。</li>
<li>原型式继承prototypal inheritance: 可手写一个object函数或使用ECMAScript 5定义的Object.create函数实现继承，其中Object.create()除了接受原型对象实例，还可以传入额外的属性对象。但用原型式继承的方式，超类型实例中的引用类型属性又是共享的了。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">o</span>) &#123;</span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">	F.<span class="property"><span class="keyword">prototype</span></span> = o;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&quot;Bobby&quot;</span>,</span><br><span class="line">	<span class="attr">friends</span>: [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>] 	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="title function_">object</span>(person);</span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = <span class="title class_">Object</span>.<span class="title function_">create</span>(person, &#123;</span><br><span class="line">	<span class="attr">name</span>: &#123;</span><br><span class="line">		<span class="attr">value</span>: <span class="string">&quot;C&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>寄生式继承: 创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后返回这个对象。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createAnother</span>(<span class="params">original</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> clone = <span class="title function_">object</span>(original);</span><br><span class="line">	clone.<span class="property">sayHi</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;		<span class="comment">// 增强对象，也就是加点料</span></span><br><span class="line">		<span class="title function_">alert</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="title function_">createAnother</span>(person);</span><br></pre></td></tr></table></figure>
<ul>
<li>寄生组合式继承: 首先要指出，这是引用类型最理想的继承范式。前面提到组合继承需要调用两次超类型的构造函数，所以这里的思路是不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。我们可以使用寄生式继承来继承超类型的原型，然后将结果指定给子类型的原型。它的高效性体现在只调用一次超类型的构造函数、避免了创建不必要的冗余属性。它仍保持了原型链，故instanceof和isPrototypeOf都能正常使用。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">o</span>) &#123;</span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">	F.<span class="property"><span class="keyword">prototype</span></span> = o;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span>(<span class="params">subType, superType</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> prototype = <span class="title function_">object</span>(superType.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">// 创建超类型原型的一个副本</span></span><br><span class="line">	prototype.<span class="property">constructor</span> = subType;   <span class="comment">// 弥补因重写原型而失去的默认的constructor属性</span></span><br><span class="line">	subType.<span class="property"><span class="keyword">prototype</span></span> = prototype;     <span class="comment">// 将副本赋值作为子类型的原型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">name</span>) &#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;yellow&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">	<span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">inheritPrototype</span>(<span class="title class_">SubType</span>, <span class="title class_">SuperType</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h1><hr>
<ol>
<li>ECMAScript中的函数<br> 如前面所提，函数声明有两种方式。一是正常的函数声明，二是函数表达式（赋值）。前者具有函数提升的特性，保证在执行代码之前，所声明的函数都是可用的。</li>
<li>递归<br> 如前面所提，函数声明的形式实现递归，可能导致无法正确引用原函数的问题。一个解决方法是使用arguments.callee，但在strict模式下不能用。所以最好用函数表达式+重命名内部函数来实现。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> factorial = (<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">n</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n * <span class="title function_">f</span>(n - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherFac = factorial;</span><br><span class="line">factorial = <span class="literal">null</span>;</span><br><span class="line"><span class="title function_">alert</span>(<span class="title function_">anotherFac</span>(<span class="number">4</span>));</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>闭包</li>
</ol>
<ul>
<li>闭包的概念: 指有权访问另一个函数作用域中变量的函数。创建闭包的常见形式，就是在一个函数内部创建另一个函数。当函数返回了一个闭包时，这个函数的作用域将会一直存在于内存直到闭包不存在为止。</li>
<li>以下面这个“创建比较函数”的代码为例。在createCmp内部创建的匿名函数中访问了外部的变量propertyName，即使内部函数已经被返回、离开了createCmp的执行环境、且创建的内部函数是在其他地方被调用，也仍然可以访问到createCmp的变量。这是因为<strong>在函数内部定义的函数会将包含它的函数（即外部函数）的活动对象添加到它的作用域链中</strong>，当createCmp函数返回后，它的活动对象不会被销毁，因为它包含的匿名函数的作用域链仍在引用它的活动对象。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createCmp</span>(<span class="params">propertyName</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">object1, object2</span>) &#123;</span><br><span class="line">		<span class="keyword">var</span> value1 = object1[propertyName];</span><br><span class="line">		<span class="keyword">var</span> value2 = object2[propertyName];	<span class="comment">// 访问外部函数的变量</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cmpNames = <span class="title function_">createCmp</span>(<span class="string">&quot;names&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> result = <span class="title function_">cmpNames</span>(&#123;<span class="attr">name</span>: <span class="string">&quot;A&quot;</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">&quot;B&quot;</span>&#125;);</span><br><span class="line">cmpNames = <span class="literal">null</span>;	<span class="comment">// 匿名函数在此时才销毁，手动通知释放内存</span></span><br></pre></td></tr></table></figure>
<ul>
<li>谨慎使用闭包: 由于闭包会携带包含它的函数的作用域，所以会比正常的函数占用更多内存。</li>
<li>闭包与变量: 闭包只能取得外部包含它的函数的任何变量的最终值。这是由于闭包保存的是外部活动对象这个整体，而不是具体的某个变量。在下面的例1中，每个匿名函数都保存着同一个createFunctions函数的活动对象，它们引用的是同一个i，也是最终状态的i。而例2则创建多了一个匿名函数并立即执行，将结果返回给数组</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例1</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createFunctions</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> result = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		result[i] = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;	<span class="comment">// 全都是10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例2</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createFunctions</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> result = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		result[i] = <span class="keyword">function</span>(<span class="params">num</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> num;		<span class="comment">// 访问num的闭包</span></span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;(i);	<span class="comment">// 立即执行匿名函数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;	<span class="comment">// 1, 2, 3, ..., 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>闭包中的this: this对象是在运行时基于函数的执行环境而定的。由于匿名函数的执行环境具有全局性，其中的this对象通常指向window.每个函数在调用时，其活动对象都会自动取得this和arguments两个特殊变量，内部函数在搜索这两个变量时，只会搜索到它自己的活动变量为止，不可能直接访问外部函数的这两个变量。如下面的例子所示，调用可写作<code>(object.(sayName())())</code>，先执行里面一层，再执行后面一层的匿名函数。既然闭包能够访问的是在包含函数中特意用var声明的变量，那我们就可以先用一个that变量将包含函数的this保存起来，这样即使调用时第一层的函数返回了，that也保持着对object的引用，这样匿名函数就能正常访问到object内定义的name了。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;The Window&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&quot;The Object&quot;</span>,</span><br><span class="line">	<span class="attr">sayName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">alert</span>(object.<span class="title function_">sayName</span>()());	<span class="comment">// 在非strict模式下弹出The Window</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用闭包让匿名函数能访问到外部函数的this</span></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&quot;The Object&quot;</span>,</span><br><span class="line">	<span class="attr">sayName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">var</span> that = <span class="variable language_">this</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> that.<span class="property">name</span>;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">alert</span>(object.<span class="title function_">sayName</span>()());	<span class="comment">// 弹出The Object</span></span><br></pre></td></tr></table></figure>
<ul>
<li>防止内存泄漏: 如果闭包的作用域链中保存着一个HTML元素，该元素无法正常销毁。如例1中为element的onclick事件创建了处理程序的闭包，而匿名函数又保持了对assignHandler函数中活动对象的引用，这导致无法减少element的引用数而无法被回收。所以我们需要养成好习惯，将DOM元素的某些属性单独拎出来存入单独的变量，然后在匿名函数后面手动将DOM操作的元素变量赋值为null解除对DOM元素的引用。如果没有这一步，即使闭包不直接引用element，闭包引用的包含函数的整个活动对象仍会保存着element的引用。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">assignHandler</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;someElement&quot;</span>);</span><br><span class="line">	element.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="title function_">alert</span>(element.<span class="property">id</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>用匿名函数模仿块级作用域</li>
</ol>
<ul>
<li>块级作用域: 在JavaScript中是没有块级作用域的，在块语句中定义的变量，实际上在外部依然可以访问，只要作用域没有销毁。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outputN</span>(<span class="params">n</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">		<span class="title function_">alert</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="title function_">alert</span>(i);	<span class="comment">// 仍然可以访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>匿名函数cosplay块级作用域: 在匿名函数内定义的任何变量，都会在执行结束时销毁。那么我们可以在声明一个匿名函数后立即执行，则其中的变量就会自然而然地销毁了。这个特性可以在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">	<span class="keyword">if</span> (now.<span class="title function_">getMonth</span>() == <span class="number">0</span> &amp;&amp; now.<span class="title function_">getDate</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="title function_">alert</span>(<span class="string">&quot;Happy new year!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)();	<span class="comment">// 对应传入参数，立即执行</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>私有变量</li>
</ol>
<ul>
<li>私有变量的概念: 任何在函数中定义的变量都是私有变量，因为不能在函数的外部访问到这些变量。私有变量包括函数的参数、局部变量和函数内部定义的其他函数。（注意说的不是私有属性！JavaScript的所有属性都是公有的！）</li>
<li>特权方法privileged method: 有权访问私有变量和函数的公有方法。利用私有和特权成员，可以隐藏那些不应该被直接修改的数据。在构造函数中，在定义方法前加this即可，利用的是“初始化未经声明的变量，总会创建一个全局变量”。但缺点是每个实例都会创建同样的一组方法。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyObject</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> privateVar = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">privateFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 特权方法。但在strict模式下给未经var声明的变量赋值会报错</span></span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">publicMethod</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;	</span><br><span class="line">		privateVar++;</span><br><span class="line">		<span class="keyword">return</span> <span class="title function_">privateFunc</span>();</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>静态私有变量: 私有变量和函数由实例共享，变量的修改牵一发而动全身。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="title class_">Person</span> = <span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">		name = value;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setName</span> = <span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">		name = value;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">&#125;) ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>(p1.<span class="title function_">getName</span>());	<span class="comment">// B</span></span><br><span class="line"><span class="title function_">alert</span>(p2.<span class="title function_">getName</span>());	<span class="comment">// B</span></span><br></pre></td></tr></table></figure>
<ul>
<li>模块模式module pattern: 为单例singleton创建私有变量和特权的方法。单例指的是只有一个实例的对象，JavaScript中的对象字面量可以很方便地创建单例对象。如果必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有数据的方法，就可以用模块模式。注意每个单例的类型用instanceof都只能得出是Object类型，作为全局变量存在。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> application = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="comment">// 私有变量和函数</span></span><br><span class="line">	<span class="keyword">var</span> components = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">	components.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">BaseComponent</span>());	<span class="comment">// 初始化，例如丢进一些组件</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 公共</span></span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		<span class="attr">getComponentCount</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> components.<span class="property">length</span>;</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="attr">registerComponent</span>: <span class="keyword">function</span>(<span class="params">component</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">typeof</span> component == <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">				components.<span class="title function_">push</span>(component);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125; ();</span><br></pre></td></tr></table></figure>
<ul>
<li>增强版模块模式: 在返回对象之前加入对其增强的代码，即返回的是一个特定类型的对象实例同时对其添加了属性和方法进行增强。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> application = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="comment">// 私有变量和函数</span></span><br><span class="line">	<span class="keyword">var</span> components = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">	components.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">BaseComponent</span>());	<span class="comment">// 初始化，例如丢进一些组件</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 创建指定类型的局部副本</span></span><br><span class="line">	<span class="keyword">var</span> app = <span class="keyword">new</span> <span class="title class_">BaseComponent</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 公共接口</span></span><br><span class="line">	app.<span class="property">getComponentCount</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> components.<span class="property">length</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	app.<span class="property">registerComponent</span> = <span class="keyword">function</span>(<span class="params">component</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">typeof</span> component == <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">			components.<span class="title function_">push</span>(component);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> app;	<span class="comment">// 将特定类型的实例返回</span></span><br><span class="line">&#125; ();</span><br></pre></td></tr></table></figure>

<h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><hr>
<ol>
<li>window对象</li>
</ol>
<ul>
<li>BOM: 浏览器对象模型，是JavaScript能在Web中使用的关键。BOM提供了很多对象，用于访问浏览器的功能，而与页面无关。</li>
<li>window: BOM的核心对象，是浏览器的实例。它既是通过JavaScript访问浏览器窗口的一个接口、又是ECMAScript规定的Global对象。</li>
<li>全局作用域: 所有在全局作用域中声明的变量、函数都会变成window对象的属性和方法。不过直接定义到window上的属性和全局变量还是有一点区别的，前者可以用delete操作符从window中删除，后者不行。window还能提供一个”属性查询”的功能:</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newValue = oldValue;	<span class="comment">// 若oldValue没有定义，会报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newValue = <span class="variable language_">window</span>.<span class="property">oldValue</span>;	<span class="comment">//这是一次属性查询，newValue获得值undefined</span></span><br></pre></td></tr></table></figure>
<ul>
<li>frame中的window: 在HTML中使用frameset+frame可以在同一个浏览器窗口中显示多个独立的小方框显示不同的页面。虽然现在已经很少用frame了，不过不妨了解一下在使用frame的情况下如何获取各个独立页面的window对象。每个frame都有独立的window对象，存储在frames集合中，可通过索引或名称的方式访问，即<code>top.frames[0]</code>或<code>top.frames[&quot;topFrame&quot;]</code>。其中<strong>top对象始终指向最外层框架，即浏览器窗口</strong>，而如果用window对象访问frames集合，可能指向的是某个框架的特定实例而不是顶层的窗口。与top对象相对应地，<strong>parent对象始终指向当前框架的上层</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>Frameset Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">frameset</span> <span class="attr">rows</span>=<span class="string">&quot;100,*&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">&quot;frame.html&quot;</span> <span class="attr">name</span>=<span class="string">&quot;topFrame&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">frame</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">frameset</span> <span class="attr">cols</span>=<span class="string">&quot;50%, 50%&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">&quot;anotherFrame.html&quot;</span> <span class="attr">name</span>=<span class="string">&quot;leftFrame&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">frame</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">&quot;anotherFrameset.html&quot;</span> <span class="attr">name</span>=<span class="string">&quot;rightFrame&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">frame</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">其中的anotherFrameset.html包含一个新的frameset，这里就不列出来了。</span><br></pre></td></tr></table></figure>
<ul>
<li>窗口位置: 使用screenLeft和screenTop（或screenX和screenY）可取得窗口的位置信息，但可能无法跨浏览器获得窗口左边和上边的精确坐标，而且可能无法获取frame的坐标。而移动窗口到指定位置可以用window.moveTo和window.moveBy完成，不过可能被浏览器默认禁用。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跨浏览器获取页面左边和上边的位置</span></span><br><span class="line"><span class="keyword">var</span> leftPos = (<span class="keyword">typeof</span> <span class="variable language_">window</span>.<span class="property">screenLeft</span> == <span class="string">&quot;number&quot;</span>)? <span class="variable language_">window</span>.<span class="property">screenLeft</span>: <span class="variable language_">window</span>.<span class="property">screenX</span>;</span><br><span class="line"><span class="keyword">var</span> topPos = (<span class="keyword">typeof</span> <span class="variable language_">window</span>.<span class="property">screenTop</span> == <span class="string">&quot;number&quot;</span>)? <span class="variable language_">window</span>.<span class="property">screenTop</span>: <span class="variable language_">window</span>.<span class="property">screenY</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">moveTo</span>(<span class="number">0</span>, <span class="number">0</span>);	<span class="comment">// 移动窗口到左上角</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">moveBy</span>(-<span class="number">50</span>, <span class="number">100</span>);	<span class="comment">// 左移50，下移100</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>窗口大小: 使用innerWidth, innerHeight, outerWidth, outerHeight可以获取页面视图大小和外层浏览器本身的尺寸，但外层尺寸不一定可以跨浏览器获取。此外，还可以通过document属性的方式来获取。调整窗口可以使用window.resizeTo和window.resizeBy，也可能会被浏览器禁用。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// document方式获取窗口大小</span></span><br><span class="line"><span class="keyword">var</span> pageWidth = <span class="variable language_">window</span>.<span class="property">innerWidth</span>,</span><br><span class="line">	pageHeight = <span class="variable language_">window</span>.<span class="property">innerHeight</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> pageWidth !== <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">compatMode</span> === <span class="string">&quot;CSS1Compat&quot;</span>) &#123;</span><br><span class="line">		pageWidth = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span>;</span><br><span class="line">		pageHeight = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		pageWidth = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientWidth</span>;</span><br><span class="line">		pageHeight = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientHeight</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调整到100 * 100</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">resizeTo</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"><span class="comment">// 调整到200 * 50</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">resizeBy</span>(<span class="number">100</span>, -<span class="number">50</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>打开窗口: 使用<code>window.open</code>可以导航到特定URL或打开一个新的浏览器窗口，接收4个参数：目标URL、target、特性字符串和是否取代当前页历史记录的boolean。其中第二个参数会优先查找并打开在URL中是否有该名称的窗口或框架，其次可以选择_self, _parent, _top, 或_blank，最后若确实没有找到该名称，则会根据第三个参数打开新窗口。<code>window.open</code>会返回一个指向新窗口的引用，可存入一个变量中对该窗口进行其他操作。新窗口还会用opener指向原始窗口，但原窗口并不会记录自己打开了哪些新窗口。有些浏览器会有弹出窗口屏蔽的功能，我们有时需要检测弹出的窗口是否被封杀。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&quot;http://xxx.com&quot;</span>, <span class="string">&quot;newWindow&quot;</span>, <span class="string">&quot;height=400, width=400, top=20, left=0, resizeable=yes&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测封杀</span></span><br><span class="line"><span class="keyword">var</span> blocked = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> newWin = <span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&quot;http://xxx.com&quot;</span>, <span class="string">&quot;_blank&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (newWin === <span class="literal">null</span>) &#123;</span><br><span class="line">		blocked = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ex) &#123;	<span class="comment">// 有些封杀后会抛出异常</span></span><br><span class="line">	blocked = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>超时调用与间歇调用: <code>setTimeout(function, timems)</code>可控制延时多少ms再执行函数，可利用返回的id结合clearTimeout取消掉。<code>setInterval(function, timems)</code>则是设置每间隔多少ms就执行一次函数。在真正开发时，间歇调用很少用上，因为后一个间歇调用很可能在前一个间歇调用结束之前启动。完全可以用超时调用来模拟间歇调用避免间歇调用的混乱。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timeoutId = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="title function_">alert</span>(<span class="string">&quot;Hey, girl!&quot;</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">clearTimeout</span>(timeoutId);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tick = <span class="number">0</span>, max = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> intervalId = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">tickIncre</span>(<span class="params"></span>) &#123;</span><br><span class="line">	tick++;</span><br><span class="line">	<span class="keyword">if</span> (tick === max) &#123;</span><br><span class="line">		<span class="built_in">clearInterval</span>(intervalId);</span><br><span class="line">		<span class="title function_">alert</span>(<span class="string">&quot;tick Done!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">intervalId = <span class="built_in">setInterval</span>(tickIncre, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用超时调用模拟间歇调用</span></span><br><span class="line"><span class="keyword">var</span> tick = <span class="number">0</span>, max = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> intervalId = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">tickIncre</span>(<span class="params"></span>) &#123;</span><br><span class="line">	tick++;</span><br><span class="line">	<span class="keyword">if</span> (tick &lt; max) &#123;</span><br><span class="line">		<span class="built_in">setTimeout</span>(tickIncre, <span class="number">500</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="title function_">alert</span>(<span class="string">&quot;tick Done!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(tickIncre, <span class="number">500</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>浏览器对话框: 对话框样式由浏览器定义，与网页无关。打开的对话框都是同步和模态的，弹出时代码会暂停执行，等用户操作反馈后才会恢复执行。<code>alert()</code>弹出只有“确定”按钮的对话框；<code>confirm()</code>则有“确定”和“取消”两个按钮，会根据用户的选择返回布尔值；<code>prompt()</code>与confirm相比又多了一个文本输入框，点击确定则会返回这个字符串、否则返回null。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="title function_">prompt</span>(<span class="string">&quot;What do you mean?&quot;</span>, <span class="string">&quot;hint text&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (result !== <span class="literal">null</span>) &#123;</span><br><span class="line">	<span class="title function_">alert</span>(<span class="string">&quot;Welcome, &quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>location对象<br> location对象既是window的属性，又是document的属性。location保存着当前文档的信息，还将URL分割成独立的片段，可通过不同属性访问这些片段。</li>
</ol>
<ul>
<li>查询参数: 在URL后接参数（以?开头）可以传递参数，使用location.search可以访问这一串参数，但是没法把每个参数拆分开来。不妨手动实现一发，直接用返回对象的属性的形式来访问各个参数，十分方便。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getQueryStringArgs</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> qs = (location.<span class="property">search</span>.<span class="property">length</span> &gt; <span class="number">0</span> ? location.<span class="property">search</span>.<span class="title function_">substring</span>(<span class="number">1</span>) : <span class="string">&quot;&quot;</span>,</span><br><span class="line">		args = &#123;&#125;,</span><br><span class="line"></span><br><span class="line">		items = qs.<span class="property">length</span> ? qs.<span class="title function_">split</span>(<span class="string">&quot;&amp;&quot;</span>) : [];</span><br><span class="line">		item = <span class="literal">null</span>,</span><br><span class="line">		name = <span class="literal">null</span>,</span><br><span class="line">		value = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = items.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">		item = items[i].<span class="title function_">split</span>(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">		name = <span class="built_in">decodeURIComponent</span>(item[<span class="number">0</span>]);</span><br><span class="line">		value = <span class="built_in">decodeURIComponent</span>(item[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (name.<span class="property">length</span>) &#123;</span><br><span class="line">			args[name] = value;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>地址跳转: 使用assign方法、设置window.location、修改location.href属性是三种等价的方式可以进行地址跳转。而使用replace方法就是直接替换地址（即无法后退）。使用reload方法可以重新加载页面。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浏览器地址跳转</span></span><br><span class="line">location.<span class="title function_">assign</span>(<span class="string">&quot;http://xxx.com&quot;</span>);</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span> = <span class="string">&quot;http://xxx.com&quot;</span>;</span><br><span class="line">location.<span class="property">href</span> = <span class="string">&quot;http://xxx.com&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换</span></span><br><span class="line">location.<span class="title function_">replace</span>(<span class="string">&quot;http://xxx.com&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重加载</span></span><br><span class="line">location.<span class="title function_">reload</span>();		<span class="comment">// 重新加载，可能用到缓存</span></span><br><span class="line">location.<span class="title function_">reload</span>(<span class="literal">true</span>);	<span class="comment">// 从服务器重新加载</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>navigator对象<br> 用于识别客户端浏览器，拥有一大堆属性帮助检测浏览器。</li>
</ol>
<ul>
<li>检测插件: 对于非IE浏览器可通过navigator.plugins来获取插件的集合，然后进行字符串搜索就可以知道是否安装给定的插件。而IE得使用ActiveXObject尝试创建一个实例来检测是否有给定的插件。通常会针对不同插件编写不同的函数，保证跨浏览器都能检测。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hasPlugin</span>(<span class="params">name</span>) &#123;</span><br><span class="line">	name = name.<span class="title function_">toLowerCase</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = navigator.<span class="property">plugins</span>.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (navigator.<span class="property">plugins</span>[i].<span class="property">name</span>.<span class="title function_">toLowerCase</span>().<span class="title function_">indexOf</span>(name) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IE专属</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hasIEPlugin</span>(<span class="params">name</span>) &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(name);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hasQuickTime</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> result = <span class="title function_">hasPlugin</span>(<span class="string">&quot;QuickTime&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!result) &#123;</span><br><span class="line">		result = <span class="title function_">hasIEPlugin</span>(<span class="string">&quot;QuickTime.QuickTime&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>注册处理程序: <code>navigator.registerContentHandler()</code>和<code>navigator.registerProtocolHandler()</code>可以让站点指明它所能处理特定类型的信息。使用history.length还可以得知当前窗口的记录数量，可用于判断本页面是否为用户打开的第一个页面。</li>
</ul>
<ol start="4">
<li>screen对象<br> 包含浏览器外部显示屏的信息，例如availWidth, availHeight。</li>
<li>history对象<br> 包含用户的上网记录，每个窗口都有history属性。虽然不能获取用户的历史记录，但可以用go函数实现前进、后退等跳转。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">history.<span class="title function_">go</span>(<span class="number">2</span>);	<span class="comment">// 前进2页</span></span><br><span class="line">history.<span class="title function_">go</span>(-<span class="number">1</span>);	<span class="comment">// 后退1页</span></span><br><span class="line"></span><br><span class="line">history.<span class="title function_">back</span>();</span><br><span class="line">history.<span class="title function_">forward</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>



    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/frontend/" rel="tag"># frontend</a>
              <a href="/tags/js/" rel="tag"># js</a>
              <a href="/tags/DOM/" rel="tag"># DOM</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2016/09/05/jquery_miniui/" rel="prev" title="Note for Ducumentation of jQuery MiniUI">
                  <i class="fa fa-angle-left"></i> Note for Ducumentation of jQuery MiniUI
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2016/09/22/java_spring/" rel="next" title="Java Spring框架入门">
                  Java Spring框架入门 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2016 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="futbol-o"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Bob</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"bobbyliujb","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js" defer></script>

</body>
</html>
