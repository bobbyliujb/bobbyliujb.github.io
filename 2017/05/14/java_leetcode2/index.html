<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"bobbyliujb.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"hide","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="刷题。祝我好运。">
<meta property="og:type" content="article">
<meta property="og:title" content="Note for LeetCode in Java (101~200)">
<meta property="og:url" content="https://bobbyliujb.github.io/2017/05/14/java_leetcode2/index.html">
<meta property="og:site_name" content="Bob&#39;s Blog">
<meta property="og:description" content="刷题。祝我好运。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2017-05-14T23:32:39.000Z">
<meta property="article:modified_time" content="2021-04-23T06:41:45.540Z">
<meta property="article:author" content="Bob">
<meta property="article:tag" content="java">
<meta property="article:tag" content="algorithm">
<meta property="article:tag" content="interview">
<meta property="article:tag" content="leetcode">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://bobbyliujb.github.io/2017/05/14/java_leetcode2/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://bobbyliujb.github.io/2017/05/14/java_leetcode2/","path":"2017/05/14/java_leetcode2/","title":"Note for LeetCode in Java (101~200)"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Note for LeetCode in Java (101~200) | Bob's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-118868735-1"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-118868735-1","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js" defer></script>








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Bob's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#101-symmetric-tree"><span class="nav-number">1.</span> <span class="nav-text">101. symmetric-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#102-binary-tree-level-order-traversal"><span class="nav-number">2.</span> <span class="nav-text">102. binary-tree-level-order-traversal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#103-binary-tree-zigzag-level-order-traversal"><span class="nav-number">3.</span> <span class="nav-text">103. binary-tree-zigzag-level-order-traversal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#104-maximum-depth-of-binary-tree"><span class="nav-number">4.</span> <span class="nav-text">104. maximum-depth-of-binary-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#105-construct-binary-tree-from-preorder-and-inorder-traversal"><span class="nav-number">5.</span> <span class="nav-text">105. construct-binary-tree-from-preorder-and-inorder-traversal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#106-construct-binary-tree-from-inorder-and-postorder-traversal"><span class="nav-number">6.</span> <span class="nav-text">106. construct-binary-tree-from-inorder-and-postorder-traversal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#107-binary-tree-level-order-traversal-ii"><span class="nav-number">7.</span> <span class="nav-text">107. binary-tree-level-order-traversal-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#108-convert-sorted-array-to-binary-search-tree"><span class="nav-number">8.</span> <span class="nav-text">108. convert-sorted-array-to-binary-search-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#109-convert-sorted-list-to-binary-search-tree"><span class="nav-number">9.</span> <span class="nav-text">109. convert-sorted-list-to-binary-search-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#110-balanced-binary-tree"><span class="nav-number">10.</span> <span class="nav-text">110. balanced-binary-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#111-minimum-depth-of-binary-tree"><span class="nav-number">11.</span> <span class="nav-text">111. minimum-depth-of-binary-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#OK-112-path-sum"><span class="nav-number">12.</span> <span class="nav-text">OK.112. path-sum</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#OK-113-path-sum-ii"><span class="nav-number">13.</span> <span class="nav-text">OK.113. path-sum-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#114-flatten-binary-tree-to-linked-list"><span class="nav-number">14.</span> <span class="nav-text">114. flatten-binary-tree-to-linked-list</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#115-distinct-subsequences"><span class="nav-number">15.</span> <span class="nav-text">115. distinct-subsequences</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#116-populating-next-right-pointers-in-each-node"><span class="nav-number">16.</span> <span class="nav-text">116. populating-next-right-pointers-in-each-node</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#117-populating-next-right-pointers-in-each-node-ii"><span class="nav-number">17.</span> <span class="nav-text">117. populating-next-right-pointers-in-each-node-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#118-pascals-triangle"><span class="nav-number">18.</span> <span class="nav-text">118. pascals-triangle</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#119-pascals-triangle-ii"><span class="nav-number">19.</span> <span class="nav-text">119. pascals-triangle-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#120-triangle"><span class="nav-number">20.</span> <span class="nav-text">120. triangle</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#121-best-time-to-buy-and-sell-stock"><span class="nav-number">21.</span> <span class="nav-text">121. best-time-to-buy-and-sell-stock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#122-best-time-to-buy-and-sell-stock-ii"><span class="nav-number">22.</span> <span class="nav-text">122. best-time-to-buy-and-sell-stock-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#123-best-time-to-buy-and-sell-stock-iii"><span class="nav-number">23.</span> <span class="nav-text">123. best-time-to-buy-and-sell-stock-iii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#124-binary-tree-maximum-path-sum"><span class="nav-number">24.</span> <span class="nav-text">124. binary-tree-maximum-path-sum</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#125-valid-palindrome"><span class="nav-number">25.</span> <span class="nav-text">125. valid-palindrome</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#126-word-ladder-ii"><span class="nav-number">26.</span> <span class="nav-text">126. word-ladder-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#127-word-ladder"><span class="nav-number">27.</span> <span class="nav-text">127. word-ladder</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#128-longest-consecutive-sequence"><span class="nav-number">28.</span> <span class="nav-text">128. longest-consecutive-sequence</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#129-sum-root-to-leaf-numbers"><span class="nav-number">29.</span> <span class="nav-text">129. sum-root-to-leaf-numbers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#130-surrounded-regions"><span class="nav-number">30.</span> <span class="nav-text">130. surrounded-regions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#131-palindrome-partitioning"><span class="nav-number">31.</span> <span class="nav-text">131. palindrome-partitioning</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#132-palindrome-partitioning-ii"><span class="nav-number">32.</span> <span class="nav-text">132. palindrome-partitioning-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#133-clone-graph"><span class="nav-number">33.</span> <span class="nav-text">133. clone-graph</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#134-gas-station"><span class="nav-number">34.</span> <span class="nav-text">134. gas-station</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#135-candy"><span class="nav-number">35.</span> <span class="nav-text">135. candy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#136-single-number"><span class="nav-number">36.</span> <span class="nav-text">136. single-number</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#137-single-number-ii"><span class="nav-number">37.</span> <span class="nav-text">137. single-number-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#138-copy-list-with-random-pointer"><span class="nav-number">38.</span> <span class="nav-text">138. copy-list-with-random-pointer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#139-word-break"><span class="nav-number">39.</span> <span class="nav-text">139. word-break</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#140-word-break-ii"><span class="nav-number">40.</span> <span class="nav-text">140. word-break-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#141-linked-list-cycle"><span class="nav-number">41.</span> <span class="nav-text">141. linked-list-cycle</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#142-linked-list-cycle-ii"><span class="nav-number">42.</span> <span class="nav-text">142. linked-list-cycle-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#143-reorder-list"><span class="nav-number">43.</span> <span class="nav-text">143. reorder-list</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#144-binary-tree-preorder-traversal"><span class="nav-number">44.</span> <span class="nav-text">144. binary-tree-preorder-traversal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#145-binary-tree-postorder-traversal"><span class="nav-number">45.</span> <span class="nav-text">145. binary-tree-postorder-traversal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#146-lru-cache"><span class="nav-number">46.</span> <span class="nav-text">146. lru-cache</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#147-insertion-sort-list"><span class="nav-number">47.</span> <span class="nav-text">147. insertion-sort-list</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#148-sort-list"><span class="nav-number">48.</span> <span class="nav-text">148. sort-list</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#149-max-points-on-a-line"><span class="nav-number">49.</span> <span class="nav-text">149. max-points-on-a-line</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#150-evaluate-reverse-polish-notation"><span class="nav-number">50.</span> <span class="nav-text">150. evaluate-reverse-polish-notation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#151-reverse-words-in-a-string"><span class="nav-number">51.</span> <span class="nav-text">151. reverse-words-in-a-string</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#152-maximum-product-subarray"><span class="nav-number">52.</span> <span class="nav-text">152. maximum-product-subarray</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#153-find-minimum-in-rotated-sorted-array"><span class="nav-number">53.</span> <span class="nav-text">153. find-minimum-in-rotated-sorted-array</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#154-find-minimum-in-rotated-sorted-array-ii"><span class="nav-number">54.</span> <span class="nav-text">154. find-minimum-in-rotated-sorted-array-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#155-min-stack"><span class="nav-number">55.</span> <span class="nav-text">155. min-stack</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#156-binary-tree-upside-down"><span class="nav-number">56.</span> <span class="nav-text">156. binary-tree-upside-down</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#157-read-n-characters-given-read4"><span class="nav-number">57.</span> <span class="nav-text">157. read-n-characters-given-read4</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#158-read-n-characters-given-read4-ii-call-multiple-times"><span class="nav-number">58.</span> <span class="nav-text">158. read-n-characters-given-read4-ii-call-multiple-times</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#160-intersection-of-two-linked-lists"><span class="nav-number">59.</span> <span class="nav-text">160. intersection-of-two-linked-lists</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#161-one-edit-distance"><span class="nav-number">60.</span> <span class="nav-text">161. one-edit-distance</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#162-find-peak-element"><span class="nav-number">61.</span> <span class="nav-text">162. find-peak-element</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#163-missing-ranges"><span class="nav-number">62.</span> <span class="nav-text">163. missing-ranges</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#164-maximum-gap"><span class="nav-number">63.</span> <span class="nav-text">164. maximum-gap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#165-compare-version-numbers"><span class="nav-number">64.</span> <span class="nav-text">165. compare-version-numbers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#166-fraction-to-recurring-decimal"><span class="nav-number">65.</span> <span class="nav-text">166. fraction-to-recurring-decimal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#167-two-sum-ii-input-array-is-sorted"><span class="nav-number">66.</span> <span class="nav-text">167. two-sum-ii-input-array-is-sorted</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#168-excel-sheet-column-title"><span class="nav-number">67.</span> <span class="nav-text">168. excel-sheet-column-title</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#169-majority-element"><span class="nav-number">68.</span> <span class="nav-text">169. majority-element</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#170-two-sum-iii-data-structure-design"><span class="nav-number">69.</span> <span class="nav-text">170. two-sum-iii-data-structure-design</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#171-excel-sheet-column-number"><span class="nav-number">70.</span> <span class="nav-text">171. excel-sheet-column-number</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#172-factorial-trailing-zeroes"><span class="nav-number">71.</span> <span class="nav-text">172. factorial-trailing-zeroes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#173-binary-search-tree-iterator"><span class="nav-number">72.</span> <span class="nav-text">173. binary-search-tree-iterator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#174-dungeon-game"><span class="nav-number">73.</span> <span class="nav-text">174. dungeon-game</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#175-largest-number"><span class="nav-number">74.</span> <span class="nav-text">175. largest-number</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#186-reverse-words-in-a-string-ii"><span class="nav-number">75.</span> <span class="nav-text">186. reverse-words-in-a-string-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#187-repeated-dna-sequences"><span class="nav-number">76.</span> <span class="nav-text">187. repeated-dna-sequences</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#188-best-time-to-buy-and-sell-stock-iv"><span class="nav-number">77.</span> <span class="nav-text">188. best-time-to-buy-and-sell-stock-iv</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#189-rotate-array"><span class="nav-number">78.</span> <span class="nav-text">189. rotate-array</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#190-reverse-bits"><span class="nav-number">79.</span> <span class="nav-text">190. reverse-bits</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#191-number-of-1-bits"><span class="nav-number">80.</span> <span class="nav-text">191. number-of-1-bits</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#198-house-robber"><span class="nav-number">81.</span> <span class="nav-text">198. house-robber</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#199-binary-tree-right-side-view"><span class="nav-number">82.</span> <span class="nav-text">199. binary-tree-right-side-view</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#200-number-of-islands"><span class="nav-number">83.</span> <span class="nav-text">200. number-of-islands</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Bob"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Bob</p>
  <div class="site-description" itemprop="description">I'm a Software Engineer!</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">50</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://bobbyliujb.github.io/2017/05/14/java_leetcode2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bob">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bob's Blog">
      <meta itemprop="description" content="I'm a Software Engineer!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Note for LeetCode in Java (101~200) | Bob's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Note for LeetCode in Java (101~200)
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-05-14 16:32:39" itemprop="dateCreated datePublished" datetime="2017-05-14T16:32:39-07:00">2017-05-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-04-22 23:41:45" itemprop="dateModified" datetime="2021-04-22T23:41:45-07:00">2021-04-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Tech/" itemprop="url" rel="index"><span itemprop="name">Tech</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2017/05/14/java_leetcode2/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/05/14/java_leetcode2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>刷题。祝我好运。</p>
<span id="more"></span>

<h4 id="101-symmetric-tree"><a href="#101-symmetric-tree" class="headerlink" title="101. symmetric-tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/symmetric-tree/#/description">101. symmetric-tree</a></h4><ul>
<li>给一个二叉树根节点，判断这棵树是否对称。recursive和iterative都想想。</li>
<li>ME：只想到了recursive，很好写。iterative一开始想到了中序遍历转成前后对称的数组来判断，但感觉是小题大作了，毕竟中序遍历似乎并不必要。偷看了一下关键词，DFS和BFS。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/5941/recursive-and-non-recursive-solutions-in-java/">这个</a>告诉你，原来可以借助Stack！每次取栈顶两个节点，先判断其值是否相等，然后将二者的左、右子节点和右、左子节点入栈，继续判断。</li>
<li>JAVA可以重载呀，同名方法、不同参数列表即可，不用绞尽脑汁想另一个名字哇。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// recursive</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">helper</span><span class="params">(TreeNode left, TreeNode right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span> || right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left.val == right.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> helper(left.left, right.right) &amp;&amp; helper(left.right, right.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iterative</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(root.left);</span><br><span class="line">        stack.push(root.right);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> stack.pop();        <span class="comment">// take two nodes from stack top</span></span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;                   <span class="comment">// should always have 2 at </span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left == <span class="literal">null</span> || right == <span class="literal">null</span></span><br><span class="line">               || left.val != right.val) &#123;      <span class="comment">// ensure equal</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(left.left); <span class="comment">// push 2 symmetric positions into stack</span></span><br><span class="line">            stack.push(right.right);</span><br><span class="line"></span><br><span class="line">            stack.push(left.right);</span><br><span class="line">            stack.push(right.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="102-binary-tree-level-order-traversal"><a href="#102-binary-tree-level-order-traversal" class="headerlink" title="102. binary-tree-level-order-traversal"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-level-order-traversal/#/description">102. binary-tree-level-order-traversal</a></h4><ul>
<li>level层面的遍历二叉树，返回一个<code>List&lt;List&lt;Integer&gt;&gt;</code>。</li>
<li>ME：用了辅助的<code>List&lt;List&lt;TreeNode&gt;&gt;</code>记录每一层的节点情况，同时为了防止加入空的List，设置了一个isNull<br> 布尔值判断是否这一层已经没有后续节点了。相当于BFS。</li>
<li>TA：BFS原来不用多一个双重List，<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/7647/java-solution-with-a-queue-used">直接一个Queue就搞定了</a>。<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/7332/java-solution-using-dfs/1">这个DFS方法</a>则是通过Level层级控制当前节点应当塞到哪一层对应的List当中。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; curr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> q.size();</span><br><span class="line">            <span class="keyword">while</span> (len-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                curr.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    q.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    q.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(curr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="103-binary-tree-zigzag-level-order-traversal"><a href="#103-binary-tree-zigzag-level-order-traversal" class="headerlink" title="103. binary-tree-zigzag-level-order-traversal"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/#/description">103. binary-tree-zigzag-level-order-traversal</a></h4><ul>
<li>level层面的遍历二叉树，但是遍历顺序不是固定的从左到右，而是蛇形，这一层从左到右、下一行从右到左。</li>
<li>ME：使用<code>Queue&lt;TreeNode&gt;</code>+按照每层节点计数循环遍历的BFS比较容易想到，根据level的奇偶，在加入结果之前将当前层级的List使用<code>Collections.reverse</code>反转一下就好了。而DFS也是利用level的奇偶，决定把当前节点的值插入List的头还是尾。DFS还是略快一点。</li>
<li>TA：看<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/3413/my-accepted-java-solution/3">这个</a>发现，BFS的时候也可以用LinkedList的addFirst将当前值插入头部（或者ArrayList的add(index, Element)），而不必在最后来Collections.reverse。</li>
<li>should be simple to come up with reversed version of normal level-traverse…</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.add(root);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">rev</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> q.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (len-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    q.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    q.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rev) &#123;</span><br><span class="line">                Collections.reverse(list);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(list);</span><br><span class="line">            rev = !rev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root, ans, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, List&lt;List&lt;Integer&gt;&gt; ans, <span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (level == ans.size()) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = ans.get(level);</span><br><span class="line">        <span class="keyword">if</span> (level % <span class="number">2</span> == <span class="number">1</span>) &#123;                   <span class="comment">// odd level should reverse</span></span><br><span class="line">            list.add(<span class="number">0</span>, root.val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            list.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left, ans, level + <span class="number">1</span>);</span><br><span class="line">        dfs(root.right, ans, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="104-maximum-depth-of-binary-tree"><a href="#104-maximum-depth-of-binary-tree" class="headerlink" title="104. maximum-depth-of-binary-tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-depth-of-binary-tree/#/description">104. maximum-depth-of-binary-tree</a></h4><ul>
<li>求二叉树的深度。</li>
<li>ME：三行的递归。毕竟衣洗题。</li>
<li>TA：没啥了。</li>
</ul>
<h4 id="105-construct-binary-tree-from-preorder-and-inorder-traversal"><a href="#105-construct-binary-tree-from-preorder-and-inorder-traversal" class="headerlink" title="105. construct-binary-tree-from-preorder-and-inorder-traversal"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/#/description">105. construct-binary-tree-from-preorder-and-inorder-traversal</a></h4><ul>
<li>给出前序遍历和中序遍历的数组，构造一个完整的二叉树，树的节点值不会重复。</li>
<li>ME：明明是数据结构讲树的时候讲过的，但是就是不记得了。。。憋了很久，不会。偷看了一下tag，提到了DFS。更可怕的是，我发现中序和前序被我搞反了，做的草稿都是反的。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/3695/my-accepted-java-solution">这个</a>介绍得很清楚，在preorder中先出现的一定是root，那么对应在inorder中找到它的位置，其左到inStart都是它左子树的节点，其右到inEnd都是它右子树的节点，递归下去找root的左节点和右节点即可。注意此题说了节点的值不重复，因此用循环在inorder中找root的位置时一旦找到就可以break；但如果允许值重复，则应当保证是当前查找范围内『最后一个出现的』，这也是上面这个答案的方式。我一开始一直在思考怎么用Stack，似乎记得老师讲过，果然看到了<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/795/the-iterative-solution-is-easier-than-you-think">这个用栈的iterative方法</a>，不过其实<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/795/the-iterative-solution-is-easier-than-you-think/16">这个Java版的更简洁</a>，或者看<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/102951192/">我提交的</a>，Java版的思路是先把跟节点入栈，然后每次从取栈顶元素和inorder比，不匹配则继续把preorder元素入栈；一旦匹配则持续出栈并继续与inorder后续元素比较，直到栈顶元素不再匹配，则把最后一个匹配的栈顶元素的右节点设为preorder的元素并入栈。</li>
<li>very basic isn’t it? But need to know the iterative one.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder == <span class="literal">null</span> || inorder == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(preorder, inorder, <span class="number">0</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">helper</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder, <span class="type">int</span> preStart, <span class="type">int</span> inStart, <span class="type">int</span> inEnd)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (preStart == preorder.length || inStart &gt; inEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> inStart;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> inStart; i &lt;= inEnd; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == preorder[preStart]) &#123; <span class="comment">// get the pos of current root in inorder</span></span><br><span class="line">                pos = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[preStart]);</span><br><span class="line">        <span class="comment">// all in front of pos in inorder are in left part, while latter are in right part</span></span><br><span class="line">        root.left = helper(preorder, inorder, preStart + <span class="number">1</span>, inStart, pos - <span class="number">1</span>);  </span><br><span class="line">        root.right = helper(preorder, inorder, preStart + <span class="number">1</span> + pos - inStart, pos + <span class="number">1</span>, inEnd);</span><br><span class="line">        <span class="comment">// note that right part need to shift (pos - inStart), which means how many elements in left.</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder == <span class="literal">null</span> || inorder == <span class="literal">null</span> || preorder.length == <span class="number">0</span> || inorder.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">prev</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">int</span> <span class="variable">indexPre</span> <span class="operator">=</span> <span class="number">1</span>, indexIn = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (indexPre &lt; preorder.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prev.val == inorder[indexIn]) &#123; <span class="comment">// reaches a root of its subtree</span></span><br><span class="line">                indexIn++;</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; inorder[indexIn] == stack.peek().val) &#123;</span><br><span class="line">                    prev = stack.pop();     <span class="comment">// pop until reaches previous root</span></span><br><span class="line">                    indexIn++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[indexPre]);   <span class="comment">// always take from preorder</span></span><br><span class="line">                prev.right = curr;      <span class="comment">// set to previous root&#x27;s right</span></span><br><span class="line">                prev = curr;            <span class="comment">// go into right</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[indexPre]);   <span class="comment">// take from preorder</span></span><br><span class="line">                prev.left = curr;       <span class="comment">// simply means curr is prev&#x27;s left</span></span><br><span class="line">                stack.push(prev);</span><br><span class="line">                prev = curr;</span><br><span class="line">            &#125;</span><br><span class="line">            indexPre++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="106-construct-binary-tree-from-inorder-and-postorder-traversal"><a href="#106-construct-binary-tree-from-inorder-and-postorder-traversal" class="headerlink" title="106. construct-binary-tree-from-inorder-and-postorder-traversal"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal">106. construct-binary-tree-from-inorder-and-postorder-traversal</a></h4><ul>
<li>给出中序遍历和后续遍历的数组，构造一个完整的二叉树。节点值不重复。</li>
<li>ME：按照上一题学习的，<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/102969951/">用Stack搞的iterative</a>方法和<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/102970738/">recursive的方法</a>都搞定了，毕竟刚刚才做过，记忆还很新鲜。</li>
<li>TA：由于元素不重复，因此可以考虑用一个HashMap来保存inorder中的值与对应的索引，这样就省去了线性查找的时间了。</li>
</ul>
<h4 id="107-binary-tree-level-order-traversal-ii"><a href="#107-binary-tree-level-order-traversal-ii" class="headerlink" title="107. binary-tree-level-order-traversal-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/#/description">107. binary-tree-level-order-traversal-ii</a></h4><ul>
<li>给一个二叉树的头结点，返回按从下到上的层级遍历的结果。</li>
<li>ME：老办法，BFS用一个Queue从上到下遍历，返回之前Collections.reverse一发。还尝试了一波DFS，借助level，最后reverse。</li>
<li>TA：我的方法应该是有点取巧了lol，虽然应该是比add(index, Element )好一点的，取反是一波流，而每次插入挪动的元素反而还多。通常大家的做法是，BFS中每次添加到结果的时候用add(0, List )，DFS中则是get的时候不是直接get对应level的那个List去添加，而是size - level - 1取到对称位置的。</li>
</ul>
<h4 id="108-convert-sorted-array-to-binary-search-tree"><a href="#108-convert-sorted-array-to-binary-search-tree" class="headerlink" title="108. convert-sorted-array-to-binary-search-tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree">108. convert-sorted-array-to-binary-search-tree</a></h4><ul>
<li>给一个排好序的数组，构造出对应的二分查找树。</li>
<li>ME：recursive的方法，每次进行二分找到根节点，然后在前、后两半各自确定左、右子节点。</li>
<li>TA：同样有大神<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/14412/java-iterative-solution">将recursive的方法改成了iterative的方法</a>，利用了三个stack模拟递归。<strong>递归的方法都可以通过栈来改写成遍历</strong>。</li>
<li>Recursive OK.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">helper</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[start]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        root.left = helper(nums, start, mid - <span class="number">1</span>);</span><br><span class="line">        root.right = helper(nums, mid + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="109-convert-sorted-list-to-binary-search-tree"><a href="#109-convert-sorted-list-to-binary-search-tree" class="headerlink" title="109. convert-sorted-list-to-binary-search-tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/#/description">109. convert-sorted-list-to-binary-search-tree</a></h4><ul>
<li>这回给的是一个排好序的链表的头结点，构造出对应的二分查找树。</li>
<li>ME：采用快慢指针的方式找中间节点，需要分节点数为奇、偶两种情况适当地挪动来取得中间节点作为当前根节点。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/35997/share-my-java-solution-1ms-very-short-and-concise">这个解答</a>也是快慢指针，但写起来比你的简洁好多。它传入了start和end，slow和fast一开始都指向start，利用tail判断什么时候停止挪动fast，然后直接将slow作为当前的根节点，其left和right递归去找就可以了，这个代码真的很漂亮。还有一种是<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/8141/share-my-o-1-space-and-o-n-time-java-code">先遍历一遍得到长度，然后根据长度分成左半部分和右半部分</a>，速度也不慢，不过借助了一个全局变量来遍历原链表，不太喜欢，也不好懂，毕竟在递归的时候变来变去的比较绕。</li>
</ul>
<h4 id="110-balanced-binary-tree"><a href="#110-balanced-binary-tree" class="headerlink" title="110. balanced-binary-tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/balanced-binary-tree/#/description">110. balanced-binary-tree</a></h4><ul>
<li>给一个二叉树，判断它是否balanced。</li>
<li>ME：一开始想法错了，以为左、右子树都是balanced就是了（你想想为啥）。后来改成老老实实根据高度来判断，若出现了左右两子树高度差大于1则返回-1，一直回溯到根。WA了两次才过，丢人呀还是个衣洗题。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/7798/the-bottom-up-o-n-solution-would-be-better/">这里</a>提到了两种，一种是比较浪费时间的自顶向下每次求高度法，另一种就是自下向上累计高度法。我就用的累计法，方便确认平衡状态嘛。</li>
<li>Recursive OK.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getHeight(root) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> getHeight(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> getHeight(root.right);</span><br><span class="line">        <span class="keyword">if</span> (left == -<span class="number">1</span> || right == -<span class="number">1</span> || Math.abs(left - right) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;   <span class="comment">// accumulate with max of left sub and right sub.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="111-minimum-depth-of-binary-tree"><a href="#111-minimum-depth-of-binary-tree" class="headerlink" title="111. minimum-depth-of-binary-tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-depth-of-binary-tree/#/description">111. minimum-depth-of-binary-tree</a></h4><ul>
<li>求最小深度，即从根到最浅的叶子节点经过的节点数。</li>
<li>ME：递归搞定。</li>
<li>TA：没啥了。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> minDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> minDepth(root.right);</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + (left == <span class="number">0</span>? right: right == <span class="number">0</span>? left: Math.min(left, right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="OK-112-path-sum"><a href="#OK-112-path-sum" class="headerlink" title="OK.112. path-sum"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/path-sum/#/description">OK.112. path-sum</a></h4><ul>
<li>给一个整数和一棵二叉树，判断是否存在路径使得经过的节点的值之和是给定的这个sum。</li>
<li>ME：递归搞定，每次深入之前先把sum减掉当前节点的值，达到sum的时候再判断是否是叶子节点。</li>
<li>TA：差不多吧。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val == sum &amp;&amp; root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newSum</span> <span class="operator">=</span> sum - root.val;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, newSum) || hasPathSum(root.right, newSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="OK-113-path-sum-ii"><a href="#OK-113-path-sum-ii" class="headerlink" title="OK.113. path-sum-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/path-sum-ii/#/description">OK.113. path-sum-ii</a></h4><ul>
<li>给一个整数和一棵二叉树，返回所有的从根到叶的和为sum的路径。</li>
<li>ME：DFS递归搞定。</li>
<li>TA：没啥了。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(root, sum, ans, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> sum, List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; curr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr.add(root.val);</span><br><span class="line">        <span class="keyword">if</span> (root.val == sum &amp;&amp; root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(curr));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dfs(root.left, sum - root.val, ans, curr);</span><br><span class="line">            dfs(root.right, sum - root.val, ans, curr);</span><br><span class="line">        &#125;</span><br><span class="line">        curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="114-flatten-binary-tree-to-linked-list"><a href="#114-flatten-binary-tree-to-linked-list" class="headerlink" title="114. flatten-binary-tree-to-linked-list"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/#/description">114. flatten-binary-tree-to-linked-list</a></h4><ul>
<li>给一个二叉树，将它in-place地改造成一个以右节点为next的链表状的树。</li>
<li>ME：作死地看了一下提示。。用DFS和本身的flatten相互嵌套递归，然后将左子树的最右下叶子节点的右指针指向经过flatten的右子树，返回给root。这种嵌套的写法，写是写得出来，但似乎不太好跟人解释。</li>
<li>TA：写得太短真心不好懂，比如<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/11444/my-short-post-order-traversal-java-solution-for-share">这个</a>，摆个全局变量在那，很不好想。<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/11444/my-short-post-order-traversal-java-solution-for-share/7">这个</a>给改成了传参版，也。。</li>
<li>This is really an extremely beautiful solution:</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">TreeNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;    <span class="comment">// sth like post order</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;                           </span><br><span class="line">        flatten(root.right);        <span class="comment">// but go right first to locate prev at root of right</span></span><br><span class="line">        flatten(root.left);         <span class="comment">// prev will be connected to the very right of left sub</span></span><br><span class="line">        root.left = <span class="literal">null</span>;           <span class="comment">// prev will become root of left sub</span></span><br><span class="line">        root.right = prev;</span><br><span class="line">        prev = root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="115-distinct-subsequences"><a href="#115-distinct-subsequences" class="headerlink" title="115. distinct-subsequences"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/distinct-subsequences/#/description">115. distinct-subsequences</a></h4><ul>
<li>给两个字符串S和T，在S中任意去除字符后得到T，求总共有多少种操作可以做到。</li>
<li>ME：画了个<code>dp[tLen+1][sLen+1]</code>，DP搞定。dp[i][j]表示T从0取到i-1位、S从0取到j-1位的时候，S有多少种删法能完美得到T。对于第i&#x3D;0行来说，T是空，因此S不论取多少都只有一种删法能得到T；从i&#x3D;1开始就要逐位确认字母是否匹配，若匹配则为左一位和左上一位之和，即dp[i][j] &#x3D; dp[i-1][j-1] + dp[i][j-1]；若不匹配，则j-1这一位的字母必须删除，因此直接由左一位决定，即dp][i][j] &#x3D; dp[i][j-1]。</li>
<li>TA：DP嘛，都差不多。<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/9488/easy-to-understand-dp-in-java/21">最下面这个</a>给改成了一维，确实是可以的，因为我更新dp table的时候刚好也是斜向下对角线更新的。</li>
</ul>
<h4 id="116-populating-next-right-pointers-in-each-node"><a href="#116-populating-next-right-pointers-in-each-node" class="headerlink" title="116. populating-next-right-pointers-in-each-node"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/#/description">116. populating-next-right-pointers-in-each-node</a></h4><ul>
<li>给一个二叉树，要求把所有节点的next都指向其同level的右边的节点。只能用O(1)的extra space，且这里的二叉树一定是perfect的，所有叶子都在一个level上、每个节点都有两个子树。</li>
<li>ME：第一次碰到不给run的题目，只能写完直接submit。还是递归嘛，每个根节点都先右后左地深入去connect，但这样还不够，因为从左子树和右子树的节点也有要相连的，因此又写了个connectL2R方法。不过这样一来感觉会浪费一些时间，因为两边深入下去搞完了回到根节点，还要再深入一次。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/2202/a-simple-accepted-solution">这个很强</a>，我一开始也想用一个prev一个curr搞的，但是逻辑没有理清楚。这里prev从root开始，让curr从prev的左子树开始挪动设置next，最妙的是左右两个子树的连接，是通过curr的next是否为null判断之后办到的，如果curr的next存在，那么curr.right.next就应当指向curr.next.left，画个图就明白了。之后curr就挪到curr.next，继续设置。妙哉！这样节省了我方法里的重复深入，而且不需要递归呢。</li>
<li>Did not come up with prev + curr method.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(TreeLinkNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeLinkNode</span> <span class="variable">prev</span> <span class="operator">=</span> root;       <span class="comment">// first of each level</span></span><br><span class="line">        <span class="type">TreeLinkNode</span> <span class="variable">curr</span> <span class="operator">=</span> <span class="literal">null</span>;       <span class="comment">// go throught the level</span></span><br><span class="line">        <span class="keyword">while</span> (prev.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            curr = prev;</span><br><span class="line">            <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">                curr.left.next = curr.right;    <span class="comment">// nodes on this level have set next</span></span><br><span class="line">                <span class="keyword">if</span> (curr.next != <span class="literal">null</span>) &#123;        </span><br><span class="line">                    curr.right.next = curr.next.left;</span><br><span class="line">                &#125;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="117-populating-next-right-pointers-in-each-node-ii"><a href="#117-populating-next-right-pointers-in-each-node-ii" class="headerlink" title="117. populating-next-right-pointers-in-each-node-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/">117. populating-next-right-pointers-in-each-node-ii</a></h4><ul>
<li>给一个二叉树，要求把所有节点的next都指向其同level的右边的节点。只能用O(1)的extra space，但不一定是perfect的了。</li>
<li>ME：用上一题学到的prev+curr写法，写了一大堆条件判断，因为不是perfect的话，curr在设置next的时候要考虑很多情况，prev在挪动的时候也不只是简单的prev.left了，而是先判断如果当前是叶子，得往next找下一层的首个节点。WA了三四次才过。</li>
<li>TA：手动再见。看<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/1106/o-1-space-o-n-complexity-iterative-solution">人家这个写的</a>，多么清晰简洁，既然每一层的head无法直接确定，那不妨多设一个变量来存放嘛，每一层每一层这样设置next，非常优雅！还有<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/28580/java-solution-with-constant-space">一个使用dummyHead的方法</a>，dummyHead作为每一层伪头部，总是指向该层的首个元素，再用一个pre去往后设置next，当上一层的root.next为null说明当前这一层设置完成，root来到dummy.next就到达当前这一层的首个元素了，这时需要切断dummy.next，再继续设置。妙哉！</li>
<li>Similar to 116, just generalized.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(TreeLinkNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeLinkNode</span> <span class="variable">fakeHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeLinkNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">TreeLinkNode</span> <span class="variable">prev</span> <span class="operator">=</span> fakeHead;   <span class="comment">// previous node that should set its next</span></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;           </span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                prev.next = root.left;</span><br><span class="line">                prev = prev.next;       <span class="comment">// should not be put outside</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                prev.next = root.right;</span><br><span class="line">                prev = prev.next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            root = root.next;</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;             <span class="comment">// means the level of root is expired</span></span><br><span class="line">                root = fakeHead.next;       <span class="comment">// go to next level</span></span><br><span class="line">                prev = fakeHead;</span><br><span class="line">                fakeHead.next = <span class="literal">null</span>;       <span class="comment">// IMPORTANT! reset fakeHead to ensure root will become null</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="118-pascals-triangle"><a href="#118-pascals-triangle" class="headerlink" title="118. pascals-triangle"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/pascals-triangle/#/description">118. pascals-triangle</a></h4><ul>
<li>给一个整数，返回对应层数的完整的杨辉三角。</li>
<li>ME：暴力O(n^2)做呀，List嘛。</li>
<li>TA：没啥了。</li>
</ul>
<h4 id="119-pascals-triangle-ii"><a href="#119-pascals-triangle-ii" class="headerlink" title="119. pascals-triangle-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/pascals-triangle-ii/#/description">119. pascals-triangle-ii</a></h4><ul>
<li>给一个整数，返回该层的杨辉三角，如<code>row = 0</code>则返回<code>[1]</code>。</li>
<li>ME：说是只能用O(k)的空间，那么我就用了两个List交替更新，一开始理解错这个rowIndex了搞死我。写出来发现速度好慢啊。</li>
<li>TA：我发现我好像搞错了，我那样其实还是有多余的空间，真正精简的O(k)应该是<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/2510/here-is-my-brief-o-k-solution/3">这样</a>，而且答主还用了我一直想用的数组，省去了set的麻烦。妙哉！还有<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/33175/my-clean-o-k-java-solution">直接用公式的</a>，这个就。。。</li>
<li>数组转List可以用Arrays.asList()，不过这个数组不能是基本类型的，要改成对应的封装类。</li>
</ul>
<h4 id="120-triangle"><a href="#120-triangle" class="headerlink" title="120. triangle"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/triangle/#/description">120. triangle</a></h4><ul>
<li>给一个List&lt;List<Integer>&gt;定义的三角形，求从顶端到底端走过路径经过节点值之和的最小值。</li>
<li>ME：一个dp数组先拷贝最低端的n个数字，然后自底向上在相邻两个数之间选较小值加上上一层的数，更新到数组中。一直更新到最顶层，dp[0]即为所求。</li>
<li>TA：你写的<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/103190786/">这个</a>在第二重循环中从右到左搞，没有必要啊！搞得你还要用一个额外的变量来存放old值。。大家思路都差不多，DP嘛，<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/22254/7-lines-neat-java-solution">bottom-up</a>已然最优了。</li>
</ul>
<h4 id="121-best-time-to-buy-and-sell-stock"><a href="#121-best-time-to-buy-and-sell-stock" class="headerlink" title="121. best-time-to-buy-and-sell-stock"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/#/description">121. best-time-to-buy-and-sell-stock</a></h4><ul>
<li>给一个int数组表示一个股票走势，求某一次最佳买入&amp;卖出点的情况下，收益是多少。</li>
<li>ME：维护了一个数组保存到当前位置位置的最低买入点价格，然后从右往左更新maxprofit。特别慢。</li>
<li>TA：在<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/103192762/">提交的时候看了一下比较快的做法</a>，竟然一波流就搞定了，当前值大于sofarMin的时候就判断是否需要更新maxprofit，否则就更新sofarMin，讨论版里也有<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/40721/very-simple-java-solution-with-detail-explanation-1ms-beats-96/2">类似的</a>。此外，讨论版里<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/19853/kadane-s-algorithm-since-no-one-has-mentioned-about-this-so-far-in-case-if-interviewer-twists-the-input">这个</a>提出了一个变种题，就是给的数组不再是当前股票价格，而是想比前一天的差，在这种情况下求最大收益。思路是每次都求差值，若为正则继续累加，若为负则重置为0.</li>
</ul>
<h4 id="122-best-time-to-buy-and-sell-stock-ii"><a href="#122-best-time-to-buy-and-sell-stock-ii" class="headerlink" title="122. best-time-to-buy-and-sell-stock-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/#/description">122. best-time-to-buy-and-sell-stock-ii</a></h4><ul>
<li>给一个int数组表示股票走势，允许多次买入卖出操作，求总共最大的收益。</li>
<li>ME：sofarMin的更新稍微变了一下，不仅是当前值小于sofarMin时、在当前值小于前面一个值的时候也要更新，同时将当前的profit累加到sum中。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/726/is-this-question-a-joke">大神</a>直接假设天天都能买入卖出，虽然不符合『卖出之后才能买入』的规则，但是这代码的结果也是对的。</li>
</ul>
<h4 id="123-best-time-to-buy-and-sell-stock-iii"><a href="#123-best-time-to-buy-and-sell-stock-iii" class="headerlink" title="123. best-time-to-buy-and-sell-stock-iii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/#/description">123. best-time-to-buy-and-sell-stock-iii</a></h4><ul>
<li>给一个int数组表示股票走势，至多允许两次买入卖出操作，求最大收益。</li>
<li>ME：以为和前面那题类似，一开始就按照累加那样的形式扫一遍，然后稍微更新一下max1和max2，但是没想到类似于<code>[1,2,4,2,5,7,2,4,9]</code>的情况，即按照前一题的做法得到的是<code>3,5,7</code>三个里面，取较大二者则为12；但实际上可以取到<code>6 + 7 = 13</code>。WA后一筹莫展了。看了下tag，DP。。。</li>
<li>TA：由于我考虑过从两端分别遍历，所以先参考的是<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/7028/java-solution-with-just-two-traverses">这个</a>，维护了一个leftProfit数组，表示从最左开始到当前位置的最大收益；然后再从右端遍历，这时就不需要维护一个数组了，而是在每次计算出从当前到最右端的最大收益时，加上leftProfit数组对应位置的值，取个Math.max，意义为从0<del>i的最大收益加上从i</del>end的收益（虽然这个i这一点疑似又买又卖，但实际上不会发生）。此外，还有<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/5934/is-it-best-solution-with-o-n-o-1">这个</a>消除了DP中冗余变量的方法，思想是假设一开始本金是0，release2表示第二次卖掉股票后剩余多少钱、hold2表示第二次买入股票时剩余多少钱、release1表示第一次卖掉股票后剩余多少钱、hold1表示第一次买入股票时剩余多少钱。通过for-each每次取出prices中的数值，依次更新这四个值。还有<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/4766/a-clean-dp-solution-which-generalizes-to-k-transactions">这个</a>就是推广了到允许多次交易的情形，真的非常不好懂。。。</li>
</ul>
<h4 id="124-binary-tree-maximum-path-sum"><a href="#124-binary-tree-maximum-path-sum" class="headerlink" title="124. binary-tree-maximum-path-sum"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-maximum-path-sum/#/description">124. binary-tree-maximum-path-sum</a></h4><ul>
<li>给一个二叉树，求其中的任意一条路径使得经过所有节点的值最大，不一定要经过root。</li>
<li>ME：一筹莫展。。。看了下tag，是DFS。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/4407/accepted-short-solution-in-java">这个</a>竟然这么轻松就给解出来了，非常简洁明了，一学就会。需要用一个辅助函数不断递归，先不断向左深挖，直到空，向右；辅助函数返回的是左和右的较大者加上当前根节点，且必须为正数才能取（负数那就越加越小了），而返回值则是用一个全局变量维护，每次尝试<code>left + right + node.val</code>，相当于把当前node作为根节点而不经过全局的root了。</li>
<li>Fail.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> max;        <span class="comment">// store the value of taking current root as swag point &quot;^&quot;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">return</span> Math.max(dfs(root), max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, dfs(root.left));</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, dfs(root.right));</span><br><span class="line">        max = Math.max(max, left + right + root.val);   <span class="comment">// take both of the branches</span></span><br><span class="line">        <span class="keyword">return</span> root.val + Math.max(left, right);    <span class="comment">// means only take one of the branches</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="125-valid-palindrome"><a href="#125-valid-palindrome" class="headerlink" title="125. valid-palindrome"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-palindrome/#/description">125. valid-palindrome</a></h4><ul>
<li>给一个字符串，忽略字母大小写并只考虑数字和字母，判断它是否中心对称。</li>
<li>ME：前指针+后指针搞，若不是字母或数字则用while不断找。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/25405/my-three-line-java-solution">这个</a>很简单粗暴，用正则表达式+replaceAll，把非字母数字的替换成空，然后reverse一下，直接判断是否相等即可。</li>
</ul>
<h4 id="126-word-ladder-ii"><a href="#126-word-ladder-ii" class="headerlink" title="126. word-ladder-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/word-ladder-ii/#/description">126. word-ladder-ii</a></h4><ul>
<li>给一个List的String，然后一个初始String一个目标String，要求每次变动一个字母且变动后的词语来自该List的情况下，返回所有最短变换得到目标String的方式（List的形式）。</li>
<li>ME：这个涉及到去重，所以想到的是DFS，但是做出来发现超时。没办法又回到BFS，但是如何防止走回头路的同时保证同一层的其他节点还能够正常走这条路径到达endWord？又是手足无措.jpg。</li>
<li>TA：看了discuss，发现竟然是DFS和BFS结合！真的复杂，第一次做题做到毫无耐心。。。暂时放一放。。。。然而没想到一而再再而三地见到这个题及其变种，不能不搞懂了。。。其实就是个图论题，词典中每一个词都是一个node，要从起点到终点，如果只是求最短路径的长度，那只需要一步BFS构建每个节点的邻居就可以了，只要邻居中出现了终点，就输出距离。但是如果要记录这些最短的路径具体是怎么走的，就需要再来一个DFS，从起点开始一直往后（不走回头路利用的是后出现的节点的距离一定是先经过的节点的距离+1），如果到了终点就把经过的路径存起来。最后形成的就是路径的列表了。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">findLadders</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (beginWord == <span class="literal">null</span> || endWord == <span class="literal">null</span> || beginWord.length() == <span class="number">0</span> || endWord.length() == <span class="number">0</span></span><br><span class="line">        || beginWord.length() != endWord.length() || wordList == <span class="literal">null</span> || wordList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;String, Integer&gt; distMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String word : wordList) &#123;</span><br><span class="line">        distMap.put(word, Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!distMap.containsKey(endWord)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    distMap.put(beginWord, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    Map&lt;String, Set&lt;String&gt;&gt; neighborMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Queue&lt;String&gt; toVisit = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    toVisit.offer(beginWord);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">found</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!toVisit.isEmpty() &amp;&amp; !found) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> toVisit.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">currWord</span> <span class="operator">=</span> toVisit.poll();</span><br><span class="line">            <span class="keyword">if</span> (currWord.equals(endWord)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                bfs(currWord, distMap, neighborMap, toVisit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(beginWord, endWord, distMap, neighborMap, ans, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(String fromWord, Map&lt;String, Integer&gt; distMap, </span></span><br><span class="line"><span class="params">                Map&lt;String, Set&lt;String&gt;&gt; neighborMap, Queue&lt;String&gt; q)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(fromWord);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sb.length(); i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">origin</span> <span class="operator">=</span> sb.charAt(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">26</span>; k++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span> + k);</span><br><span class="line">            sb.setCharAt(i, c);</span><br><span class="line">            <span class="type">String</span> <span class="variable">curr</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">            <span class="keyword">if</span> (distMap.containsKey(curr) &amp;&amp; distMap.get(fromWord) + <span class="number">1</span> &lt;= distMap.get(curr)) &#123;</span><br><span class="line">                q.add(curr);</span><br><span class="line">                distMap.put(curr, distMap.get(fromWord) + <span class="number">1</span>);</span><br><span class="line">                neighborMap.putIfAbsent(fromWord, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line">                neighborMap.get(fromWord).add(curr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.setCharAt(i, origin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(String fromWord, String toWord, Map&lt;String, Integer&gt; distMap, </span></span><br><span class="line"><span class="params">                Map&lt;String, Set&lt;String&gt;&gt; neighborMap, List&lt;List&lt;String&gt;&gt; ans, List&lt;String&gt; path)</span> &#123;</span><br><span class="line">    path.add(fromWord);</span><br><span class="line">    <span class="keyword">if</span> (fromWord.equals(toWord)) &#123;</span><br><span class="line">        ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;String&gt; neighbors = neighborMap.get(fromWord);</span><br><span class="line">    <span class="keyword">if</span> (neighbors != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String neighbor : neighbors) &#123;</span><br><span class="line">            <span class="keyword">if</span> (distMap.get(neighbor) == distMap.get(fromWord) + <span class="number">1</span>) &#123;</span><br><span class="line">                dfs(neighbor, toWord, distMap, neighborMap, ans, path);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="127-word-ladder"><a href="#127-word-ladder" class="headerlink" title="127. word-ladder"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/word-ladder/#/description">127. word-ladder</a></h4><ul>
<li>给一个List的String，然后一个初始String一个目标String，要求每次变动一个字母且变动后的词语来自该List的情况下，最短需要变几次得到目标String。</li>
<li>ME：毫无头绪，也不像是有DP的那种状态转换啊。稍微看了下Discuss里的关键词，BFS。</li>
<li>TA：BFS果然好用，看<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/16983/easy-76ms-c-solution-using-bfs">这个</a>搞出来的，思路是利用queue确定下一层要访问的字符串，然后对每一层进行遍历，遍历时就是用26个字母逐一替换进去看看是否在所给的字典中，存在则放入下一层，这样最快找到endWord就是最短路径了，其实有一点点图论的意思。答主还提到了加速的方法，<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/29303/two-end-bfs-in-java-31ms/16">这里</a>也有大神进行了解释，即从前和后同时开始找，每次选择规模较小的方向进行BFS，但这样为什么就能提速呢？</li>
<li><code>possible lossy conversion from int to char</code>说明出现潜在的精度丢失，需要在运算式子最前面加个括号强制转换。Queue用LinkedList，不是push而是add；Set用HashSet，有contains、remove等方法。</li>
</ul>
<h4 id="128-longest-consecutive-sequence"><a href="#128-longest-consecutive-sequence" class="headerlink" title="128. longest-consecutive-sequence"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-consecutive-sequence/#/description">128. longest-consecutive-sequence</a></h4><ul>
<li>给一个数组，要求在O(n)的时间内，返回其最长的连续子序列的长度。</li>
<li>ME：毫无头绪，偷看了下tag，提到了并查集。然而似乎不能直接用类似木桶法那样的数组搞啊，八成会越界。</li>
<li>TA：看了<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/6148/my-really-simple-java-o-n-solution-accepted/">这个</a>用了HashMap和<code>val+1</code>、<code>val-1</code>判断的答案，其实我本来有往这方面考虑的啊哭。思路是维护一个map，存储的是以当前数值为边界的最大连续长度，先从原数组中逐个取出数值n，再到map中查找<code>n-1</code>和<code>n+1</code>对应的长度<code>left</code>和<code>right</code>，那么加上当前数值之后的长度就为<code>left+right+1</code>了，判断一下取个max即为结果，注意要更新两个边界的长度，即map中<code>n+left</code>和<code>n+right</code>处的值。若原数组中有重复元素，即已经在map中出现了，就不能再拿来更新了。此外，还有<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/25493/simple-fast-java-solution-using-set">一个使用set实现的</a>，模仿了一下也AC了。这种也是有点图论的感觉，<code>n-1</code>和<code>n+1</code>就是邻居，看n最远可以走到哪。</li>
</ul>
<h4 id="129-sum-root-to-leaf-numbers"><a href="#129-sum-root-to-leaf-numbers" class="headerlink" title="129. sum-root-to-leaf-numbers"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sum-root-to-leaf-numbers/#/description">129. sum-root-to-leaf-numbers</a></h4><ul>
<li>给一个二叉树，每个节点值只可能为0~9，从根到叶经过的节点表示一个数字，求所有这些数字之和。</li>
<li>ME：DFS搞定。</li>
<li>TA：差不多吧。不过我用了一个全局变量，其实可以直接用返回值的，避免类中的全局变量。改成返回值版后，真的快了。</li>
<li>Not really OK…</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNumbers</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;  <span class="comment">// is leaf</span></span><br><span class="line">            <span class="keyword">return</span> root.val + val;                      <span class="comment">// previous val add current node val</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newVal</span> <span class="operator">=</span> (root.val + val) * <span class="number">10</span>;     </span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            sum += dfs(root.left, newVal);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            sum += dfs(root.right, newVal);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="130-surrounded-regions"><a href="#130-surrounded-regions" class="headerlink" title="130. surrounded-regions"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/surrounded-regions/#/description">130. surrounded-regions</a></h4><ul>
<li>给一个只含有<code>XXOO</code>的char二维数组，要求把所有被<code>X</code>完美包围的<code>O</code>替换成<code>X</code>，而绵延到边界的<code>O</code>就不替换。</li>
<li>ME：总感觉这题似曾相识，我最担心的情况出现了——在费劲地想和之前做过的什么题相似，而思路本身却卡壳了。我只能想到利用一个辅助二维table帮助判定是边界的O还是内部的O，一旦是边界的就向四个方向拓展判断。测试了一下算法是对的，但是递归的时候StackOverflow了。。。</li>
<li>TA：原来我的DFS方法是可以的，但是这个StackOverflow是因为你递归太多层了，而且也没有必要来多一个辅助的table，直接在原棋盘上操作就好了。<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/17224/a-really-simple-and-readable-c-solution-only-cost-12ms/8">这个大神</a>给出了解释，当从首行开始改变<code>O</code>的时候，如果向后一直蛇形连成一长串<code>O</code>，那么从(0, 0)开始的DFS会一路递归下去，规模非常可观。虽然改了之后可以AC，但是对于这个大神提出的第二个情况，DFS还是不行的。因此，还是不能偷懒搞DFS+recursive，得BFS+iterative，我参考了<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/2982/my-bfs-solution-c-28ms">这个</a>写出来了<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/104040158/">自己的</a>，思路就是遍历四条边的<code>O</code>，碰到就对它进行BFS，在BFS中先把<code>O</code>给换成别的什么字符，利用Queue来保存该<code>O</code>四个方向相邻的<code>O</code>（用了个内部类），入Queue之前也要把<code>O</code>给换掉，然后一直遍历Queue中的<code>O</code>直到Queue为空。最后把四个边界遍历完成后，再从头到尾来一波，把特殊字符换回<code>O</code>，把剩余的<code>O</code>换成<code>X</code>。此外还有<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/1944/solve-it-using-union-find">一个使用并查集的方法</a>，不是太好懂。。。似乎答主的灵感还是来自MIT的coursera作业，然而我没搞&#x3D; &#x3D;</li>
</ul>
<h4 id="131-palindrome-partitioning"><a href="#131-palindrome-partitioning" class="headerlink" title="131. palindrome-partitioning"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/palindrome-partitioning/#/description">131. palindrome-partitioning</a></h4><ul>
<li>给一个字符串，求它所有的划分方式使得每一个子字符串都是自对称的。</li>
<li>ME：DFS暴力搞，从头开始取1、2…长度的自字符串，判断是否自对称，是则固定并以下一个字符为起始继续DFS。不过速度奇慢，我一开始还怀疑会超时的其实。。。</li>
<li>TA：原来可以<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/2884/my-java-dp-only-solution-without-recursion-o-n-2">用DP提速</a>！思路是利用一个二维的boolean数组<code>isPalin[i][j]</code>表示字符串从i到j的部分是自对称的，然后维护一个类似于三维的<code>List&lt;List&lt;String&gt; [len]</code>数组<code>result</code>，result[x]表示从第一个字符到x的前一个字符为止的List&lt;List<String>&gt;.</li>
</ul>
<h4 id="132-palindrome-partitioning-ii"><a href="#132-palindrome-partitioning-ii" class="headerlink" title="132. palindrome-partitioning-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/palindrome-partitioning-ii/#/description">132. palindrome-partitioning-ii</a></h4><ul>
<li>给一个字符串，求最少的划分数使得每一个子字符串都是自对称的。</li>
<li>ME：用了刚刚学到的DP方法，用一个二维的boolean表示从i到j是自对称的，然后再用一个dp重新遍历一遍它，dp[x]就表示长度为x的部分的最少划分数，dp[x]由前面的划分数以及对称情况确定，若本身就对称了那划分数为0，否则找到前面子字符串中划分数最少的加一即得。但速度并不快，大概是因为我是O(2 * n^2 )？</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/32575/easiest-java-dp-solution-97-36/">这个</a>思路和我一样，而且也是用到了一个table加一个数组，不过他直接把我的两部给合并到一起了，模仿了一波果然快了。然后优化的话可以考虑把table给省掉，<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/2840/my-solution-does-not-need-a-table-for-palindrome-is-it-right-it-uses-only-o-n-space/">只用O(n )的空间</a>，双重循环，对当前字符向左右扩展判断是否对称，注意要区分奇数和偶数的子串长度两种情况分别扩展。老实说，不太好懂。</li>
</ul>
<h4 id="133-clone-graph"><a href="#133-clone-graph" class="headerlink" title="133. clone-graph"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/clone-graph/#/description">133. clone-graph</a></h4><ul>
<li>给一个无向有环图的其中一个节点，要求拷贝一个完整的无向有环图，并返回拷贝而成的对应的该节点。而且竟然两个节点之间可以有多条通路。</li>
<li>ME：DFS+一个map。既然label是唯一的，那么在复制当前节点之前需要先看看map里面是否已经有了当前节点，若有就直接取出来即可，若无，再进一步复制。复制时又分两种情况，当前节点没有更多邻居，则直接new一下再put进map里就可以返回了，若还有邻居，则需要先看看是否它自己（成环），是环就直接在neighbor里add自己就行，若不是环再去递归克隆。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/4690/simple-java-iterative-bfs-solution-with-hashmap-and-queue">这个</a>则是一个<code>BFS + map + Queue</code>的iterative方法，队列中存放的是原节点，map中存放的是label对应的新创建的拷贝节点。每次从队首poll一个出来，把它的首次出现的邻居都存入queue、new一个存入map（用map判断是否首次出现），然后根据label从map中把拷贝的节点取出来，给它的neighbor列表加上map中对应的节点。BFS还是不太熟啊。。。</li>
</ul>
<h4 id="134-gas-station"><a href="#134-gas-station" class="headerlink" title="134. gas-station"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/gas-station/#/description">134. gas-station</a></h4><ul>
<li>假设一个环形的路线，给一个gas数组表示每个索引处对应的供应油量，cost数组表示从当前索引到下一索引所需的油量，求从哪个索引开始能够保证油量足够绕一圈。</li>
<li>ME：一开始按照最直接的想法DFS，暴力从每个索引出发判断油量够不够，结果超时。改成了一个O(n)的根据剩余油量正负来更新start的方法，又是WA。看了一下标签，就是个Greedy，不知道我Greedy的逻辑哪不对。。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/1344/share-some-of-my-ideas">这个</a>和我WA的O(n)很像，思路是从头开始算剩余油量，当油量为负就累计一下『所欠的油量』，然后将剩余油量归0再往后遍历，遍历完后看看剩余油量够不够所欠油量，够就可以把start输出了。就差一点呀，关键就是这个『所欠油量』！<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/5088/my-ac-is-o-1-space-o-n-running-time-solution-does-anybody-have-posted-this-solution/">这个</a>也很6，有个trick比较难想到，把最后一个索引当成start、第一个索引当成end，将剩余油量初始化为最后一个索引处往第一个索引处开之后的油量sum，若sum非负，则可以继续往后开（加上end这个索引处的油量情况），若sum负了说明从当前start不能开到end，需要让start往回滚找到能够开到end的起点。当start和end相遇仍没有办法让油量非负，说明无解。</li>
</ul>
<h4 id="135-candy"><a href="#135-candy" class="headerlink" title="135. candy"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/candy/#/description">135. candy</a></h4><ul>
<li>给一个ratings数组表示一排小朋友的优先级，要求每个小孩至少一颗糖，优先级高于相邻小朋友的必须得到多于邻居的糖。求发出去的糖果总数的最小值。</li>
<li>ME：一开始超时的做法是，用一个candy数组表示每个小朋友所分得的糖果数，一旦小于前面的小朋友就默认发1颗，若出现相邻的小朋友rating不相等但糖数一样，就一直往前回滚每人多加一颗。注意若相邻小朋友优先级相等并不意味着糖数相等，例如<code>1,2,2,2,2</code>的最少糖果分配方式是<code>1,2,1,1,1</code>。很气，怎么避免回滚呢，tag也只是个简单的Greedy。</li>
<li>TA：玛德！原来可以<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/5243/a-simple-solution/2">把回滚放到最后求sum的循环里</a>，从后往前判断ratings，若前一rating比后一rating高而糖果却不是前者多于后者，则直接把后者的糖果数加一赋给前者。又是只差一点！还有<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/8208/one-pass-constant-space-java-solution/">一个constant space的方法</a>，我一开始也有想过似乎可以不用数组，但看了这个答案发现没有我想的那么简单，这里有一个arithmetic progression的规律，所谓的『首项加上末项乘以项数除以二』，利用一个countDown表示逆序了多少位，一旦正序了就让result加上前面逆序部分所需的糖果数，即<code>(1+countDown ) * countDown / 2</code>。但还有一个比较复杂的情形是<strong>正序部分最多的糖果少于逆序部分最多的糖果</strong>，除了用上面这个公式求最后一个正序到末尾这部分的糖果，还要判断一下countDown是否比最后一个正序所获得的糖果都多，因为可能出现<code>[1,2,3,4,3,2,1,0,-1]</code>这样的情形，4是最后一个正序，-1是末位，countDown是5而最后一次正序获得的糖果是4，如果只是简单地那样派糖果则[4]的糖果（4）就小于等于[3]的糖果（5）了，所以需要给最后一个正序的小孩补偿<code>countDown - prev + 1</code>个糖果，在这里就是补充两颗给他，这样就6&gt;5了。</li>
</ul>
<h4 id="136-single-number"><a href="#136-single-number" class="headerlink" title="136. single-number"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/single-number/#/description">136. single-number</a></h4><ul>
<li>给一个int数组，其中有一个单身狗，其他都是恰好出现两次，返回这个单身狗的值。</li>
<li>ME：用HashMap搞定，若不存在就put，存在就remove，最后用new ArrayList&lt;&gt;(map.values( ) )揪出单身狗。follow up要去不借助额外的内存，那就不给用map咯。想了一阵没头绪。。。</li>
<li>TA：还有<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/1916/my-o-n-solution-using-xor">这种骚操作</a>？？？原来是位运算，利用异或XOR的交换律，一路往后异或，最后剩下的就是单身狗。btw，位运算跑起来的效率比香港记者还快，多熟悉。</li>
</ul>
<h4 id="137-single-number-ii"><a href="#137-single-number-ii" class="headerlink" title="137. single-number-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/single-number-ii/#/description">137. single-number-ii</a></h4><ul>
<li>给一个int数组，其中有一个单身狗，其他都是恰好出现<strong>三</strong>次，返回这个单身狗的值。</li>
<li>ME：用HashMap搞定，第一次出现直接put，再次出现且value等于key，说明是第二次，直接让value和key不同就好了，再次出现且value不等于key，说明是第三次，remove掉。最后剩下的就是单身狗了。follow up还是要求no extra memory。异或似乎不行了。。。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/2031/challenge-me-thx">这个大神标题6得不行</a>，结合了异或、取反和与运算。至于解释，必须看<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/11877/detailed-explanation-and-generalization-of-the-bitwise-operation-method-for-single-numbers">这个大神的推广</a>，适用于『一数组中大部分数出现k次，唯独一个数只出现p次』的问题。不太好理解原理，先记下来怎么写吧。将k写成<code>101</code>的形式，从右往左对应<code>x1,...,xm</code>是否取反。xm全部初始化为0，mask也是0。遍历原数组，从xm开始更新，<code>xm ^= x(m-1 ) &amp; ... &amp; x1</code>，然后<code>mask = ~(x1 &amp; x2 ... &amp; xm )</code>，注意其中的xm有可能要取个反，例如对应于<code>101</code>就是<code>mask = ~(x1 &amp; ~x2 &amp; x3 )</code>，最后再从xm与一波，<code>xm &amp;= mask</code>。</li>
</ul>
<h4 id="138-copy-list-with-random-pointer"><a href="#138-copy-list-with-random-pointer" class="headerlink" title="138. copy-list-with-random-pointer"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/copy-list-with-random-pointer/#/description">138. copy-list-with-random-pointer</a></h4><ul>
<li>一个链表，其中含有一个指向任意节点的random引用。深复制这个链表。</li>
<li>ME：感觉跟前面有个复制图的很像，一开始就直接用HashMap递归着搞了，结果stack overflow。改成HashMap+iterative就AC了。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/7594/a-solution-with-constant-space-complexity-o-1-and-linear-time-complexity-o-n">这个不用Map的constant space的方法给跪</a>，思路是把每一个拷贝的节点拼接到原节点的后面，这样一轮循环过后所有节点都有了一份拷贝；第二轮循环就是为random赋值了，既然知道原节点之后就是对应的拷贝节点，那random的引用也就可以直接获得了。最后一轮循环则是把拷贝的节点正确地拼接起来，最后返回。66666</li>
</ul>
<h4 id="139-word-break"><a href="#139-word-break" class="headerlink" title="139. word-break"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/word-break/#/description">139. word-break</a></h4><ul>
<li>给一个List表示词典，给一个String，求能否把该String按照某种方式以空格分割，使得每个单词都来自于字典。</li>
<li>ME：一开始用DFS搞，先建立一个以首字母开头的<code>map&lt;Character, HashSet&lt;String&gt;&gt;</code>，结果超时，这个思路也就比暴力破解好在有个『首字母查找』吧。。而且又用到eclipse来找bug，扎心了。想改成BFS又不知可不可行，而且也不太会。看了一下tag，原来是DP！然而也似乎找不到状态转换在哪里。。。手足无措ing</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/2545/a-solution-using-bfs/5">这个</a>是一个BFS的方法，利用了visited trick加速，否则估计也是超时的。BFS思路是先直接把List转成HashSet，用Queue存放『下一个要尝试的起始索引』，trick在于用一个HashSet visited存放Queue中的这些索引，表示『这个索引之前的是true的，需要从当前索引开始尝试』，如果都已经在visited中出现过了，说明前面已经有结果覆盖到了这个索引，那么后续再碰到这个索引就不用再试了。每次遍历都从Queue中poll一个索引出来，若在Set中不存在说明没尝试过，那就一直往后尝试取子字符串是否在字典中，有就把那个截止位置索引入队，表示下一个从那里开始尝试；当截止位置达到String的末尾，说明前面都符合了，返回true即可。<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/6156/java-implementation-using-dp-in-two-ways">tag里所说的DP方法</a>，短得令人发指，不过我更喜欢<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/104209012/">经过maxLen优化的这个</a>。思想和BFS有点像，状态转换在于『某索引之前的部分符合字典词，那往后判断也是字典词的话就是了』。DP别总想着多维数组，一维数组难道就不能DP了么？此外，<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/9615/dfs-with-path-memorizing-java-solution">DFS经过优化也是可以的</a>，优化点和BFS类似，利用一个Set记录走过的Path，在前面BFS中的set记录的是『该索引之前的是OK的』，而DFS这里的Set记录的是『以当前索引结尾的是不行的』，估计二者是可以转换的吧。总之这里的DP可以转换成<code>DFS/BFS + path memorization</code>，面试别一上来就DP最优了。</li>
</ul>
<h4 id="140-word-break-ii"><a href="#140-word-break-ii" class="headerlink" title="140. word-break-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/word-break-ii/#/description">140. word-break-ii</a></h4><ul>
<li>给一个List表示词典，给一个String，求所有以空格分割的单词组成的字符串，使得每个单词都来自于字典。</li>
<li>ME：用上面学到的DP方法搞，结果跪在一个比较长的、不存在解的情况。我就先来一个O(n^2)的DP判断一下有没有解，然后再深入DP去求，<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/104231993/">终于过了，而且速度居然超过98%</a>，我也是一脸懵逼。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || wordDict == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">minLen</span> <span class="operator">=</span> Integer.MAX_VALUE, maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String word : wordDict) &#123;</span><br><span class="line">            set.add(word);</span><br><span class="line">            minLen = Math.min(minLen, word.length());</span><br><span class="line">            maxLen = Math.max(maxLen, word.length());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (canForm(s, set)) &#123;</span><br><span class="line">            List&lt;StringBuilder&gt;[] bucket = <span class="keyword">new</span> <span class="title class_">List</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">            bucket[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            bucket[<span class="number">0</span>].add(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>());</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">1</span>; right &lt;= s.length(); right++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> Math.max(right - maxLen, <span class="number">0</span>); left &lt; right; left++) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">curr</span> <span class="operator">=</span> s.substring(left, right);</span><br><span class="line">                    <span class="keyword">if</span> (set.contains(curr) &amp;&amp; bucket[left] != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (bucket[right] == <span class="literal">null</span>) &#123;</span><br><span class="line">                            bucket[right] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (StringBuilder prev : bucket[left]) &#123;</span><br><span class="line">                            bucket[right].add(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(prev).append(curr).append(<span class="string">&quot; &quot;</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (bucket[s.length()] != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (StringBuilder sb : bucket[s.length()]) &#123;</span><br><span class="line">                    sb.setLength(sb.length() - <span class="number">1</span>);</span><br><span class="line">                    ans.add(sb.toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">canForm</span><span class="params">(String s, Set&lt;String&gt; set)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">1</span>; right &lt;= s.length(); right++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> right - <span class="number">1</span>; left &gt;= <span class="number">0</span>; left--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[left] &amp;&amp; set.contains(s.substring(left, right))) &#123;</span><br><span class="line">                    dp[right] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>TA：WOW，没想到<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/27855/my-concise-java-solution-based-on-memorized-dfs">这个memorized DFS方法</a>还更优雅，思路是利用一个<code>Map&lt;String, LinkedList&lt;String&gt;&gt;</code>记录以该Key开头的后续的组合。对于当前字符串s来说，首先看看字典中有没有刚好可以作为开头部分的（<code>s.startsWith(word)</code>），有则固定它，往后取字符串，再向后进行DFS，这样一直深入到末尾，返回一个空字符串的List。当取得后续字符串的所有组合后，就一个个取出来然后把当前的s拼到最前面，形成新的以空格分隔的组合，记得在返回当前的组合之前，要放到map里面。</li>
<li>StringBuilder的append会影响到原sb的，String可以直接用<code>+</code>拼接。String有个startsWith方法很6。</li>
</ul>
<h4 id="141-linked-list-cycle"><a href="#141-linked-list-cycle" class="headerlink" title="141. linked-list-cycle"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/linked-list-cycle/#/description">141. linked-list-cycle</a></h4><ul>
<li>判断一个链表是否有环。</li>
<li>ME：这个印象十分深刻好吧，快慢指针，如果碰到一起了就是有环，如果快指针都到null了还没有，就无环。</li>
<li>TA：没啥，毕竟衣洗题。</li>
</ul>
<h4 id="142-linked-list-cycle-ii"><a href="#142-linked-list-cycle-ii" class="headerlink" title="142. linked-list-cycle-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/linked-list-cycle-ii/#/description">142. linked-list-cycle-ii</a></h4><ul>
<li>返回一个链表的环的起始位置（从哪里开始进入了环），如果没有环则返回Null。</li>
<li>ME：用一个HashMap瞬秒。不给用extra space的话。。。一时想不出来。。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/19367/java-o-1-space-solution-with-detailed-explanation">这个</a>解释了快慢指针的原理，若快慢指针都从head出发，从head到环的起始经过了A，假设慢指针经过A+B与快指针相遇，快指针速度是慢指针的两倍，那么快指针走过了<code>2*(A+B )</code>，假设环的长度为N，快指针比慢指针就多走了一个环的距离，即<code>A+B+N = 2*(A+B )</code>。那么此时再来一个指针从head出发，同时慢指针也出发，往后挪A了之后，慢指针一定是回到环的起点，因为<code>N - A = B</code>，相当于慢指针往回挪了B。妙哉！</li>
</ul>
<h4 id="143-reorder-list"><a href="#143-reorder-list" class="headerlink" title="143. reorder-list"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reorder-list/#/description">143. reorder-list</a></h4><ul>
<li>给一个链表，要求in-place地重新调整顺序，让第一个与最后一个相连、第二个与倒数第二个相连…</li>
<li>ME：一开始没有用辅助函数强行递归，每次都要重新遍历求最后一个元素，怒超时一波。顿时陷入了一个江局。。。</li>
<li>TA：看了<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/18092/java-solution-with-3-steps/">这个</a>才明白trick在哪，原来可以分三步走，第一步找到中间节点，第二步把中间节点之后的部分全部反转，第三步把前半部分和后半部分对应相连。注意按照这种方法求得的两半部分长度在偶数时前后相等，奇数时前半部分少于后半部分，因此在第三步要适当判断一下前半部分是否已经空了。</li>
</ul>
<h4 id="144-binary-tree-preorder-traversal"><a href="#144-binary-tree-preorder-traversal" class="headerlink" title="144. binary-tree-preorder-traversal"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-preorder-traversal/#/description">144. binary-tree-preorder-traversal</a></h4><ul>
<li>给一个二叉树，返回其前序遍历。要求iterative。</li>
<li>ME：Stack搞定。先让右节点入栈，再让左节点入栈，每次从栈顶节点的值输出到List中。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/6493/accepted-iterative-solution-in-java-using-stack">这个Iterative的方法</a>也是用stack，但只用存右边的节点，小优化一波。</li>
</ul>
<h4 id="145-binary-tree-postorder-traversal"><a href="#145-binary-tree-postorder-traversal" class="headerlink" title="145. binary-tree-postorder-traversal"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-postorder-traversal/#/description">145. binary-tree-postorder-traversal</a></h4><ul>
<li>给一个二叉树，返回其后序遍历。要求iterative。</li>
<li>ME：双Stack搞定。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/30632/preorder-inorder-and-postorder-iteratively-summarization">大神给出了Iterative的前中后序遍历总结</a>。</li>
</ul>
<h4 id="146-lru-cache"><a href="#146-lru-cache" class="headerlink" title="146. lru-cache"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/lru-cache/#/description">146. lru-cache</a></h4><ul>
<li>实现一个cache类的put和get方法，这个cache符合Least recently used规则来覆盖旧元素。</li>
<li>ME：存储键值对当然用HashMap，为了维护这个Least recently used我用的是LinkedList来不断地线性查找remove然后再add到最后，每次空间不够就poll最前面的即可。然而超时。关键就是这个LRU要如何高效更新呢？？陷入江局。。。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/6613/java-hashtable-double-linked-list-with-a-touch-of-pseudo-nodes/">这个</a>告诉你，自己新创一个DLinkedNode类构建双向链表，让Hash表由key映射到这样的节点上，每个DLinkedNode要存储key和value，value当然是为了get的时候返回，而保存key则是为了当链表的容量爆了的时候，弹出末尾的这个节点时能获得这个key，告诉map去remove。</li>
<li>双向链表的特点是插入和删除都不需要额外传入prev节点，不需要像通常单向链表那样O(n)遍历找到插入&#x2F;删除的位置。</li>
</ul>
<h4 id="147-insertion-sort-list"><a href="#147-insertion-sort-list" class="headerlink" title="147. insertion-sort-list"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/insertion-sort-list">147. insertion-sort-list</a></h4><ul>
<li>给一个链表，实现插入排序。</li>
<li>ME：用一个swapAfter用于交换当前节点后面的两个节点，比较当然也就是比较后面这两个节点辣。每次遍历完之后都回到头部，需要用一个swapped的标志表示上一次是否有交换，若已经没有交换了说明已经有序了。<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/104290648/">实现了但是神慢</a>，没试过垫底成这样。。。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/8570/an-easy-and-clear-way-to-sort-o-1-space">这个</a>写得比较清晰，回头看看感觉我的那个并不能看出来是『插入排序』。正确的思路是，设置一个伪头部表示排序后的链表，每次从原链表中取一个元素，然后在新链表中遍历找到正确的插入位置进行插入。</li>
</ul>
<h4 id="148-sort-list"><a href="#148-sort-list" class="headerlink" title="148. sort-list"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sort-list/#/description">148. sort-list</a></h4><ul>
<li>给一个链表，实现O(n*logn )时间复杂度的排序。</li>
<li>ME：用归并排序搞定了，每次先找到中间节点，一分为二，分别去归并，直到伪头部之后只剩一个有效节点，就开始合并，前一半一定比后一半小才行，通过改next指向实现，到最后若左半部分空了而右半部分还有有效节点，直接把左半部分最后一个节点的next指向右半部分的next即可。速度还行吧，打败了38%。</li>
<li>TA：差不多都是MergeSort，小伙子有眼光哇。在<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/104299110/">提交</a>那里看到比较快的是QuickSort的，我当时没敢搞是因为对『以首元素为pivot』的快排写法没把握，之前自己练的快排都是『以中间元素为pivot然后左边都小于pivot、右边都大于pivot』。值得学习一个。</li>
</ul>
<h4 id="149-max-points-on-a-line"><a href="#149-max-points-on-a-line" class="headerlink" title="149. max-points-on-a-line"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/max-points-on-a-line/#/description">149. max-points-on-a-line</a></h4><ul>
<li>给平面上点的坐标的数组，求最多有多少个点共线。</li>
<li>ME：一开始直接用<code>HashMap&lt;Double, Integer&gt;</code>搞，以每个点为起点向后遍历求斜率存入Map，若Map已有该斜率则++，WA后发现对于起始点在后续遍历中重复出现，则利用一个bonus变量统计，最后统一加上去。但依旧WA，因为计算精度的问题斜率没法精确求得，会误将两个坐标较大的点的斜率算成一样的。陷入江局。。。</li>
<li>TA：<a target="_blank" rel="noopener" href="http://blog.csdn.net/iwm_next/article/details/7450424">高票答案</a>，既然除法求Double有精度问题，那不妨就保留被除数和除数两个Integer的最简形式呗，利用嵌套的Map，外层Map的Key是约减后的dx，内层Map的Key是约减后的dy，所谓约减就是求横坐标差dx和纵坐标差dy的最大公约数gcd除一下。此外，为何不考虑使用long存储二者交叉相乘的结果呢？看<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/104318471/">提交这里靠前的比较快的算法</a>，有个8ms的就是直接用三重循环的long乘法判断三点共线的，前面两重是正常求两点横纵坐标差，第三重就是往后求乘法看是否共线的。</li>
<li>Double的精度丢失问题！<a target="_blank" rel="noopener" href="http://blog.csdn.net/iwm_next/article/details/7450424">最大公约数求法</a>有这题用的辗转相除法，还有相减法，最小公倍数则是两数之积除以最大公约数！</li>
</ul>
<h4 id="150-evaluate-reverse-polish-notation"><a href="#150-evaluate-reverse-polish-notation" class="headerlink" title="150. evaluate-reverse-polish-notation"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/evaluate-reverse-polish-notation/#/description">150. evaluate-reverse-polish-notation</a></h4><ul>
<li>给一个String的数组，其中包含整数或者加减乘除四种符号表示一个Reverse Polish Notation，求该算式的结果。</li>
<li>ME：印象深刻好吧，数据结构还是哪里讲到的，其实就是二叉树的遍历嘛后续遍历嘛，一个Stack存Integer.valueOf(str )，出现运算符就对应处理栈顶两个整数，然后把运算结果再入栈回去，最后栈顶剩下的就是运算结果辣。</li>
<li>TA：如果不用stack的话就要用到递归求操作符前面的两个操作数，用一个指针从后往前怼，因为操作符一定是出现在数字后面的。<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/104322005/">改写了一波</a>，速度超级快。</li>
</ul>
<h4 id="151-reverse-words-in-a-string"><a href="#151-reverse-words-in-a-string" class="headerlink" title="151. reverse-words-in-a-string"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-words-in-a-string/#/description">151. reverse-words-in-a-string</a></h4><ul>
<li>给一个句子，将句子以空格为分割的单词依次反过来（只是反单词顺序不是反单词里面的字符内容）。</li>
<li>ME：先trim一下，从后往前找空格，依次添加到StringBuilder里面。</li>
<li>TA：很欣赏<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/18189/clean-java-two-pointers-solution-no-trim-no-split-no-stringbuilder">这个大神的代码风格</a>，分步走、分函数，非常清晰。不过他这个的做法，大概有点绕了？他是第一步先转成charArray，一口气欠火候对调反转过来；第二步再找出每个单词的边界，再内部再调用第一步的reverse，这样就将每个单词都反转了；第三步则是整理空格，使前后无多余空格且单词之间只有一个空格，这个就有点复杂化了。。。</li>
</ul>
<h4 id="152-maximum-product-subarray"><a href="#152-maximum-product-subarray" class="headerlink" title="152. maximum-product-subarray"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-product-subarray/#/description">152. maximum-product-subarray</a></h4><ul>
<li>给一个int数组，求截取其中的子数组使得各int之积最大。</li>
<li>ME：I know it for sure that it should be solved with DP!!!!试了很久，然而发现我的思路只适用于子数组中只有两个负号的情况。。。陷入江局。。。</li>
<li>TA：我的DP还想着用三个数组呢，其中有个pos和neg的交换和<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/4417/possibly-simplest-solution-with-o-n-time-complexity">这个</a>很像，这个真的是太妙了。思路是用imax和imin分别记录以当前索引处截止的最大&#x2F;最小product，当出现负数的时候，先交换imax和imin再乘以这个负数，这样就能让最大&#x2F;最小保持下去，因为交换过后就是用最小负数的乘以个负数自然得到的是最大的了、用最大的正数乘以个负数自然是最小的了。妙哉啊！！！</li>
</ul>
<h4 id="153-find-minimum-in-rotated-sorted-array"><a href="#153-find-minimum-in-rotated-sorted-array" class="headerlink" title="153. find-minimum-in-rotated-sorted-array"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/#/description">153. find-minimum-in-rotated-sorted-array</a></h4><ul>
<li>给一个int数组，原本已经从小到大排好序了，从某个元素开始前半部分和后半部分对调位置（rotate），求最小元素。此题数组中的元素不会重复。</li>
<li>ME：一开始纳闷这题O(n)不就搞定了嘛，后来突然感觉四层相识，这种rotate过后『一定有一半的元素是正确的升序排列』，所以用类似于二分查找的方法来搞非常合适。所以就用二分查找搞定咯。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/4100/compact-and-clean-c-solution">这个</a>简洁好多，判断条件少了速度自然就快了。当left已经小于right，说明本身有序，直接返回left对应的即可；否则，当left小于mid，而left又大于right，说明应该在右半部分，因此<code>left = mid + 1</code>，否则<code>right = mid</code>。不过为了和后面的对应，我都统一改写成了<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/104512898/">用mid和right比较来判断哪半部分有序</a>。</li>
</ul>
<h4 id="154-find-minimum-in-rotated-sorted-array-ii"><a href="#154-find-minimum-in-rotated-sorted-array-ii" class="headerlink" title="154. find-minimum-in-rotated-sorted-array-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/#/description">154. find-minimum-in-rotated-sorted-array-ii</a></h4><ul>
<li>与上题的区别在于可能重复。</li>
<li>ME：与上题相比增加了相等的判断，而且为了处理<code>[10,1,10,10,10]</code>这样的情况即左中右均相等，还用到了recursive的方法向前、后半部分分别去找。过是可以过，但是很慢。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/6468/my-pretty-simple-code-to-solve-it">这个</a>也是很简洁，我结合前一题改写成了<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/104512752/">这个</a>。先根据left和right比较来判断是否本身有序，否则用mid和right比较判断哪半部分有序。对于mid与right相等的情况，则只能通过right一点点向前挪的方式来处理了，所以最坏情况是O(n)，其实和我上面递归的一样。</li>
</ul>
<h4 id="155-min-stack"><a href="#155-min-stack" class="headerlink" title="155. min-stack"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/min-stack/#/description">155. min-stack</a></h4><ul>
<li>实现一个最小栈，除了正常stack的push, top, pop操作，还要在constant time内返回当前栈内的最小值。</li>
<li>ME：两个LinkedList搞定，一个正常按照后入先出的方式存元素，另一个则是起一个标记的作用，表示当前位对应的最小值是多少。然而速度比较慢。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/7020/java-accepted-solution-using-one-stack">这个只用一个stack和一个整数标记实现的答案</a>很厉害。思路是每次在push的时候，如果这个元素比之前标记的Min还要小，那么就先把原本标记的min给push进去，紧接着再把新的元素push进去，同时更新min。对应地，在pop的时候如果发现和标记的min相同，就需要把栈中前面一个元素也pop出来赋给min，相当于一个恢复的过程。我还发        现了个bug就是stack为空的时候，调用getMin，LeetCode本身的代码竟然跑不出来。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 升级的做法是用双stack，但minStack存放的是num-count pair，避免重复存放相同元素</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    </span><br><span class="line">    Deque&lt;Integer&gt; stack;</span><br><span class="line">    Deque&lt;<span class="type">int</span>[]&gt; minStack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">        <span class="keyword">if</span> (minStack.isEmpty() || x &lt; minStack.peek()[<span class="number">0</span>]) &#123;</span><br><span class="line">            minStack.push(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;x, <span class="number">1</span>&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == minStack.peek()[<span class="number">0</span>]) &#123;</span><br><span class="line">            minStack.peek()[<span class="number">1</span>]++;</span><br><span class="line">        &#125;                                                                                                                                                    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!minStack.isEmpty() &amp;&amp; minStack.peek()[<span class="number">0</span>] == stack.peek()) &#123;</span><br><span class="line">            minStack.peek()[<span class="number">1</span>]--;</span><br><span class="line">            <span class="keyword">if</span> (minStack.peek()[<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                minStack.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.isEmpty() ? <span class="number">0</span> : minStack.peek()[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="156-binary-tree-upside-down"><a href="#156-binary-tree-upside-down" class="headerlink" title="156. binary-tree-upside-down"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-upside-down/">156. binary-tree-upside-down</a></h4><ul>
<li>给一个左优先二叉树，即每一个子树要么没有右子树、有右子树就一定是叶子且有对应的左子树。将树上下颠倒并把原右节点变成左leaf节点，返回转换后的树。</li>
<li>和逆转链表非常类似，也是考察递归、迭代的两种写法。递归时，root在上下反转之后就一定是在最下层的，root.left则会被提到root上方，root.right平移到左边。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">upsideDownBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> || root.left == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">newRoot</span> <span class="operator">=</span> upsideDownBinaryTree(root.left);</span><br><span class="line">        root.left.left = root.right;</span><br><span class="line">        root.left.right = root;</span><br><span class="line">        root.left = <span class="literal">null</span>;</span><br><span class="line">        root.right = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>iterative从root开始，从底层一步步构建新的树。新的root就是当前的left，当前的left应该是上一层的right、当前的right应该是上一层的root，然后需要传递当前的right到下一层去。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">upsideDownBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">prevRight</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            next = curr.left;</span><br><span class="line">            </span><br><span class="line">            curr.left = prevRight;</span><br><span class="line">            prevRight = curr.right;</span><br><span class="line">            curr.right = prev;</span><br><span class="line">            </span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="157-read-n-characters-given-read4"><a href="#157-read-n-characters-given-read4" class="headerlink" title="157. read-n-characters-given-read4"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/read-n-characters-given-read4/description/">157. read-n-characters-given-read4</a></h4><ul>
<li>给一个API read4，每次从某个source读取至多4个字符存入输入的char数组，返回值表示实际读入的字符。利用这个API实现readN.</li>
<li>手动实现，在read4时先判断还有没有剩余字符，有才继续操作。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The read4 API is defined in the parent class Reader4.</span></span><br><span class="line"><span class="comment">      int read4(char[] buf); */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> <span class="keyword">extends</span> <span class="title class_">Reader4</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buf Destination buffer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n   Maximum number of characters to read</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>    The number of characters read</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">char</span>[] buf, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span>[] temp = <span class="keyword">new</span> <span class="title class_">char</span>[N];</span><br><span class="line">        <span class="type">int</span> <span class="variable">add</span> <span class="operator">=</span> read4(temp);</span><br><span class="line">        <span class="keyword">while</span> (add &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n &gt; <span class="number">0</span> &amp;&amp; j &lt; add &amp;&amp; index &lt; buf.length) &#123;</span><br><span class="line">                buf[index++] = temp[j++];</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">            add = read4(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="158-read-n-characters-given-read4-ii-call-multiple-times"><a href="#158-read-n-characters-given-read4-ii-call-multiple-times" class="headerlink" title="158. read-n-characters-given-read4-ii-call-multiple-times"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/read-n-characters-given-read4-ii-call-multiple-times/description/">158. read-n-characters-given-read4-ii-call-multiple-times</a></h4><ul>
<li>给一个API read4，每次从某个source读取至多4个字符存入输入的char数组，返回值表示实际读入的字符。利用这个API实现readN.与上一题不同的是，每个call之间不是独立的，上一次如果读了4个但只consume了2个，那么这次要先consume上次没有用掉的字符。</li>
<li>用全局变量存放上一次读了多少和上一次index指向了哪里。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> <span class="keyword">extends</span> <span class="title class_">Reader4</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buf Destination buffer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n   Maximum number of characters to read</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>    The number of characters read</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">4</span>, tempIndex = <span class="number">0</span>, lastLimit = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>[] temp = <span class="keyword">new</span> <span class="title class_">char</span>[N];</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">char</span>[] buf, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (tempIndex == lastLimit) &#123;</span><br><span class="line">            lastLimit = read4(temp);</span><br><span class="line">            tempIndex = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (lastLimit &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (n &gt; <span class="number">0</span> &amp;&amp; tempIndex &lt; lastLimit &amp;&amp; index &lt; buf.length) &#123;</span><br><span class="line">                buf[index++] = temp[tempIndex++];</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果n读够了，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果tempIndex到头了，可以继续读</span></span><br><span class="line">            lastLimit = read4(temp);</span><br><span class="line">            tempIndex = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="160-intersection-of-two-linked-lists"><a href="#160-intersection-of-two-linked-lists" class="headerlink" title="160. intersection-of-two-linked-lists"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/intersection-of-two-linked-lists/#/description">160. intersection-of-two-linked-lists</a></h4><ul>
<li>给两个单向链表，求其中是否有交汇点。</li>
<li>ME：之前有一个求环的起始点的，和这个有那么一丢丢相似。我的思路是，从两个链表头出发，每次都判断是否相等，一旦相等就直接是交汇点了。若不等，则继续后移，当其中一个已经移到Null的时候，就跳转到另一条链表的头部，这样继续找。在纸上画画能看出来，假设链表A的独立部分长度为m，公共部分长度为a，链表B的独立部分为n，那么从A出发的指针经过了m+a+n，从B出发的指针经过了n+a+m，二者交汇的地方恰好就是交汇点。不过一开始陷入了死循环，这是因为没有设置一个shift的标志，因为至多只可能这样从null跳到另一条链表两次。</li>
<li>TA：额，怎么我的方法反而没有<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/5492/concise-java-solution-o-1-memory-o-n-time/">暴力pass两个链表求长度<code>O(A.length + B.length + max[lenA,lenB]</code> )</a>快。。。Anyway，我的思路和<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/28067/java-solution-without-knowing-the-difference-in-len/">这个</a>一样，O(m + n + a )，应该比暴力pass稍快一点才对？他没有用到shift标志，而是直接比较两个ptr来控制循环跳出，比我高明。</li>
</ul>
<h4 id="161-one-edit-distance"><a href="#161-one-edit-distance" class="headerlink" title="161. one-edit-distance"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/one-edit-distance/description/">161. one-edit-distance</a></h4><ul>
<li>给两个字符串s和t，问是否是one edit away，即往s中插入、删除、替换一个字符后得到t。</li>
<li>插入和删除是可以看作是互逆操作，可以用一个函数实现；替换用另一个函数实现。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isOneEditDistance</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || t == <span class="literal">null</span> || Math.abs(s.length() - t.length()) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s.length() &gt; t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> checkInsert(t, s);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.length() &lt; t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> checkInsert(s, t);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> checkReplace(s, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkInsert</span><span class="params">(String src, String dest)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ptr1</span> <span class="operator">=</span> <span class="number">0</span>, ptr2 = <span class="number">0</span>, end1 = src.length(), end2 = dest.length();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">inserted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (ptr1 &lt; end1 &amp;&amp; ptr2 &lt; end2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (src.charAt(ptr1) != dest.charAt(ptr2)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (inserted) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                inserted = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ptr1++;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkReplace</span><span class="params">(String src, String dest)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> src.length();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">replaced</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (src.charAt(i) != dest.charAt(i)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (replaced) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                replaced = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> replaced;    <span class="comment">// 一定要有replace才行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="162-find-peak-element"><a href="#162-find-peak-element" class="headerlink" title="162. find-peak-element"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-peak-element/#/description">162. find-peak-element</a></h4><ul>
<li>给一个数组，求峰值对应的下标。峰值指的是比左右两邻居都大。要求时间复杂度O(logN)。</li>
<li>ME：相当于在一个无序数组中找最大值的索引？为什么不求最大值本身而是求对应的索引？本身无序还怎么二分、怎么满足O(logN )？？反正我暴力O(n )是过了。。。不是很懂这题能有什么trick。</li>
<li>TA：原来真的理解错题意了，这题不是求maximum，只是要求任意一个合法的峰值，只要它比旁边两个邻居大就可以。<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/5724/find-the-maximum-by-binary-search-recursion-and-iteration">针对这题的二分法</a>与一般的二分多出来一个<code>mid2 = mid1 + 1</code>，每次判断的时候就比较<code>mid1</code>和<code>mid2</code>对应的值就行了，若小于则<code>left = mid2</code>，否则<code>right = mid1</code>。这题略无聊。。。</li>
</ul>
<h4 id="163-missing-ranges"><a href="#163-missing-ranges" class="headerlink" title="163. missing-ranges"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/missing-ranges/description/">163. missing-ranges</a></h4><ul>
<li>给一个排好序的int数组和lower &amp; upper bound(inclusive)，求missing的range List，用string表示每一段缺失的内容。如<code>nums = [0, 1, 3, 50, 75], lower = 0 and upper = 99</code>，就缺失了<code>[&quot;2&quot;, &quot;4-&gt;49&quot;, &quot;51-&gt;74&quot;, &quot;76-&gt;99&quot;]</code>。</li>
<li>直接遍历一波，利用一个expectedValue来判断是否出现了缺失。若当前数num大于expectedValue，说明expectedValue到num - 1都是缺失的。注意有个overflow问题，需要将expectedValue声明成long.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findMissingRanges</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lower, <span class="type">int</span> upper)</span> &#123;</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">expectedVal</span> <span class="operator">=</span> lower;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &lt; expectedVal) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &gt; expectedVal) &#123;</span><br><span class="line">                    ans.add(getString((<span class="type">int</span>) expectedVal, num - <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                expectedVal = (<span class="type">long</span>) num + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (expectedVal &lt;= (<span class="type">long</span>) upper) &#123;</span><br><span class="line">            ans.add(getString((<span class="type">int</span>) expectedVal, upper));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getString</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> start == end ? String.valueOf(start) : String.format(<span class="string">&quot;%d-&gt;%d&quot;</span>, start, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="164-maximum-gap"><a href="#164-maximum-gap" class="headerlink" title="164. maximum-gap"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-gap/#/description">164. maximum-gap</a></h4><ul>
<li>给一个乱序数组，要求O(n )的时间和空间复杂度内求它对应的有序数组中相邻两元素的最大gap。所有元素都是32-bit正整数，</li>
<li>ME：一开始又想到木桶排序了，毕竟O(n )又是正整数的，然而如果出现2147483647的话又会爆内存，只能另寻出路。偷看了下tag，只写了个sort，废话。。。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/5999/bucket-sort-java-solution-with-explanation-o-n-time-and-space">真的是可以用bucket木桶法的</a>，关键是如何压缩bucket不要浪费空间。该答主的做法是，首先O(N )一遍找出min和max值，然后利用min, max, 数组本身元素数确定gap值（<code>gap = ceiling[(max - min  ) / (N - 1 )]</code>），因为N个数就有N-1个相邻间隔，平均分布值再取个ceiling得到的就是『尽量大』的平均gap。其实这貌似是个<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/13172/pigeon-hole-principle">鸽子洞理论</a>。维护两个bucketMIN和bucketMAX，其索引表示的是『当前数字距离最小值大概占了平均gap的多少份』，计算索引用<code>index = (num - min ) / gap</code>，MIN和MAX木桶分别存储相同份数数字中的最小和最大值，这样就完美地解决了木桶空间浪费的问题。最后再从头到尾遍历，取MIN木桶值与前一个MAX木桶的值相减看看间隔多少，而同一索引对应的MIN和MAX就不用比了，因为一个平均gap都没到，当然比不过大于一个gap的了（牢记索引的含义是gap的份数，因此相邻的索引所存数字的间隔必然超过一份gap）。这个方法，妙是妙，但得学会怎么迁移到别的问题呢。。。此外，还有<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/22221/radix-sort-solution-in-java-with-explanation">使用基数排序的这个方法</a>，原来<a target="_blank" rel="noopener" href="http://blog.csdn.net/cjf_iceking/article/details/7943609">基数排序的时间复杂度也是O(dN )的</a>！基数排序就是根据个十百千万等各个位置的数字大小，利用一个count数组记录每个该位出现了多少个数字，然后将count从前往后加一波，表示『以当前索引i为当前位的数字num在新数组中的位置必须在count[i-1]以后』，此时再引入一个aux辅助数组，在原数组从后往前取数字判断它在aux中的索引。最后排好序了再一波流看看相邻的最大间隔是多少。挺好的，通过这个对基数排序又学习了一波。</li>
</ul>
<h4 id="165-compare-version-numbers"><a href="#165-compare-version-numbers" class="headerlink" title="165. compare-version-numbers"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/compare-version-numbers/#/description">165. compare-version-numbers</a></h4><ul>
<li>给两个表示版本号的字符串，比较谁更新，返回1&#x2F;0&#x2F;-1。</li>
<li>ME：直接从头部开始找小数点，找到了就Integer.valueOf得出数值，两者比较，一旦不相等就可以输出结果了。若相等再继续往后找。若前面都相等但二者长度不同，需要继续往更长的那串后面确认数值，如果都是0那二者版本号还是一样的。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/6238/accepted-small-java-solution">这个</a>又用到了强大的split函数，根据小数点将String拆分存储到数组中，然后取较长者作为界限进行遍历，若其中一个数组超出了自身的界限则直接赋值为0.同时为了方便，直接用Integer类的compareTo函数，直接就返回的是1&#x2F;0&#x2F;-1。</li>
</ul>
<h4 id="166-fraction-to-recurring-decimal"><a href="#166-fraction-to-recurring-decimal" class="headerlink" title="166. fraction-to-recurring-decimal"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/fraction-to-recurring-decimal/#/description">166. fraction-to-recurring-decimal</a></h4><ul>
<li>将分数转换成小数，若是无限循环小数则将循环部分用括号括起来，如<code>0.16666 = 0.1(6 )</code>。</li>
<li>ME：一开始的想法很简单，int越界问题用long搞定，确认完符号就直接开始除，出现小数点后每次从后往前取2、4、6看看是否出现了重复，若重复就直接当成循环输出了，对于连续出现的单个数字还好办，直接判断一下数字就好了，但是对于多个数字就不行了。。后来不断思考，又不小心瞄了一眼discuss看到了HashMap，突然想到我为什么要先插入再比较呢，为什么不直接利用HashMap把当前的被除数与对应的小数点位置存起来呢？当被除数在之前出现过，就一定会开始循环，那么获得它首次出现时对应的位置，然后插入一个<code>(</code>，最后再append一个<code> )</code>，不就美滋滋了？果然OK了。。。</li>
<li>TA：差不多的思路，怎么<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/7876/my-clean-java-solution/">大神的版本就简洁这么多呢</a>。首先对于符号处理就很优雅，一个异或就确定了要不要加负号。然后整数部分直接一除就出来了，HashMap中存储的索引直接就是被除数所对应的商的位置，这样直接就能替换了。还有<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/11851/short-java-solution">一个更短的</a>，循环条件直接就是看有没有出现重复的被除数，最后直接将结果用0用括号括起来，若是循环部分则是有效的，可以保留；若没有循环，最后的结果就是0，因此输出前直接将<code>(0 )</code>替换掉就好。</li>
<li><code>StringBuilder.replace(&quot;target&quot;, &quot;newStr&quot; );</code></li>
</ul>
<h4 id="167-two-sum-ii-input-array-is-sorted"><a href="#167-two-sum-ii-input-array-is-sorted" class="headerlink" title="167. two-sum-ii-input-array-is-sorted"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/#/description">167. two-sum-ii-input-array-is-sorted</a></h4><ul>
<li>给一个排好序的数组，再给一个target，求两个索引使得索引对应的数字之和等于target。</li>
<li>ME：印象深刻好吧，第一题就是它，当时我用到就是先排序再二分查找的办法。这里也可以。此外还用了学到的HashMap记录索引的方法，也可以。</li>
<li>TA：tag给了个two pointer，原来有个<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/6229/share-my-java-ac-solution">O(N )的方法</a>，思想和二分有点点像吧，前后两个指针对应的数字相加，与target比较，大了则右指针向前、小了则左指针向后。二分得有O(N * logN )吧。</li>
</ul>
<h4 id="168-excel-sheet-column-title"><a href="#168-excel-sheet-column-title" class="headerlink" title="168. excel-sheet-column-title"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/excel-sheet-column-title/#/description">168. excel-sheet-column-title</a></h4><ul>
<li>输入一个int，转换成excel中的那种column字母。</li>
<li>ME：循环除法和取模搞定。但是速度怎么那么慢？？？</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/6214/my-1-lines-code-in-java-c-and-python/9">丧心病狂，递归一行就解决了。。。</a></li>
</ul>
<h4 id="169-majority-element"><a href="#169-majority-element" class="headerlink" title="169. majority-element"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/majority-element/#/description">169. majority-element</a></h4><ul>
<li>给一个数组，求其中的majority number。mj指的是出现次数超过一半规模的数字。</li>
<li>ME：傻傻地用HashMap来存每个数字出现的次数，达到就输出。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/28601/java-solutions-sorting-hashmap-moore-voting-bit-manipulation">这里介绍了三种方法</a>。一是直接sort一下，取中间索引的即可，因为超过一半嘛，就算是最小&#x2F;最大值，也得越过中线啊。还有一个是Moore voting方法，利用一个count计数，假设首位为major开始，往后遍历，如果当前元素与major匹配则count++，否则count–，当count到达0的时候说明前面打成平手没有谁是major，那么再设置当前元素为major继续向后pk。毕竟极端情况是major刚好比不major的元素多1个，因此一定会保证count到最后胜者为王。</li>
</ul>
<h4 id="170-two-sum-iii-data-structure-design"><a href="#170-two-sum-iii-data-structure-design" class="headerlink" title="170. two-sum-iii-data-structure-design"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/two-sum-iii-data-structure-design/description/">170. two-sum-iii-data-structure-design</a></h4><ul>
<li>实现一个class，包含add（加入新的数字）和find（给定sum判断是否包含两个数字相加得到该sum）。</li>
<li>使用Map记录每一个加入number及其个数，在find的时候减一下即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TwoSum</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; map;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> min, max;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TwoSum</span><span class="params">()</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        min = Integer.MAX_VALUE;</span><br><span class="line">        max = Integer.MIN_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Add the number to an internal data structure.. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">        min = Math.min(number, min);</span><br><span class="line">        max = Math.max(number, max);</span><br><span class="line">        map.put(number, map.getOrDefault(number, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Find if there exists any pair of numbers which sum is equal to the value. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; <span class="number">2</span> * min || value &gt; <span class="number">2</span> * max) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(value - n)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (n == value - n &amp;&amp; map.get(n) &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="171-excel-sheet-column-number"><a href="#171-excel-sheet-column-number" class="headerlink" title="171. excel-sheet-column-number"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/excel-sheet-column-number">171. excel-sheet-column-number</a></h4><ul>
<li>与168对应，给的是excel中column字母的字符串，返回对应的数字。</li>
<li>ME：直接循环，<code>ans = ans * 26 + (ch - &#39;A&#39; + 1 )</code>搞定。</li>
<li>TA：没啥。</li>
</ul>
<h4 id="172-factorial-trailing-zeroes"><a href="#172-factorial-trailing-zeroes" class="headerlink" title="172. factorial-trailing-zeroes"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/factorial-trailing-zeroes/#/description">172. factorial-trailing-zeroes</a></h4><ul>
<li>在logarithmic时间复杂度内求N的阶乘末尾有几个0。</li>
<li>ME：这个衣洗题竟然搞得我毫无头绪，给的tag就只有个Math。有什么规律啊？？？</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/6516/my-one-line-solutions-in-3-languages">这个的思路很清楚</a>，在阶乘中末尾产生<code>0</code>完全可以归结于<code>2 * 5</code>，而2的数量肯定比5多多了，因此我们就判断一下当前数字可以拆分成几个5即可，有几个5就能产生几个trailing zeroes。为什么这么做是logarithmic呢？<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/6848/my-explanation-of-the-log-n-solution">这里</a>给出了解释，<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/17316/4-lines-4ms-c-solution-with-explanations">对应的iterative实现</a>这里其实是<code>log5(N )</code>的复杂度，以5为底数。</li>
</ul>
<h4 id="173-binary-search-tree-iterator"><a href="#173-binary-search-tree-iterator" class="headerlink" title="173. binary-search-tree-iterator"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-search-tree-iterator/#/description">173. binary-search-tree-iterator</a></h4><ul>
<li>给一个二分查找树的根节点，实现next和hasNext函数，前者每次返回下一个未访问的最小节点int值。要求这两个函数的时间复杂度为常数，空间复杂度为O(height)，即数的高度。</li>
<li>ME：卡在了iterative实现中序遍历这儿n久。最后还是参考了<a target="_blank" rel="noopener" href="http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion/">这个</a>才搞出来<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/104694864/">这个</a>。但是！不符合要求！因为你这一波遍历就是彻底的中序遍历，不只是O(h )而是O(N )了。</li>
<li>TA：看了<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/6604/ideal-solution-using-stack-java">这个</a>才明白，原来不需要在一开始就中序遍历把整个树搞出来，而是『breaks in-order traversal into hasNext( ) and next( )』。一开始只是尽可能地把左节点放入栈，当调用了next再把栈顶弹出，同时检查栈顶对应的这个节点是否有右节点，有则入栈并继续深挖左节点入栈。</li>
<li>need to get more familiar with iterative *-order traversal.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BSTIterator</span> &#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;TreeNode&gt; stack;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BSTIterator</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> root;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;  <span class="comment">// cache left sub in stack</span></span><br><span class="line">            stack.push(curr);   </span><br><span class="line">            curr = curr.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> whether we have a next smallest number */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> !stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> the next smallest number */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">ret</span> <span class="operator">=</span> stack.pop();     <span class="comment">// pop the left most</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> ret.right;      </span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;          <span class="comment">// then go into right</span></span><br><span class="line">            stack.push(curr);           <span class="comment">// continue to push left sub</span></span><br><span class="line">            curr = curr.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="174-dungeon-game"><a href="#174-dungeon-game" class="headerlink" title="174. dungeon-game"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/dungeon-game/#/description">174. dungeon-game</a></h4><ul>
<li>给一个二维int数组，骑士从左上角出发，到右下角去救公主，没到达一个各自就会加血&#x2F;扣血，一旦血为0就挂，求初始最少要有多少血。</li>
<li>ME：<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/104717088/">DP搞定</a>，二维数组dp[i][j]表示到达当前位置所需要的最少血，公主所在位置当然就是1了。更新从右下角开始，由于每个格子可能加血（正值）可能扣血（负值）。如果是负值，直接用dp减去它就是该位置之前一位（左、上）的最小血；如果是加血，显然不能从负数往上加，那么就需要与1作个判断，如果不是正数了那么前一位直接赋值为1.</li>
<li>TA：我的思路和<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/6858/my-ac-java-version-suggestions-are-welcome">这个类似</a>，不过答主是直接存储的是前一步应有的最小血了。没啥了。</li>
</ul>
<h4 id="175-largest-number"><a href="#175-largest-number" class="headerlink" title="175. largest-number"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/largest-number/#/description">175. largest-number</a></h4><ul>
<li>给一个非负的int数组，用它们拼成一个最大的数字，以String的形式返回。</li>
<li>ME：原本的思路是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/104724904/">直接将int转换成String来搞</a>，自定义实现Comparator的compare函数，高位数字越大的就排前面，若相同部分长度相等，则需要继续向后与首位元素进行比较。就是在这里疯狂地WA，头晕眼花，条件判断太多了。边缘情况例如<code>[830,8308]</code>这种，你说怎么排序？我只能想到，当与首位又相同时，需要假设进行拼接，挪动指针来判断，例如8308308和8308830这两个，就需要指针i和j分别来到8和3，这样就能看出是要8308排在前面了。</li>
<li>TA：我他喵的就呵呵了，<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/8018/my-java-solution-to-share">直接拼接之后用String的compareTo就搞定了</a>，我相当于手动实现了一遍。。。</li>
</ul>
<h4 id="186-reverse-words-in-a-string-ii"><a href="#186-reverse-words-in-a-string-ii" class="headerlink" title="186. reverse-words-in-a-string-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-words-in-a-string-ii/description/">186. reverse-words-in-a-string-ii</a></h4><ul>
<li>给一个char数组，反转单词出现顺序。<code>I love programming</code>变成<code>programming love I</code>。</li>
<li>先反转全部，再根据空格位置反转每个单词。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseWords</span><span class="params">(<span class="type">char</span>[] str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || str.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(str, <span class="number">0</span>, str.length - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                reverse(str, start, i - <span class="number">1</span>);</span><br><span class="line">                start = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(str, start, str.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] str, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> str[start];</span><br><span class="line">            str[start] = str[end];</span><br><span class="line">            str[end] = temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="187-repeated-dna-sequences"><a href="#187-repeated-dna-sequences" class="headerlink" title="187. repeated-dna-sequences"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/repeated-dna-sequences/#/description">187. repeated-dna-sequences</a></h4><ul>
<li>给一个字符串表示DNA基因序列，求其中出现次数超过一次的长度为10的子串。</li>
<li>ME：用Map记录每个子串出现的位置，后续再出现的话就放入set，最后遍历set存入list返回。一开始WA是因为不知道竟然重叠也可以算，我还以为一定要完美重复即前后错开呢。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/27517/7-lines-simple-java-o-n">这个</a>告诉你，不用管前后索引重叠的话，直接用Set就可以判断『是否已经出现过』。此外，还有<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/8894/clean-java-solution-hashmap-bits-manipulation">使用bit manipulation的</a>，直接用数组实现map映射关系，因为字符都是确定的，只有那四种，那每次就取个差值就好啦，那么四种情况对应的就是两个bit，那么每次都右移两位再把当前字符的数值『或』上去，总共是20个Bit，这时再放进set里。注意有个trick是利用set.add的返回值判断是否重复了，而且需要额外的一个set防止重复输出，例如<code>&quot;TTTTTTTTTTTTT&quot;</code>。</li>
<li>[HashSet的遍历方法]有(1 )for-each (2 )Iterator<E> it; while (it.hasNext( ) )。</li>
</ul>
<h4 id="188-best-time-to-buy-and-sell-stock-iv"><a href="#188-best-time-to-buy-and-sell-stock-iv" class="headerlink" title="188. best-time-to-buy-and-sell-stock-iv"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/#/description">188. best-time-to-buy-and-sell-stock-iv</a></h4><ul>
<li>前面第123题的升级版，各一个整数数组表示股票价格走势，给定交易次数k（买卖各一次为一次交易），求最大收益。</li>
<li>ME：前面123题那个两次交易的都勉勉强强搞定，这个k次交易的直接懵逼。我按照<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/4766/a-clean-dp-solution-which-generalizes-to-k-transactions/">123看到的这个推广</a>写了出来，但是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/104787288/">爆内存</a>了。我观察了一下，发现每次都只是用到上次的结果，因此可以把行数压缩成两行，但是又<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/104787930/">超时</a>。陷入江局了。。。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/8984/a-concise-dp-solution-in-java/">这个</a>告诉你原来当允许交易的数目大于等于长度的一半的时候，说明所有差值都可以纳入profit，直接一波流累计就好，不用DP慢慢搞了，终于<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/104788513/">过了</a>。不过上面那个答案空间浪费挺多的，在<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/104788513/">提交这里</a>最快的那个方法所用的优化是直接用两个数组（而不是我原本的二维数组）来存，最后直接交换一下就好。解决了之后真是神清气爽，希望可以牢记。</li>
</ul>
<h4 id="189-rotate-array"><a href="#189-rotate-array" class="headerlink" title="189. rotate-array"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/rotate-array/#/description">189. rotate-array</a></h4><ul>
<li>给一个数组，给一个k，要求rotate k，即所有元素一次向后挪k，末尾的k个元素则放到最前面。至少有三种方法。其中可以办到in-place。</li>
<li>ME：用了规模为k的辅助数组，结合System.arraycopy完成的。总觉得in-place的有见到过，但想不出来。。。</li>
<li>TA：原来<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/14341/easy-to-read-java-solution">这么简单</a>，先整个反转，然后分段reverse。我就隐约感觉是要用到swap的，就是没想过要reverse之后再swap。<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/9801/summary-of-c-solutions/">这个是总结</a>，其中第四个方法<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/9406/3-lines-of-c-in-one-pass-using-swap">原帖在这里</a>，就是梦寐以求的『直接根据正确的索引来swap』，确实不好想，而且这是C&#x2F;C++中才有的数组名字就是个指针，因此可以在swap的时候任意挪动，这样前面已经到达正确位置的数字就不会参与到后续的swap了，而Java似乎办不到？</li>
</ul>
<h4 id="190-reverse-bits"><a href="#190-reverse-bits" class="headerlink" title="190. reverse-bits"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-bits/#/description">190. reverse-bits</a></h4><ul>
<li>给一个int，但是要把他当成无符号的数字，将该数字对应的bit串反转，得到对应的int输出。</li>
<li>ME：首先我想的是，从原数字的最低位开始，用一个pivot和它逐位去与，获得的结果插入到新数字的末尾。交的<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/104804052/">这个版本</a>没有办法处理超出Integer范围的问题。。。</li>
<li>TA：参考了<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/9764/java-solution-and-optimization">这个</a>，答主用了『unsigned shift』<code>&gt;&gt;&gt;</code>，此外还有个边缘情况，就是当已经算到原数字最高位的时候，就不用再对ans进行左移了。至于follow-up问到的，如果这个函数多次被调用，如何优化？这种『反复被调用』的情况，很自然地想到优化之处在于cache，将之前算过的结果存下来。答主的策略是利用8 bit的byte存放计算过的结果，map&lt;Byte, Integer&gt;就是这样的一个映射。当输入32bit的n，先拆分成4个byte，然后分别反转这四个byte，最后将结果再用位移和加法拼起来。</li>
</ul>
<h4 id="191-number-of-1-bits"><a href="#191-number-of-1-bits" class="headerlink" title="191. number-of-1-bits"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/number-of-1-bits/#/description">191. number-of-1-bits</a></h4><ul>
<li>给一个int，但是要把他当成无符号的数字，计算该数字的bit形式有多少个1。</li>
<li>ME：用一个pivot从1开始往左移，和该数字作与，结果非0则该位为1，统计即可。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/11385/simple-java-solution-bit-shifting">额，也可以反方向</a>，每次都直接用1和它与，用<code>&gt;&gt;&gt;</code>获得前一位bit。一定要是『unsigned shift』！</li>
<li>位运算的优先级不如一般的<code>==, !=, &lt;</code>等，<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/23095004/bad-operand-types-for-binary-operator-java">如果不加上括号可能出现『bad operand types for binary operator “&amp;”』</a>。</li>
</ul>
<h4 id="198-house-robber"><a href="#198-house-robber" class="headerlink" title="198. house-robber"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/house-robber/#/description">198. house-robber</a></h4><ul>
<li>给一个int数组表示每一户的财产，不能抢相邻的人家，问最多可以搞到多少财产。</li>
<li>ME：有点DP的意思，不过只需要维护到前一家和再前一家为止能得到的财产。如果抢当前索引，则只能加到再前一家的财产，如果不抢当前索引，则还是维持前一家为止的数目。</li>
<li>TA：没啥了。</li>
</ul>
<h4 id="199-binary-tree-right-side-view"><a href="#199-binary-tree-right-side-view" class="headerlink" title="199. binary-tree-right-side-view"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-right-side-view/#/description">199. binary-tree-right-side-view</a></h4><ul>
<li>给一个二叉树，返回从右侧看这个树所能看到的节点，从上到下输出。</li>
<li>ME：也就是求每一层的最右侧节点吗，用BFS做level遍历，到达每层的最后一个节点时，即size - 1时便把值存起来就好。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/11768/my-simple-accepted-solution-java">DFS也能做</a>，利用level来判断到达了哪一层。</li>
</ul>
<h4 id="200-number-of-islands"><a href="#200-number-of-islands" class="headerlink" title="200. number-of-islands"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/number-of-islands/#/description">200. number-of-islands</a></h4><ul>
<li>给一个二维char数组，其中只含有<code>&#39;0&#39;</code>或<code>&#39;1&#39;</code>两种字符，分别表示水和陆地，上下左右直接相邻的两个陆地算作相连，求有几片独立的陆地。和前面130有一点点相似，然而只想起来了DFS。</li>
<li>ME：申请了额外的二维int数组存放对应的陆地编号，当发现原char数组为陆地而辅助数组中尚未标记，就开始DFS上下左右，分别赋值为当前的陆地编号。原以为会超时，没想到<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/104807941/">这么朴素的DFS</a>也能过。后来利用内部类定义坐标，用Queue改写成了BFS，结果<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/104811218/">速度更慢</a>。</li>
<li>TA：DFS和BFS大同小异。前面130没搞定的并查集方法，在这题里也可以用，比如<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/33947/java-union-find-solution">这个</a>，修改了一波，结合前面比较规范的130（加了rank）写出来了<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/104814183/">这个</a>，速度也不快。。。并查集记得是大二在讲图论的时候介绍的，所以涉及什么连通性问题、可达不可达之类的就可以考虑。在UF类中维护一个id数组，这个id表示当前索引的祖宗的索引，若<code>id[idx] = idx</code>说明它本身就是老大，初始时每个元素都是自己的老大。<code>find(p)</code>函数就是返回p的老大的索引，union(p, q)函数就是将索引p和q两伙合并起来，分别找到p和q的老大索引pRoot和qRoot，但是他们谁隶属于谁呢？rank就是在这时候起作用，将rank高的保留，rank低的老大合并到更高的老大那去，若两个老大一样，就随意了，合并后新老大的rank要加加。在外层函数真正使用UF的时候，遍历棋盘，遇到1就检查右方和下方的邻居是不是1，是就进行Union。在UF中还有一个count变量，其实就是算有几个独立老大的，初始时每个1都是老大，而每次成功调用union是count都会减减。</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
              <a href="/tags/algorithm/" rel="tag"># algorithm</a>
              <a href="/tags/interview/" rel="tag"># interview</a>
              <a href="/tags/leetcode/" rel="tag"># leetcode</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2017/04/16/java_leetcode/" rel="prev" title="Note for LeetCode in Java (1~100)">
                  <i class="fa fa-angle-left"></i> Note for LeetCode in Java (1~100)
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2017/06/03/java_leetcode3/" rel="next" title="Note for LeetCode in Java (201~300)">
                  Note for LeetCode in Java (201~300) <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2016 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="futbol-o"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Bob</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"bobbyliujb","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js" defer></script>

</body>
</html>
