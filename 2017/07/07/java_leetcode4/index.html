<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"bobbyliujb.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"hide","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="刷题。祝我好运。">
<meta property="og:type" content="article">
<meta property="og:title" content="Note for LeetCode in Java (301~400)">
<meta property="og:url" content="https://bobbyliujb.github.io/2017/07/07/java_leetcode4/index.html">
<meta property="og:site_name" content="Bob&#39;s Blog">
<meta property="og:description" content="刷题。祝我好运。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2017-07-07T16:26:30.000Z">
<meta property="article:modified_time" content="2021-03-20T03:05:16.880Z">
<meta property="article:author" content="Bob">
<meta property="article:tag" content="java">
<meta property="article:tag" content="algorithm">
<meta property="article:tag" content="interview">
<meta property="article:tag" content="leetcode">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://bobbyliujb.github.io/2017/07/07/java_leetcode4/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://bobbyliujb.github.io/2017/07/07/java_leetcode4/","path":"2017/07/07/java_leetcode4/","title":"Note for LeetCode in Java (301~400)"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Note for LeetCode in Java (301~400) | Bob's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-118868735-1"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-118868735-1","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js" defer></script>








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Bob's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#301-remove-invalid-parentheses"><span class="nav-number">1.</span> <span class="nav-text">301. remove-invalid-parentheses</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#303-range-sum-query-immutable"><span class="nav-number">2.</span> <span class="nav-text">303. range-sum-query-immutable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#304-range-sum-query-2d-immutable"><span class="nav-number">3.</span> <span class="nav-text">304. range-sum-query-2d-immutable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#306-additive-number"><span class="nav-number">4.</span> <span class="nav-text">306. additive-number</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%85307-range-sum-query-mutable"><span class="nav-number">5.</span> <span class="nav-text">待307. range-sum-query-mutable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#309-best-time-to-buy-and-sell-stock-with-cooldown"><span class="nav-number">6.</span> <span class="nav-text">309. best-time-to-buy-and-sell-stock-with-cooldown</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#310-minimum-height-trees"><span class="nav-number">7.</span> <span class="nav-text">310. minimum-height-trees</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#311-sparse-matrix-multiplication"><span class="nav-number">8.</span> <span class="nav-text">311. sparse-matrix-multiplication</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#312-burst-balloons"><span class="nav-number">9.</span> <span class="nav-text">312. burst-balloons</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#313-super-ugly-number"><span class="nav-number">10.</span> <span class="nav-text">313. super-ugly-number</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#314-binary-tree-vertical-order-traversal"><span class="nav-number">11.</span> <span class="nav-text">314. binary-tree-vertical-order-traversal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#316-remove-duplicate-letters"><span class="nav-number">12.</span> <span class="nav-text">316. remove-duplicate-letters</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#317-shortest-distance-from-all-buildings"><span class="nav-number">13.</span> <span class="nav-text">317. shortest-distance-from-all-buildings</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#318-maximum-product-of-word-lengths"><span class="nav-number">14.</span> <span class="nav-text">318. maximum-product-of-word-lengths</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#319-bulb-switcher"><span class="nav-number">15.</span> <span class="nav-text">319. bulb-switcher</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#320-generalized-abbreviation"><span class="nav-number">16.</span> <span class="nav-text">320. generalized-abbreviation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#321-create-maximum-number"><span class="nav-number">17.</span> <span class="nav-text">321. create-maximum-number</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#322-coin-change"><span class="nav-number">18.</span> <span class="nav-text">322. coin-change</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#323-number-of-connected-components-in-an-undirected-graph"><span class="nav-number">19.</span> <span class="nav-text">323. number-of-connected-components-in-an-undirected-graph</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#324-wiggle-sort-ii"><span class="nav-number">20.</span> <span class="nav-text">324. wiggle-sort-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#325-maximum-size-subarray-sum-equals-k"><span class="nav-number">21.</span> <span class="nav-text">325. maximum-size-subarray-sum-equals-k</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#326-power-of-three"><span class="nav-number">22.</span> <span class="nav-text">326. power-of-three</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#328-odd-even-linked-list"><span class="nav-number">23.</span> <span class="nav-text">328. odd-even-linked-list</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#329-longest-increasing-path-in-a-matrix"><span class="nav-number">24.</span> <span class="nav-text">329. longest-increasing-path-in-a-matrix</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#330-patching-array"><span class="nav-number">25.</span> <span class="nav-text">330. patching-array</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#331-verify-preorder-serialization-of-a-binary-tree"><span class="nav-number">26.</span> <span class="nav-text">331. verify-preorder-serialization-of-a-binary-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#332-reconstruct-itinerary"><span class="nav-number">27.</span> <span class="nav-text">332. reconstruct-itinerary</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#333-largest-bst-subtree"><span class="nav-number">28.</span> <span class="nav-text">333. largest-bst-subtree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#334-increasing-triplet-subsequence"><span class="nav-number">29.</span> <span class="nav-text">334. increasing-triplet-subsequence</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#335-self-crossing"><span class="nav-number">30.</span> <span class="nav-text">335. self-crossing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#336-palindrome-pairs"><span class="nav-number">31.</span> <span class="nav-text">336. palindrome-pairs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#337-house-robber-iii"><span class="nav-number">32.</span> <span class="nav-text">337. house-robber-iii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#338-counting-bits"><span class="nav-number">33.</span> <span class="nav-text">338. counting-bits</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#339-nested-list-weight-sum"><span class="nav-number">34.</span> <span class="nav-text">339. nested-list-weight-sum</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#341-flatten-nested-list-iterator"><span class="nav-number">35.</span> <span class="nav-text">341. flatten-nested-list-iterator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#342-power-of-four"><span class="nav-number">36.</span> <span class="nav-text">342. power-of-four</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#343-integer-break"><span class="nav-number">37.</span> <span class="nav-text">343. integer-break</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#344-reverse-string"><span class="nav-number">38.</span> <span class="nav-text">344. reverse-string</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#345-reverse-vowels-of-a-string"><span class="nav-number">39.</span> <span class="nav-text">345. reverse-vowels-of-a-string</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#346-moving-average-from-data-stream"><span class="nav-number">40.</span> <span class="nav-text">346. moving-average-from-data-stream</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#347-top-k-frequent-elements"><span class="nav-number">41.</span> <span class="nav-text">347. top-k-frequent-elements</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#348-design-tic-tac-toe"><span class="nav-number">42.</span> <span class="nav-text">348. design-tic-tac-toe</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#349-intersection-of-two-arrays"><span class="nav-number">43.</span> <span class="nav-text">349. intersection-of-two-arrays</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#350-intersection-of-two-arrays-ii"><span class="nav-number">44.</span> <span class="nav-text">350. intersection-of-two-arrays-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#352-data-stream-as-disjoint-intervals"><span class="nav-number">45.</span> <span class="nav-text">352. data-stream-as-disjoint-intervals</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#353-design-snake-game"><span class="nav-number">46.</span> <span class="nav-text">353. design-snake-game</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#354-russian-doll-envelopes"><span class="nav-number">47.</span> <span class="nav-text">354. russian-doll-envelopes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#355-design-twitter"><span class="nav-number">48.</span> <span class="nav-text">355. design-twitter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#356-line-reflection"><span class="nav-number">49.</span> <span class="nav-text">356. line-reflection</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#357-count-numbers-with-unique-digits"><span class="nav-number">50.</span> <span class="nav-text">357. count-numbers-with-unique-digits</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#358-rearrange-string-k-distance-apart"><span class="nav-number">51.</span> <span class="nav-text">358. rearrange-string-k-distance-apart</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#359-logger-rate-limiter"><span class="nav-number">52.</span> <span class="nav-text">359. logger-rate-limiter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#360-sort-transformed-array"><span class="nav-number">53.</span> <span class="nav-text">360. sort-transformed-array</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#362-design-hit-counter"><span class="nav-number">54.</span> <span class="nav-text">362. design-hit-counter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#363-max-sum-of-rectangle-no-larger-than-k"><span class="nav-number">55.</span> <span class="nav-text">363. max-sum-of-rectangle-no-larger-than-k</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#364-nested-list-weight-sum-ii"><span class="nav-number">56.</span> <span class="nav-text">364. nested-list-weight-sum-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#365-water-and-jug-problem"><span class="nav-number">57.</span> <span class="nav-text">365. water-and-jug-problem</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#366-find-leaves-of-binary-tree"><span class="nav-number">58.</span> <span class="nav-text">366. find-leaves-of-binary-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#367-valid-perfect-square"><span class="nav-number">59.</span> <span class="nav-text">367. valid-perfect-square</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#368-largest-divisible-subset"><span class="nav-number">60.</span> <span class="nav-text">368. largest-divisible-subset</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#369-plus-one-linked-list"><span class="nav-number">61.</span> <span class="nav-text">369. plus-one-linked-list</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#370-range-addition"><span class="nav-number">62.</span> <span class="nav-text">370. range-addition</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#371-sum-of-two-integers"><span class="nav-number">63.</span> <span class="nav-text">371. sum-of-two-integers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#372-super-pow"><span class="nav-number">64.</span> <span class="nav-text">372. super-pow</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#373-find-k-pairs-with-smallest-sums"><span class="nav-number">65.</span> <span class="nav-text">373. find-k-pairs-with-smallest-sums</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#374-guess-number-higher-or-lower"><span class="nav-number">66.</span> <span class="nav-text">374. guess-number-higher-or-lower</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#375-guess-number-higher-or-lower-ii"><span class="nav-number">67.</span> <span class="nav-text">375. guess-number-higher-or-lower-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#376-wiggle-subsequence"><span class="nav-number">68.</span> <span class="nav-text">376. wiggle-subsequence</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#377-combination-sum-iv"><span class="nav-number">69.</span> <span class="nav-text">377. combination-sum-iv</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#378-kth-smallest-element-in-a-sorted-matrix"><span class="nav-number">70.</span> <span class="nav-text">378. kth-smallest-element-in-a-sorted-matrix</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#379-design-phone-directory"><span class="nav-number">71.</span> <span class="nav-text">379. design-phone-directory</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#380-insert-delete-getrandom-o1"><span class="nav-number">72.</span> <span class="nav-text">380. insert-delete-getrandom-o1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#381-insert-delete-getrandom-o1-duplicates-allowed"><span class="nav-number">73.</span> <span class="nav-text">381. insert-delete-getrandom-o1-duplicates-allowed</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#382-linked-list-random-node"><span class="nav-number">74.</span> <span class="nav-text">382. linked-list-random-node</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#383-ransom-note"><span class="nav-number">75.</span> <span class="nav-text">383. ransom-note</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#384-shuffle-an-array"><span class="nav-number">76.</span> <span class="nav-text">384. shuffle-an-array</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#385-mini-parser"><span class="nav-number">77.</span> <span class="nav-text">385. mini-parser</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#386-lexicographical-numbers"><span class="nav-number">78.</span> <span class="nav-text">386. lexicographical-numbers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#387-first-unique-character-in-a-string"><span class="nav-number">79.</span> <span class="nav-text">387. first-unique-character-in-a-string</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#388-longest-absolute-file-path"><span class="nav-number">80.</span> <span class="nav-text">388. longest-absolute-file-path</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#389-find-the-difference"><span class="nav-number">81.</span> <span class="nav-text">389. find-the-difference</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#390-elimination-game"><span class="nav-number">82.</span> <span class="nav-text">390. elimination-game</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#391-perfect-rectangle"><span class="nav-number">83.</span> <span class="nav-text">391. perfect-rectangle</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#392-is-subsequence"><span class="nav-number">84.</span> <span class="nav-text">392. is-subsequence</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#394-decode-string"><span class="nav-number">85.</span> <span class="nav-text">394. decode-string</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#395-longest-substring-with-at-least-k-repeating-characters"><span class="nav-number">86.</span> <span class="nav-text">395. longest-substring-with-at-least-k-repeating-characters</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#396-rotate-function"><span class="nav-number">87.</span> <span class="nav-text">396. rotate-function</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#397-integer-replacement"><span class="nav-number">88.</span> <span class="nav-text">397. integer-replacement</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#398-random-pick-index"><span class="nav-number">89.</span> <span class="nav-text">398. random-pick-index</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#399-evaluate-division"><span class="nav-number">90.</span> <span class="nav-text">399. evaluate-division</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#400-nth-digit"><span class="nav-number">91.</span> <span class="nav-text">400. nth-digit</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Bob"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Bob</p>
  <div class="site-description" itemprop="description">I'm a Software Engineer!</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">48</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">49</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://bobbyliujb.github.io/2017/07/07/java_leetcode4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bob">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bob's Blog">
      <meta itemprop="description" content="I'm a Software Engineer!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Note for LeetCode in Java (301~400) | Bob's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Note for LeetCode in Java (301~400)
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-07-07 09:26:30" itemprop="dateCreated datePublished" datetime="2017-07-07T09:26:30-07:00">2017-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-03-19 20:05:16" itemprop="dateModified" datetime="2021-03-19T20:05:16-07:00">2021-03-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Tech/" itemprop="url" rel="index"><span itemprop="name">Tech</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2017/07/07/java_leetcode4/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/07/07/java_leetcode4/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>刷题。祝我好运。</p>
<span id="more"></span>

<h4 id="301-remove-invalid-parentheses"><a href="#301-remove-invalid-parentheses" class="headerlink" title="301. remove-invalid-parentheses"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-invalid-parentheses/#/description">301. remove-invalid-parentheses</a></h4><ul>
<li>给一个字符串，其中包含小括号和其他一些字符，这些括号可能并不匹配，移除尽可能少的括号使得字符串中的括号能valid，返回所有可能的结果。</li>
<li>ME：这和<a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-valid-parentheses/#/description">前面这个求最长匹配的括号子字符串长度</a>有那么一点点相似。回头看了一下求长度，可以用Stack也可以用DP，但是换到这题就陷入了江局。。。</li>
<li>TA：首先看了<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/34875/easy-short-concise-and-fast-java-dfs-3-ms-solution/">百事哥的DFS方法</a>，思路是先从左到右根据count判断右括号有没有多，一旦多了（count为负数）就开始尝试删除右括号，尝试的起点是last_j，即上一次删除的索引，重点是当前开始多出来的索引i。从前往后找非连续出现的右括号或者连续的右括号中的第一个，这样就可以保证得到的结果不会重复。但是对于左括号怎么办？那就从右往左再判断一波左括号，答主的做法是直接反转字符串，这样就可以重复使用代码了，当这一波也结束了，就可以把结果反转回来，加入结果List了。模仿了一波写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/109694060/">这样</a>。此外还有<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/28827/share-my-java-bfs-solution/">BFS的方法</a>，从完整的s开始入队，每次poll队首出来，判断是否valid，不valid就用循环尝试删除每一位的括号，并将生成的这些子字符串入队。为了防止重复，用到了Set来存放每一个出现的字符串，如果在Set中出现过就不再入队了。一旦出现了一个合法的，它就是删除最少的括号使之合法的，那么当前这一个level的所有字符串都验证完之后该存的存完之后，就不用继续了。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; validExpressions = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">removeInvalidParentheses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftToRemove</span> <span class="operator">=</span> <span class="number">0</span>, rightToRemove = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                leftToRemove++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 在没有多余的左括号的情况下才需要删除当前的右括号</span></span><br><span class="line">                rightToRemove = leftToRemove == <span class="number">0</span> ? rightToRemove + <span class="number">1</span> : rightToRemove;</span><br><span class="line">                <span class="comment">// 与之前的「多余」左括号相抵消</span></span><br><span class="line">                leftToRemove = leftToRemove &gt; <span class="number">0</span> ? leftToRemove - <span class="number">1</span> : leftToRemove;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(s, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, leftToRemove, rightToRemove, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(validExpressions);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(String s, <span class="type">int</span> index, <span class="type">int</span> leftCount, <span class="type">int</span> rightCount, <span class="type">int</span> leftRem, <span class="type">int</span> rightRem, StringBuilder curr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == s.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftRem == <span class="number">0</span> &amp;&amp; rightRem == <span class="number">0</span>) &#123;</span><br><span class="line">                validExpressions.add(curr.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(index);</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> curr.length();</span><br><span class="line">            <span class="keyword">if</span> ((c == <span class="string">&#x27;(&#x27;</span> &amp;&amp; leftRem &gt; <span class="number">0</span>) || (c == <span class="string">&#x27;)&#x27;</span> &amp;&amp; rightRem &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">                dfs(s, index + <span class="number">1</span>, leftCount, rightCount, leftRem - (c == <span class="string">&#x27;(&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>), rightRem - (c == <span class="string">&#x27;)&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>), curr);</span><br><span class="line">            &#125;</span><br><span class="line">            curr.append(c);</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">&#x27;(&#x27;</span> &amp;&amp; c != <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                dfs(s, index + <span class="number">1</span>, leftCount, rightCount, leftRem, rightRem, curr);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                dfs(s, index + <span class="number">1</span>, leftCount + <span class="number">1</span>, rightCount, leftRem, rightRem, curr);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (leftCount &gt; rightCount) &#123;    <span class="comment">// 拼接了右括号且目前左括号较多，则可以继续</span></span><br><span class="line">                dfs(s, index + <span class="number">1</span>, leftCount, rightCount + <span class="number">1</span>, leftRem, rightRem, curr);</span><br><span class="line">            &#125;</span><br><span class="line">            curr.deleteCharAt(len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="303-range-sum-query-immutable"><a href="#303-range-sum-query-immutable" class="headerlink" title="303. range-sum-query-immutable"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/range-sum-query-immutable/#/description">303. range-sum-query-immutable</a></h4><ul>
<li>给一个int数组，系统会调用rangeSum求两个索引之间的数字和（inclusive）。</li>
<li>ME：用一个cache存从第一个到当前索引的和，要用的时候减一下呗。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/108659810/">这样</a>。</li>
<li>TA：没啥。</li>
</ul>
<h4 id="304-range-sum-query-2d-immutable"><a href="#304-range-sum-query-2d-immutable" class="headerlink" title="304. range-sum-query-2d-immutable"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/range-sum-query-2d-immutable/#/description">304. range-sum-query-2d-immutable</a></h4><ul>
<li>给一个棋盘，求<code>(row1, col1)</code>和<code>(row2, col2)</code>所夹矩形的数字之和。</li>
<li>ME：和上题差不多吧，维护的变成了二维的棋盘，每一格寸的是从左上角到当前位置的元素之和。要求局部之和的时候就减去左边、上面再加回左上角的即可。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/108684944/">这样</a>。</li>
<li>TA：都差不多吧。</li>
</ul>
<h4 id="306-additive-number"><a href="#306-additive-number" class="headerlink" title="306. additive-number"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/additive-number/#/description">306. additive-number</a></h4><ul>
<li>给一个纯数字组成的字符串，判断它是否是additive number字符串，即前后相邻的两个数相加得到下一个数，一路直到最后都符合这种相加的关系。</li>
<li>ME：自己没搞出来。。。</li>
<li>TA：我没有搞清楚的是，只要前两个数确定了，后续数字就都确定了，要做的只是去验证一遍。所以只需要来一波双重循环确定前两个数即可。首先看的是<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/29856/java-recursive-and-iterative-solutions/">这个方法</a>，两个for的变量分别表示前两个数的长度，于是就确定了前两个数，继续往后check是否符合加法即可。check的时候一旦发现，当前这两个数之和的字符串不是后续字符串的开头（使用startsWith），就不用再检查了，跳出回到双重循环继续穷举前两个数吧。而为了防止越界问题，可以引入<code>import java.math.BigInteger</code>类。另外还有一个<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/30453/java-very-straightforward-solution-with-detailed-explanation/">挺简洁的recursive方法</a>。</li>
</ul>
<h4 id="待307-range-sum-query-mutable"><a href="#待307-range-sum-query-mutable" class="headerlink" title="待307. range-sum-query-mutable"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/range-sum-query-mutable/#/description">待307. range-sum-query-mutable</a></h4><ul>
<li>相比303，多了一个update(index, value)函数，可以更新原本输入的数组。</li>
<li>ME：一开始就想着直接每次更新的时候O(N)更新对应的sum数组呗，结果<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/108797164/">超时</a>。毕竟update调用次数和sumRange差不多的话，你这么更新相当于每次都是O(N)的sumRange，那和咸鱼有什么区别？陷入江局。。。感觉进入300题之后基本每题都会陷入江局啊&#x3D;_&#x3D;</li>
<li>TA：</li>
</ul>
<h4 id="309-best-time-to-buy-and-sell-stock-with-cooldown"><a href="#309-best-time-to-buy-and-sell-stock-with-cooldown" class="headerlink" title="309. best-time-to-buy-and-sell-stock-with-cooldown"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/#/description">309. best-time-to-buy-and-sell-stock-with-cooldown</a></h4><ul>
<li>又是这个股票的，相比121那几题多了一天的缓冲期，即出售后必须至少隔一天才能再买。同样是求无限次交易的最大收益。</li>
<li>ME：不会！很气！！连续发烧，状态全无。</li>
<li>TA：看了<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/30421/share-my-thinking-process/">百事哥的解答</a>终于懂了状态转换是个啥意思。答主给了三种状态，buy, sell和rest，buy就是消耗资金、sell是获得收益。buy[i]要么是继续保持前一天buy[i-1]买入的状态，要么是从两天前卖出sell[i-2]之后再减去当天购买股票要消耗的资金；sell[i]要么是保持前一天sell[i-1]卖出的状态，要么是前一天买入的资金加上今天出手时的价格。这个状态转换还是很清晰的。</li>
</ul>
<h4 id="310-minimum-height-trees"><a href="#310-minimum-height-trees" class="headerlink" title="310. minimum-height-trees"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-height-trees/#/description">310. minimum-height-trees</a></h4><ul>
<li>给一个整数n表示有n个点，再给n-1条边，将其中一个点作为根节点可以变成一个树的样子，求最小高度的树可以以哪些点为根。</li>
<li>ME：不会。。。。。。。。。</li>
<li>TA：又看了<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/30572/share-some-thoughts/">百事哥的解答</a>，和大神差距还是很大。思路是，这一坨东西中肯定有至少两个是叶子节点，即只有一个邻接边，每次把这些叶子节点都从它相邻的点的邻接列表中给抹去，相当于把level最低的这些节点从图中删除，然后会形成新的最低层叶子节点，一路遍历一路删，删到最顶上剩余节点一个或两个的时候，就可以输出结果了。邻接表这里用的是ArrayList + Set的形式存放，每次看看List中各个Set的size就知道它是不是叶子节点了。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/109837478/">这样</a>。</li>
</ul>
<h4 id="311-sparse-matrix-multiplication"><a href="#311-sparse-matrix-multiplication" class="headerlink" title="311. sparse-matrix-multiplication"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sparse-matrix-multiplication/description/">311. sparse-matrix-multiplication</a></h4><ul>
<li>给两个二维数组表示的sparse矩阵A和B，其中含有较多的0 element，实现矩阵乘法。</li>
<li>根据矩阵乘法的规律，只有<code>A[i][j]</code>不为0时才去<code>B[j][列数]</code>调取元素相乘并累加到结果矩阵中。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] multiply(<span class="type">int</span>[][] A, <span class="type">int</span>[][] B) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || B == <span class="literal">null</span> || A.length == <span class="number">0</span> || B.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> A.length, n = A[<span class="number">0</span>].length, nB = B[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] AB = <span class="keyword">new</span> <span class="title class_">int</span>[m][nB];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; nB; k++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (B[j][k] != <span class="number">0</span>) &#123;</span><br><span class="line">                            AB[i][k] += A[i][j] * B[j][k];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> AB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="312-burst-balloons"><a href="#312-burst-balloons" class="headerlink" title="312. burst-balloons"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/burst-balloons/#/description">312. burst-balloons</a></h4><ul>
<li>给一个整数数组表示一系列bonus，吹一个气球就能获得当前bonus乘以左、右相邻的bonus之积，同时该气球就从数组中取走了，然后继续。求最优的顺序使获得的总bonus最多。</li>
<li>ME：不会。。。。。。。。。。</li>
<li>TA：这题又是看<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/30746/share-some-analysis-and-explanations/">百事哥的帖子</a>，毕竟这些题好像还都是他添加的。这个问题首先要考虑哪一步的结果是确定的，因为你抽走了中间的一个数字之后，其左、右元素会并过来，所以不能简单地拆分成左、右两个子问题来做。但是你走到最后，只剩下一个元素的时候，乘积一定就直接是这个bonus了。所以可以用类似于回溯法的思路来思考，给定区间(left, right)，其中left和right位置的bonus不能够被选择&#x2F;清除，那么中间的某个元素i如果留到最后，它的bonus就是<code>num[left] * num[i] * num[right]</code>，至于剩下其他位置的就需要交给递归(left, i)和(i, right)来做。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/109846518/">这样</a>，用memo二维数组来节省不必要的递归。也可以改写成三重循环的DP，第一重循环从2开始到n，表示区间长度；第二重循环从0开始到n-k，表示起始位置，结束位置直接在循环入口由left + k确定；第三重循环从其实位置的下一位开始，这就是真正更新dp数组的位置了，dp[left][right] &#x3D; dp[left][i] + dp[i][right] + bonus[i]。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/109846793/">这样的</a>。</li>
</ul>
<h4 id="313-super-ugly-number"><a href="#313-super-ugly-number" class="headerlink" title="313. super-ugly-number"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/super-ugly-number/#/description">313. super-ugly-number</a></h4><ul>
<li>和前面264非常像，只不过把固定的2、3、5改成了一个可自定义的Prime数组。</li>
<li>ME：参考前面的做法<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/109863727/">搞出来了</a>。定义candidate数组，对应存放prime中每个数可能的倍数形式。而所乘的这个倍数需要来自ugly数组，每一个candidate当前的倍数在ugly中的索引也需要用一个index数组存起来。总的来说执行步骤是，来一波循环找出candidate中最小的那个放入ugly数组，然后在遍历一遍candidate数组找到符合这个最小值的项，根据index去更新。</li>
<li>TA：毕竟我这样每次都来一波循环求最小值并不划算，<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/34841/java-three-methods-23ms-36-ms-58ms-with-heap-performance-explained/">这个使用PriorityQueue的方法</a>深得我心，自定义了一个Number类，为了让PriorityQueue能排序，需要override一下compareTo函数。这样每次poll出来之后只需要再更新下一个倍数值，直接插入PriorityQueue，之后就可以直接取了。</li>
</ul>
<h4 id="314-binary-tree-vertical-order-traversal"><a href="#314-binary-tree-vertical-order-traversal" class="headerlink" title="314. binary-tree-vertical-order-traversal"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-vertical-order-traversal/description/">314. binary-tree-vertical-order-traversal</a></h4><ul>
<li>给一个二叉树，要求进行vertical level traversal， 如果垂直方向是平级的，则从上到下输出。</li>
<li>用Queue + Map解决。要判断垂直方向平级，就利用相对往左、往右移动的步数来判断，对应存到map中。不过事实上可以先走一波求出index的range，然后就可以直接往List里加了，不用额外的map。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> <span class="number">0</span>, maxIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">verticalOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; nodeQueue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; indexQueue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        nodeQueue.offer(root);</span><br><span class="line">        indexQueue.offer(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (!nodeQueue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">currNode</span> <span class="operator">=</span> nodeQueue.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">currIndex</span> <span class="operator">=</span> indexQueue.poll();</span><br><span class="line">            maxIndex = Math.max(maxIndex, currIndex);</span><br><span class="line">            minIndex = Math.min(minIndex, currIndex);</span><br><span class="line">            map.putIfAbsent(currIndex, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            map.get(currIndex).add(currNode.val);</span><br><span class="line">            <span class="keyword">if</span> (currNode.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                nodeQueue.offer(currNode.left);</span><br><span class="line">                indexQueue.offer(currIndex - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (currNode.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                nodeQueue.offer(currNode.right);</span><br><span class="line">                indexQueue.offer(currIndex + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> minIndex; i &lt;= maxIndex; i++) &#123;</span><br><span class="line">            ans.add(i - minIndex, map.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="316-remove-duplicate-letters"><a href="#316-remove-duplicate-letters" class="headerlink" title="316. remove-duplicate-letters"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-duplicate-letters/#/description">316. remove-duplicate-letters</a></h4><ul>
<li>给一个只含有小写字母的字符串，要求删除其中重复的字母，且删除后的结果必须lexicographical升序。</li>
<li>ME：不会。。。。。。。。。</li>
<li>TA：看了<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/31404/a-short-o-n-recursive-greedy-solution">这个greedy方法</a>感觉怎么这么简单&#x3D; &#x3D;。先来一波统计各个字母的出现频数，然后从头往后找当前最小的字母，把它作为第一个并删除后续字符串中的该字母，然后递归继续处理后续字符串。需要注意的是，如果在找最小字母的过程中发现某一个字母已经耗尽了，那么就不能再正常往后找了，因为耗尽的这个字母在后面不会再出现，因此必须以当前找到的最小字母为开头，这样就保证这个耗尽的字母不会被舍弃掉。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/109945116/">这样</a>。还可以使用Stack来存放字母，像<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/32259/java-solution-using-stack-with-comments/">这样</a>，若当前字母比栈顶字母小就弹出弹出，直到当前字母能放进去而不比栈顶的大，若栈中已有当前字母（用另一个数组标记）就直接跳过了。此外还有<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/31413/easy-to-understand-iterative-java-solution">纯iterative的方法</a>，思路是找到每个字母最后一个出现的位置，存入Map。然后遍历Map找到这些索引中的最小值，然后从0到这个最小值之间找最小的字母，并把这个字母从Map中删去，然后从该字母最后一次出现的下一位开始往后，到剩下那些字母中的最小索引位置。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicateLetters</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Character, Integer&gt; lastIndex = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Set&lt;Character&gt; inStack = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            lastIndex.put(chars[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inStack.contains(chars[i])) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; </span><br><span class="line">                   chars[i] &lt; stack.peek() &amp;&amp;</span><br><span class="line">                   lastIndex.get(stack.peek()) &gt; i) &#123;</span><br><span class="line">                inStack.remove(stack.pop());    <span class="comment">// 若栈顶字母更大且后续还有，就丢出来</span></span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(chars[i]);</span><br><span class="line">            inStack.add(chars[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(stack.size());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : stack) &#123;</span><br><span class="line">            sb.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="317-shortest-distance-from-all-buildings"><a href="#317-shortest-distance-from-all-buildings" class="headerlink" title="317. shortest-distance-from-all-buildings"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/shortest-distance-from-all-buildings/">317. shortest-distance-from-all-buildings</a></h4><ul>
<li>给一个grid，1表示楼房、2表示障碍物、0表示空地。求在哪个空地上可以到所有其他的楼房、且总路程最短，返回这个最小总路程。</li>
<li>近似于暴力的做法。维护一个distance二维数组，表示该空地到其他楼房的距离之和，同时维护一个reach二维数组，表示该空地可到达的楼房数量。从每个<code>1</code>出发进行BFS更新distance和reach，BFS时对于同一批的节点累积相同的steps。最后再走一波所有的空地，根据distance和reach来更新retVal，取最小值。时间复杂度为O(NM*NM). 这里最开始的这部统计1的个数只是为了在BFS中进行pruning，防止一个绝不可达的1.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestDistance</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 求所有1的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> grid.length, cols = grid[<span class="number">0</span>].length, buildingNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>; row &lt; rows; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; cols; col++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[row][col] == <span class="number">1</span>) &#123;</span><br><span class="line">                    buildingNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从1出发，累计每个1到每个0处的距离，同时统计0能到达的1的个数</span></span><br><span class="line">        <span class="type">int</span>[][] distance = <span class="keyword">new</span> <span class="title class_">int</span>[rows][cols], reachCount = <span class="keyword">new</span> <span class="title class_">int</span>[rows][cols];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>; row &lt; rows; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; cols; col++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[row][col] == <span class="number">1</span> &amp;&amp; !bfs(grid, distance, reachCount, row, col, buildingNum)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// 如果该1处并不能到达所有的其他的1，则这个1是孤立的、不可达的，直接返回-1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历所有0处，找到能到达所有1的最小距离</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">retVal</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>; row &lt; rows; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; cols; col++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[row][col] == <span class="number">0</span> &amp;&amp; reachCount[row][col] == buildingNum) &#123;</span><br><span class="line">                    retVal = Math.min(retVal, distance[row][col]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retVal == Integer.MAX_VALUE ? -<span class="number">1</span> : retVal;   <span class="comment">// 最后有可能没有0可以到达所有1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] dir = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span>[][] distance, <span class="type">int</span>[][] reachCount, <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> buildingNum)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> grid.length, cols = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[rows][cols];</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        visited[row][col] = <span class="literal">true</span>;</span><br><span class="line">        q.offer(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;row, col&#125;);</span><br><span class="line">        <span class="type">int</span> <span class="variable">steps</span> <span class="operator">=</span> <span class="number">1</span>, reached = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> q.size();</span><br><span class="line">            <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span>[] curr = q.poll();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">rowNext</span> <span class="operator">=</span> curr[<span class="number">0</span>] + dir[i];</span><br><span class="line">                    <span class="type">int</span> <span class="variable">colNext</span> <span class="operator">=</span> curr[<span class="number">1</span>] + dir[i + <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (rowNext &lt; <span class="number">0</span> || rowNext &gt;= rows ||</span><br><span class="line">                       colNext &lt; <span class="number">0</span> || colNext &gt;= cols ||</span><br><span class="line">                       visited[rowNext][colNext] ||</span><br><span class="line">                       grid[rowNext][colNext] == <span class="number">2</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    visited[rowNext][colNext] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (grid[rowNext][colNext] == <span class="number">1</span>) &#123;</span><br><span class="line">                        reached++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        distance[rowNext][colNext] += steps;</span><br><span class="line">                        reachCount[rowNext][colNext]++;</span><br><span class="line">                        q.offer(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;rowNext, colNext&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            steps++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reached == buildingNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="318-maximum-product-of-word-lengths"><a href="#318-maximum-product-of-word-lengths" class="headerlink" title="318. maximum-product-of-word-lengths"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-product-of-word-lengths/#/description">318. maximum-product-of-word-lengths</a></h4><ul>
<li>给一个String的数组，求其中没有重复字母的两个字符串长度之积的最大值。</li>
<li>ME：利用位运算，每一个字母出现则对应位置的bit置为1，然后两两作与运算，如果结果是0说明二者没有重复的字母，把他俩的长度乘一下即可。双重循环求出最大值。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/109971543/">这样</a>。</li>
<li>TA：差不多吧，位运算是最快最方便的了。</li>
</ul>
<h4 id="319-bulb-switcher"><a href="#319-bulb-switcher" class="headerlink" title="319. bulb-switcher"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/bulb-switcher/#/description">319. bulb-switcher</a></h4><ul>
<li>给一个整数n表示灯泡数，按照每一个、每两个…每n个的间隔反转灯泡状态，一开始全关，然后全开，然后隔一个关一个，然后隔两个toggle。。。</li>
<li>ME：一开始老老实实地按题意来做，<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/109974554/">超时</a>。。。</li>
<li>TA: 没想到<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/31929/math-solution/">这么无聊</a>。因为灯泡最后要能亮着，它经历的操作一定是奇数次，一个数有奇数个因数，那它一定是平方数，所以问题就转换成求n中含有多少个平方数了。写出来就<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/109978560/">这样</a>。</li>
</ul>
<h4 id="320-generalized-abbreviation"><a href="#320-generalized-abbreviation" class="headerlink" title="320. generalized-abbreviation"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/generalized-abbreviation/">320. generalized-abbreviation</a></h4><ul>
<li>给一个字符串，求它的所有用数字代替字母个数后可能的缩写形式。例如<code>abc</code>可以缩写成<code>[&quot;3&quot;,&quot;2c&quot;,&quot;1b1&quot;,&quot;1bc&quot;,&quot;a2&quot;,&quot;a1c&quot;,&quot;ab1&quot;,&quot;abc&quot;]</code>.</li>
<li>对于一个字母只有两种情况，要么将它缩写成数字，要么保留字母本身，因此最直接的想法就是递归解法。从前往后逐个字母走，若替换成数字则继续加上前面的数字，若保留字母本身则需要看看它前面是数字则需要先append上数字、再append上当前字母、清零字母计数。我觉得时间复杂度是O(2^N)，其中N是单词的长度，因为一共就是2^N种可能性，都需要访问一次。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateAbbreviations</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        generate(ans, word.toCharArray(), <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">generate</span><span class="params">(List&lt;String&gt; ans, <span class="type">char</span>[] wordChar, <span class="type">int</span> index, StringBuilder sb, <span class="type">int</span> charCount)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == wordChar.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (charCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sb.append(charCount);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(sb.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">originalLen</span> <span class="operator">=</span> sb.length();</span><br><span class="line">            generate(ans, wordChar, index + <span class="number">1</span>, sb, charCount + <span class="number">1</span>);</span><br><span class="line">            sb.setLength(originalLen);</span><br><span class="line">            <span class="keyword">if</span> (charCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sb.append(charCount);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(wordChar[index]);</span><br><span class="line">            generate(ans, wordChar, index + <span class="number">1</span>, sb, <span class="number">0</span>);</span><br><span class="line">            sb.setLength(originalLen);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="321-create-maximum-number"><a href="#321-create-maximum-number" class="headerlink" title="321. create-maximum-number"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/create-maximum-number/#/description">321. create-maximum-number</a></h4><ul>
<li>给两个一位整数的数组，给一个整数k，要求从两个数组中选取数字组成k位数，使它尽可能大。</li>
<li>ME：不会。。。。。。</li>
<li>TA：又是看了<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/32272/share-my-greedy-solution/">百事哥的解答</a>，思路是根据长度<code>i</code>确定第一个数组能得到的最大数组，然后根据<code>k - i</code>确定第二个数组能得到的最大数组，然后把他俩合并成一个长度为k的数组。主要分成了三个辅助函数。一个是greater，用于比较两个数组组成的数字谁更大，需要找出第一个不同的位置，然后直接判断首个不同的数字谁大。而是maxArray，根据传入的数组和所需的长度，找出最大的一个结果，在外层循环中从第一位遍历到最后一位，在内层取数字时需要与上一位结果进行比较，如果结果还比现在这位数字还小，那把当前数字覆盖掉之前的数字结果就能尽可能大，因此需要回退一波，再继续判断（因此要用while而不能简单地if），当然也不能太贪心一直要取最大的，免得到最后剩下的数字还不够填进去的，因此需要用一个判断<code>n - i + j &gt; k</code>来判断，i为循环变量表示已经从原数组中取到了多少位，j表示结果索引，n为原数组的数字个数，显然剩余数字加上已经取的数字应当大于k才能进行取舍，否则是没得挑的。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/109993027/">这样的</a>。</li>
</ul>
<h4 id="322-coin-change"><a href="#322-coin-change" class="headerlink" title="322. coin-change"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/coin-change/#/description">322. coin-change</a></h4><ul>
<li>给一个数组表示有哪些面值的硬币，然后给一个目标值，求最少用多少枚硬币能达到的这个目标值。</li>
<li>ME：这个很明显的DP，所以我会做，写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/110001596/">这样</a>。思路是从前往后更新DP数组，一开始全部初始化为-1表示不可达，dp[i]表示面值为i需要多少枚硬币，显然dp[0]应为0。对coin面值数组排序保证从小到大排列，然后开始从1更新。若<code>i - coin[j] &gt;= 0</code>说明可以从该状态加一枚coin[j]的硬币到达状态i，更新之，否则就可以直接跳出内层循环了，因为再往后看其他面值的coin只会负得更多。最后取dp[amount]即得。</li>
<li>TA：我的是Bottom-up的DP，从无到有累积到目标值。还有一种<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/32489/java-both-iterative-and-recursive-solutions-with-explanations">Top-down的思路</a>，利用递归来直接从目标值往回减。递归的结束条件有两种，一个是target减完成了负数，则不存在，返回0；若target恰好是0，那么直接返回0表示不需要额外添加硬币；还有就是如果在之前的结果中已经计算出了DP的值，直接返回即可。否则就逐个取出coin面值，然后用当前target减去这个面值递归到下一层去看需要多少枚硬币，该结果如果存在，则加一即为当前target所需的硬币数。需要尝试所有面值的硬币来找到最小值。模仿出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/110003917/">这样</a>。</li>
</ul>
<h4 id="323-number-of-connected-components-in-an-undirected-graph"><a href="#323-number-of-connected-components-in-an-undirected-graph" class="headerlink" title="323. number-of-connected-components-in-an-undirected-graph"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/description/">323. number-of-connected-components-in-an-undirected-graph</a></h4><ul>
<li>给一个n和由0~n-1组成的边，求这些node和edge组成多少个独立的components。</li>
<li>方法一：并查集，指定每一组的祖先，最后再一波遍历看看有多少个root即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countComponents</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (edges == <span class="literal">null</span> || edges.length == <span class="number">0</span> || edges[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] id = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(id, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; edges.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">fromRoot</span> <span class="operator">=</span> find(id, edges[i][<span class="number">0</span>]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">toRoot</span> <span class="operator">=</span> find(id, edges[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (fromRoot != toRoot) &#123;</span><br><span class="line">                id[fromRoot] = toRoot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (id[i] == -<span class="number">1</span>) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] id, <span class="type">int</span> p)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (id[p] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (id[id[p]] != -<span class="number">1</span>) id[p] = id[id[p]];</span><br><span class="line">            p = id[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更标准的并查集：以每个index作为label判定是否是root，而不是-1；而且最后也不用一波统计了。</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countComponents</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] roots = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) roots[i] = i; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>[] e : edges) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">root1</span> <span class="operator">=</span> find(roots, e[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">root2</span> <span class="operator">=</span> find(roots, e[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(root1 != root2) &#123;      </span><br><span class="line">            roots[root1] = root2;  <span class="comment">// union</span></span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] roots, <span class="type">int</span> id)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(roots[id] != id) &#123;</span><br><span class="line">        roots[id] = roots[roots[id]];  <span class="comment">// optional: path compression</span></span><br><span class="line">        id = roots[id];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：先把图建起来，然后用BFS／DFS来count。</li>
</ul>
<h4 id="324-wiggle-sort-ii"><a href="#324-wiggle-sort-ii" class="headerlink" title="324. wiggle-sort-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/wiggle-sort-ii/#/description">324. wiggle-sort-ii</a></h4><p> * </p>
<h4 id="325-maximum-size-subarray-sum-equals-k"><a href="#325-maximum-size-subarray-sum-equals-k" class="headerlink" title="325. maximum-size-subarray-sum-equals-k"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/description/">325. maximum-size-subarray-sum-equals-k</a></h4><ul>
<li>给一个int数组和一个target sum k，求subarray whose sum等于k中的最长长度。</li>
<li>这种根据sum在数组中找xxx的问题，通常都用map。既然我是要通过sum找在数组中的位置，map中存的就是sum-index pair。如果当前累计的sum减去targetSum在map中出现过，说明该index到当前处这部分的和就是targetSum，更新一下maxLen即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArrayLen</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>, maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 记录从开头到当前index的sum</span></span><br><span class="line">        <span class="comment">// 需要sum -&gt; index保证通过sum访问index是O(1)时间</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; sum2Index = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (sum == k) &#123;</span><br><span class="line">                maxLen = i + <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum2Index.containsKey(sum - k)) &#123;    <span class="comment">// 若有说明index~i这段的和就是k</span></span><br><span class="line">                maxLen = Math.max(maxLen, i - sum2Index.get(sum - k));</span><br><span class="line">            &#125;</span><br><span class="line">            sum2Index.putIfAbsent(sum, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="326-power-of-three"><a href="#326-power-of-three" class="headerlink" title="326. power-of-three"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/power-of-three/#/description">326. power-of-three</a></h4><ul>
<li>给一个int，判断它是否3的幂。</li>
<li>ME：前面231是判断是否2的幂，用while不断乘3判断，写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/109496147/">这样</a>。但是题目问能不能不要用循环或递归，在之前的2的幂用的是bit的特点，n &amp; (n - 1)这样搞的，这个我就不知所措了。。</li>
<li>TA：没想到是<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/36150/1-line-java-solution-without-loop-recursion">这样的</a>，直接用int范围内最大的一个3的幂模n，为0就说明n也是3的幂。</li>
</ul>
<h4 id="328-odd-even-linked-list"><a href="#328-odd-even-linked-list" class="headerlink" title="328. odd-even-linked-list"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/odd-even-linked-list/#/description">328. odd-even-linked-list</a></h4><ul>
<li>给一个链表，要求将奇数位置的节点挪到链表前半部分、偶数的节点放到后半部分。要求in-place且时间复杂度为O(N)。</li>
<li>ME：从前往后遍历一波找到链表最后一个节点作为边界，然后再从头开始处理，把当前节点的后两个节点作为下一个节点，而原本的下一个节点直接丢到链表末尾拼接上去，一直处理直到碰到边界。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/110128337/">这样</a>。</li>
<li>TA：额，你需要先遍历一波找末尾元素这个不太优雅，<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/34292/simple-o-n-time-o-1-space-java-solution">这个</a>直接新建一个even一个odd然后逐步往后拼的方法更优雅。</li>
</ul>
<h4 id="329-longest-increasing-path-in-a-matrix"><a href="#329-longest-increasing-path-in-a-matrix" class="headerlink" title="329. longest-increasing-path-in-a-matrix"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-increasing-path-in-a-matrix/#/description">329. longest-increasing-path-in-a-matrix</a></h4><ul>
<li>给一个矩阵，求从某一点开始沿上下左右的最长的完美升序路径的长度。</li>
<li>ME：带memory的DFS咯，如果已经访问过该点就直接返回从该点出发的最长升序路径长度，否则就沿上下左右拓展，若大于等于该方向的数直接返回1，否则就返回DFS该方向的结果加1。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/110133975/">这样</a>。</li>
<li>TA：思路差不多，<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/34835/15ms-concise-java-solution/">别人的写得更优雅</a>。</li>
</ul>
<h4 id="330-patching-array"><a href="#330-patching-array" class="headerlink" title="330. patching-array"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/patching-array/#/description">330. patching-array</a></h4><ul>
<li>给一个排好序的数组，给一个目标值n，要求通过数组中的这些数字任意组合之和能够覆盖[1, n]这个范围内（含边界的所有数字），若不满足则可以往里加数字，求最少加多少个数字能满足要求。</li>
<li>ME：一开始想到Set的方法，将当前Set中的数字导入Queue之后，逐个取出并加上后续的数字，然后塞进Set中。然后从前往后遍历，如果Set的规模已经达到n就结束，否则找到第一个Set中缺乏的元素，然后加入进去，然后对应再更新Set即通过这个数字加上Set中原本的数字能够得到哪些新的数字。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/110147540/">这样</a>，但是如果n非常大就爆内存了。</li>
<li>TA：又看了<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/35494/solution-explanation">这个眼熟大神的方法</a>才恍然大悟。假设给定范围是<code>[1, n]</code>，假设缺的数字为miss，从1开始，从nums数组中取出数字nums[i]，若不大于miss，则<code>[1, miss + nums[i] - 1]</code>范围内都能取到了，下一个缺的数字就更新为<code>miss + nums[i]</code>；但如果nums[i]超过了miss，说明仅凭这些数字没有办法凑出miss，因此就补一个miss，因此可达范围就更新为<code>[1, miss + miss - 1]</code>，下一个缺乏的数字就变成了<code>miss + miss</code>。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/110151201/">这样</a>。</li>
</ul>
<h4 id="331-verify-preorder-serialization-of-a-binary-tree"><a href="#331-verify-preorder-serialization-of-a-binary-tree" class="headerlink" title="331. verify-preorder-serialization-of-a-binary-tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/#/description">331. verify-preorder-serialization-of-a-binary-tree</a></h4><ul>
<li>给一个二叉树的前序遍历serialize的字符串，判断这个字符串能否还原出一棵二叉树（但不能真的去还原）。</li>
<li>ME：用Stack搞定。将原字符串以逗号分隔，为数字则push(0)，为<code>#</code>则对栈顶数字加一，若达到了2则弹出，并对前一个数字加一。在这个过程中如果栈已经弹空了而节点还没有遍历完成，说明数字有多，不合法。一直到最后如果栈恰好弹空，则完美。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/110224877/">这样</a>。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/35976/7-lines-easy-java-solution/">百事哥还是6</a>。思路是，每一个节点分为两种边，一定有一个in边，若不是空节点则还有两个out边。初始化计数为diff，从第一个节点开始遍历，默认会因为in边减1，再根据<code>#</code>决定是否加上两个out边。</li>
</ul>
<h4 id="332-reconstruct-itinerary"><a href="#332-reconstruct-itinerary" class="headerlink" title="332. reconstruct-itinerary"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reconstruct-itinerary/#/description">332. reconstruct-itinerary</a></h4><ul>
<li>给一系列机票出发地&#x2F;目的地的字符串数组，求一条字典序最小的路径能用遍这些机票。</li>
<li>ME：一开始只想到如何取字典序最小，就是HashMap + PriorityQueue的组合，每次给定一个出发机场就能够拿到目的地中的最小者，但是没留意到可能最小的这条路是个死胡同，去了就回不来了、没法遍历全部目的地。没办法，只能老老实实地DFS。为了保证字典序最小，必须先对这些机场排个序再对应赋索引值，这样按顺序从左到右遍历目的地的时候一定是按照字典序从小到大遍历的，那先达到的答案就一定是字典序最小的了。我一开始提交还没有注意到机票可能有重复的，因此直接用了二维boolean作为邻接矩阵，最后改成<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/110259901/">这样</a>才过了。</li>
<li>TA：卧槽，没想到我一开始的想法确实是可以的，<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/36383/share-my-solution">百事哥</a>就是这么搞出来的。在DFS的时候，对于每个起始点都获取它能到达的目的地的PriorityQueue，按顺序取出来就是字典序最小的，poll出来后DFS它。当它所有的目的地都已遍历结束，就把当前的这个字符串addFirst到结果List中，表示是从我出发前往的。只能说，很强。</li>
</ul>
<h4 id="333-largest-bst-subtree"><a href="#333-largest-bst-subtree" class="headerlink" title="333. largest-bst-subtree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/largest-bst-subtree/submissions/">333. largest-bst-subtree</a></h4><ul>
<li>给一个二叉树跟节点，求其中能够形成BST的最大子树的size。</li>
<li>构建一个类保存当前子树的size、最小值和最大值，当size小于0就表示当前子树不是合法的BST。用一个全局变量维护最大的BST子树size。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">        <span class="type">int</span> size;</span><br><span class="line">        <span class="type">int</span> min;</span><br><span class="line">        <span class="type">int</span> max;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(<span class="type">int</span> size, <span class="type">int</span> min, <span class="type">int</span> max)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.size = size;</span><br><span class="line">            <span class="built_in">this</span>.min = min;</span><br><span class="line">            <span class="built_in">this</span>.max = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestBSTSubtree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">maxSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Result <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">Result</span> <span class="variable">retVal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">0</span>, Integer.MAX_VALUE, Integer.MIN_VALUE);</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Result</span> <span class="variable">leftResult</span> <span class="operator">=</span> traverse(root.left);</span><br><span class="line">            <span class="type">Result</span> <span class="variable">rightResult</span> <span class="operator">=</span> traverse(root.right);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (leftResult.size &lt; <span class="number">0</span> || rightResult.size &lt; <span class="number">0</span> ||</span><br><span class="line">                root.val &lt;= leftResult.max || root.val &gt;= rightResult.min) &#123;</span><br><span class="line">                retVal = <span class="keyword">new</span> <span class="title class_">Result</span>(-<span class="number">1</span>, Integer.MAX_VALUE, Integer.MIN_VALUE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 最小值出现在左子树，最大值出现在右子树</span></span><br><span class="line">                retVal = <span class="keyword">new</span> <span class="title class_">Result</span>(leftResult.size + rightResult.size + <span class="number">1</span>,</span><br><span class="line">                                    Math.min(leftResult.min, root.val),</span><br><span class="line">                                    Math.max(rightResult.max, root.val));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxSize = Math.max(retVal.size, maxSize);</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="334-increasing-triplet-subsequence"><a href="#334-increasing-triplet-subsequence" class="headerlink" title="334. increasing-triplet-subsequence"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/increasing-triplet-subsequence/#/description">334. increasing-triplet-subsequence</a></h4><ul>
<li>给一个数组，判断它是否包含长度为3的升序子序列（可以不连续）。要求O(N)的时间复杂度，O(1)的空间。</li>
<li>ME：一波流遍历。每次需要更新最小值min，若当前值大于min，说明这是一个长度为2的升序，接下来只需要找到比结尾数字更大的就是一个长度为3的升序了。但可能往后找的过程中会出现新的min，或者出现比min大同时又比结尾数字小的，都需要更新。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/110268678/">这样</a>。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/37426/concise-java-solution-with-comments">别人写得更清晰简洁</a>，只需要维护第一个元素small和第二个元素big即可。</li>
</ul>
<h4 id="335-self-crossing"><a href="#335-self-crossing" class="headerlink" title="335. self-crossing"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/self-crossing/#/description">335. self-crossing</a></h4><ul>
<li>给一个含有正整数的数组，表示从原点出发，依次沿上下左右走的长度，判断路径是否会交叉。</li>
<li>ME：不会。。。</li>
<li>TA：这题似乎没什么意思，就是找规律。比如<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/38014/java-oms-with-explanation">这个</a>。</li>
</ul>
<h4 id="336-palindrome-pairs"><a href="#336-palindrome-pairs" class="headerlink" title="336. palindrome-pairs"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/palindrome-pairs/#/description">336. palindrome-pairs</a></h4><ul>
<li>给一个字符串数组，求索引对的List使得word[i]和word[j]拼接而成的字符串自对称。</li>
<li>ME：第一反应和前面的<a target="_blank" rel="noopener" href="https://leetcode.com/problems/shortest-palindrome/#/description">214. shortest-palindrome</a>有点像，但那个是在前面拼接最短的字符串使之自对称，但这里不论长短、前后，能使它自对称就OK。然而不会啊。。。</li>
<li>TA：我擦，没想到<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/40657/150-ms-45-lines-java-solution">这样直接暴力破解</a>也可以，写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/110418729/">这样</a>。先一波流把每个字符串放到Map中形成字符串袄索引的映射，然后取每个字符串，用内层循环截成前后两个部分，判断是否对称，然后再适当反转后查找是否存在于Map中，对应添加即可。需要注意的是防止重复，可能需要根据长度判断取还是不取。不过其实这题考察的是Trie结构，所以不提倡前面的暴力法，得看<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/39585/o-n-k-2-java-solution-with-trie-structure-n-total-number-of-words-k-average-length-of-each-word">这个</a>。</li>
<li>方法一: 一个字符串能和另一个组成palidrome分三种情况，一是自身和对方长度长度相等且互为reverse；二是自身前半部分是pali，只需要后半部分能找到对应的reverse即可，将reverse拼在前方；三是自身的后半部分是pali，只需要前半部分找到对应reverse即可，reverse拼在后方。假设最长的字符串长度为k，时间复杂度为<code>O(k^2 * N)</code>，其中的<code>k^2</code>消耗在找所有的prefix&#x2F;suffix上。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">palindromePairs</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; retVal = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (words == <span class="literal">null</span> || words.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> retVal;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, Integer&gt; word2Index = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            word2Index.put(words[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">currIndex</span> <span class="operator">=</span> word2Index.get(word);</span><br><span class="line">            <span class="comment">// word + reverse的形式</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">rev</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(word).reverse().toString();</span><br><span class="line">            <span class="keyword">if</span> (!word.equals(rev) &amp;&amp; word2Index.containsKey(rev)) &#123;</span><br><span class="line">                retVal.add(Arrays.asList(currIndex, word2Index.get(rev)));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// [prefix + pali] + prefixReverse的形式</span></span><br><span class="line">            List&lt;String&gt; prefixes = getPrefixesBeforePali(word);</span><br><span class="line">            <span class="keyword">for</span> (String prefix : prefixes) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">prefixReverse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(prefix).reverse().toString();</span><br><span class="line">                <span class="keyword">if</span> (word2Index.containsKey(prefixReverse)) &#123;</span><br><span class="line">                    retVal.add(Arrays.asList(currIndex, word2Index.get(prefixReverse)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// suffixReverse + [pali + suffix]的形式</span></span><br><span class="line">            List&lt;String&gt; suffixes = getSuffixesAfterPali(word);</span><br><span class="line">            <span class="keyword">for</span> (String suffix : suffixes) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">suffixReverse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(suffix).reverse().toString();</span><br><span class="line">                <span class="keyword">if</span> (word2Index.containsKey(suffixReverse)) &#123;</span><br><span class="line">                    retVal.add(Arrays.asList(word2Index.get(suffixReverse), currIndex));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; <span class="title function_">getPrefixesBeforePali</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        List&lt;String&gt; retVal = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isValidPali(word, i, word.length() - <span class="number">1</span>)) &#123;</span><br><span class="line">                retVal.add(word.substring(<span class="number">0</span>, i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; <span class="title function_">getSuffixesAfterPali</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        List&lt;String&gt; retVal = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isValidPali(word, <span class="number">0</span>, i)) &#123;</span><br><span class="line">                retVal.add(word.substring(i + <span class="number">1</span>, word.length()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValidPali</span><span class="params">(String str, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(left++) != str.charAt(right--)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="337-house-robber-iii"><a href="#337-house-robber-iii" class="headerlink" title="337. house-robber-iii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/house-robber-iii/#/description">337. house-robber-iii</a></h4><ul>
<li>给一个二叉树，每个节点表示所能抢到的钱财，强盗不能同时抢具有直接父子关系的两个节点。求最大收益。</li>
<li>ME：偷看了<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/39834/step-by-step-tackling-of-the-problem">这个</a>写出了个最慢最low的无脑递归方法，写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/110433121/">这样</a>。反正就是取当前节点加上后左节点的两个孩子和右节点的两个孩子（可能为空），然后与左右孩子递归结果之和做比较，取较大者。不过似乎有重复计算的节点，比较浪费时间，可以用<code>HashMap&lt;TreeNode, Integer&gt;</code>记录下来，不过<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/110536625/">也不算特别快</a>？</li>
<li>TA：最后的那个方法是记录状态的，有点DP的意思，写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/110540431/">这样</a>。利用一个辅助函数，返回数组int[2]，索引0表示不取当前节点的时候的最大收益、1则表示取，对应地就可以求左节点和右节点取和不取的值，对应加一下，最后返回取或不取root的最大值。</li>
</ul>
<h4 id="338-counting-bits"><a href="#338-counting-bits" class="headerlink" title="338. counting-bits"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/counting-bits/#/description">338. counting-bits</a></h4><ul>
<li>给一个正整数num，返回size为num + 1的数组，每个位置对应存放该索引的bit形式含有的1的数量。</li>
<li>ME：最naive的方法，遍历一遍，每个都求一次1有多少个，写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/110542361/">这样</a>。但是题目问能不能做到one-pass，不要每个都重新求。我就观察出了规律，把2的幂作为分界，后面都依赖于前面（减去这个幂）的结果，写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/110544492/">这样</a>，不过速度好慢。。。</li>
<li>TA：原来还可以<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/40162/three-line-java-solution">这么简洁</a>，规律是直接利用除2的索引和是否为奇数来求，写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/110545297/">这样</a>.后来还看到了<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/50315/a-summary-how-to-use-bit-manipulation-to-solve-problems-easily-and-efficiently">一个用了循环的方法</a>，也是挺6。</li>
</ul>
<h4 id="339-nested-list-weight-sum"><a href="#339-nested-list-weight-sum" class="headerlink" title="339. nested-list-weight-sum"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/nested-list-weight-sum/description/">339. nested-list-weight-sum</a></h4><ul>
<li>给一个nested的list，根据nested的深度赋予weight，深度深一层weight就加1，求weighted sum。</li>
<li>递归解决。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the interface that allows for creating nested lists.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * public interface NestedInteger &#123;</span></span><br><span class="line"><span class="comment"> *     // Constructor initializes an empty nested list.</span></span><br><span class="line"><span class="comment"> *     public NestedInteger();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Constructor initializes a single integer.</span></span><br><span class="line"><span class="comment"> *     public NestedInteger(int value);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // <span class="doctag">@return</span> true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line"><span class="comment"> *     public boolean isInteger();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // <span class="doctag">@return</span> the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line"><span class="comment"> *     // Return null if this NestedInteger holds a nested list</span></span><br><span class="line"><span class="comment"> *     public Integer getInteger();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Set this NestedInteger to hold a single integer.</span></span><br><span class="line"><span class="comment"> *     public void setInteger(int value);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.</span></span><br><span class="line"><span class="comment"> *     public void add(NestedInteger ni);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // <span class="doctag">@return</span> the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line"><span class="comment"> *     // Return null if this NestedInteger holds a single integer</span></span><br><span class="line"><span class="comment"> *     public List&lt;NestedInteger&gt; getList();</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">depthSum</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nestedList == <span class="literal">null</span> || nestedList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getSum(nestedList, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(List&lt;NestedInteger&gt; nestedList, <span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (NestedInteger i : nestedList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i.isInteger()) &#123;</span><br><span class="line">                sum += level * i.getInteger();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += getSum(i.getList(), level + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="341-flatten-nested-list-iterator"><a href="#341-flatten-nested-list-iterator" class="headerlink" title="341. flatten-nested-list-iterator"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/flatten-nested-list-iterator/#/description">341. flatten-nested-list-iterator</a></h4><ul>
<li>设计题，一个NestedInteger类List的遍历，即List中元素可能为List也可能为Integer，转化成纯Integer的List。</li>
<li>ME：递归把数字都存起来呗，写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/110547755/">这样</a>。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/42042/simple-java-solution-using-a-stack-with-explanation">这个</a>告诉你还可以用Stack改写成Iterative的，写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/110551399/">这样</a>。</li>
</ul>
<h4 id="342-power-of-four"><a href="#342-power-of-four" class="headerlink" title="342. power-of-four"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/power-of-four/#/description">342. power-of-four</a></h4><ul>
<li>给一个int，判断它是否4的幂。</li>
<li>ME：这题都不想自己写循环&#x2F;递归的了，但还是想不出一行的解法。</li>
<li>TA：没想到就只是比2的幂多了一步判断而已，比如<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/44430/simple-c-o-1-solution-without-0x55555555/">这个</a>是利用num  - 1一定是3的倍数来搞的，另外就是<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/42860/java-1-line-cheating-for-the-purpose-of-not-using-loops">利用<code>0x55555555</code></a>来确认bit中的1是否出现在奇数位。</li>
</ul>
<h4 id="343-integer-break"><a href="#343-integer-break" class="headerlink" title="343. integer-break"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/integer-break/#/description">343. integer-break</a></h4><ul>
<li>给一个正整数，将它拆分成至少两个正整数之和，使得这些小正整数之积最大，求这个积。</li>
<li>ME：用了DP，近似于O(N^2)的复杂度，写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/110553184/">这样</a>。</li>
<li>TA：没想到还能<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/45341/a-simple-explanation-of-the-math-part-and-a-o-n-solution/2">这样直接找规律</a>，所有这些小整数，只要尽可能多一些3就能使积最大了。</li>
</ul>
<h4 id="344-reverse-string"><a href="#344-reverse-string" class="headerlink" title="344. reverse-string"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-string/#/description">344. reverse-string</a></h4><ul>
<li>反转字符串。</li>
<li>ME：没啥，就<a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-string/#/description">这样</a></li>
<li>TA：没啥。</li>
</ul>
<h4 id="345-reverse-vowels-of-a-string"><a href="#345-reverse-vowels-of-a-string" class="headerlink" title="345. reverse-vowels-of-a-string"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-vowels-of-a-string/#/description">345. reverse-vowels-of-a-string</a></h4><ul>
<li>反转字符串中的元音字母。</li>
<li>ME：用个set放元音字母，然后一前一后俩指针对换呗，写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/109504011/">这样</a>。</li>
<li>TA：没啥。</li>
<li>Set的初始化方法：<code>Set&lt;Character&gt; vowels = new HashSet&lt;&gt;(Arrays.asList(new Character[]&#123;&#39;a&#39;,&#39;e&#39;,&#39;i&#39;,&#39;o&#39;,&#39;u&#39;,&#39;A&#39;,&#39;E&#39;,&#39;I&#39;,&#39;O&#39;,&#39;U&#39;&#125;));</code>，而不用一个个add。</li>
</ul>
<h4 id="346-moving-average-from-data-stream"><a href="#346-moving-average-from-data-stream" class="headerlink" title="346. moving-average-from-data-stream"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/moving-average-from-data-stream/description/">346. moving-average-from-data-stream</a></h4><ul>
<li>求moving average。其实就是维护一个sum，初一下就好了。skip.</li>
</ul>
<h4 id="347-top-k-frequent-elements"><a href="#347-top-k-frequent-elements" class="headerlink" title="347. top-k-frequent-elements"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/top-k-frequent-elements/#/description">347. top-k-frequent-elements</a></h4><ul>
<li>给一个乱序的int数组，给一个k，求这个数组中出现频数前k高的数，要求时间复杂度优于O( N*logN )。</li>
<li>ME：其实不是自己做出来的，看了<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/44237/java-o-n-solution-bucket-sort">这个O(N)木桶法</a>，真的叼，写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/109631491/">这样</a>。先扫一遍统计各个数值与对应的频数，构建map映射；然后就是木桶排序了，这里的木桶索引的意义是『频数』，存放的是该频数对应的所有数值的List，也就是从map的keySet()遍历各个key的value，根据这个value确定索引，然后把key给add到木桶对应索引的List中。最后再木桶末尾往前取k个即可。</li>
<li>TA：木桶法确实不太好想具体的索引意义，但是用普通的堆你应该是能想到才对，就像<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/48158/3-java-solution-using-array-maxheap-treemap">这个</a>，priorityQueue或者TreeMap都可以啊。PriorityQueue需要根据map的value从大到小排序，才能保证队首拿的是频数最高的，而TreeMap可以任意从头从尾取，所以默认的话就是从小到大，从尾取即可。</li>
<li>Map遍历用keySet()获得key的集合，再for-each逐个取吧。Map在put的时候可以用<code>getOrDefault(key, defalutValue)</code>来省去判断<code>containsKey</code>的单独的if。</li>
</ul>
<h4 id="348-design-tic-tac-toe"><a href="#348-design-tic-tac-toe" class="headerlink" title="348. design-tic-tac-toe"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/design-tic-tac-toe/description/">348. design-tic-tac-toe</a></h4><ul>
<li>XXOO游戏，两个玩家，每一行、每一列、两条对角线都是一样的话，对应玩家就赢了。要设计一个class，其中包含move函数，给坐标和玩家编号，在图里放，如果该玩家赢了就返回玩家编号。每行、每列需要统计两个玩家各自的个数，如果都是其中一个玩家都就赢了，两条对角线也是。</li>
<li>记录行、列、两条对较线。区分两个玩家的O和X就通过正负一来判断，这样如果有一个玩家赢了就意味着一路相加结果是n或者-n</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TicTacToe</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] rows;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] cols;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> diag1, diag2;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TicTacToe</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        rows = <span class="keyword">new</span> <span class="title class_">int</span> [n];</span><br><span class="line">        cols = <span class="keyword">new</span> <span class="title class_">int</span> [n];</span><br><span class="line">        diag1 = <span class="number">0</span>;</span><br><span class="line">        diag2 = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Player &#123;player&#125; makes a move at (&#123;row&#125;, &#123;col&#125;).</span></span><br><span class="line"><span class="comment">        <span class="doctag">@param</span> row The row of the board.</span></span><br><span class="line"><span class="comment">        <span class="doctag">@param</span> col The column of the board.</span></span><br><span class="line"><span class="comment">        <span class="doctag">@param</span> player The player, can be either 1 or 2.</span></span><br><span class="line"><span class="comment">        <span class="doctag">@return</span> The current winning condition, can be either:</span></span><br><span class="line"><span class="comment">                0: No one wins.</span></span><br><span class="line"><span class="comment">                1: Player 1 wins.</span></span><br><span class="line"><span class="comment">                2: Player 2 wins. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">move</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> player)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= n || col &lt; <span class="number">0</span> || row &gt;= n || player &lt; <span class="number">1</span> || player &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">addVal</span> <span class="operator">=</span> player == <span class="number">1</span>? -<span class="number">1</span>: <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// for diag1</span></span><br><span class="line">        <span class="keyword">if</span> (row == col) &#123;</span><br><span class="line">            diag1 += addVal;</span><br><span class="line">            <span class="keyword">if</span> (isConnect(diag1)) &#123;</span><br><span class="line">                <span class="keyword">return</span> player;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// for diag2</span></span><br><span class="line">        <span class="keyword">if</span> (row + col == n - <span class="number">1</span>) &#123;</span><br><span class="line">            diag2 += addVal;</span><br><span class="line">            <span class="keyword">if</span> (isConnect(diag2)) &#123;</span><br><span class="line">                <span class="keyword">return</span> player;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// for row</span></span><br><span class="line">        rows[row] += addVal;</span><br><span class="line">        <span class="keyword">if</span> (isConnect(rows[row])) &#123;</span><br><span class="line">            <span class="keyword">return</span> player;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// for col</span></span><br><span class="line">        cols[col] += addVal;</span><br><span class="line">        <span class="keyword">if</span> (isConnect(cols[col])) &#123;</span><br><span class="line">            <span class="keyword">return</span> player;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isConnect</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> val / n != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="349-intersection-of-two-arrays"><a href="#349-intersection-of-two-arrays" class="headerlink" title="349. intersection-of-two-arrays"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/intersection-of-two-arrays/#/description">349. intersection-of-two-arrays</a></h4><ul>
<li>给两个数组，求其中重复的项（交集），重复出现的只算一个。</li>
<li>ME：<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/110554016/">用hashSet搞定</a>。</li>
<li>TA：其实有<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/45685/three-java-solutions/">三种方法</a>，后两种都是需要排序之后再操作。一个是排序后用俩指针挪动判断，一个是排序后用二分查找在第一个数组中搜索第二个数组的每个数字。</li>
</ul>
<h4 id="350-intersection-of-two-arrays-ii"><a href="#350-intersection-of-two-arrays-ii" class="headerlink" title="350. intersection-of-two-arrays-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/intersection-of-two-arrays-ii/#/description">350. intersection-of-two-arrays-ii</a></h4><ul>
<li>给两个数组，求其中重复的项，只要重复就放进数组，不用管重不重复。</li>
<li>ME：hashmap统计一波各个数字出现的频数，然后从第二个数字取数字，匹配到就放到List中并将map中的频数减1.写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/110560702/">这样</a>。</li>
<li>TA：题目有follow-up问题，如果排好序可以直接分别遍历两个数组去判断；如果数组规模太大无法一次性加载到内存中，<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/45992/solution-to-3rd-follow-up-question">这里有个办法</a>就是external sort，然后每次只需要读进来两个数字就好了。</li>
</ul>
<h4 id="352-data-stream-as-disjoint-intervals"><a href="#352-data-stream-as-disjoint-intervals" class="headerlink" title="352. data-stream-as-disjoint-intervals"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/data-stream-as-disjoint-intervals/#/description">352. data-stream-as-disjoint-intervals</a></h4><ul>
<li>自定义了类Interval，给一个数组作为data stream，要求把它转化成Interval的List。</li>
<li>ME：直觉就是二分查找，但是。。。木有自己写出来。</li>
<li>TA：TreeMap来处理Interval边界问题。TreeMap的key是每个interval的起始点，新来的一个val可以在treeMap中找到小于它、大于它的key。分情况讨论，val可能可以恰好把前后两个interval连起来、可能落在前面的区间内&#x2F;区间后方一位、可能落在后面的区间的前方一位（不可能在区间内，否则lowerKey就是后面这个区间了）、也可能就是独立的一个val。TreeMap的<code>lowerKey</code>, <code>higherKey</code>, <code>put</code>, <code>remove</code>都是O(logN)的。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SummaryRanges</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TreeMap&lt;Integer, Interval&gt; treeMap;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SummaryRanges</span><span class="params">()</span> &#123;</span><br><span class="line">        treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (treeMap.containsKey(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">lower</span> <span class="operator">=</span> treeMap.lowerKey(val);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">higher</span> <span class="operator">=</span> treeMap.higherKey(val);</span><br><span class="line">        <span class="keyword">if</span> (lower != <span class="literal">null</span> &amp;&amp; higher != <span class="literal">null</span> &amp;&amp; treeMap.get(lower).end + <span class="number">1</span> == val &amp;&amp; val + <span class="number">1</span> == higher) &#123;</span><br><span class="line">            treeMap.get(lower).end = treeMap.get(higher).end;   <span class="comment">// merge前后两段</span></span><br><span class="line">            treeMap.remove(higher);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lower != <span class="literal">null</span> &amp;&amp; treeMap.get(lower).end + <span class="number">1</span> &gt;= val) &#123;</span><br><span class="line">            treeMap.get(lower).end = Math.max(treeMap.get(lower).end, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (higher != <span class="literal">null</span> &amp;&amp; val + <span class="number">1</span> == higher) &#123;</span><br><span class="line">            treeMap.put(val, <span class="keyword">new</span> <span class="title class_">Interval</span>(val, treeMap.get(higher).end));</span><br><span class="line">            treeMap.remove(higher);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            treeMap.put(val, <span class="keyword">new</span> <span class="title class_">Interval</span>(val, val));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;Interval&gt; <span class="title function_">getIntervals</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(treeMap.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="353-design-snake-game"><a href="#353-design-snake-game" class="headerlink" title="353. design-snake-game"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/design-snake-game/description/">353. design-snake-game</a></h4><ul>
<li>模拟贪吃蛇游戏，给两个int表示grid大小，给一个food数组表示每次吃完食物之后下一个食物出现的坐标，保证不会出现在贪吃蛇的路径上。每次调用一次move函数，给定移动方向，返回移动之后的分数，若挂了就返回-1.</li>
<li>移动本身不难，难点一是如何维护蛇本身，由于需要在头部增加点、在尾部删除点（若吃到食物则尾部不删除），需要从两头操作，因此想到Deque；二是如何判断蛇有没有hit到自身，通过重写equal和hash函数就可以将自定义的Point类丢进Set中。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SnakeGame</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">        <span class="type">int</span> row, col;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.row = row;</span><br><span class="line">            <span class="built_in">this</span>.col = col;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Point) &#123;</span><br><span class="line">                <span class="type">Point</span> <span class="variable">that</span> <span class="operator">=</span> (Point) o;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.row == that.row &amp;&amp; <span class="built_in">this</span>.col == that.col;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hash(row, col);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> rowTotal, colTotal, score;</span><br><span class="line">    Deque&lt;Point&gt; snake;</span><br><span class="line">    Set&lt;Point&gt; body;</span><br><span class="line">    <span class="type">int</span>[][] food;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here.</span></span><br><span class="line"><span class="comment">        <span class="doctag">@param</span> width - screen width</span></span><br><span class="line"><span class="comment">        <span class="doctag">@param</span> height - screen height </span></span><br><span class="line"><span class="comment">        <span class="doctag">@param</span> food - A list of food positions</span></span><br><span class="line"><span class="comment">        E.g food = [[1,1], [1,0]] means the first food is positioned at [1,1], the second is at [1,0]. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SnakeGame</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height, <span class="type">int</span>[][] food)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rowTotal = height;</span><br><span class="line">        <span class="built_in">this</span>.colTotal = width;</span><br><span class="line">        <span class="built_in">this</span>.food = food;</span><br><span class="line">        <span class="built_in">this</span>.score = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">this</span>.snake = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.body = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        snake.addFirst(<span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        body.add(snake.peekFirst());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Moves the snake.</span></span><br><span class="line"><span class="comment">        <span class="doctag">@param</span> direction - &#x27;U&#x27; = Up, &#x27;L&#x27; = Left, &#x27;R&#x27; = Right, &#x27;D&#x27; = Down </span></span><br><span class="line"><span class="comment">        <span class="doctag">@return</span> The game&#x27;s score after the move. Return -1 if game over. </span></span><br><span class="line"><span class="comment">        Game over when snake crosses the screen boundary or bites its body. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">move</span><span class="params">(String direction)</span> &#123;</span><br><span class="line">        <span class="type">Point</span> <span class="variable">head</span> <span class="operator">=</span> snake.peekFirst();</span><br><span class="line">        <span class="type">Point</span> <span class="variable">nextHead</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (direction.equals(<span class="string">&quot;U&quot;</span>)) &#123;</span><br><span class="line">            nextHead = <span class="keyword">new</span> <span class="title class_">Point</span>(head.row - <span class="number">1</span>, head.col);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (direction.equals(<span class="string">&quot;D&quot;</span>)) &#123;</span><br><span class="line">            nextHead = <span class="keyword">new</span> <span class="title class_">Point</span>(head.row + <span class="number">1</span>, head.col);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (direction.equals(<span class="string">&quot;L&quot;</span>)) &#123;</span><br><span class="line">            nextHead = <span class="keyword">new</span> <span class="title class_">Point</span>(head.row, head.col - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (direction.equals(<span class="string">&quot;R&quot;</span>)) &#123;</span><br><span class="line">            nextHead = <span class="keyword">new</span> <span class="title class_">Point</span>(head.row, head.col + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println(nextHead.row + &quot;, &quot; + nextHead.col + &quot; &quot; + checkOutBound(nextHead) + &quot; &quot; + hitSelf(nextHead));</span></span><br><span class="line">        <span class="keyword">if</span> (nextHead == <span class="literal">null</span> || checkOutBound(nextHead) || hitSelf(nextHead)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (score &lt; food.length &amp;&amp; nextHead.row == food[score][<span class="number">0</span>] &amp;&amp; nextHead.col == food[score][<span class="number">1</span>]) &#123;</span><br><span class="line">            score++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Point</span> <span class="variable">tail</span> <span class="operator">=</span> snake.pollLast();</span><br><span class="line">            body.remove(tail);</span><br><span class="line">        &#125;</span><br><span class="line">        snake.addFirst(nextHead);</span><br><span class="line">        body.add(nextHead);</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkOutBound</span><span class="params">(Point p)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p.row &lt; <span class="number">0</span> || p.row &gt;= rowTotal || p.col &lt; <span class="number">0</span> || p.col &gt;= colTotal;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hitSelf</span><span class="params">(Point p)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !p.equals(snake.peekLast()) &amp;&amp; body.contains(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="354-russian-doll-envelopes"><a href="#354-russian-doll-envelopes" class="headerlink" title="354. russian-doll-envelopes"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/russian-doll-envelopes/#/description">354. russian-doll-envelopes</a></h4><ul>
<li>给一个数组，存放的是各个信封的规格，要让信封能套进去必须长和宽都小于外面的信封，求最多可以有多少个信封套在一起。</li>
<li>ME：搞了半天没搞出来，各种WA。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/47469/java-nlogn-solution-with-explanation">这个利用Arrays.binarySearch的方法</a>真的给力。Arrays.binarySearch方法的定义可以看<a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html#binarySearch(float[],%20int,%20int,%20float)">这里</a>，有一个很叼的地方是这个二分查找在搜索不到key的情况下会返回<code>- 插入索引 - 1</code>，这样就可以直接知道往哪里插入了。算法总思路是，先根据信封的[0]从小到大排序，[0]相等的情况下[1]大的排在前面。然后遍历原数组，根据[1]去二分查找DP数组，找不到就更正index为最小的大于目标值的索引，然后直接覆盖或插入，最后返回DP的有效长度即可。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/110655150/">这样</a>。还有一个<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/47404/simple-dp-solution/">完全暴力的方法</a>，我一开始就打算这么搞的不过没有注意到更新的时候需要Math.max一下，正解写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/110656111/">这样</a>。还有个大神提出信封在现实中肯定可以旋转之后塞进去，挺有意思。</li>
<li>Arrays.sort自定义排序参考了<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/22482/short-java-solution">这个</a>，传入第二个参数<code>(a, b) -&gt; &#123; if return xxx &#125;</code>。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxEnvelopes</span><span class="params">(<span class="type">int</span>[][] envelopes)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (envelopes == <span class="literal">null</span> || envelopes.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先按照宽度升序排序，然后按照高度降序排序</span></span><br><span class="line">        Arrays.sort(envelopes, (a, b) -&gt; a[<span class="number">0</span>] == b[<span class="number">0</span>] ? b[<span class="number">1</span>] - a[<span class="number">1</span>] : a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] heights = <span class="keyword">new</span> <span class="title class_">int</span>[envelopes.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; envelopes.length; i++) &#123;</span><br><span class="line">            heights[i] = envelopes[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在宽度是升序的情况下，只要保证高度升序即可嵌套</span></span><br><span class="line">        <span class="keyword">return</span> getLenOfLongestIncreasingSequence(heights);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/dong-tai-gui-hua-she-ji-zui-chang-di-zeng-zi-xu-lie</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getLenOfLongestIncreasingSequence</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123; <span class="comment">// O(NlogN)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">piles</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] tops = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> binarySearchInsertion(tops, piles, num);</span><br><span class="line">            tops[index] = num;</span><br><span class="line">            <span class="keyword">if</span> (index == piles) &#123;</span><br><span class="line">                piles++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> piles;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">binarySearchInsertion</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> len, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = len;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="355-design-twitter"><a href="#355-design-twitter" class="headerlink" title="355. design-twitter"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/design-twitter/#/description">355. design-twitter</a></h4><ul>
<li>设计题，模拟twitter的发推、关注、取关操作，以及对于给定用户返回最近10条应当显示的推文id。</li>
<li>ME：用Map存储用户id和关注的其他用户的Set，然后自定义一个推文类，用个List存总的timeline，没有删除推文省事很多。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/110663745/">这样</a>。</li>
<li>TA：好吧，每次我调取给定用户应显示的最近十条推文的方法很低效，因为是直接遍历总的timeline然后判断是否是当前用户关注的对象。这里有个<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/48100/java-oo-design-with-most-efficient-function-getnewsfeed">看起来很6的设计</a>。它给每个Tweet设置一个时间戳，这样就可以判断谁先谁后了。然后每个用户发送Tweet的时候放在该用户对象的Tweet的链表的头部。在取feed的时候就将每个用户follow的用户的Tweet链表头放到PriorityQueue中（排序规则是时间戳大的在前），然后往外取的时候同时把Tweet的next再插入PriorityQueue，这样就可以保持时间戳大的、且是follow用户发的推文先被取出。</li>
</ul>
<h4 id="356-line-reflection"><a href="#356-line-reflection" class="headerlink" title="356. line-reflection"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/line-reflection/">356. line-reflection</a></h4><ul>
<li>给一系列在二维坐标系中点的坐标（可能重复），判断是否存在一条垂直线，使所有点的分布关于它对称。</li>
<li>这种两两匹配的问题，最直观的办法就是用set找pair中的另一半，第一次遍历将点存入set并且找出横轴的最大最小值以求出对称轴位置，第二次遍历就从set中逐对判断了。一开始想到的是排序之后双指针一前一后夹逼判断，但这样时间复杂度高，而且排序规则本身也十分tricky。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isReflected</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (points == <span class="literal">null</span> || points.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE, min = Integer.MAX_VALUE;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] point : points) &#123;</span><br><span class="line">            min = Math.min(min, point[<span class="number">0</span>]);</span><br><span class="line">            max = Math.max(max, point[<span class="number">0</span>]);</span><br><span class="line">            set.add(point[<span class="number">0</span>] + <span class="string">&quot;,&quot;</span> + point[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> min + max;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> [] point : points) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains((sum - point[<span class="number">0</span>]) + <span class="string">&quot;,&quot;</span> + point[<span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="357-count-numbers-with-unique-digits"><a href="#357-count-numbers-with-unique-digits" class="headerlink" title="357. count-numbers-with-unique-digits"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/count-numbers-with-unique-digits/#/description">357. count-numbers-with-unique-digits</a></h4><ul>
<li>给一个非负整数n，求在<code>[0, 10^n)</code>范围内有多少个数的各位数字各不相同。</li>
<li>ME：一开始总想着怎么减出结果，后来还是偷看了discuss。。。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/47983/java-dp-o-1-solution/">这个</a>告诉你，直接用排列组合的思路不就好了嘛！第一位是1<del>9九个数字，第二位就是0</del>9减去第一位用掉的数字还剩九个数字，第三位是八个数字，以此类推。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/110742143/">这样</a>。当然还有<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/48001/backtracking-solution/">用回溯法的</a>，用一个used表示是否用了索引对应的数字。</li>
</ul>
<h4 id="358-rearrange-string-k-distance-apart"><a href="#358-rearrange-string-k-distance-apart" class="headerlink" title="358. rearrange-string-k-distance-apart"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/rearrange-string-k-distance-apart/description/">358. rearrange-string-k-distance-apart</a></h4><ul>
<li>给一个只含有小写字母的字符串，再给一个长度k，求其中相同字符串每隔k个才出现的版本。例如<code>s = &quot;aabbcc&quot;, k = 3</code>，整理后就是<code>abcabc</code>.</li>
<li>greedy可破。先统计每个字母的出现频数，然后塞入PriorityQueue每次取（consume）频数最高的拼接上去，同时将用掉的这个字符暂存到另一个waitQueue中，之后当用足了长度k，再从waitQueue中取（produce）放回pq。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">rearrangeString</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(c)) &#123;</span><br><span class="line">                map.put(c, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(c, map.get(c) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;Map.Entry&lt;Character, Integer&gt;&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> b.getValue() != a.getValue()? b.getValue() - a.getValue() : a.getKey() - b.getKey();</span><br><span class="line">        &#125;);</span><br><span class="line">        q.addAll(map.entrySet());</span><br><span class="line">        </span><br><span class="line">        Queue&lt;Map.Entry&lt;Character, Integer&gt;&gt; waitQueue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            Map.Entry&lt;Character, Integer&gt; entry = q.poll();</span><br><span class="line">            sb.append(entry.getKey());</span><br><span class="line">            entry.setValue(entry.getValue() - <span class="number">1</span>);</span><br><span class="line">            waitQueue.offer(entry);</span><br><span class="line">            <span class="keyword">if</span> (waitQueue.size() &lt; k) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Map.Entry&lt;Character, Integer&gt; next = waitQueue.poll();</span><br><span class="line">            <span class="keyword">if</span> (next.getValue() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                q.add(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.length() == s.length()? sb.toString() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="359-logger-rate-limiter"><a href="#359-logger-rate-limiter" class="headerlink" title="359. logger-rate-limiter"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/logger-rate-limiter/description/">359. logger-rate-limiter</a></h4><ul>
<li>给一个string和timestamp，判断是否输出， 输出的条件是在10秒内没有输出过。skip。</li>
</ul>
<h4 id="360-sort-transformed-array"><a href="#360-sort-transformed-array" class="headerlink" title="360. sort-transformed-array"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sort-transformed-array/description/">360. sort-transformed-array</a></h4><ul>
<li>给一个sorted的int数组，给a, b, c并对数组每个元素求<code>a*x^2 + b*x + c</code>，返回排好序的结果，要求时间复杂度O(N)。</li>
<li>如果是二次函数就是个轴对称问题，一开始实现的时候也是按照这个思路先用二分查找来到中间，然后双指针往外扩张，分了很多种情况讨论。但其实更简单的方法是从两边往中间夹逼，而且只需要讨论a是否大于0即可，不需要再针对b有什么操作。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortTransformedArray(<span class="type">int</span>[] nums, <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length, left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> a &gt;= <span class="number">0</span> ? n - <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">leftVal</span> <span class="operator">=</span> calculate(nums[left], a, b, c);</span><br><span class="line">            <span class="type">int</span> <span class="variable">rightVal</span> <span class="operator">=</span> calculate(nums[right], a, b, c);</span><br><span class="line">            <span class="keyword">if</span> (a &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (leftVal &gt;= rightVal) &#123;</span><br><span class="line">                    ans[index--] = leftVal;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans[index--] = rightVal;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (leftVal &lt;= rightVal) &#123;</span><br><span class="line">                    ans[index++] = leftVal;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans[index++] = rightVal;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a * x * x + b * x + c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="362-design-hit-counter"><a href="#362-design-hit-counter" class="headerlink" title="362. design-hit-counter"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/design-hit-counter/description/">362. design-hit-counter</a></h4><ul>
<li>实现一个hitCount类，通过hit(timestamp)表示在什么时候出现了hit（可能同一时刻有多次hit），然后通过getHits得到最近300s内hit了多少次。</li>
<li>利用循环数组记录hits即可，容量可以直接设为300，这样最多就可以同时记录300s中每一秒的hit数量，在getHis的时候直接遍历一边如何保证每个bucket都是valid的count呢，就需要记录每一个bucket对应的hit的时刻是几时，因此需要另一个time数组来记录。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HitCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] hits;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] time;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="type">int</span> <span class="variable">TIMEWINDOW</span> <span class="operator">=</span> <span class="number">300</span>;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HitCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        hits = <span class="keyword">new</span> <span class="title class_">int</span> [TIMEWINDOW];</span><br><span class="line">        time = <span class="keyword">new</span> <span class="title class_">int</span> [TIMEWINDOW];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Record a hit.</span></span><br><span class="line"><span class="comment">        <span class="doctag">@param</span> timestamp - The current timestamp (in seconds granularity). */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hit</span><span class="params">(<span class="type">int</span> timestamp)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> timestamp % TIMEWINDOW;</span><br><span class="line">        <span class="keyword">if</span> (time[index] != timestamp) &#123;</span><br><span class="line">            time[index] = timestamp;</span><br><span class="line">            hits[index] = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hits[index]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Return the number of hits in the past 5 minutes.</span></span><br><span class="line"><span class="comment">        <span class="doctag">@param</span> timestamp - The current timestamp (in seconds granularity). */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHits</span><span class="params">(<span class="type">int</span> timestamp)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; TIMEWINDOW; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timestamp - time[i] &lt; TIMEWINDOW) &#123;</span><br><span class="line">                count += hits[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="363-max-sum-of-rectangle-no-larger-than-k"><a href="#363-max-sum-of-rectangle-no-larger-than-k" class="headerlink" title="363. max-sum-of-rectangle-no-larger-than-k"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/#/description">363. max-sum-of-rectangle-no-larger-than-k</a></h4><ul>
<li>给一个二维int数组，给一个目标值k，求这个矩阵中的子矩阵各项之和不超过k的最大值。</li>
<li>ME：偷看了<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/48923/2-accepted-java-solution">这个</a>才写出了<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/110927546/">这个O(N^4)的纯暴力法</a>。先求从左上角到各个位置的和，然后四重循环固定一个位置往右下角遍历求子矩阵之和，取最接近k的值即可。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/48923/2-accepted-java-solution/">刚刚这个答案</a>还给出了更高效的办法，利用了TreeSet。同样是先获取左上角到各格的和，然后固定行r1，让r2从r1开始往下遍历各行，在每个r2再遍历每一列c，求出<code>curr = sum[r2][c] - sum[r1 - 1][c]</code>并存入TreeSet。然后最妙的地方出现了，根据<code>curr - k</code>到TreeSet中找『最小的不小于这个值的值』，如果这个值<code>x</code>存在，那么<code>curr - x</code>就是『最大的不大于k的值』，再和ans取个较大值即可。这是因为<code>curr - k &lt;= x</code>，所以<code>curr - x &lt;= k</code>。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/111064030/">这样</a>，妙哉啊妙哉但是为啥反而更慢了？大概是因为用了个更高级的数据结构TreeSet吧。follow-up还有个问题，如果行数比列数多得多怎么破？<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/48854/java-binary-search-solution-time-complexity-min-m-n-2-max-m-n-log-max-m-n">这个</a>和刚刚的第二个TreeSet方法差不多，有一点点小区别是在第二重循环那里是从r1开始往0递减的，没啥区别其实。但是他在最开始根据行数和列数做了个类似于转置的操作，保证行数能大于列数，在后续的操作中就直接当作行大于列的矩阵操作了。</li>
</ul>
<h4 id="364-nested-list-weight-sum-ii"><a href="#364-nested-list-weight-sum-ii" class="headerlink" title="364. nested-list-weight-sum-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/nested-list-weight-sum-ii/description/">364. nested-list-weight-sum-ii</a></h4><ul>
<li>和339题目背景类似，只不过这里是反过来，层数约深weight越小，因此在最外层的要根据最深的层数确定weight.</li>
<li>既然需要求最深的深度，就先走一波求最深深度，然后最外层就乘这个weight，然后逐层叠加。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">depthSumInverse</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nestedList == <span class="literal">null</span> || nestedList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> getDepth(nestedList);</span><br><span class="line">        <span class="keyword">return</span> getSum(nestedList, depth);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getDepth</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxDepth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (NestedInteger i : nestedList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i.isInteger()) &#123;</span><br><span class="line">                maxDepth = Math.max(maxDepth, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxDepth = Math.max(getDepth(i.getList()) + <span class="number">1</span>, maxDepth);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxDepth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(List&lt;NestedInteger&gt; nestedList, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (NestedInteger i : nestedList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i.isInteger()) &#123;</span><br><span class="line">                sum += i.getInteger() * depth;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += getSum(i.getList(), depth - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个weight其实就相当于加多少遍，因此在进入nested下一层的时候，把上一层的sum传进去重复叠加，即可达到weight的效果了。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">depthSumInverse</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nestedList == <span class="literal">null</span> || nestedList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getSum(nestedList, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(List&lt;NestedInteger&gt; nestedList, <span class="type">int</span> prevLevelSum)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> prevLevelSum;     <span class="comment">// 在当前level重复叠加</span></span><br><span class="line">        List&lt;NestedInteger&gt; nextLevel = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (NestedInteger i : nestedList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i.isInteger()) &#123;</span><br><span class="line">                sum += i.getInteger();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nextLevel.addAll(i.getList());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextLevel.size() == <span class="number">0</span> ? sum : sum + getSum(nextLevel, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="365-water-and-jug-problem"><a href="#365-water-and-jug-problem" class="headerlink" title="365. water-and-jug-problem"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/water-and-jug-problem/#/description">365. water-and-jug-problem</a></h4><ul>
<li>给两个整数表示两个水樽的容量，再给一个目标值，判断仅用这两个水樽，通过加满水、清空水、倒到另一个水樽这三个操作能否获得目标值。</li>
<li>ME：一开始想到用带状态记录的DFS，写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/111071389/">这样</a>，但是爆内存了。即便我改成用<code>Map&lt;Integer, Set&lt;Integer&gt;&gt;</code>的形式也还是爆。。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/50425/breadth-first-search-with-explanation">这儿有个超时的BFS方法</a>估计和你的思路差不多，不过它报的错是超时，而不是爆内存。正解是用纯数学方法<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/B%C3%A9zout%27s_identity">Bezout’s Identity</a>利用最大公约数，比如<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/49238/math-solution-java-solution/">这个解答</a>，没啥意思。。。</li>
<li>最大公约数的求法要会！</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getGCD</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> b;</span><br><span class="line">        b = a % b;</span><br><span class="line">        a = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="366-find-leaves-of-binary-tree"><a href="#366-find-leaves-of-binary-tree" class="headerlink" title="366. find-leaves-of-binary-tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-leaves-of-binary-tree/description/">366. find-leaves-of-binary-tree</a></h4><ul>
<li>给一个二叉树，求一层层仰视时所能看到的节点，看完后删除这些节点后继续仰视下一层。注意不是层级遍历！</li>
<li>其实就是利用高度的定义，对于每个节点对应地放到它所属的高度的位置即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">findLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        height(root, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">(TreeNode node, List&lt;List&lt;Integer&gt;&gt; ans)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// 保证叶子节点高度为0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">1</span> + Math.max(height(node.left, ans), height(node.right, ans));  <span class="comment">// 当前节点的高度 = 左右较大者 + 1</span></span><br><span class="line">        <span class="keyword">if</span> (ans.size() == h) &#123;  <span class="comment">// 叶子结点高度为0，索引也为0</span></span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        ans.get(h).add(node.val);</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="367-valid-perfect-square"><a href="#367-valid-perfect-square" class="headerlink" title="367. valid-perfect-square"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-perfect-square/#/description">367. valid-perfect-square</a></h4><ul>
<li>给一个int，判断它是否平方数。</li>
<li>ME：二分查找破之，写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/111065625/">这样</a>。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/49325/a-square-number-is-1-3-5-7-java-code">这个</a>的第一个解法很有意思，直接用<code>1 + 3 + 5 + 7 + 9...</code>是平方数的特性，逐渐减得结果。此外还有个<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division">牛顿法</a>判断平方数，利用公式<code>curr = (curr + (num / curr)) / 2</code>不断更新，最后就根据<code>curr * curr == num</code>来判断是否平方数。这个。。。如果不知道根本不懂呀。</li>
</ul>
<h4 id="368-largest-divisible-subset"><a href="#368-largest-divisible-subset" class="headerlink" title="368. largest-divisible-subset"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/largest-divisible-subset/#/description">368. largest-divisible-subset</a></h4><ul>
<li>给一个int数组，元素各不相同，求最大的子序列使得其中的元素两两之间<code>x % y == 0</code>或<code>y % x == 0</code>.</li>
<li>ME：一开始想的是DFS，先从小到大排个序，然后从前往后看到能模的就深入DFS，写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/111079431/">这样</a>。然而超时。。。</li>
<li>TA：没想到给的tag是DP。参考了<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/49741/easy-understood-java-dp-solution-in-28ms-with-o-n-2-time/">这个</a>，一下就懂了，dp[i]的意义是『到i为止的最长能整除子序列的长度』。一开始也是先排序，然后先从前往后走一波二重循环，求到每个索引处的满足要求的最长长度，同时找到储存最长长度的那个索引。接着重开一波循环，从最长长度的这个索引开始往前，若可以整除且对应的dp能对得上号，就加入List（不必在意顺序）。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/111084948/">这样</a>。</li>
</ul>
<h4 id="369-plus-one-linked-list"><a href="#369-plus-one-linked-list" class="headerlink" title="369. plus-one-linked-list"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/plus-one-linked-list/description/">369. plus-one-linked-list</a></h4><ul>
<li>给一个用链表存储的int，返回将它加1之后的链表。递归解决。skip.</li>
</ul>
<h4 id="370-range-addition"><a href="#370-range-addition" class="headerlink" title="370. range-addition"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/range-addition/description/">370. range-addition</a></h4><ul>
<li>给一系列<code>[startIndex, endIndex, value]</code>的组成的二维数组，给一个length表示一个长度为length、初始值为0的数组，求经过这一系列操作之后的结果。例如<code>length = 5, updates = [[1, 3, 2],[2, 4, 3],[0, 2, -2]]</code>，返回<code>[-2, 0, 3, 5, 3]</code>。</li>
<li>tricky的做法，用数组本身来标记从当前索引开始应该加什么value。因为[i, j]加value相当于[i, ~]加value同时[j + 1, ~]减value，因此直接在i处标记一个value，在结尾处j标记一个-value即可。注意这里都不能直接赋值，而是需要累加之前的结果。时间复杂度O(K + N).</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// [i, j]加value相当于[i, ~]加value同时[j + 1, ~]减value</span></span><br><span class="line">    <span class="comment">// 因此直接在i处标记一个value，在结尾处j标记一个-value即可</span></span><br><span class="line">    <span class="comment">// 最后一波遍历的时候，直接用一个值delta加这些value，直接把delta赋值到对应位置即可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getModifiedArray(<span class="type">int</span> length, <span class="type">int</span>[][] updates) &#123;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span> [length];</span><br><span class="line">        <span class="keyword">if</span> (updates == <span class="literal">null</span> || updates.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] update : updates) &#123;  </span><br><span class="line">            ans[update[<span class="number">0</span>]] += update[<span class="number">2</span>];       <span class="comment">// 标记i为value</span></span><br><span class="line">            <span class="keyword">if</span> (update[<span class="number">1</span>] + <span class="number">1</span> &lt; length) &#123;      <span class="comment">// 标记j + 1为-value</span></span><br><span class="line">                ans[update[<span class="number">1</span>] + <span class="number">1</span>] -= update[<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">delta</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            delta += ans[i];</span><br><span class="line">            ans[i] = delta;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="371-sum-of-two-integers"><a href="#371-sum-of-two-integers" class="headerlink" title="371. sum-of-two-integers"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sum-of-two-integers/#/description">371. sum-of-two-integers</a></h4><ul>
<li>不能使用加、减运算符，实现加法运算。</li>
<li>ME：想到了位操作，但一开始<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/111091202/">这个</a>只适用于正数，负数就WA了。负数的二进制表示是『除了符号位，所有位取反再加1』，位操作还是挺复杂的。。。</li>
<li>TA：看了<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/50315/a-summary-how-to-use-bit-manipulation-to-solve-problems-easily-and-efficiently">这个逆天的位操作总结</a>，真的妙哉啊！回顾一下：</li>
<li>求给定数n的二进制表示中的bit为1的个数，不断更新n为<code>n &amp; (n - 1)</code>直到n等于0，所得的计数即是。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">countOne</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>判断是否4的幂：跟2的幂判断相比，多了一步判断那个1bit是否在奇数位置上，即AND 0x55555555不为0.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isPowerOfFour</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span> &amp;&amp; (n &amp; <span class="number">0x55555555</span>) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>求两个整数的和：利用了<strong>异或操作『保留不同的bit、置0相同的bit』</strong>，在bit的加法中，不同的bit相加一定是1，而相同的bit如果都是0就没事，如果都是1，则需要在左侧产生进位，因此为了获得这个进位还需要对两个数AND一下获得『同为1』的bit，然后左移1形成进位。递归直到进位为0，加法完全结束。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span>? a: getSum((a ^ b), (a &amp; b) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于乱序的规模为n的数组，从0~n中选n个数任意放进去，求缺少的那个数：利用索引和元素的对应关系，持续异或，最后没有异或成0的即为结果。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>, n = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ans ^= i;</span><br><span class="line">        ans ^= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ans ^ n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>求不超过数n的最大的2的幂：利用了<strong>取或操作『保留尽可能多的1』</strong>，将n的最高位及其右边的位全部置为1，然后加1就来到了最高位的左边，再右移1即得。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">largestNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">16</span>; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        n = n | (n &gt;&gt; i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>前后反转一个32bit无符号数的bit：从原数的最低位开始取bit，如果是1就对应或个Mask到ans中，其中mask持续右移，n也持续右移，这样每次都取最低位事实上就是从最低到最高取n的各个bit。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">reverseBits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            ans |= mask;</span><br><span class="line">        &#125;</span><br><span class="line">        mask &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>给一个范围[lo, hi]，求这个范围内所有数的AND的值：其实就是找lo和hi的最长高位相同部分，lo和hi同时向右移，右移的次数用一个count记录下来，直到lo &#x3D;&#x3D; hi时跳出循环，此时lo或hi左移count位即为所求。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rangeAND</span><span class="params">(<span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo != hi) &#123;</span><br><span class="line">        lo &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        hi &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lo &lt;&lt; count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="372-super-pow"><a href="#372-super-pow" class="headerlink" title="372. super-pow"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/super-pow/#/description">372. super-pow</a></h4><ul>
<li>给一个整数a表示底数，给一个数组形式的超大整数b表示幂，求(a ^ b) % 1337的值。</li>
<li>利用<code>num ^ 1,2,3,4 = (num ^ 1,2,3) ^ 10 * a ^ 4</code>，也就是按照个十百千万来拆分大数，再利用递归解决括号中间的部分。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1337</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">superPow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span>[] b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> superPow(a, b, b.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">superPow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span>[] b, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">part1</span> <span class="operator">=</span> getPow(a, b[index]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">part2</span> <span class="operator">=</span> getPow(superPow(a, b, index - <span class="number">1</span>), <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> (part1 * part2) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getPow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">1</span> || k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a %= MOD;</span><br><span class="line">        <span class="type">int</span> <span class="variable">retVal</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            retVal *= a;</span><br><span class="line">            retVal %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>优化：这里的getPow可以利用以下公式加速：<br><a target="_blank" rel="noopener" href="https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2F-M5mNKb1DvzLOmKFp0Tr%2F-M5mNMdVfjf4_eOBjHcJ%2Fformula2.png?alt=media">!img</a></li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getPow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">1</span> || k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    a %= MOD;</span><br><span class="line">    <span class="comment">// 偶数砍半</span></span><br><span class="line">    <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> getPow(a, k / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> (half * half) % MOD;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (a * getPow(a, k - <span class="number">1</span>)) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="373-find-k-pairs-with-smallest-sums"><a href="#373-find-k-pairs-with-smallest-sums" class="headerlink" title="373. find-k-pairs-with-smallest-sums"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-k-pairs-with-smallest-sums/description/">373. find-k-pairs-with-smallest-sums</a></h4><ul>
<li>给两个排好序的递增int数组，要求从两个数组中分别取一个元素出来组成的数对之和小者排在前面，求前k个这样的组合。</li>
<li>ME：一开始又想得太简单，结果并不是用两个索引就可以搞定的。。。</li>
<li>TA：看了<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/50885/simple-java-o-klogk-solution-with-explanation/">这个</a>，直接把数组对象存入优先队列，数对和小的排在前面，同时数组末尾再增添一个索引，表示当前数组第二个数对应到第二个原数组中的索引，这样就可以把后续的继续添加到优先队列中了。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/112037464/">这样</a>。其实挺简单的。。。</li>
<li>数组的初始化可以不用指定规模，而且后面跟的花括号中的元素可以不是const，例如<code>new int[] &#123;i, j, 0&#125;</code>。</li>
</ul>
<h4 id="374-guess-number-higher-or-lower"><a href="#374-guess-number-higher-or-lower" class="headerlink" title="374. guess-number-higher-or-lower"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/guess-number-higher-or-lower/tabs/description">374. guess-number-higher-or-lower</a></h4><ul>
<li>给一个整数n表示在[1, n]内找一个未知数字，通过调用guess(num)的返回值来判定当前猜的数大了还是小了，返回最终猜中的结果。</li>
<li>ME：没啥好说的，二分查找搞定。</li>
<li>TA：没啥。</li>
</ul>
<h4 id="375-guess-number-higher-or-lower-ii"><a href="#375-guess-number-higher-or-lower-ii" class="headerlink" title="375. guess-number-higher-or-lower-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/guess-number-higher-or-lower-ii/tabs/description">375. guess-number-higher-or-lower-ii</a></h4><ul>
<li>还是给一个整数n，但是这次猜错了就要交对应数目的罚款，求保证猜对的情况下至少要准备多少罚款。</li>
<li>ME：一开始还以为是二分查找，后来发现是个夹逼猜测的策略更有效，但是不懂怎么推广，找不到可以转换成代码的规律呀。。。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/51353/simple-dp-solution-with-explanation">这他喵的就是个带有状态记录的DFS嘛</a>，你应该能写出来才对。第一个递归的方法思路是从起始位置遍历到结束位置，在循环过程中确定当前取的数字加入罚款，然后递归求左半边和右半边的罚款，然后求总和，再用一个变量记录当前这一层调用的最小罚款值，循环结束后就将最小罚款值更新到状态记录的二维数组中，这个二维数组其实只用到了右上部分，因为table[i][j]表示从i到j所需要的最少罚款，而i必须小于j。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/111363608/">这样</a>。第二个就是递归的方法，需要三重循环，第一重循环j&#x3D;[2, j]，表示结束的位置，即状态记录数组当前已更新到的列数；接下来一重递减循环i&#x3D;[j-1, 1]表示起始位置；最内层循环k&#x3D;[i+1, j)就是中界了，中界本身的罚款加上左、右两侧的最小罚款就是当前位置的最小罚款了。</li>
</ul>
<h4 id="376-wiggle-subsequence"><a href="#376-wiggle-subsequence" class="headerlink" title="376. wiggle-subsequence"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/wiggle-subsequence/description/">376. wiggle-subsequence</a></h4><ul>
<li>给一个int数组，求最长的wiggle子序列，即子序列中的元素一大一小震锯齿形地往后。</li>
<li>ME：直接一个for循环搞定了，写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/111891530/">这样</a>。</li>
<li>TA：我的方法算是贪心吧，看这里有个<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/51893/two-solutions-one-is-dp-the-other-is-greedy-8-lines/">总结</a>，不过他的贪心写得更优雅。</li>
</ul>
<h4 id="377-combination-sum-iv"><a href="#377-combination-sum-iv" class="headerlink" title="377. combination-sum-iv"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/combination-sum-iv/description/">377. combination-sum-iv</a></h4><ul>
<li>给一个不含重复元素的正整数数组，再给一个target，求有多少中组合方式（元素可重复使用）凑成target。</li>
<li>ME：DFS呗，先从小到大排个序，for循环逐个取出来，然后用target减之得到新的target，再递归去求，当刚好新的target为0的时候，就表示这是一种方式，返回1即可；而在循环过程中减出来的新的target小于0，就直接结束循环了，因为排过序之后后续的元素肯定更大，减出来更负。不过一开始没有设置状态记录数组，导致DFS计算了很多重复的情况，引入cache[target]表示目标为target的时候对应的组合数目，若一波循环之后还是0，则设置为负数，表示当前的target访问过且无法组合出来。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/111960965/">这样</a>。</li>
<li>TA：我这个也能算作是DP了吧。不过<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/52302/1ms-java-dp-solution-with-detailed-explanation/">这个</a>写得更加优雅，因为他是一开始直接将状态数组全部置为-1，而访问的时候则是从0开始递归累加，省去了很多判断。事实上这是个top-down的思路，还有一个bottom-up的思路，也就是二重循环从前往后更新。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/111963938/">这样</a>。</li>
</ul>
<h4 id="378-kth-smallest-element-in-a-sorted-matrix"><a href="#378-kth-smallest-element-in-a-sorted-matrix" class="headerlink" title="378. kth-smallest-element-in-a-sorted-matrix"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description/">378. kth-smallest-element-in-a-sorted-matrix</a></h4><ul>
<li>求排好序的二维数组中从小到大排在第k个的元素。这里的排好序意思是同一行从左到右递增、同一列从上到下递增。</li>
<li>ME：一开始理解成了从左到右递增同时下一行的比上一行的都大，还觉得这题怎么这么无脑。。结果还是太天真。。。</li>
<li>TA：看了<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/52948/share-my-thoughts-and-clean-java-code">这个</a>才知道要怎么做。第一个是使用最没技术含量的方式，自定义Item类，先将第一行元素全部入优先队列，然后每次取队首即最小元素出来，取它的下方和右方元素入队，为了防止重复入队，我还申请了二维的boolean数组标记，不过按照原po的做法，他只取出队元素的下方元素，就不用考虑重复的问题了。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/111979576/">这样</a>。第二种方法是二分查找，答主总结得很好，二分有两种二分的对象，一个是索引一个是值。这里不能用索引是因为这是两个方向的顺序，没办法形成索引大小关系和实际值之间的一一映射，因此直接对值进行二分，以左上角元素为下界、右下角元素为上界开始查找。不过相比一般的二分查找，在内部还需要两波循环。外层循环从第一行开始向下，内层循环则从最后一列开始向前，要做的是查找共有多少元素小于等于mid值（内层循环条件就是当前元素大于mid值），而由于同一列的元素是从上到下递增的，因此当前元素如果大于mid，则下面的全部都大于mid，直接将内层循环变量向前挪就行了。计算出小于等于mid的元素数目后，与k比较。如果<code>count &lt; k</code>，说明mid还太小，需要提升下界；否则说明mid略大，就需要降低上界。注意不能在<code>count == k</code>的时候就返回mid了，因为这个mid是由lo和hi计算出来的，并不一定存在于原矩阵当中。最后当lo不小于hi时结束查找，返回lo。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/112026049/">这样</a>。</li>
</ul>
<h4 id="379-design-phone-directory"><a href="#379-design-phone-directory" class="headerlink" title="379. design-phone-directory"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/design-phone-directory/description/">379. design-phone-directory</a></h4><ul>
<li>实现get, check, release函数，分别对应申请一个号码、查询给定号码是否已分配、释放一个号码。</li>
<li>用数组记录是否被占用、用Queue返回可用号码。一开始用Set，其实没必要，因为对号码的顺序没有要求。如果有要求，可用PriorityQueue。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/135617410/">这样</a>.</li>
</ul>
<h4 id="380-insert-delete-getrandom-o1"><a href="#380-insert-delete-getrandom-o1" class="headerlink" title="380. insert-delete-getrandom-o1"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/insert-delete-getrandom-o1/description/">380. insert-delete-getrandom-o1</a></h4><ul>
<li>设计题，实现一个类似于set的类，要求平均在O(1)的时间内完成插入、删除、随机获取一个值等操作。</li>
<li>ME：这个O(1)的时间要求搞死我。本来想用Set + List + 自定义类搞的，但是卡在了O(1)时间要求这里，而且Set没法获取原本存储在其中的对象了。后来偷看了discuss还是改掉了。</li>
<li>TA：我看的是<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/53216/java-solution-using-a-hashmap-and-an-arraylist-along-with-a-follow-up-131-ms">这个</a>。他用到了Map + List，O(1)的秘诀就是在删除的时候，直接将最后一个元素覆盖到List中要删除的那个元素的位置，然后再删除List的最后一个元素即可。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/112047314/">这样</a>。</li>
<li>java.util.Random类：使用<code>r.nextInt(val)</code>可以获取<code>[0, val)</code>中的一个随机数。Java的随机数实现默认是根据当前时间种子<code>System.currentTimeMillis()</code>生成的，因此每次执行的结果不一样。要想传入特定种子，可以在构造时写成<code>Random((long)seed)</code>，这样每次执行的结果就一样了。</li>
</ul>
<h4 id="381-insert-delete-getrandom-o1-duplicates-allowed"><a href="#381-insert-delete-getrandom-o1-duplicates-allowed" class="headerlink" title="381. insert-delete-getrandom-o1-duplicates-allowed"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/insert-delete-getrandom-o1-duplicates-allowed/description/">381. insert-delete-getrandom-o1-duplicates-allowed</a></h4><ul>
<li>和上一题相比，允许在自定义的这个Set类中插入相同元素。</li>
<li>ME：我虽然<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/112112643/">这样</a>做出来了，但是用Queue的方式在remove的时候并不是O(1)的，所以严格来说我自己没有做出来。</li>
<li>TA：还是参考<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/53688/java-haspmap-linkedhashset-arraylist-155-ms/">大神的</a>，他把我的Queue给换成了LinkedHashSet，我研究了一下，感觉直接用Set也行，至于访问元素直接用一下<code>set.iterator().next()</code>即可。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/112116382/">这样</a>。</li>
</ul>
<h4 id="382-linked-list-random-node"><a href="#382-linked-list-random-node" class="headerlink" title="382. linked-list-random-node"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/linked-list-random-node/description/">382. linked-list-random-node</a></h4><ul>
<li>给一个链表，实现一个getRandom函数，随机返回一个节点的值，要求每个节点被返回的概率一样。</li>
<li>ME：转成了ArrayList，结合java.util.Random搞定了。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/112118077/">这样</a>。但是follow-up说如果长度过长，且不能使用额外space怎么破？这就触及到我知识的盲区了。。。</li>
<li>TA：事实上这是一个<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/53753/brief-explanation-for-reservoir-sampling/2">蓄水池抽样问题</a>，中文博客<a target="_blank" rel="noopener" href="http://blog.jobbole.com/42550/">在此</a>，代码<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/55049/java-solution-with-cases-explain">在此</a>。假设链表元素为<code>[1, 2, 3]</code>，每次只能读入一个数字。一开始读入1，只能保留它，概率为1；然后读入2，这是1和2之间保留谁的概率就是1&#x2F;2；然后读入3，此时保留的数字与3只能保留一个，为了保证概率均等，需要在0~2中产生随机数，只有等于2的时候才选择索引为2的元素即3，概率为1&#x2F;3，而上一步保留的那个数字留下来的概率则是<code>1/2 * 2/3 = 1/3</code>，概率依然相等。这个算法还可以推广到取k个元素出来的情况，这样内存中始终就只有非常少量（k + 1）的数字需要读入了。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/112126197/">这样</a>。</li>
</ul>
<h4 id="383-ransom-note"><a href="#383-ransom-note" class="headerlink" title="383. ransom-note"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/ransom-note/description/">383. ransom-note</a></h4><ul>
<li>写勒索信的时候要从杂志上剪一些字母出来，给勒索信内容字符串和杂志内容字符串，判断能不能拼出来。</li>
<li>ME：用HashMap存字符和对应到杂志中的索引，下次再找这个字母的时候就从map中索引的下一位开始查找。</li>
<li>TA：没注意到题目说只有lowercase的字母，所以可以把map改成数组就好了，像<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/53864/java-o-n-solution-easy-to-understand">这个</a>。而且他不需要用到String的indexOf查找函数，直接就两波遍历，杂志的字母加、勒索信的字母减，最后只要没有负数就说明可以拼出来。</li>
</ul>
<h4 id="384-shuffle-an-array"><a href="#384-shuffle-an-array" class="headerlink" title="384. shuffle-an-array"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/shuffle-an-array/description/">384. shuffle-an-array</a></h4><ul>
<li>design题，实现一个类，传入元素各不相同的int数组后可以生成shuffle后的数组，调用reset还能返回原数组。要求所有可能的答案返回的概率相同。</li>
<li>ME：第一次接触这种shuffle题，我就只是简单地用Random产生随机的index再结合ArrayList的remove功能，取出该索引对应元素后就删掉它。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/112812834/">这样</a>，但感觉ArrayList的remove非常耗时。</li>
<li>TA：看了<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/53978/first-accepted-solution-java/">这个</a>才知道，原来根本就不需要借助ArrayList，直接在数组上操作，至于生成随机数后如何删除，还是前面那个方法——对调法，直接和最后一个元素swap一下，再把生成随机数的区间减小一个，就不会再访问swap到后面的元素了，也就相当于删掉了。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/112816208/">这样</a>，不过怎么还更慢了？</li>
</ul>
<h4 id="385-mini-parser"><a href="#385-mini-parser" class="headerlink" title="385. mini-parser"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/mini-parser/description/">385. mini-parser</a></h4><ul>
<li>design提，又是NestedInteger类，要求从String形式转化成NestedInteger的形式。</li>
<li>ME：用递归的方法搞咯。本来还想着直接用逗号split的，但是<code>[12,[12,23],2,[1,[2,[3,4],5]]]</code>中用逗号分隔会是各个碎片。所以还是得手动找segment，如果是数字就直接转成NestedInteger了，如果有方括号就往后找到结束位置，然后递归求里面的NestedInteger。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/112853773/">这样</a>，出乎意料地快。</li>
<li>TA：大神又<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/54270/an-java-iterative-solution/">用Stack改写成了Iterative的方法</a>。用Stack存放NestedInteger，若为左括号，则将当前的NestedInteger入栈；若为右括号，则先看看前一位是否是正常的数字，是的话就转成NestedInteger加入当前的NestedInteger，再把栈顶元素取出来，把当前元素作为栈顶元素包含的NestedInteger给add进去；若为逗号，则先看看前一位是否是方括号，不是方括号说明前面是正常的数字，直接转就好。</li>
</ul>
<h4 id="386-lexicographical-numbers"><a href="#386-lexicographical-numbers" class="headerlink" title="386. lexicographical-numbers"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/lexicographical-numbers/description/">386. lexicographical-numbers</a></h4><ul>
<li>给一个整数n，从1～n按字典序存入List。字典序即先看数字小的在前面，前缀部分相同则长度短的在前面。</li>
<li>ME：感觉明明不难，又是磕磕绊绊持续debug才搞出来。我是用递归搞的，从<code>curr = 1</code>开始，如果curr的十倍依然在范围内就取它的十倍去递归，直到超过n为止，这时就从curr开始往后逐步加1，但是怎么控制加多少个1呢，我用到的是比较前缀法，例如原本进入递归时curr是11，那就要保证我加1的时候除了不能超过n、而且不能超过20，这就需要除一下10来判断前缀部分是否一致了。而在加1之后如果新形成的curr的十倍又符合要求，则继续。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/115594928/">这样</a>。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/55184/java-o-n-time-o-1-space-iterative-solution-130ms">这里</a>有个iterative的方法，需要精确地找出规律，每一步都直接跳到下一个正确的数字，不太好想。反正就是从1开始，先尝试乘10并放到list中，然后尝试加1直到末位为9，然后就往前回溯到起点，需要找到9左边第一个非9的数字，然后加1继续。我上面的方法应该也算是DFS，<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/55377/simple-java-dfs-solution/">这里</a>还有个更简洁明显的DFS，visualize成一个树，每个节点都是需要放入List的数字，然后下一层就是父节点的数乘以10后加上1～9的结果，然后一层层深入下去找，相当于多叉树的前序遍历吧，写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/115673397/">这样</a>。</li>
</ul>
<h4 id="387-first-unique-character-in-a-string"><a href="#387-first-unique-character-in-a-string" class="headerlink" title="387. first-unique-character-in-a-string"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/first-unique-character-in-a-string/description/">387. first-unique-character-in-a-string</a></h4><ul>
<li>给一个只含有小写字母的字符串，求其中第一个出现的『只出现了一次的字母』的索引。</li>
<li>ME：循环两波，第一波记录各个字母出现的次数，第二波看字母出现的次数为1时就直接输出了。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/112879202/">这样</a>。不过其实里面的index数组多余了。。。</li>
<li>TA：没啥。</li>
</ul>
<h4 id="388-longest-absolute-file-path"><a href="#388-longest-absolute-file-path" class="headerlink" title="388. longest-absolute-file-path"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-absolute-file-path/description/">388. longest-absolute-file-path</a></h4><ul>
<li>给一个用字符串表示的文件系统目录，求其中的文件（以.xxx结尾的文件）的最长目录长度。</li>
<li>ME：用自定义类加Stack搞咯。自定义类中存放层级数，然后通过<code>\t</code>来计算当前目录的层级数，如果小于等于栈顶的层级数，说明前一部分的文件目录已经结束了，弹出直到栈顶层级小于当前目录层级，然后再入栈。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/113003817/">这样</a>。</li>
<li>TA：我擦，O(N)并不一定是One-pass呀，我是何必呢。而且，不需要自定义类，看看人家<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/55247/9-lines-4ms-java-solution/">这个</a>。思路是利用一个stack数组，<code>stack[i]</code>表示第<code>i - 1</code>层目录的长度，<code>stack[0]</code>为0。利用split将原字符串拆分成String的数组，遍历之，根据每个字符串的<code>\t</code>数目确定level（可以利用lastIndexOf找到最后一个<code>\t</code>的索引），然后到<code>stack[level]</code>取出第<code>level - 1</code>层的长度，加上当前字符串长度，再加上1（后续<code>\n</code>的长度），再减去level（因为最终结果中所有的<code>\t</code>都是不存在的，只有换行变成了斜杠），就得到了当前level的长度。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/113014402/">这样</a>。</li>
</ul>
<h4 id="389-find-the-difference"><a href="#389-find-the-difference" class="headerlink" title="389. find-the-difference"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-the-difference/description/">389. find-the-difference</a></h4><ul>
<li>给一个只含有小写字母的字符串，打乱他后再随机插入一个小写字母，形成新的字符串，求插入的这个字符。</li>
<li>ME：用Bucket记录字母出现的频数咯，一个加一个减，频数为负的就是插入的咯。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/112881041/">这样</a>。</li>
<li>TA：没啥。</li>
</ul>
<h4 id="390-elimination-game"><a href="#390-elimination-game" class="headerlink" title="390. elimination-game"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/elimination-game/description/">390. elimination-game</a></h4><ul>
<li>给一个正整数n，表示有1~n这么多个数，从左到右从第一个开始隔一个删一个，然后从右往左从第一个隔一个删一个。求最后留下来的那个数。</li>
<li>ME：想了一下，没想出来高效的办法，不可能暴力搞吧。。</li>
<li>TA：看了<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/59293/java-easiest-solution-o-logn-with-explanation">这个</a>，找规律找得真6.设置一个头元素head，remain表示剩下多少数字，如果剩下一个就直接输出head了。如果是从左到右，那么删完了一波之后第一个元素就是head加上步长。如果是从右到左，就要看剩下的元素数remain的奇偶性了，只有剩下奇数个从右到左的时候才需要更新head。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/113024599/">这样</a>。此外<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/59257/o-logn-solution-clear-break-down">还有一个break down的方法</a>，直接想挺难想出来的。。。还有<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/61875/one-line-java-solution-based-on-josephus-problem/">这个</a>一行递归的，我的天。也是通过找规律搞出来的。</li>
</ul>
<h4 id="391-perfect-rectangle"><a href="#391-perfect-rectangle" class="headerlink" title="391. perfect-rectangle"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/perfect-rectangle/description/">391. perfect-rectangle</a></h4><ul>
<li>给若干个矩形的左下和右上顶点坐标，判断是否可以组成一个完整的矩形。</li>
<li>ME：看到hard就怂了，结果看到别人写的规律感觉并不难。。暗中观察出的rule是：这些点中最左下和最右上的顶点组成的大矩形的面积必须等于这些小矩形的面积之和；同时把每个矩形的四个顶点都求出来，除了最外侧的四个顶点只出现一次，其余点必须恰好出现偶数次。这个抽象真的完美，写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/115903004/">这样</a>。</li>
<li>TA：我上面看的就是<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/56052/really-easy-understanding-solution-o-n-java/">这个答案</a>，确实很好懂。还有一个<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/55944/o-n-log-n-sweep-line-solution/">略微复杂的方法</a>，用的是sweepline的思想，从左到右定义每个矩形的竖边为event发生的时间点，定义一个class含有time和完整两个点的坐标数组的类，并重写compareTo函数，先根据发生的时间排序、相同则end的边在前。遍历一波将每个矩形的两个Event都放入pq中，并更新y坐标的上届和下界。然后声明一个TreeSet根据y坐标在下的在前，若两个矩形的竖边有重叠则视为相等。然后从pq里取每个时间点的边进行y范围判断并维护一个当前时间点的y长度，如果它是一个end边就直接从yLen中扣除，为开始边泽加上，如果在开始边的时候发现y有重合（TreeSet加入返回false）则直接不行了；结尾边就直接从set中remove掉，不用管end的yLen是因为start总在end前面嘛，start都通过了那end边也一定不重合；然后当前时间点结束后，就看看目前所得的长度是否是最外围的长度，注意如果是最后的end边，这时长度会降到0（正确的情况下），这需要先判断pq是否为空，为空了就说明完全OK，不为空就说明还没到最后，再和最外围的y判断一下。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/116070556/">这样</a>，略慢啊。。</li>
</ul>
<h4 id="392-is-subsequence"><a href="#392-is-subsequence" class="headerlink" title="392. is-subsequence"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/is-subsequence/description/">392. is-subsequence</a></h4><ul>
<li>给两个字符串，判断其中一个字符串是否是另一个字符串的子串，这个字串不要求字符连续出现，只要求出现顺序一致且全部出现即可。</li>
<li>ME：一开始想到扫长的扫一遍记录下每个字符在其中出现的位置，然后在较短串（咦好像少了这个判断在开头）中从头到尾各个字符在长串中的出现索引是否能形成从小到大的顺序，但是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/115837371/">写出来谜之WA</a>。后来一看<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/57147/straight-forward-java-simple-solution/">这个</a>，嗬，根本不List来记录嘛，直接两个指针分别扫就是了，写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/115838954/">这样</a>，不过那个判断长度那里应该放到if里面更好。虽然这么写似乎很不错，速度也很快，但是根据tag，这题考的其实是二分法和DP，follow-up问的是如果有若干个短串需要check而长串特别长的时候，怎么优化。</li>
<li>TA：看了<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/58367/binary-search-solution-for-follow-up-with-detailed-comments/">这个</a>发现我原来的方法似乎是可以的，只不过我是线性地往后找大于prev的索引，而二分查找就把这个过程加速了。总结就是先把长串的每个字符出现的位置存入List，然后根据短串的字符取出对应的在长串中出现的索引List，给定二分查找的key pos，如果找到就完美下一位，找不到就是「-(insertion point) - 1」，因此取个负再减1就是该字符在长串中pos后面的最前一位了。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/115890162/">这样</a>。</li>
<li>List数组的声明不能再忘啦！<code>List&lt;Integer&gt;[] list = new List[n];</code></li>
</ul>
<h4 id="394-decode-string"><a href="#394-decode-string" class="headerlink" title="394. decode-string"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/decode-string/description/">394. decode-string</a></h4><ul>
<li>给一个数字 + 中括号 + 字符串的经过encode的字符串，要求以数字作为后续中括号中字符串的频数decode成完整的字符串。</li>
<li>ME：玛德这么简单的题搞了这么半天。。用了双Stack，一个存频数，一个存后续的字符串。当出现数字时进行乘10的累加，并且在嵌套的情况下意味着前面的字符串结束了，push到栈中；当出现左括号时说明前面的数字结束了，push到栈中；出现右括号时先将当前的字符串push到栈中，然后将栈顶的字符串拼接栈顶的频数那么多次，作为当前的字符串。这样一直到最后，留下的当前字符串就是所求了。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/115583076/">这样</a>。</li>
<li>TA：为什么别人写出来的就这么简洁呢。。。<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/57250/java-short-and-easy-understanding-solution-using-stack">这个</a>跟我的思路基本就是一样的，就是这么简洁。我在提交那里还看到了一个递归的方法，利用全局的index控制起始位置，碰到数字的时候直接往后找左括号确定频数，然后就递归到下一层看对应的字符串是什么，然后根据频数不断地拼接即可；遇到右括号就意味着当前的这部分字符串已经到头，break出来直接返回上层即可。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/115588689/">这样</a>.</li>
</ul>
<h4 id="395-longest-substring-with-at-least-k-repeating-characters"><a href="#395-longest-substring-with-at-least-k-repeating-characters" class="headerlink" title="395. longest-substring-with-at-least-k-repeating-characters"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/description/">395. longest-substring-with-at-least-k-repeating-characters</a></h4><ul>
<li>给一个只有小写字母的字符串，再给一个频数，求最长子字符串的长度使得其中字母出现的次数都不少于给定的频数。</li>
<li>ME：束手无策。。</li>
<li>TA：看了<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/57372/java-divide-and-conquer-recursion-solution">这个解释</a>之后，豁然开朗。这是个O(N^2)分治的做法，揪出当前子串中不满足频数要求的字母，排除掉它，然后递归看左右两边子串的情况，直接返回；如果统计好出现次数后发现它们全都符合要求，那就直接返回目前这段的全长即可。写出来就是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/115687057/">这样</a>，还是很直接的。还有<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/57596/java-strict-o-n-two-pointer-solution">一种O(N)双指针的做法</a>，思路是用左右两个索引划定出子字符串的区间，再定义「在这个区间中所能出现的不重复的字符数」，这个字符数就是最外层循环的边界1～26，内层就根据给定的频数和这个限制确定挪动左边界还是右边界：先尝试挪动右边界，如果这个字符在这部分字符串中是否出现过（利用count数组统计频数），并看看更新频数后这个频数是否满足了给定最小频数；如果这一波下来发现当前的子字符串中所有出现的字符都满足最小频数，就更新长度；至于什么时候挪动左边界呢？当子字符串中出现的字符数超过外层循环限制时，就需要挪动左边界，同时更新count数组和相关的变量，例如挪出后出现的字符数和满足最小频数的字符数都可能会受到count数组的影响。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/115724068/">这样</a>。</li>
</ul>
<h4 id="396-rotate-function"><a href="#396-rotate-function" class="headerlink" title="396. rotate-function"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/rotate-function/description/">396. rotate-function</a></h4><ul>
<li>定义一个rotate函数，<code>F(0)</code>表示不旋转、<code>F(1)</code>表示后挪一位…函数输出的是各索引的数字乘以索引之和。求从<code>F(0)</code>到<code>F(n-1)</code>中的最大值。</li>
<li>ME：我只想到了暴力法，感觉也不难实现就啥也没管直接试了一发，就是按照函数的定义这样暴力实现出来，讲道理应该是O(N^2)的时间复杂度，我原本都做好了超时的心理准备了，竟然改好WA之后（一开始以为全是正数，就没有把初始值设成最小负数）<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/115553812/">这样子</a>就过了。不过看了一下，速度是勉强过的那种，说明症结正解还不是这样。</li>
<li>TA：看到discuss版一溜的O(N)，我震惊了。看了<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/58459/java-o-n-solution-with-explanation/">这个</a>顿悟，这踏马的是数列问题啊！根据F的公式可以推导出F(k)和F(k-1)的关系，那就可以从F(0)开始逐步往后更新，用到哪更新到哪，每一步都求一个最大值就好了。<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/115557946/">写出来O(N)这个果然</a>就快很多了。</li>
</ul>
<h4 id="397-integer-replacement"><a href="#397-integer-replacement" class="headerlink" title="397. integer-replacement"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/integer-replacement/description/">397. integer-replacement</a></h4><ul>
<li>给一个数字n，如果是偶数则除2，奇数则加1或减1，求最少经过多少步能从n变成1.</li>
<li>ME：第一反应就是DP，但直接用n作为dp数组的规模会导致内存爆炸。后来偷看了一下discuss，发现时bit manipulation位操作，于是又暗中观察了一下，找出了规律。对于偶数可以直接右移一位，奇数则需要递归看看加1和减1的偶数的情况。但是第一次提交还是错误，因为Integer.MAX_VALUE边界情况有点奇怪，正常来说只能是前一个偶数的操作数加1，但是这题其实是允许unsigned数字出现的，因此实际上它还可以往后一个偶数2^31递归，这时就只是简单地从31右移到第0位了，因此是1 + 31.不过我还是觉得很怪。。。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/115533711/">这样</a>。</li>
<li>TA：其实我一开始看的是<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/58334/a-couple-of-java-solutions-with-explanations">这个</a>但其实没有认真看答主的思路。他的想法是，每步操作都尽量减少1的个数，对于偶数没话说直接unsigned shift，对于奇数就需要判断一下最后一位之前是0还是1，如果是0说明当前数减1是个好选择，如果是1说明当前数加1能消除尽量多的结尾1.</li>
</ul>
<h4 id="398-random-pick-index"><a href="#398-random-pick-index" class="headerlink" title="398. random-pick-index"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/random-pick-index/description/">398. random-pick-index</a></h4><ul>
<li>给一个数组，然后给一个目标值，随机返回一个在数组中这个目标值出现的索引。</li>
<li>ME：偷看了一下discuss，发现又是reservior抽样问题，和前面382很像。。先来一遍找出target出现的所有索引并add到List中，然后从前往后生成Random.nextInt来刷新结果，最后返回。懂了之后写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/115522958/">这样</a>。</li>
<li>TA：我看的就是<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/58301/simple-reservoir-sampling-solution/">这个</a>，答主并没有用到额外的ArrayList，而是巧妙地利用了索引为0的情况。<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/115524090/">模仿了一下</a>。</li>
</ul>
<h4 id="399-evaluate-division"><a href="#399-evaluate-division" class="headerlink" title="399. evaluate-division"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/evaluate-division/description/">399. evaluate-division</a></h4><ul>
<li>用字符串代表一些数值，给出一系列字符串对，再给一系列它们对应相除的结果，然后给一组字符串对，求这些query的相除结果。</li>
<li>ME：Ummm，一开始WA了一波，只能reshape思路了。偷看了一下别人的思路，我才意识到这是一个graph题，可以抽象成一个双向图，每个字符串都作为节点，然后权重就是两个节点的商。我的做法分三步：遍历一遍形成str到index的映射，然后建立邻接矩阵并把权重填充进去（正反都放，不存在就是0），最后就query的时候就用DFS，遍历当前节点所有能走到的节点看看能否到达终点。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/115463103/">这样</a>，没想到出奇地快。</li>
<li>TA：自己会了之后看类似的就不太有动力看了。。<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/58981/java-solution-using-floyd-warshall-algorithm">这个</a>倒是挺简洁的，而且也提示我，是不是可以对应修改一下matrix中的值？这样下次query就不会重复计算了。</li>
</ul>
<h4 id="400-nth-digit"><a href="#400-nth-digit" class="headerlink" title="400. nth-digit"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/nth-digit/description/">400. nth-digit</a></h4><ul>
<li>给一个正整数n，求1, 2, 3, …这一系列数组组成的连续字符串中的第n个数字。</li>
<li>ME：一开始自己做居然<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/113016261/">他喵的超时了</a>。。。</li>
<li>TA：还是看了<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/59314/java-solution">大神的杰作</a>。思路是先根据数字的长度找到要求的这个n所在的数字具体是几位数，一位数有9个，两位数有90个， 三位数有900个…然后在这个范围内求n所在的数字具体是几，这就可以通过定义一个x位数的起始数字往后加的形式求得了，也就是在前面求n所在范围时不断减去一位数、两位数的个数这样，然后到了当前范围内的第n个，就可以用<code>(n - 1) / 几位数</code>来求n在第几个数，加上起始数字就找到了。最后就是看看n在这个数字内部是第几个，那同样是<code>(n - 1) % 几位数</code>就可以找到了。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/113017506/">这样</a>。</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
              <a href="/tags/algorithm/" rel="tag"># algorithm</a>
              <a href="/tags/interview/" rel="tag"># interview</a>
              <a href="/tags/leetcode/" rel="tag"># leetcode</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2017/07/01/reading_note2017_2/" rel="prev" title="闲书摘录2017下">
                  <i class="fa fa-angle-left"></i> 闲书摘录2017下
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2017/09/04/cheatsheet/" rel="next" title="Algorithm reference cheatsheet">
                  Algorithm reference cheatsheet <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2016 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="futbol-o"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Bob</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"bobbyliujb","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js" defer></script>

</body>
</html>
