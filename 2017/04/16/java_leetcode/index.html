<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"bobbyliujb.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"hide","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="刷题。祝我好运。">
<meta property="og:type" content="article">
<meta property="og:title" content="Note for LeetCode in Java (1~100)">
<meta property="og:url" content="https://bobbyliujb.github.io/2017/04/16/java_leetcode/index.html">
<meta property="og:site_name" content="Bob&#39;s Blog">
<meta property="og:description" content="刷题。祝我好运。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2017-04-17T00:23:42.000Z">
<meta property="article:modified_time" content="2021-06-01T00:32:42.280Z">
<meta property="article:author" content="Bob">
<meta property="article:tag" content="java">
<meta property="article:tag" content="algorithm">
<meta property="article:tag" content="interview">
<meta property="article:tag" content="leetcode">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://bobbyliujb.github.io/2017/04/16/java_leetcode/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://bobbyliujb.github.io/2017/04/16/java_leetcode/","path":"2017/04/16/java_leetcode/","title":"Note for LeetCode in Java (1~100)"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Note for LeetCode in Java (1~100) | Bob's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-118868735-1"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-118868735-1","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js" defer></script>








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Bob's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Two-Sum"><span class="nav-number">1.</span> <span class="nav-text">1. Two Sum</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Add-2-Num"><span class="nav-number">2.</span> <span class="nav-text">2. Add 2 Num</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Longest-substring"><span class="nav-number">3.</span> <span class="nav-text">3. Longest substring</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Median-of-2-sorted-arrays"><span class="nav-number">4.</span> <span class="nav-text">4. Median of 2 sorted arrays</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-Longest-palindromic-substring"><span class="nav-number">5.</span> <span class="nav-text">5. Longest palindromic substring</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-zigzag-conversion"><span class="nav-number">6.</span> <span class="nav-text">6. zigzag-conversion</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-reverse-integer"><span class="nav-number">7.</span> <span class="nav-text">7. reverse-integer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-string-to-integer-atoi"><span class="nav-number">8.</span> <span class="nav-text">8. string-to-integer-atoi</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-palindrome-number"><span class="nav-number">9.</span> <span class="nav-text">9. palindrome-number</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-regular-expression-matching"><span class="nav-number">10.</span> <span class="nav-text">10. regular-expression-matching</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#container-with-most-water"><span class="nav-number">11.</span> <span class="nav-text">container-with-most-water</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#integer-to-roman"><span class="nav-number">12.</span> <span class="nav-text">integer-to-roman</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#roman-to-integer"><span class="nav-number">13.</span> <span class="nav-text">roman-to-integer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-longest-common-prefix"><span class="nav-number">14.</span> <span class="nav-text">14. longest-common-prefix</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-3-Sum"><span class="nav-number">15.</span> <span class="nav-text">15. 3 Sum</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3sum-closest"><span class="nav-number">16.</span> <span class="nav-text">3sum-closest</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17-letter-combinations"><span class="nav-number">17.</span> <span class="nav-text">17. letter-combinations</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Sum"><span class="nav-number">18.</span> <span class="nav-text">4 Sum</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#remove-nth-node-from-end-of-list"><span class="nav-number">19.</span> <span class="nav-text">remove-nth-node-from-end-of-list</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#20-valid-parentheses"><span class="nav-number">20.</span> <span class="nav-text">20. valid-parentheses</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#21-merge-two-sorted-lists"><span class="nav-number">21.</span> <span class="nav-text">21. merge-two-sorted-lists</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#22-generate-parentheses"><span class="nav-number">22.</span> <span class="nav-text">22. generate-parentheses</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#23-merge-k-sorted-lists"><span class="nav-number">23.</span> <span class="nav-text">23. merge-k-sorted-lists</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#24-swap-nodes-in-pairs"><span class="nav-number">24.</span> <span class="nav-text">24. swap-nodes-in-pairs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reverse-nodes-in-k-group"><span class="nav-number">25.</span> <span class="nav-text">reverse-nodes-in-k-group</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#remove-duplicates-from-sorted-array"><span class="nav-number">26.</span> <span class="nav-text">remove-duplicates-from-sorted-array</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#remove-element"><span class="nav-number">27.</span> <span class="nav-text">remove-element</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#28-implement-strStr"><span class="nav-number">28.</span> <span class="nav-text">28. implement-strStr</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#29-divide-two-integers"><span class="nav-number">29.</span> <span class="nav-text">29. divide-two-integers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#30-substring-with-concatenation-of-all-words"><span class="nav-number">30.</span> <span class="nav-text">30. substring-with-concatenation-of-all-words</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#31-next-permutation"><span class="nav-number">31.</span> <span class="nav-text">31. next-permutation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#longest-valid-parentheses"><span class="nav-number">32.</span> <span class="nav-text">longest-valid-parentheses</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#search-in-rotated-sorted-array"><span class="nav-number">33.</span> <span class="nav-text">search-in-rotated-sorted-array</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#find-first-and-last-position-of-element-in-sorted-array"><span class="nav-number">34.</span> <span class="nav-text">find-first-and-last-position-of-element-in-sorted-array</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#search-insert-position"><span class="nav-number">35.</span> <span class="nav-text">search-insert-position</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#36-valid-sudoku"><span class="nav-number">36.</span> <span class="nav-text">36. valid-sudoku</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#37-sudoku-solver"><span class="nav-number">37.</span> <span class="nav-text">37. sudoku-solver</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#count-and-say"><span class="nav-number">38.</span> <span class="nav-text">count-and-say</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#combination-sum"><span class="nav-number">39.</span> <span class="nav-text">combination-sum</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#combination-sum-ii"><span class="nav-number">40.</span> <span class="nav-text">combination-sum-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#41-first-missing-positive"><span class="nav-number">41.</span> <span class="nav-text">41. first-missing-positive</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#42-trapping-rain-water"><span class="nav-number">42.</span> <span class="nav-text">42. trapping-rain-water</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#43-multiply-strings"><span class="nav-number">43.</span> <span class="nav-text">43. multiply-strings</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#44-wildcard-matching"><span class="nav-number">44.</span> <span class="nav-text">44. wildcard-matching</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#jump-game-ii"><span class="nav-number">45.</span> <span class="nav-text">jump-game-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#permutations"><span class="nav-number">46.</span> <span class="nav-text">permutations</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#permutations-ii"><span class="nav-number">47.</span> <span class="nav-text">permutations-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rotate-image"><span class="nav-number">48.</span> <span class="nav-text">rotate-image</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#group-anagrams"><span class="nav-number">49.</span> <span class="nav-text">group-anagrams</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#powx-n"><span class="nav-number">50.</span> <span class="nav-text">powx-n</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#n-queens"><span class="nav-number">51.</span> <span class="nav-text">n-queens</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#n-queens-ii"><span class="nav-number">52.</span> <span class="nav-text">n-queens-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#53-maximum-subarray"><span class="nav-number">53.</span> <span class="nav-text">53. maximum-subarray</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#spiral-matrix"><span class="nav-number">54.</span> <span class="nav-text">spiral-matrix</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#jump-game"><span class="nav-number">55.</span> <span class="nav-text">jump-game</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#56-merge-intervals"><span class="nav-number">56.</span> <span class="nav-text">56. merge-intervals</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#insert-interval"><span class="nav-number">57.</span> <span class="nav-text">insert-interval</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#length-of-last-word"><span class="nav-number">58.</span> <span class="nav-text">length-of-last-word</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#59-spiral-matrix-ii"><span class="nav-number">59.</span> <span class="nav-text">59. spiral-matrix-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#permutation-sequence"><span class="nav-number">60.</span> <span class="nav-text">permutation-sequence</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rotate-list"><span class="nav-number">61.</span> <span class="nav-text">rotate-list</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unique-paths"><span class="nav-number">62.</span> <span class="nav-text">unique-paths</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unique-paths-ii"><span class="nav-number">63.</span> <span class="nav-text">unique-paths-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#minimum-path-sum"><span class="nav-number">64.</span> <span class="nav-text">minimum-path-sum</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#valid-number"><span class="nav-number">65.</span> <span class="nav-text">valid-number</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#plus-one"><span class="nav-number">66.</span> <span class="nav-text">plus-one</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#67-add-binary"><span class="nav-number">67.</span> <span class="nav-text">67. add-binary</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#text-justification"><span class="nav-number">68.</span> <span class="nav-text">text-justification</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sqrtx"><span class="nav-number">69.</span> <span class="nav-text">sqrtx</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#climbing-stairs"><span class="nav-number">70.</span> <span class="nav-text">climbing-stairs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#simplify-path"><span class="nav-number">71.</span> <span class="nav-text">simplify-path</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#72-edit-distance"><span class="nav-number">72.</span> <span class="nav-text">72. edit-distance</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#set-matrix-zeroes"><span class="nav-number">73.</span> <span class="nav-text">set-matrix-zeroes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#search-a-2d-matrix"><span class="nav-number">74.</span> <span class="nav-text">search-a-2d-matrix</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#75-sort-colors"><span class="nav-number">75.</span> <span class="nav-text">75. sort-colors</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#minimum-window-substring"><span class="nav-number">76.</span> <span class="nav-text">minimum-window-substring</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#combinations"><span class="nav-number">77.</span> <span class="nav-text">combinations</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#subsets"><span class="nav-number">78.</span> <span class="nav-text">subsets</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#word-search"><span class="nav-number">79.</span> <span class="nav-text">word-search</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#remove-duplicates-from-sorted-array-ii"><span class="nav-number">80.</span> <span class="nav-text">remove-duplicates-from-sorted-array-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#search-in-rotated-sorted-array-ii"><span class="nav-number">81.</span> <span class="nav-text">search-in-rotated-sorted-array-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#remove-duplicates-from-sorted-list-ii"><span class="nav-number">82.</span> <span class="nav-text">remove-duplicates-from-sorted-list-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#remove-duplicates-from-sorted-list"><span class="nav-number">83.</span> <span class="nav-text">remove-duplicates-from-sorted-list</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#largest-rectangle-in-histogram"><span class="nav-number">84.</span> <span class="nav-text">largest-rectangle-in-histogram</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#85-maximal-rectangle"><span class="nav-number">85.</span> <span class="nav-text">85. maximal-rectangle</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#partition-list"><span class="nav-number">86.</span> <span class="nav-text">partition-list</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#scramble-string"><span class="nav-number">87.</span> <span class="nav-text">scramble-string</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#merge-sorted-array"><span class="nav-number">88.</span> <span class="nav-text">merge-sorted-array</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gray-code"><span class="nav-number">89.</span> <span class="nav-text">gray-code</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#subsets-ii"><span class="nav-number">90.</span> <span class="nav-text">subsets-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#91-decode-ways"><span class="nav-number">91.</span> <span class="nav-text">91. decode-ways</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reverse-linked-list-ii"><span class="nav-number">92.</span> <span class="nav-text">reverse-linked-list-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#restore-ip-addresses"><span class="nav-number">93.</span> <span class="nav-text">restore-ip-addresses</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#binary-tree-inorder-traversal"><span class="nav-number">94.</span> <span class="nav-text">binary-tree-inorder-traversal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#95-unique-binary-search-trees-ii"><span class="nav-number">95.</span> <span class="nav-text">95. unique-binary-search-trees-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#96-unique-binary-search-trees"><span class="nav-number">96.</span> <span class="nav-text">96. unique-binary-search-trees</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#97-interleaving-string"><span class="nav-number">97.</span> <span class="nav-text">97. interleaving-string</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#98-validate-binary-search-tree"><span class="nav-number">98.</span> <span class="nav-text">98. validate-binary-search-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#99-recover-binary-search-tree"><span class="nav-number">99.</span> <span class="nav-text">99. recover-binary-search-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#100-same-tree"><span class="nav-number">100.</span> <span class="nav-text">100. same-tree</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Bob"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Bob</p>
  <div class="site-description" itemprop="description">I'm a Software Engineer!</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">50</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://bobbyliujb.github.io/2017/04/16/java_leetcode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bob">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bob's Blog">
      <meta itemprop="description" content="I'm a Software Engineer!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Note for LeetCode in Java (1~100) | Bob's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Note for LeetCode in Java (1~100)
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-04-16 17:23:42" itemprop="dateCreated datePublished" datetime="2017-04-16T17:23:42-07:00">2017-04-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-05-31 17:32:42" itemprop="dateModified" datetime="2021-05-31T17:32:42-07:00">2021-05-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Tech/" itemprop="url" rel="index"><span itemprop="name">Tech</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2017/04/16/java_leetcode/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/04/16/java_leetcode/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>刷题。祝我好运。</p>
<span id="more"></span>

<h4 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/two-sum">1. Two Sum</a></h4><ul>
<li>给定一串整型数组，给一个目标值，求数组中唯一的一对数字，相加得到该目标值。</li>
<li>ME：先排序，然后二分查找遍历一遍看看给定数字a能否找到数字b &#x3D; target - a。确定后再回到原数组扫出a和b的位置。时间nlogn + n*logn + n.</li>
<li>TA：利用HashMap，从头到尾扫原数组，先查看b &#x3D; target - a是否在HashMap的Key中，不在则把值和索引分别作为键和值加入HashMap。一旦扫到符合的即可输出，时间为n。（Java的HashMap查找是O(1)的，C++中是O(logn)）</li>
</ul>
<h4 id="2-Add-2-Num"><a href="#2-Add-2-Num" class="headerlink" title="2. Add 2 Num"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/add-two-numbers">2. Add 2 Num</a></h4><ul>
<li>给两个链表，每个节点是一个数字，输出也是一个链表，每个节点就是那两个输入链表对应节点的值之和。</li>
<li>ME：就是个简单版模拟加法，和归并排序总体思路差不多，都是一个将两个链表相加直到其中一个为空，再把剩余内容继续倒出来，只不过要考虑多个进位问题。开始没通过就是因为没考虑两个链表都加完了，进位可能还得加的情况。</li>
<li>TA：想法一样，但代码简洁很多。我的三个while循环可以归整到一个while里面，在里面再判断链表谁空了；进位和加法整合，上一步的进位直接用到这一步的加法中，省去了一个变量；少了first_flag因为他直接设了一个sentinel，它的下一位才是要返回的内容。</li>
</ul>
<h4 id="3-Longest-substring"><a href="#3-Longest-substring" class="headerlink" title="3. Longest substring"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-substring-without-repeating-characters/#/description">3. Longest substring</a></h4><ul>
<li>给一个字符串，找其中不含重复字符的最长子串的长度。</li>
<li>ME：利用HashMap&lt;Character, Integer&gt;，再利用一个log数组记录每个字符的对应的长度计数（其实可以不用），然后从前往后扫<br>  -&gt; 若不在HashMap中则直接把char, index插入，并在log的对应位置赋值为前面一位计数值+1；<br>  -&gt; 若已经出现过，则取『前面一位计数值+1』和『距离HashMap中存放index的距离』二者的较小值。</li>
<li>TA：引入了双指针而不需要我这样的log数组， 左指针指向在HashMap出现过的字符get到的index的下一位，右指针一直向后遍历。两个指针之间的距离就是所求的最大子串了。还有一种DP动态规划的方法，用一个数组模拟HashMap，初始值为-1，每个字符出现时就会更新为它的索引，不过它也需要和ME的方法一样用到一个取max的过程来保证更新最大长度时不出错。</li>
<li>HashMap的get(key)返回的value需要强制转换一下才能用。(???当时为啥写这句)</li>
<li>Two pointers. three fails.</li>
</ul>
<h4 id="4-Median-of-2-sorted-arrays"><a href="#4-Median-of-2-sorted-arrays" class="headerlink" title="4. Median of 2 sorted arrays"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/median-of-two-sorted-arrays/#/solutions">4. Median of 2 sorted arrays</a></h4><ul>
<li>给两个int数组，返回二者合并后的中位数，要求在O(log(m+n))的时间复杂度以内。</li>
<li>ME：很直接地想到mergeSort的最后一步，将两个有序数组合并，然后合并到总长度一半的时候就知道中位数了。但这个方法时间复杂度似乎是O((m+n)&#x2F;2)？虽然AC了但并不符合要求。。。其实看到有序、logN，还能想到的就是二分查找了。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/4996/share-my-o-log-min-m-n-solution-with-explanation">中位数是用来将数组分割成相等长度的两部分的</a>，因此使用二分查找找出刚好能分成登等长的两部分并且前部分的最大值&lt;&#x3D;后部分的最小值。边缘情况真的特别复杂，比较难理解，怪不得是hard题。</li>
<li>BinarySearch. know nothing about the method of split and check.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1 == <span class="literal">null</span> || nums2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums1.length, n = nums2.length;</span><br><span class="line">        <span class="keyword">if</span> (nums1.length &gt; nums2.length) &#123;  <span class="comment">// ensure the len of 1 &lt;= 2</span></span><br><span class="line">            <span class="keyword">return</span> findMedianSortedArrays(nums2, nums1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// to ensure equality of the two parts after merged, i + j = m - i + n - j</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">iLo</span> <span class="operator">=</span> <span class="number">0</span>, iHi = m, allMid = (n + m + <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// merge odd / even case</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// i stands for &quot;how many num taken from nums1 as front part&quot; 0 ~ i-1 | i ~ m-1</span></span><br><span class="line">        <span class="comment">// j stands for &quot;how many num taken from nums2 as front part&quot; 0 ~ j-1 | j ~ n-1</span></span><br><span class="line">        <span class="keyword">while</span> (iLo &lt;= iHi) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (iLo + iHi) / <span class="number">2</span>, j = allMid - i;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// nums1[i-1], nums2[j-1] are the largest element of front part of nums1, nums2</span></span><br><span class="line">            <span class="comment">// nums1[i], nums2[j] are the smallest of lag part of nums1, nums2</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; m &amp;&amp; nums2[j - <span class="number">1</span>] &gt; nums1[i]) &#123; <span class="comment">// i not big enough</span></span><br><span class="line">                iLo = i + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums1[i - <span class="number">1</span>] &gt; nums2[j]) &#123;</span><br><span class="line">                iHi = i - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">maxLeft</span> <span class="operator">=</span> <span class="number">0</span>, minRight = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    maxLeft = nums2[j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    maxLeft = nums1[i - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    maxLeft = Math.max(nums1[i - <span class="number">1</span>], nums2[j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> ((m + n) % <span class="number">2</span> == <span class="number">1</span>) &#123; <span class="comment">// I think thats why to make (allMid = (n + m + 1)/2)</span></span><br><span class="line">                    <span class="keyword">return</span> maxLeft;     <span class="comment">// -- to make left part always at least no fewer than right</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (i == m) &#123;</span><br><span class="line">                    minRight = nums2[j];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == n) &#123;</span><br><span class="line">                    minRight = nums1[i];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    minRight = Math.min(nums1[i], nums2[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> (maxLeft + minRight) / <span class="number">2.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-Longest-palindromic-substring"><a href="#5-Longest-palindromic-substring" class="headerlink" title="5. Longest palindromic substring"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-palindromic-substring/">5. Longest palindromic substring</a></h4><ul>
<li>给一个字符串，返回最长的回文子串（对称）。</li>
<li>ME：没有想出来高招，暴力法果断超时。。暴力法就是一个指针从头开始，另一个指针从尾巴往回扫，看看是否和前面指针相同，相同就进一步分别向右挪&#x2F;向左挪，以此类推。。。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/23498/very-simple-clean-java-solution/2">这个</a>似乎也是暴力法，只是用了更优雅的方式——双指针分别扩展，而我的暴力法是双指针向中间合拢，扩展的方式在worst case下复杂度也是O( n^2)。</li>
<li>Brute force - expanding to double side index. edge case mistakes…</li>
<li>DP也可以解决。</li>
</ul>
<h4 id="6-zigzag-conversion"><a href="#6-zigzag-conversion" class="headerlink" title="6. zigzag-conversion"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/zigzag-conversion/#/description">6. zigzag-conversion</a></h4><ul>
<li>给一个字符串和行数，输出转换为zig-zag形式的对应字符串。</li>
<li>ME：找规律找出来的，直接用下标变化规律，不像是在解算法题，或者说只是我运气好找到了规律。（话说回来，我的代码速度还挺快的，毕竟是直接套规律搞出来的）</li>
<li>TA：按照真正的zig-zag式分布来写，每一行都定义了一个StringBuffer，从上往下再从下往上将每一行的字符串逐步拼接起来，最后汇总一下即可，这样的代码非常方便别人理解，不像你的要是不解释下标的变化规律别人怎么可能看得懂。</li>
<li>String转char[]用<code>s.toCharArray()</code>。</li>
<li>Just using stringbuilder appending to simulate the process. Two fails for numRows too small &#x2F; charCount too small.</li>
</ul>
<h4 id="7-reverse-integer"><a href="#7-reverse-integer" class="headerlink" title="7. reverse-integer"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-integer/#/description">7. reverse-integer</a></h4><ul>
<li>给一个32bit的带符号整数，输出倒序的这个数字并保持符号。若越界则返回0.</li>
<li>ME：简单粗暴取商、取模来做，负数则直接取反来搞。两次WA，一是越界判断是用『加完后变为负值』而实际上越界可以一越越到了正值部分，所以不可以这样；而是-2147483648这个值直接取反会越界，我后来直接处理着情况了。。。有点jian。</li>
<li>TA：直接使用取商、取模而不理会正值或负值，在JAVA中负数取模会尽量让商更大（-7 % 3 &#x3D; -1），看起来就是正数取模加个负号罢了。而越界判断使用的是计算出的值减去个位数除以10看看是否等于计算前的值。</li>
<li>Ok. Just mod and divide. Negetive mod is very similar to positive mod in Java.</li>
</ul>
<h4 id="8-string-to-integer-atoi"><a href="#8-string-to-integer-atoi" class="headerlink" title="8. string-to-integer-atoi"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/string-to-integer-atoi">8. string-to-integer-atoi</a></h4><p> 待。。。</p>
<h4 id="9-palindrome-number"><a href="#9-palindrome-number" class="headerlink" title="9. palindrome-number"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/palindrome-number/#/description">9. palindrome-number</a></h4><ul>
<li>给一个整数，判断它是不是回文数。要求不能额外申请对象空间，也就不能转成字符串处理了。</li>
<li>ME：简单粗暴，头尾分别取数字对比。边缘情况包括0和负数。但跑测试用例速度巨慢。。。</li>
<li>TA：在<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/12820/an-easy-c-8-lines-code-only-reversing-till-half-and-then-compare">这个方法</a>中直接改变原数字x，取x的前半部分和后半部分之reverse对比，不过除了x&#x3D;&#x3D;rev，还有一种情况是奇数时rev比x多一位，这时需要判定x&#x3D;&#x3D;rev&#x2F;10。边缘情况是负数和个位为0直接判定false，0不用。</li>
<li>Forgot the method of cutting into half and reverse the latter to compare. the condition to end the loop of splitting into half is awesome. Fail at case x&#x3D;10 because 0 digit in the right half can’t be represented properly into front after reversed.</li>
</ul>
<h4 id="10-regular-expression-matching"><a href="#10-regular-expression-matching" class="headerlink" title="10. regular-expression-matching"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/regular-expression-matching">10. regular-expression-matching</a></h4><ul>
<li>实现一个字符串正则表达式匹配函数，需要实现<code>.</code>和<code>*</code>。</li>
<li>ME：真心不会。。。看了讨论板块发现要用到DP，必须学一波动态规划了。</li>
<li>TA：参考了一个<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/6183/my-concise-recursive-and-dp-solutions-with-full-explanation-in-c">带有比较详细解释的C++帖子</a>。动态规划DP关键是找到状态以及状态之间的转换规律，在这题中，既然是目标字符串s和正则字符串p之间相互比较，就需要维护一个boolean的二维数组dp[i][j]，表示<code>s[0~i-1]</code>与<code>p[0~j-1]</code>是否匹配。观众朋友会问了，那么dp[i][0]和dp[0][j]表示什么呢？<br>  -&gt; dp[i][0]就是正则字符串p为空的情况，显然dp[0][0]为真，而只要s不为空就不可能用空的p来匹配上它，因此dp[i][0]除了首位，全部初始化为false；<br>  -&gt; dp[0][j]就表示目标字符串s为空的情况，由于p可能有一个bug级的<code>&#39;*&#39;</code>存在，不能轻易全部赋值为false，例如<code>a*b*c*</code>就可以匹配空的s，对于dp[0][j]就需要动用状态转移了，dp[0][j]取决于当前字符p[j-1]是否为<code>&#39;*&#39;</code>且往前两位字符处的匹配情况dp[0][j-2]。<br>  至此，dp数组初始状态设置完成。下面正式讨论状态转移。<br>  -&gt; 当前字符p[j-1]不是<code>&#39;*&#39;</code>: dp[i][j]取决于当前字符p[j-1]是否等于s[s-1]且须考虑前一个字符的匹配情况dp[i-1][j-1]。<br>  -&gt; 当前字符p[j-1]是<code>&#39;*&#39;</code>，则又要讨论这个<code>&#39;*&#39;</code>前面的字符p[j-2]应该算几个：<br>i) 算0个：说明把p[j-2]和p[j-1]抽离后不影响判断，由s[0<del>i-1]和p[0</del>j-3]决定，即dp[i][j-2];<br>ii) 算&gt;&#x3D;1个：说明把目标字符串s末尾若干个与p[j-2]相同的元素抽离后不影响判断，那么此处就以抽离一个为判断依据，除了判断s[i-1] &#x3D;&#x3D; p[j-2]，还要考虑抽离s[i-1]后的s[0<del>i-2]也与p[0</del>j-1]匹配（<code>&#39;*&#39;</code>前面的这个字符在这里大不了算0次，但这也是之前就出来的结果了，这一步直接用就好）<br>  至于<code>&#39;.&#39;</code>字符就在判断各个字符的时候单独拎出来判断一下就好了。</li>
<li>Not able to analyse DP, let alone implementing.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (s == <span class="literal">null</span> || p == <span class="literal">null</span> || s.equals(p)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">char</span>[] sChar = s.toCharArray(), pChar = p.toCharArray();</span><br><span class="line">      <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> sChar.length, n = pChar.length;</span><br><span class="line">      <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span> [m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// initial the dp states</span></span><br><span class="line">      dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j &lt;= n; j++) &#123;</span><br><span class="line">          dp[<span class="number">0</span>][j] = pChar[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; dp[<span class="number">0</span>][j - <span class="number">2</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">              <span class="keyword">if</span> (pChar[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;  </span><br><span class="line">                  <span class="comment">// check if ignoring curr pattern</span></span><br><span class="line">                  <span class="comment">// OR (the char is matched AND ignoring curr pattern)</span></span><br><span class="line">                  dp[i][j] = (dp[i][j - <span class="number">2</span>]) </span><br><span class="line">                      || ((sChar[i - <span class="number">1</span>] == pChar[j - <span class="number">2</span>] || pChar[j - <span class="number">2</span>] == <span class="string">&#x27;.&#x27;</span>) &amp;&amp; dp[i - <span class="number">1</span>][j]);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">// check if char is matched for curr pattern</span></span><br><span class="line">                  dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] </span><br><span class="line">                      &amp;&amp; (sChar[i - <span class="number">1</span>] == pChar[j - <span class="number">1</span>] || pChar[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// note that match means char equalation or equal to dot</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dp[m][n];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="container-with-most-water"><a href="#container-with-most-water" class="headerlink" title="container-with-most-water"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/container-with-most-water/#/description">container-with-most-water</a></h4><ul>
<li>给一串int数组，取其中两个作为高、Index距离作为宽组成的面积最大是多少。</li>
<li>ME：只想到暴力法，果断超时。。。</li>
<li>TA：利用双指针，分别从头和尾向中间移动来更新max值，每次移动二者之间的较小值。<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/3462/yet-another-way-to-see-what-happens-in-the-o-n-algorithm">证明在此</a>，若左边小于右边则向右移动左指针的道理是，左指针既然已经小过右指针了，此时体积就由左边决定，右指针往左移只会让面积越变越小没有计算的意义，而左指针往右移倒可能碰上更高的边从而有更大的面积；若右边小于左边则向左移动右指针的道理也类似，既然右边都小了你再让左边挪过来缩短宽度只会让面积更小，移右边才可能有更大面积。</li>
<li>Fail to come up with double pointer method from front and end. Implementation OK after knowing it.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (height == <span class="literal">null</span> || height.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initial two pointers starting from front and end</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = height.length - <span class="number">1</span>, area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left != right) &#123;</span><br><span class="line">      <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">        area = Math.max(area, height[left] * (right - left));</span><br><span class="line">        left ++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        area = Math.max(area, height[right] * (right - left));</span><br><span class="line">        right --;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="integer-to-roman"><a href="#integer-to-roman" class="headerlink" title="integer-to-roman"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/integer-to-roman/#/description">integer-to-roman</a></h4><ul>
<li>给一个int，转化为<a target="_blank" rel="noopener" href="http://baike.baidu.com/link?url=yCaufG7V4ruU8QRcBOxrUHZmd8DArUU84Ays7vOW4ylQ78HadbMErUBGVK7RvWnOQwLCUjS5V_aPDAY0zBz4W4Jtv1U3ezJ6jCyqN6OMWXJas8LPmOA1v2ANNlGBMxZj">罗马数字</a>字符串。</li>
<li>ME：暴力法，每次取一位数字来决定输出多少M D C L X V I，速度贼慢。</li>
<li>TA：直接用一个数组把1000、100、10、1级别的0~9都定义在数组里，每次直接取了append到字符串即可。服。</li>
<li>Seems a boring problem…But at first glance, still unable to figure out the simplified appending method above. Implementation OK.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> String[] ONES = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;II&quot;</span>, <span class="string">&quot;III&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;VI&quot;</span>, <span class="string">&quot;VII&quot;</span>, <span class="string">&quot;VIII&quot;</span>, <span class="string">&quot;IX&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">final</span> String[] TENS = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;XX&quot;</span>, <span class="string">&quot;XXX&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;LX&quot;</span>, <span class="string">&quot;LXX&quot;</span>, <span class="string">&quot;LXXX&quot;</span>, <span class="string">&quot;XC&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">final</span> String[] HDRS = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;CC&quot;</span>, <span class="string">&quot;CCC&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;DC&quot;</span>, <span class="string">&quot;DCC&quot;</span>, <span class="string">&quot;DCCC&quot;</span>, <span class="string">&quot;CM&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">final</span> String[] THSS = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;MM&quot;</span>, <span class="string">&quot;MMM&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> THSS[(num / <span class="number">1000</span>)] + HDRS[(num % <span class="number">1000</span>)/<span class="number">100</span>] + TENS[(num % <span class="number">100</span>)/<span class="number">10</span>] + ONES[(num % <span class="number">10</span>)];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="roman-to-integer"><a href="#roman-to-integer" class="headerlink" title="roman-to-integer"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/roman-to-integer/#/description">roman-to-integer</a></h4><ul>
<li>给一个罗马数字，转化为int.</li>
<li>ME：开了switch case语句和一堆判断。速度竟然超过96%的方法，惊了。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/821/my-solution-for-this-question-but-i-don-t-know-is-there-any-easier-way/3">二楼</a>是比较整洁的代码。</li>
<li>Still unable to come up with the method using table and simple add&#x2F;substract. The rule of add&#x2F;subtarct is subtle. Implementation with error of MISSING NEW!!!!</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">romanToInt</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&#x27;I&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;V&#x27;</span>, <span class="number">5</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;X&#x27;</span>, <span class="number">10</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;L&#x27;</span>, <span class="number">50</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;C&#x27;</span>, <span class="number">100</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;D&#x27;</span>, <span class="number">500</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;M&#x27;</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>, prev = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>[] sChar = s.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sChar.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">curr</span> <span class="operator">=</span> map.get(sChar[i]);</span><br><span class="line">      <span class="keyword">if</span> (curr &lt; prev) &#123;</span><br><span class="line">        ans -= curr;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ans += curr;</span><br><span class="line">      &#125;</span><br><span class="line">      prev = curr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="14-longest-common-prefix"><a href="#14-longest-common-prefix" class="headerlink" title="14. longest-common-prefix"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-common-prefix/#/description">14. longest-common-prefix</a></h4><ul>
<li>给一串字符串数组，求这些字符串开头的公共部分。</li>
<li>ME：暴力解之，每次取较短的作为终止长度，逐个字符判断。</li>
<li>TA：用了Array.sort将字符串数组从小到大排序，只比较最短的和最长的前置部分有什么相同的。不过从复杂度来说，排序的nlogn是逃不掉的。最主要省时间的地方是比较，它只比较最前和最后的两个，而你的是每个都要比较。</li>
<li>OK.</li>
</ul>
<h4 id="15-3-Sum"><a href="#15-3-Sum" class="headerlink" title="15. 3 Sum"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/3sum/#/description">15. 3 Sum</a></h4><ul>
<li>给一个int数组，列出三个数使得它们的和为0.</li>
<li>ME：排序之后暴力一前一后暴力找，果断超时，连2Sum时想到的二分查找都没想到，还自鸣得意地用一前一后两个指针在挪着着，果断慢啊，思考又复杂写出来还慢，实在浪费脑力和时间呀。改成二分查找就AC了，但是速度巨慢只超过6%的人。（老是忘记在函数入口确认传入参数的合法性！）</li>
<li>TA：好像和我刚开始想法差不多，也是两个指针怼，只不过是确定最小的去找中间的和最大的来凑成triplets。我不服啊。。。</li>
<li>List、ArrayList用法。List是抽象类，不能直接用；返回值类型是<code>List&lt;List&lt;Integer&gt;&gt;</code>可以用两层ArrayList不断add来生成。</li>
<li>Update two pointers’ condition not clear at first…</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;   </span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 固定nums[i]用双指针找后面两个数b, c，使b + c == 0 - nums[i]</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>, right = nums.length - <span class="number">1</span>, target = <span class="number">0</span> - nums[i];</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                    List&lt;Integer&gt; currList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                    currList.add(nums[i]);</span><br><span class="line">                    currList.add(nums[left]);</span><br><span class="line">                    currList.add(nums[right]);</span><br><span class="line">                    ans.add(currList);</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left - <span class="number">1</span>]) &#123;    <span class="comment">// 避免重复</span></span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right + <span class="number">1</span>]) &#123;  <span class="comment">// 避免重复</span></span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3sum-closest"><a href="#3sum-closest" class="headerlink" title="3sum-closest"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/3sum-closest/#/description">3sum-closest</a></h4><ul>
<li>给一个int数组，给一个target，求数组中哪三个数之和最接近target，输出这个和。</li>
<li>ME：本打算直接在3sum的基础上改一改，让二分查找当没有找到时返回最接近该目标值的位置，但始终调不好，一次都没有提交。</li>
<li>TA：玛德，看答案居然是三指针O(n^2)暴力解法，不服啊。。</li>
<li>O(N^2) OK</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">threeSumClosest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> Integer.MAX_VALUE, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// set target as target - nums[i] for two pointer search</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newTarget</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[left] + nums[right], newDiff = Math.abs(sum - newTarget);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// update diff if closer is found</span></span><br><span class="line">                <span class="keyword">if</span> (diff &gt; newDiff) &#123;</span><br><span class="line">                    diff = newDiff;</span><br><span class="line">                    ans = sum + nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// </span></span><br><span class="line">                <span class="keyword">if</span> (sum == newTarget) &#123;</span><br><span class="line">                    <span class="keyword">return</span> target;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; newTarget) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="17-letter-combinations"><a href="#17-letter-combinations" class="headerlink" title="17. letter-combinations"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/#/description">17. letter-combinations</a></h4><ul>
<li>给一串数字的字符串，求这些数字可能输出的所有字母字符串，对应关系为手机的按键。</li>
<li>ME：组合问题，DFS搞定。至于数字到字母的映射用了一个HashMap&lt;Character, char[]&gt;刷这么些题第一次自己写出来迭代，毕竟DFS不复杂。</li>
<li>TA：映射完全不必那么复杂，可以用String搞定，而key就是当前数字与字符’0’之差，完美变为数组的index。DFS属于recursive的方法，可以直接改成遍历iterative的方法，还有一种是<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/8465/my-java-solution-with-fifo-queue">使用FIFO队列</a>，用了<a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html#peek">LinkedList</a>的peek函数获取当前队列头元素，总共三重循环。第一重遍历digits读取数字，第二重获取队首元素长度若尚未append本轮新读取数字对应的字母，则取出这个队首并进入最后一重循环把所有可能的字母加在后面。复杂度不低但代码优雅，巧妙的就是在第二重循环入口利用长度来判断是否需要拼接。</li>
<li>搞熟普通数组、ArrayList的初始化！HashMap映射对象为数组时怎么写（虽然在这题其实是没必要的）！</li>
<li>OK. Just DFS.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (digits == <span class="literal">null</span> || digits.length() == <span class="number">0</span> </span><br><span class="line">           || digits.indexOf(<span class="string">&#x27;1&#x27;</span>) &gt;= <span class="number">0</span> || digits.indexOf(<span class="string">&#x27;0&#x27;</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">char</span>[][] num2Char = <span class="keyword">new</span> <span class="title class_">char</span> [][] &#123;</span><br><span class="line">            &#123;&#125;, </span><br><span class="line">            &#123;&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;s&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;v&#x27;</span>&#125;, </span><br><span class="line">            &#123;<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span>[] str = digits.toCharArray();</span><br><span class="line">        dfs(str, <span class="number">0</span>, num2Char, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(), ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[] str, <span class="type">int</span> index, <span class="keyword">final</span> <span class="type">char</span>[][] num2Char,</span></span><br><span class="line"><span class="params">                     StringBuilder sb, List&lt;String&gt; ans)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == str.length) &#123;</span><br><span class="line">            ans.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> str[index] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num2Char[temp].length; i++) &#123;</span><br><span class="line">            sb.append(num2Char[temp][i]);</span><br><span class="line">            dfs(str, index + <span class="number">1</span>, num2Char, sb, ans);</span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-Sum"><a href="#4-Sum" class="headerlink" title="4 Sum"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/4sum/#/description">4 Sum</a></h4><ul>
<li>给一个int数组，给一个target值，返回所有quadruplets四元组使它们之和等于target。</li>
<li>ME：想一招鲜，从头到尾三个指针挪，最后一个数二分查找找出来，然而超时了。没法子了。</li>
<li>TA：我只能说你死脑筋，这都第三次做这种题了怎么还不会用双指针？老想着二分查找快，但你在循环最里层加个logN的查找，有可能快吗？这种sum的题，套路差不多都是这样：<code>Arrays.sort</code>排个序，外面套几层循环不管，最重要的是到2Sum时里面是双指针一前一后往中间夹逼，根据当前求得的sum和target作比较来确定双指针下一步怎么移，这里有个<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/46339/my-solution-generalized-for-ksums-in-java/2">kSum的推广</a>了。你在2sum能用二分查找只能说运气好，确实是一种方法，但O(N^m * logN)的复杂度当m变高自然就没法通过了。</li>
<li>OK. These kind of k-sum problem can all be solved by sorting and two-pointer moving strategy.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">newTarget</span> <span class="operator">=</span> target - (nums[i] + nums[j]);</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j + <span class="number">1</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[left] + nums[right];</span><br><span class="line">                    <span class="keyword">if</span> (sum == newTarget) &#123;</span><br><span class="line">                        ans.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            left++;</span><br><span class="line">                        &#125; <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left - <span class="number">1</span>]);</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            right--;</span><br><span class="line">                        &#125; <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right + <span class="number">1</span>]);</span><br><span class="line">                  </span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; newTarget) &#123;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            left++;</span><br><span class="line">                        &#125; <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left - <span class="number">1</span>]);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            right--;</span><br><span class="line">                        &#125; <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right + <span class="number">1</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (j + <span class="number">1</span> &lt; nums.length &amp;&amp; nums[j + <span class="number">1</span>] == nums[j]) &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i + <span class="number">1</span> &lt; nums.length &amp;&amp; nums[i + <span class="number">1</span>] == nums[i]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="remove-nth-node-from-end-of-list"><a href="#remove-nth-node-from-end-of-list" class="headerlink" title="remove-nth-node-from-end-of-list"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/#/description">remove-nth-node-from-end-of-list</a></h4><ul>
<li>给一个链表的头结点，给一个整数n，要求删除倒数第n个节点，返回删完后的链表头，n可以保证合法。要求one-pass。</li>
<li>ME：既然没有空间要求，那我就用一个ArrayList来存这个链表了，然后按索引把前一节点的next指向后一节点。交了个WA，玛德又是边界条件没考虑到，一个是删除头结点，一个是删除最后的节点。</li>
<li>TA：快慢指针。一开始我确实有想到这个，不过考虑的是在判断链表有环无环时所用的2倍速度快指针，而<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/7031/simple-java-solution-in-one-pass">这里</a>是固定间隔为n+1的快慢指针，同时还有一个trick是在head之前建一个dummy节点使其next指向head，快慢指针从此处开始向后遍历即可（不是同时开始！快指针先动n+1步）。如果要消除dummy节点，<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/20745/my-one-pass-solution">这个方法</a>直接指向head，快指针先动n+1步，利用n的合法性应对删除头结点的情况，其实跟前面的没什么差别。</li>
<li>fail to come up with two pointer slow&#x2F;fast method.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// fast move first</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="literal">null</span>) &#123; <span class="comment">// fast reaches end means deleting first node</span></span><br><span class="line">            <span class="keyword">return</span> head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;   <span class="comment">// move slow to the front node of the one to be deleted</span></span><br><span class="line">        &#125;</span><br><span class="line">        slow.next = slow.next.next; <span class="comment">// change prev node.next reference</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="20-valid-parentheses"><a href="#20-valid-parentheses" class="headerlink" title="20. valid-parentheses"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-parentheses/#/description">20. valid-parentheses</a></h4><ul>
<li>给一个字符串，判断其中三种括号<code>(), [], &#123;&#125;</code>是否匹配。</li>
<li>ME：<a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/7/docs/api/java/util/Stack.html">Stack数据结构</a>搞定，左括号入栈，碰到右括号就出栈看看二者是否一对。</li>
<li>TA：也是Stack，不过左括号本身并不入栈，而是它对应的右括号入栈，这样当右括号出现的时候只需判断二者是否相等或者是否栈已经空了即可。</li>
<li>Ignored..</li>
</ul>
<h4 id="21-merge-two-sorted-lists"><a href="#21-merge-two-sorted-lists" class="headerlink" title="21. merge-two-sorted-lists"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-two-sorted-lists/#/description">21. merge-two-sorted-lists</a></h4><ul>
<li>给两个已从小到大排好序的链表头结点，归并两个链表，返回合并后的链表头结点。</li>
<li>ME：归并排序的一部分，挺熟悉了，不过之前都是用数组高的，现在用链表也没差。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/5513/my-recursive-way-to-solve-this-problem-java-easy-understanding">recursive的写法</a>，高大上一些，每次都把较小的值的节点设为头结点返回，一层一层调用最终就归并好了。还有一个<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/45002/java-1-ms-4-lines-codes-using-recursion">极其简洁版</a>的，省去了头结点变量，每次直接返回较小的节点。</li>
<li>OK. Iterative and recursive.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fakeHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr1</span> <span class="operator">=</span> l1, curr2 = l2, curr = fakeHead;</span><br><span class="line">        <span class="keyword">while</span> (curr1 != <span class="literal">null</span> &amp;&amp; curr2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr1.val &gt; curr2.val) &#123;</span><br><span class="line">                curr.next = curr2;</span><br><span class="line">                curr = curr2;</span><br><span class="line">                curr2 = curr2.next;</span><br><span class="line">                curr.next = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr.next = curr1;</span><br><span class="line">                curr = curr1;</span><br><span class="line">                curr1 = curr1.next;</span><br><span class="line">                curr.next = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curr1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            curr.next = curr1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curr2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            curr.next = curr2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fakeHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// recursive</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">        l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="22-generate-parentheses"><a href="#22-generate-parentheses" class="headerlink" title="22. generate-parentheses"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/generate-parentheses/#/description">22. generate-parentheses</a></h4><ul>
<li>给一个int表示括号的对儿数，输出所有符合括号匹配规则的字符串，存入List中返回。</li>
<li>ME：一兴奋想用前面letter-combinations刚学到的用LinkedList + 长度判断 + String拼接来做组合，结果手抖点了下提交，怒得WA，因为这个还要求括号匹配合法，更何况列举个数都不同，输入n出来的长度2*n呢。后来还是改回了我的DFS，左右括号分别用一个int来记录确保右括号数量不超过左括号就可以了。还是熟悉的好哇。</li>
<li>TA：这题竟然也可以用<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/3474/an-iterative-method/2">DP动态规划</a>，然而我还没有掌握。还有<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/5866/my-accepted-java-solution">一种想法</a>是找规律，也是动态规划的一部分，因为有个状态转移，虽然答主没提到DP。</li>
<li>DFS OK. Did not come up with DP, which seems expensive (O(N^4))…</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dfs(n, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> left, <span class="type">int</span> right, String s, List&lt;String&gt; ans)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == n &amp;&amp; right == n) &#123;</span><br><span class="line">            ans.add(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; n)</span><br><span class="line">            dfs(n, left + <span class="number">1</span>, right, s + <span class="string">&quot;(&quot;</span>, ans);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (right &lt; left)</span><br><span class="line">            dfs(n, left, right + <span class="number">1</span>, s + <span class="string">&quot;)&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; dp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dp.add(Arrays.asList(<span class="string">&quot;&quot;</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            List&lt;String&gt; curr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String first : dp.get(j)) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String second : dp.get(i - <span class="number">1</span> - j)) &#123;</span><br><span class="line">                        curr.add(<span class="string">&quot;(&quot;</span> + first + <span class="string">&quot;)&quot;</span> + second);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp.add(curr);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp.get(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="23-merge-k-sorted-lists"><a href="#23-merge-k-sorted-lists" class="headerlink" title="23. merge-k-sorted-lists"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-k-sorted-lists/#/description">23. merge-k-sorted-lists</a></h4><ul>
<li>给一个ListNode节点数组，分别是排好序的若干链表头，要求输出合并后的新链表头。题目特别提示注意时间复杂度。</li>
<li>ME：一开始硬上，每次都遍历一遍链表头来获取最小值，然而超时。我又考虑既然每次都只需要一个最小值，那完全可以维护一个小根堆，直接取根节点就好，然而改了半天还是超时。没辙了。其实这个想法是可以的，看下面就知道为什么了，现在看来你之前整理的堆排序也是错的。</li>
<li>TA：看了tag，写着分治法、堆，说明我用小根堆的思路是其中一种。<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/2780/a-java-solution-based-on-priority-queue">这个</a>用了Java内建的<code>PriorityQueue</code>，其实就和小根堆是一回事。令我吃惊的是后面<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/2780/a-java-solution-based-on-priority-queue/9">这个答案</a>明明也是维护了一个小根堆，怎么他就可以呢？原来他对于小根堆分成了两个函数，一个是create从尾到头确保小根、一个是adjust从根向下每次*2一次性调整完毕，而我全程用的create来调整，复杂度自然高了。于是我也拆成create和maintain两个，怒AC。看看<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/26095/my-simple-java-solution-use-recursion/1">分治</a>，前面做过了mergeTwoLists，那这里分治就是把原链表数组拆分后再两两归并，最终合体。借助归并排序的分治法思想实现了一波，比小根堆快一点。</li>
<li>2 fails with PriorityQueue because of null ListNode condition. Did not come up with Divide and Conquer method. But what about implementing your own Heap structure? Ummm, skipping the manual heap method…</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// divide and conquer</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lists == <span class="literal">null</span> || lists.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// last two params are used to divide into sub problems</span></span><br><span class="line">        <span class="keyword">return</span> mergeKLists(lists, <span class="number">0</span>, lists.length);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (end - start == <span class="number">1</span>) &#123; <span class="comment">// only one list</span></span><br><span class="line">            <span class="keyword">return</span> lists[start];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end - start == <span class="number">2</span>) &#123;  <span class="comment">// merge two lists</span></span><br><span class="line">            <span class="keyword">return</span> mergeTwoLists(lists[start], lists[start + <span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// cut into first and second halves</span></span><br><span class="line">            <span class="keyword">return</span> mergeTwoLists(mergeKLists(lists, start, mid), </span><br><span class="line">                                 mergeKLists(lists, mid, end)); <span class="comment">// warning not mid + 1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="24-swap-nodes-in-pairs"><a href="#24-swap-nodes-in-pairs" class="headerlink" title="24. swap-nodes-in-pairs"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/swap-nodes-in-pairs/#/description">24. swap-nodes-in-pairs</a></h4><ul>
<li>给一个链表头，要去反转所有相邻的节点，返回反转后的头。不可以修改头的val，这能修改next。</li>
<li>ME：设一个伪头部，然后建一个反转后续两个节点的函数，搞定。</li>
<li>TA：基本都是我这样了吧。有一个<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/4351/my-accepted-java-code-used-recursion/">用recursion</a>的，我总感觉能不用就不用吧，一个是不好懂，一个是递归对栈的消耗不是constant space。</li>
<li>OK.</li>
</ul>
<h4 id="reverse-nodes-in-k-group"><a href="#reverse-nodes-in-k-group" class="headerlink" title="reverse-nodes-in-k-group"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-nodes-in-k-group/#/description">reverse-nodes-in-k-group</a></h4><ul>
<li>给一个链表头和小组内节点个数，按小组倒转链表，返回分组反转后的头。</li>
<li>ME：伪头部之后，将k长度的节点存入数组方便访问，然后循环一波调整各自的next指向。</li>
<li>TA：除了我这种迭代的方法，另外就是<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/7126/short-but-recursive-java-code-with-comments">递归</a>了，不得不说，递归的代码真心短，所以不太好懂。答主做法是一直往后找到最后一段需要反转的k元组，其中利用curr和head两个指针来反转还是比我用数组的优雅很多。话说回来，我用了数组的话，也相当于额外申请了空间哎，题目要求constant memeory。。。吓得我改造了一发把数组给改掉了，改造的时候要特别注意NullPointerException，因为我用了一个伪头部而答主没有。</li>
<li>Don’t know how to reverse the array at all!</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || k &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// locate curr at the next node of k-tuple group</span></span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span> &amp;&amp; count &lt; k) &#123;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (count == k) &#123;</span><br><span class="line">            <span class="comment">// set curr as starting head to reverse the following groups recursively</span></span><br><span class="line">            curr = reverseKGroup(curr, k);</span><br><span class="line">            <span class="keyword">while</span> (--count &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">headNext</span> <span class="operator">=</span> head.next;</span><br><span class="line">                head.next = curr;</span><br><span class="line">                curr = head;    <span class="comment">// curr is moving forward since head.next = curr</span></span><br><span class="line">                head = headNext;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> curr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="remove-duplicates-from-sorted-array"><a href="#remove-duplicates-from-sorted-array" class="headerlink" title="remove-duplicates-from-sorted-array"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/#/description">remove-duplicates-from-sorted-array</a></h4><ul>
<li>给一个已排好序的int数组，删除其中的重复项，返回长度。玛德我一开始以为只需要返回一个长度而不用对原数组开刀，还在想这题这么衣洗。题目说的<code>leave beyond length</code>是说该长度之后数组里是什么内容不关心，又不是说besides。。。</li>
<li>ME：既然不在意长度之后的内容，那我就直接用后面的覆盖掉前面最后一次重复的元素，省去了数组删除需要移动一大堆元素的过程。</li>
<li>TA：想法差不多，<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/10262/5-lines-java-solution">这个</a>显得更优雅，因为已经排好序所以后面的只要不同就一定比前面的大。</li>
<li>Did not come up with elegant lazy move method.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[len] != nums[i]) &#123; <span class="comment">// lazy move len</span></span><br><span class="line">                nums[++len] = nums[i];  <span class="comment">// when num[i] is diff from nums[len]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ++len;   <span class="comment">// since last one cannot be compared to next different element</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="remove-element"><a href="#remove-element" class="headerlink" title="remove-element"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-element/#/description">remove-element</a></h4><ul>
<li>给一个任意排序的int数组，给一个key，要求返回删除这个key元素的新长度，同样不关心该长度之后的内容，同时返回时数组内的key顺序可以换。同样要求in-place.</li>
<li>ME：从前往后找key，一旦发现就从后往前找不是key的元素就覆盖掉前面的。</li>
<li>TA：当大家想法差不多，就会开始比谁的代码短。。。<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/10753/accepted-java-solution">这个</a>真心短，答主不是从后往前找不是key的元素覆盖，而是直接按顺序来。这样要考虑的坑少一些，我那个又是正的又是反的，跟这个比就复杂了。</li>
<li>OK.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == val) &#123;</span><br><span class="line">                nums[i--] = nums[--len];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="28-implement-strStr"><a href="#28-implement-strStr" class="headerlink" title="28. implement-strStr"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/implement-strstr/#/description">28. implement-strStr</a></h4><ul>
<li>实现一个strStr函数，给一个字符串在其中找子字符串第一次出现的索引。</li>
<li>ME：手动实现呗。第一次WA竟然是因为在字符串中找””永远返回0。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/18839/elegant-java-solution">这个代码</a>很优雅，直接上双重循环，一旦有一位字符不同就跳出内层循环；如果长度超过了原字符串，说明找不到；如果能在内层循环顺利达到target的长度说明找到了，返回外层循环的当前索引即可。</li>
<li>String转char数组用toCharArray。注意strStr在Java中对应的是indexOf，Java中并没有strStr。</li>
<li>KMP在text中找pattern。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (haystack == <span class="literal">null</span> || needle == <span class="literal">null</span> || needle.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> needle.length();</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> dp[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle.charAt(j) != needle.charAt(i)) &#123;</span><br><span class="line">                j = dp[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (needle.charAt(j) == needle.charAt(i)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">lenFull</span> <span class="operator">=</span> haystack.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lenFull; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack.charAt(i) != needle.charAt(j)) &#123;</span><br><span class="line">                j = dp[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack.charAt(i) == needle.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == len) &#123;</span><br><span class="line">                <span class="keyword">return</span> i - len + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="29-divide-two-integers"><a href="#29-divide-two-integers" class="headerlink" title="29. divide-two-integers"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/divide-two-integers/#/description">29. divide-two-integers</a></h4><ul>
<li>给两个数字，不使用乘、除、模运算前者除以后者之商，若结果越界则返回MAX_INT。</li>
<li>ME：直接用个循环一点一点叠加除数看看sum是否&gt;&#x3D;被除数，符号则是统一把两个数都变为负数，毕竟负数的界比正数多1。然而超时了。。。</li>
<li>TA：玛德忘记了除了加减乘除还有位运算这种东西。我原本确实想过通过翻倍来加速求sum的过程，不过当时并没有想到位运算，只是想着通过数组从被除数开始往后一直翻倍记录increment，不过在极限情况下（-2147483648 &#x2F; -1）的情况下，数组要2^16这么大，把我吓跑了。按照<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/15568/detailed-explained-8ms-c-solution">这个C++的答案</a>改造成了Java，果然优雅。事实上题目所说的越界情况也就只有 -2147483648 &#x2F; -1 而已，所以我之前超时的那个很多判断都是没必要的。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> dividend, <span class="type">int</span> divisor)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((dividend == Integer.MIN_VALUE &amp;&amp; divisor == -<span class="number">1</span>) || divisor == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Math.abs(dividend), b = Math.abs(divisor), shiftCount = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (a - b &gt;= <span class="number">0</span>) &#123;    <span class="comment">// 这里a是MIN时会时负数，因此不能直接比a &gt;= b</span></span><br><span class="line">            <span class="comment">// 注意这里b经过shift可能会越界成负数，因此不能直接比较a &gt;= (b &lt;&lt; shiftCount &lt;&lt; 1)</span></span><br><span class="line">            <span class="keyword">for</span> (shiftCount = <span class="number">0</span>; a - (b &lt;&lt; shiftCount &lt;&lt; <span class="number">1</span>) &gt;= <span class="number">0</span>; shiftCount++);</span><br><span class="line">            a -= (b &lt;&lt; shiftCount);</span><br><span class="line">            ans += (<span class="number">1</span> &lt;&lt; shiftCount);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (dividend &gt; <span class="number">0</span>) == (divisor &gt; <span class="number">0</span>) ? ans : -ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="30-substring-with-concatenation-of-all-words"><a href="#30-substring-with-concatenation-of-all-words" class="headerlink" title="30. substring-with-concatenation-of-all-words"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/substring-with-concatenation-of-all-words/#/description">30. substring-with-concatenation-of-all-words</a></h4><ul>
<li>给一个长字符串s，然后一个相同长度m的word字符串的数组，要求找出该数组中字符串各种可能排列成的新字符串在s中出现的位置</li>
<li>ME：使用DFS将所有可能的target字符串拼接出来存入HashSet，然后逐个取出使用indexOf找。然而超时。。。</li>
<li>TA：给出的tag又是双指针，或者说是滑动窗口，这个双指针有点无敌啊。我的方法最耗时的部分应该就是DFS拼接所有可能的target那部分，在<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/35676/accepted-java-solution-12ms-with-explanation">这个方法</a>中，直接把每个word作为独立个体看待。首先利用一个mapping为各个word分配索引，然后从头到尾扫一遍s每次取长度为m的子串看看能否在mapping中get到，get的索引存在smapping中。固定窗口长度为m，总共滑动m次，每次循环都是一左一右两个指针扫smapping，右指针先以m的步长扫smapping获得索引并相应减去该索引的word的计数，当所有word都用完了，就挪左指针扫smapping（其实就是重走了一段右指针走过的路），扫到第一个属于word的就看看长度是否为k*m，因为各个word的长度相同所以我们只要简单判断长度就能知道这部分内容满不满足要求。还有一个<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/6432/simple-java-solution-with-two-pointers-and-map">更简短的</a>，这里直接把构建table的过程简化成map搞定，同时省去了构建smapping的过程而直接在大循环中get，面试时相同的思路当然是代码越短越好，才写得完嘛。</li>
<li><a target="_blank" rel="noopener" href="http://ahomeeye.iteye.com/blog/1235370">Set的遍历</a>，数组赋值Arrays.fill。</li>
<li>Did not come up with the method of mapping and search. After knowing and implementing it, still time limit exceeded, because calling containsKey too much. But actually there is a much faster one, which use raw array to implement the mapping relations, including finding the matched substrings in s.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findSubstring</span><span class="params">(String s, String[] words)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (words == <span class="literal">null</span> || words.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// construct map for each word and its count</span></span><br><span class="line">        Map&lt;String, Integer&gt; wordCount = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            wordCount.put(words[i], wordCount.containsKey(words[i])? wordCount.get(words[i]) + <span class="number">1</span>: <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// check each slot in s with fixed length wordLen</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">wordLen</span> <span class="operator">=</span> words[<span class="number">0</span>].length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> s.length() - words.length * wordLen;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= end; i++) &#123;</span><br><span class="line">            Map&lt;String, Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(wordCount);</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;  <span class="comment">// increase from i, each time increase by wordLen</span></span><br><span class="line">            <span class="keyword">while</span> (j &lt; s.length()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j + wordLen &lt;= s.length()) &#123;    <span class="comment">// in case substring exceed boundary</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">currStr</span> <span class="operator">=</span> s.substring(j, j + wordLen);</span><br><span class="line">                    <span class="keyword">if</span> (!temp.containsKey(currStr)) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">leftCount</span> <span class="operator">=</span> temp.get(currStr);</span><br><span class="line">                        <span class="keyword">if</span> (leftCount == <span class="number">1</span>) &#123;</span><br><span class="line">                            temp.remove(currStr);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            temp.put(currStr, leftCount - <span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                j += wordLen;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.isEmpty()) &#123;</span><br><span class="line">                ans.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findSubstring</span><span class="params">(String s, String[] words)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (words == <span class="literal">null</span> || words.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// map each word with unique index into map; Count unique wordNum</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">wordNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[][] table = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">2</span>][words.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">index</span> <span class="operator">=</span> map.get(words[i]);</span><br><span class="line">            <span class="keyword">if</span> (index == <span class="literal">null</span>) &#123;</span><br><span class="line">                index = wordNum++;</span><br><span class="line">                map.put(words[i], index);</span><br><span class="line">            &#125;</span><br><span class="line">            table[<span class="number">0</span>][index]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// tarverse s and check each index if it has word in words[], mark the wordIndex</span></span><br><span class="line">        <span class="type">int</span>[] sIndex = <span class="keyword">new</span> <span class="title class_">int</span> [s.length()];</span><br><span class="line">        Arrays.fill(sIndex, -<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">wordLen</span> <span class="operator">=</span> words[<span class="number">0</span>].length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> s.length() - wordLen + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; end; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> s.substring(i, i + wordLen);</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">mapResult</span> <span class="operator">=</span> map.get(sub);</span><br><span class="line">            <span class="keyword">if</span> (mapResult != <span class="literal">null</span>) &#123;</span><br><span class="line">                sIndex[i] = mapResult;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// use left ptr to recover word repo, right to consume word</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">expectedLen</span> <span class="operator">=</span> wordLen * words.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; wordLen; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i, right = i;</span><br><span class="line">            <span class="type">int</span> <span class="variable">wordRemain</span> <span class="operator">=</span> wordNum;</span><br><span class="line">            Arrays.fill(table[<span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span> (right &lt; end) &#123;</span><br><span class="line">                <span class="comment">// move right with slot len == wrodLen</span></span><br><span class="line">                <span class="keyword">while</span> (wordRemain &gt; <span class="number">0</span> &amp;&amp; right &lt; end) &#123; <span class="comment">// make sure there&#x27;r still word to consume</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">hitIndex</span> <span class="operator">=</span> sIndex[right];   <span class="comment">// get hitIndex from sIndex in step 2</span></span><br><span class="line">                    <span class="keyword">if</span> (hitIndex != -<span class="number">1</span> &amp;&amp; ++table[<span class="number">1</span>][hitIndex] == table[<span class="number">0</span>][hitIndex]) &#123;</span><br><span class="line">                        wordRemain--;   <span class="comment">// increase the corresponding count</span></span><br><span class="line">                                        <span class="comment">// when all is consumed, this word is drained to 0</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    right += wordLen;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// move left to recover the consumed words until at least one word exists</span></span><br><span class="line">                <span class="keyword">while</span> (wordRemain == <span class="number">0</span> &amp;&amp; left &lt; right) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">hitIndex</span> <span class="operator">=</span> sIndex[left];</span><br><span class="line">                    <span class="keyword">if</span> (hitIndex != -<span class="number">1</span> &amp;&amp; table[<span class="number">1</span>][hitIndex]-- == table[<span class="number">0</span>][hitIndex]) &#123;</span><br><span class="line">                        wordRemain++;   <span class="comment">// when this word comes from fully consumed</span></span><br><span class="line">                                        <span class="comment">// recover the wordRemain</span></span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">if</span> (right - left == expectedLen) &#123;</span><br><span class="line">                            ans.add(left);  </span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    left += wordLen;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="31-next-permutation"><a href="#31-next-permutation" class="headerlink" title="31. next-permutation"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/next-permutation/#/description">31. next-permutation</a></h4><ul>
<li>给一个int数组，将它改造成按字典序的下一个排列，若不存在则直接按从小到大的顺序调整。要求In-place对原数组操作，不能申请额外空间。</li>
<li>ME：考虑最右顺序对，这个和归并求逆序对有点像。既然求最右那就需要把原本的merge函数改成从右往左找，但写成了代码才发现不对！！！没辙了。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/14124/sharing-my-clean-and-easy-understand-java-code-with-explanation">这个想法</a>从右往左找相邻的两个数使得<code>first &lt; second</code>，然后再从右往左找首次出现的比first大的数，二者对调，然后将second及其之后的内容reverse一下即可。这才是正解，和我的思路差别还是略大。这是值得警惕的倾向，看到一个题就像往熟悉的东西上面套，套上了就很难抽出来。另外，<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/15216/a-simple-algorithm-from-wikipedia-with-c-implementation-can-be-used-in-permutations-and-permutations-ii">这里</a>给出了问题的来源，原来是一个很古老的问题了，而且可以应用在Permutation问题中，对重复也可以处理。</li>
<li>Forgot the method of finding ascending pair, swap and reverse.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nextPermutation</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (j &gt; i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[j] &gt; nums[i]) &#123;</span><br><span class="line">                        swap(nums, i, j);</span><br><span class="line">                        reverse(nums, i + <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(nums, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start, j = nums.length - <span class="number">1</span>; i &lt; j; i++, j--) &#123;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="longest-valid-parentheses"><a href="#longest-valid-parentheses" class="headerlink" title="longest-valid-parentheses"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-valid-parentheses/#/description">longest-valid-parentheses</a></h4><ul>
<li>给一个只包含了<code>(</code>和<code>)</code>的字符串，求其中合法匹配的最大子字符串长度。</li>
<li>ME：一开始直接用stack判断括号匹配的思路做，左括号++，右括号出现时则左括号–。但是对于<code>()(()</code>就错了。于是考虑那从右往左再来一次，求左右二个max的较小者？但是又一次被<code>())()()(()</code>打败，左边右边对称，算出来都是错的。</li>
<li>TA：一开始参考<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/2289/my-o-n-solution-using-a-stack">这个</a>写，维护一个存索引的stack，左括号则直接把索引push进去，右括号则看看栈顶的索引对应是否为左括号，是则弹出，否则把右括号的索引push进去，完成遍历后栈里面留下的就是造成invalid的一个个分割处的索引，遍历一遍栈的内容即得最长。不过照着实现一波之后发现超时。于是又参考<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/7234/simple-java-solution-o-n-time-one-stack">这个</a>，把之后的那一步遍历stack给融合到了前面的字符串遍历当中：同样维护一个存放int的stack，左括号直接入栈，右括号则需要分叉，若栈为空则说明不匹配，把left标记挪到当前这个索引；若非空则匹配成功，直接pop（因为栈中索引只可能是左括号的），弹出后再判断栈是否为空，若空了则之前的一长串括号都成功匹配了，用当前索引减去left即得这一段的长度；若非空则使用当前索引减去栈顶的索引表示当前已匹配的长度。很神奇，挺好懂的。当然，这题给的tag是<strong>DP</strong>，所以<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/2426/my-dp-o-n-solution-without-using-stack">这个</a>也要学习下。DP主要是状态转移方程，这里维护一个数组存放以当前索引结尾的字符串的最长valid长度。对于<code>str[i] == &#39;(&#39;</code>，不可能以它为结尾，故直接设<code>longest[i] = 0</code>；对于<code>str[i] == &#39;)&#39;</code>，若前一位字符为左括号，则<code>longest[i] = longest[i-2] + 2</code>，若前一位字符为右括号，则需要看这个右括号所能匹配的最远的距离的再前一个字符是否为左括号，即<code>str[i-longest[i-1]-1] == &#39;(&#39;</code>，若满足则不仅要加2，而且还要加上该左括号之前以为的valid长度（处理连续两个独立的且都是valid的括号组），即<code>longest[i] = longest[i-1] + 2 + longest[i-longest[i-1]-2]</code>。DP真的优雅，关键是找到这种『当前结果依赖之前结果』的规律，不一定是『前一项』，可以是往前若干项的结合。这题很漂亮。</li>
<li>Forgot the DP method!!</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestValidParentheses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span> [s.length()];    <span class="comment">// maxLen till curr char (only for valid &#x27;)&#x27;)</span></span><br><span class="line">        <span class="type">char</span>[] sChar = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sChar.length; i++) &#123;</span><br><span class="line">            <span class="comment">// only) is count as valid bit</span></span><br><span class="line">            <span class="keyword">if</span> (sChar[i] == <span class="string">&#x27;)&#x27;</span>) &#123;      <span class="comment">// &quot;xxx)&quot;</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;        </span><br><span class="line">                    <span class="keyword">if</span> (sChar[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>) &#123;  <span class="comment">// prev is (, simply add 2 to prevprev</span></span><br><span class="line">                        dp[i] = <span class="number">2</span> + (i &gt; <span class="number">1</span>? dp[i - <span class="number">2</span>]: <span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;                    <span class="comment">// prev is (</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> i - dp[i - <span class="number">1</span>] - <span class="number">1</span>;   <span class="comment">// move to the very front of prev slot</span></span><br><span class="line">                        <span class="keyword">if</span> (prev &gt;= <span class="number">0</span> &amp;&amp; sChar[prev] == <span class="string">&#x27;(&#x27;</span>) &#123;  <span class="comment">// only ( can match curr)</span></span><br><span class="line">                            dp[i] = (prev &gt; <span class="number">0</span>? dp[prev - <span class="number">1</span>]: <span class="number">0</span>) + <span class="number">2</span> + dp[i - <span class="number">1</span>];    <span class="comment">// check (&#x27;s prev</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ans = Math.max(ans, dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="search-in-rotated-sorted-array"><a href="#search-in-rotated-sorted-array" class="headerlink" title="search-in-rotated-sorted-array"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/search-in-rotated-sorted-array/#/description">search-in-rotated-sorted-array</a></h4><ul>
<li>给一个已排好序但可能前后两段换了位置（例如12345变成45123），给一个target找出它的索引。</li>
<li>ME：排好序、查找，很自然想到二分，但是这个边界条件搞死我了。这个rotated的结果只有三种：left &lt; mid &lt; right, mid &lt; right &lt; left, right &lt; left &lt; mid，在这里面再分别对target讨论，很琐碎，面试时恐怕很难想周全，leetcode还可以在WA时告诉你是什么样例通不过，面试可就没这么好了。</li>
<li>TA：我的天，为什么<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/7711/revised-binary-search">这个</a>可以这么简洁？！思想是，总有一半的数组是有序的，需要确认target在哪一半，这个代码真的是一看就懂，比你的不知高到哪里去了。</li>
<li>Trapped in edge conditions of your own method, which is complicated and impossible to debug in interview. After knowing the method of splitting into ascending part and mixed part, implementation is still not bug-free, because of edge cases in binary search.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// firstly decide which part is ascending order</span></span><br><span class="line">            <span class="comment">// warning: although no duplicate in nums[],</span></span><br><span class="line">            <span class="comment">// there is an = here! because when left == mid, nums[left] == nums[mid]</span></span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt;= nums[mid]) &#123;  <span class="comment">// first half is in order</span></span><br><span class="line">                <span class="keyword">if</span> (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) &#123;   <span class="comment">// nums[mid] excluded</span></span><br><span class="line">                    right = mid - <span class="number">1</span>;    <span class="comment">// target is in range of first half</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    <span class="comment">// second half in order</span></span><br><span class="line">                <span class="keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;     <span class="comment">// target in range of second half</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="keyword">return</span> nums[left] == target? left: -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="find-first-and-last-position-of-element-in-sorted-array"><a href="#find-first-and-last-position-of-element-in-sorted-array" class="headerlink" title="find-first-and-last-position-of-element-in-sorted-array"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/">find-first-and-last-position-of-element-in-sorted-array</a></h4><ul>
<li>给一个已排好序的数组，给一个target，找出这个target出现的索引范围，存入length为2的int数组。要求时间复杂度为logn的常数倍。</li>
<li>ME：二分查找到了之后，再往左和往右分别继续进行二分查找，找到leftMost和rightMost的索引。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/5891/clean-iterative-solution-with-two-binary-searches-with-explanation">这个</a>是C++写的，直接用一个二分找左界，然后再额外找一个右界。稍微改一下二分，可以让它变为『查找首次出现的target索引』或者『最后一次出现的target索引』，这个要灵活一点。</li>
<li>Fail to implement the binary search which returns the first occurred index of target… For left, actually it’s non interrupt return version on BS, first index is at left; for right, need to prompt mid (add 1) to biase to right and last index is at right.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span> [] &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (target &gt; nums[mid]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[left] != target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span> [] &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMost</span> <span class="operator">=</span> left;</span><br><span class="line"></span><br><span class="line">        right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; nums[mid]) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightMost</span> <span class="operator">=</span> right;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;leftMost, rightMost&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="search-insert-position"><a href="#search-insert-position" class="headerlink" title="search-insert-position"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/search-insert-position/#/description">search-insert-position</a></h4><ul>
<li>给一个已排好序的、不存在重复元素的数组，给一个target，找出他的索引或者他应该插入的位置。</li>
<li>ME：直接用刚刚学到的“第一个出现位置”的二分查找搞。末尾直接返回lo而不用判断，因为如果不等于的话其实也就相当于他应该插入的位置了。但是又忘记了边缘情况，例如hi取不取到length、数组中没有元素或者只有一个元素怎么办？</li>
<li>TA：毕竟是个衣洗提，大家想法差不多，比短码就没啥意思了，本来就没多少行。。。</li>
<li>Similar to previous return first binary search result function, but need to consider if the final return value should check target v.s. nums[left] or not: in the middle, nuh; in the rightmost end, yep.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (target &gt; nums[mid]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// warning: terminate condition should consider the rightmost insertion</span></span><br><span class="line">        <span class="keyword">return</span> left == right &amp;&amp; target &gt; nums[left]? left + <span class="number">1</span>: left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="36-valid-sudoku"><a href="#36-valid-sudoku" class="headerlink" title="36. valid-sudoku"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-sudoku/#/description">36. valid-sudoku</a></h4><ul>
<li>给一个二维char数组，里面是一个未完成的数独9x9棋盘，要求每一行、每一列、每个3x3方块中数字1-9有且仅有出现一次。判断这个棋盘是否符合数独规则，返回布尔值。</li>
<li>ME：一脸懵逼地用了个四重循环解决了。。。说是四重循环其实也就是遍历一遍9x9的棋盘，这应该是必须的。分别借助两个9x9的数组记录行和列的数字使用情况，再用一个长度为9的一维数组记录每个小正方形的，数组的索引通过<code>字符-&#39;1&#39;</code>获得，这样就省得用Map了。</li>
<li>TA：思想差不多吧，<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/9748/shared-my-concise-java-code">这个</a>就是用Map的。<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/27436/short-simple-java-using-strings">这个</a>是利用Set然后定义了一种String来记录是否出现过，利用set.add的返回值判断该字符串是否出现过，这个方法挺绝的。</li>
<li>Kinda boring…just check if current board is valid, not checking if it is solvable.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="literal">null</span> || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!set.add(board[i][j] + <span class="string">&quot; in row &quot;</span> + i) </span><br><span class="line">                        || !set.add(board[i][j] + <span class="string">&quot; in col &quot;</span> + j) </span><br><span class="line">                        || !set.add(board[i][j] + <span class="string">&quot; in block &quot;</span> + (i / <span class="number">3</span>) + <span class="string">&#x27;-&#x27;</span> + (j / <span class="number">3</span>))) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="37-sudoku-solver"><a href="#37-sudoku-solver" class="headerlink" title="37. sudoku-solver"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sudoku-solver/#/description">37. sudoku-solver</a></h4><ul>
<li>给一个二位char数组，里面是一个未完成的数独9x9棋盘，要求每一行、每一列、每个3x3方块中数字1-9有且仅有出现一次。解出数独，解有且仅有一种，直接在原二维数组中将<code>.</code>改为数字的char。</li>
<li>ME：纠结了半天，感觉是一个dfs的节奏，但是迟迟疑疑不敢下手怕是浪费时间，于是偷偷瞄了一眼discuss，发现就是用backtrack回溯，回溯和DFS在这里感觉是一回事？？于是用上一题的row col sqr记录来判断行、列、小方块是否合法，dfs搞定。</li>
<li>TA：偷瞄的就是<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/11327/straight-forward-java-solution-using-backtracking">这个</a>。答主没有用辅助函数，直接遍历，然后另外用一个函数循环一波来判断是否合法。这个想法非常直接，一目了然。</li>
<li>DFS, use prev encoded string set.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">inRow</span> <span class="operator">=</span> <span class="string">&quot; in row &quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">inCol</span> <span class="operator">=</span> <span class="string">&quot; in col &quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">inBlk</span> <span class="operator">=</span> <span class="string">&quot; in blk &quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solveSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="literal">null</span> || board.length != <span class="number">9</span> || board[<span class="number">0</span>].length != <span class="number">9</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    set.add(board[i][j] + inRow + i);</span><br><span class="line">                    set.add(board[i][j] + inCol + j);</span><br><span class="line">                    set.add(board[i][j] + inBlk + i/<span class="number">3</span> + <span class="string">&quot;-&quot;</span> + j/<span class="number">3</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(board, set);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, Set&lt;String&gt; set)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; <span class="number">9</span>; c++) &#123;</span><br><span class="line">                        <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> (<span class="type">char</span>)(c + <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">                        <span class="type">String</span> <span class="variable">row</span> <span class="operator">=</span> temp + inRow + i;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">col</span> <span class="operator">=</span> temp + inCol + j;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">blk</span> <span class="operator">=</span> temp + inBlk + i/<span class="number">3</span> + <span class="string">&quot;-&quot;</span> + j/<span class="number">3</span>;</span><br><span class="line">                        <span class="keyword">if</span> (!set.contains(row) &amp;&amp; !set.contains(col) &amp;&amp; !set.contains(blk)) &#123;</span><br><span class="line">                            set.add(row);</span><br><span class="line">                            set.add(col);</span><br><span class="line">                            set.add(blk);</span><br><span class="line">                            board[i][j] = temp;</span><br><span class="line">                            <span class="keyword">if</span> (dfs(board, set)) &#123;</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                set.remove(row);</span><br><span class="line">                                set.remove(col);</span><br><span class="line">                                set.remove(blk);</span><br><span class="line">                                board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="count-and-say"><a href="#count-and-say" class="headerlink" title="count-and-say"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/count-and-say/#/description">count-and-say</a></h4><ul>
<li>从1开始变化，数每个数字连续出现的个数代替原数字，例如<code>1, 11, 21, 1211, 111221, 312211</code>这样。给一个int表示往后的次数。</li>
<li>ME：用循环数连续出现数字的个数，相应的字符串用一个StringBuffer不断往后append就好。</li>
<li>TA：差不多吧，这是个衣洗题，不管了。</li>
<li>OK</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">countAndSay</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (--n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, len = sb.length();</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">                <span class="type">char</span> <span class="variable">curr</span> <span class="operator">=</span> sb.charAt(i++);</span><br><span class="line">                <span class="keyword">while</span> (i &lt; len &amp;&amp; sb.charAt(i) == curr) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                temp.append(count);</span><br><span class="line">                temp.append(curr);</span><br><span class="line">            &#125;</span><br><span class="line">            sb = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="combination-sum"><a href="#combination-sum" class="headerlink" title="combination-sum"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/combination-sum/#/description">combination-sum</a></h4><ul>
<li>给一个全为正整数的、不含重复项的int数组和一个正整数target，求任意个数组元素的list使得它们的和为target。</li>
<li>ME：全是正整数，立刻想到了桶排序，但这个『任意个元素组合』很不好搞，一时想不出来。。。</li>
<li>TA：依然是回溯法，似乎没人考虑怎么排序+二分使之更高效。<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/46161/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning">这里</a>有个大神总结了一个套路可以任意放在组合问题中，很强。受到这个点拨之后，这题和下一题都写出来了。以后要是还碰到这种回溯题，你得会了啊。需要指出的是，这题似乎是一个典型的<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/8200/iterative-java-dp-solution">动态规划题</a>，因为涉及到了状态转换方程，解出<code>target - candidate[x]</code>的组合则target自然也就出来了。由于结果是二维的，DP就需要维护一个三维的List了。这次我竟然看懂了DP，自己也试了一波，下次争取盲写出来吧。不过跑出来比backtrack慢，大概是因为算了一些没必要的东西吧，毕竟要维护一个三维数组呢。。</li>
<li>Still DFS… I think it is a good point to conclude DFS as In-and-Out: Put sth in and assume it can count into result can go deeper, after that pop it out. There is also DP solution.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (candidates == <span class="literal">null</span> || candidates.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        dfs(candidates, <span class="number">0</span>, target, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(), ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> index, <span class="type">int</span> target, <span class="type">int</span> sum, List&lt;Integer&gt; curr, List&lt;List&lt;Integer&gt;&gt; ans)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newSum</span> <span class="operator">=</span> sum + candidates[i];</span><br><span class="line">            <span class="keyword">if</span> (newSum &gt; target) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr.add(candidates[i]);</span><br><span class="line">                <span class="keyword">if</span> (newSum == target) &#123;</span><br><span class="line">                    List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(curr);</span><br><span class="line">                    ans.add(temp);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dfs(candidates, i, target, newSum, curr, ans);</span><br><span class="line">                &#125;</span><br><span class="line">                curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// remove duplicate because if this number has answer</span></span><br><span class="line">            <span class="comment">// it is already solved in the previous DFS iterations</span></span><br><span class="line">            <span class="comment">// Actually fits next problem....</span></span><br><span class="line">            <span class="keyword">while</span> (i + <span class="number">1</span> &lt; candidates.length &amp;&amp; candidates[i + <span class="number">1</span>] == candidates[i]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (candidates == <span class="literal">null</span> || candidates.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(candidates);    <span class="comment">// still need to guarantee the order</span></span><br><span class="line">        <span class="comment">// dp[t] means the List&lt;List&lt;&gt;&gt; that sums up at t+1</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt;[] dp = <span class="keyword">new</span> <span class="title class_">List</span>[target + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            dp[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;(); <span class="comment">// allocate memory</span></span><br><span class="line">                                                <span class="comment">// make sure candidate no larger than curr target i</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; candidates.length &amp;&amp; candidates[j] &lt;= i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (candidates[j] == i) &#123;       <span class="comment">// exact match -&gt; </span></span><br><span class="line">                    dp[i].add(Arrays.asList(i));</span><br><span class="line">                    <span class="keyword">break</span>;  <span class="comment">// actually no use. because there&#x27;s no duplicate in cdds[]</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i - candidates[j];</span><br><span class="line">                    <span class="keyword">for</span> (List&lt;Integer&gt; l: dp[index]) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (candidates[j] &lt;= l.get(<span class="number">0</span>)) &#123;</span><br><span class="line">                            List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                            temp.add(candidates[j]);</span><br><span class="line">                            temp.addAll(l);</span><br><span class="line">                            dp[i].add(temp);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="combination-sum-ii"><a href="#combination-sum-ii" class="headerlink" title="combination-sum-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/combination-sum-ii/#/description">combination-sum-ii</a></h4><ul>
<li>给一个全为正整数的、可能含重复项的int数组和一个正整数target，求数组元素的list使得它们的和为target且每个元素最多只能用一次。</li>
<li>ME：和上面一样，backtrack小改一下搞定。试了一下DP，在三维的情况下对于标记『某元素已经使用过』比较麻烦，就没试了。</li>
<li>Almost the same. Skep it.</li>
</ul>
<h4 id="41-first-missing-positive"><a href="#41-first-missing-positive" class="headerlink" title="41. first-missing-positive"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/first-missing-positive/#/description">41. first-missing-positive</a></h4><ul>
<li>给一个乱序整数数组，要求返回所缺正整数中的最小值。要求constant space，O(n).</li>
<li>ME：看到O(n)和整数我就想到了木桶排序，这个想法肯定可行，但实现后发现Memory Limit Exceeded，看来题目并不给我开太大的数组。改小之后对小数据还是可以的，但总感觉借助了额外的空间不太符合要求。。。</li>
<li>TA：看了<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/10351/o-1-space-java-solution">这个答案</a>简直了，算是个技巧题吧，基本思想类似于往k+1个桶里扔k个有标号的球，漏掉的那个总会出现在1~k+1之间，那只需要把标号对应的球投入桶中，再从头遍历一遍找到空桶即得。在这题里，就是把正数k通过交换放到k-1处，从头到尾处理过一遍之后，总会有部分位置i的值不等于i+1，这个就是所求了。</li>
<li>O(N) time DOES NOT MEAN ONE-PASS!!! Fail to come up with this swapping and overwrite method. Critical at conditioning.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstMissingPositive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == i + <span class="number">1</span> || nums[i] &lt;= <span class="number">0</span> || nums[i] &gt; nums.length) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[nums[i] - <span class="number">1</span>] != nums[i]) &#123; <span class="comment">// warning: not nums[i] != i + 1</span></span><br><span class="line">                <span class="comment">// critical: avoid re-overwriting that corrent spot</span></span><br><span class="line">                swap(nums, i, nums[i] - <span class="number">1</span>); <span class="comment">// i is curr index, nums[i] - 1 is where it should be</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums.length &amp;&amp; nums[i] == i + <span class="number">1</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span>  nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="42-trapping-rain-water"><a href="#42-trapping-rain-water" class="headerlink" title="42. trapping-rain-water"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/trapping-rain-water/#/description">42. trapping-rain-water</a></h4><ul>
<li>给一个int数组，其中包含每个索引处墙的高度。求装满水时的横截面的积水的面积。</li>
<li>ME：扫一遍获得每个索引处的左侧最高墙和右侧最高墙，再从头扫一遍，若是凹形（比较小值还小）则用该较小值减去本索引的高度得到该索引处水的高度，即是面积了。</li>
<li>TA： 服气，<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/7612/java-10-lines-accepted-code-o-n-time-o-1-space-is-there-a-better-solution">这个答案</a>又见双指针，直接把我的两个分开的循环合并到一次里面完成了。其中的plank跟我的leftHi很像，都是从左往右遍历的过程中只能增加，但是plank是一次性比较两个指针的较小值，和我那个单向的比较高端（难懂）。代码越短越不好懂，类似的方法可能<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/5125/sharing-my-simple-c-code-o-n-time-o-1-space">这个C++的</a>好懂一丢丢。自己学着写了一波，速度稍微快了那么一点。</li>
<li>Ok for my own method with two auxiliary arrays. But if follow-up asks me to do it in constant space, need to know the method of two pointers.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (height == <span class="literal">null</span> || height.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] hiLeft = <span class="keyword">new</span> <span class="title class_">int</span> [height.length];     <span class="comment">// leftward highest</span></span><br><span class="line">        <span class="type">int</span>[] hiRight = <span class="keyword">new</span> <span class="title class_">int</span> [height.length];    <span class="comment">// rightward highest</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> height[<span class="number">0</span>], right = height[height.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, j = height.length - <span class="number">2</span>; i &lt; height.length; i++, j--) &#123;</span><br><span class="line">            hiLeft[i] = left;</span><br><span class="line">            left = Math.max(left, height[i]);</span><br><span class="line">            </span><br><span class="line">            hiRight[j] = right;</span><br><span class="line">            right = Math.max(right, height[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> Math.min(hiLeft[i], hiRight[i]);</span><br><span class="line">            <span class="keyword">if</span> (height[i] &lt; h) &#123;</span><br><span class="line">                area += (h - height[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (height == <span class="literal">null</span> || height.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> <span class="number">0</span>, maxLeft = <span class="number">0</span>, maxRight = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt;= height[right]) &#123;    <span class="comment">// 左指针处高度不大于右指针</span></span><br><span class="line">                <span class="keyword">if</span> (maxLeft &lt;= height[left]) &#123;</span><br><span class="line">                    maxLeft = height[left];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;                            <span class="comment">// 只有当前高度完美小于左侧最大值才能储水</span></span><br><span class="line">                    area += maxLeft - height[left]; </span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 左指针处高度完美大于右指针</span></span><br><span class="line">                <span class="keyword">if</span> (maxRight &lt;= height[right]) &#123;</span><br><span class="line">                    maxRight = height[right];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    area += maxRight - height[right];</span><br><span class="line">                &#125;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="43-multiply-strings"><a href="#43-multiply-strings" class="headerlink" title="43. multiply-strings"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/multiply-strings">43. multiply-strings</a></h4><ul>
<li>给两个字符串形式的int，模拟乘法求他们的积，返回字符串。</li>
<li>ME：这种数组模拟大数运算的题目我有点提不起劲，于是瞄了一眼答案做出来了。。。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/30508/easiest-java-solution-with-graph-explanation/">这个</a>利用索引的小trick，一看就明。</li>
</ul>
<h4 id="44-wildcard-matching"><a href="#44-wildcard-matching" class="headerlink" title="44. wildcard-matching"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/wildcard-matching">44. wildcard-matching</a></h4><ul>
<li>和前面的<a target="_blank" rel="noopener" href="https://leetcode.com/problems/regular-expression-matching">regular-expression-matching</a>很像，但这里用<code>?</code>代表任意一个字符、用<code>*</code>代表任意长度的任意字符而不依赖它前面的字符（而且不只能匹配单一个字符，直接匹配任意长度的任意字符组合）。总的来说比上一题简单，要讨论的情况少了。</li>
<li>ME：按照刚刚学习的动归DP思路维护一个二维boolean数组，dp[i][j]表示s[0<del>i-1]和p[0</del>j-1]是否匹配。初始化方面，对于空的p，dp[i][0]仍是除dp[0][0]外全部false，不可能用空的p去匹配非空的s；对于空的s，dp[0][j]就要看当前是否是<code>&#39;*&#39;</code>且考虑dp[0][j-1]。接着双重循环更新dp<br> -&gt; 若当前字符p[j-1]是<code>&#39;*&#39;</code>，则考虑忽略它时，s[0<del>i-1]和p[0</del>j-2]的匹配情况，即dp[i][j-1]；或将<code>&#39;*&#39;</code>假设为s[i-1]那个字符，看看s[0<del>i-2]与p[0</del>i-1]的匹配情况，即dp[i-1][j]。<br> -&gt; 若当前字符p[j-1]不是<code>&#39;*&#39;</code>，就直接看s[i-1]和p[j-1]的匹配情况再结合dp[i-1][j-1]了。<br> 除了DP，这个题目似乎还可以用<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/3040/linear-runtime-and-constant-space-solution">贪心</a>给两个字符串分别用一个指针一直向后挪。</li>
<li>Misunderstood the problem, especially the ‘*’.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || p == <span class="literal">null</span> || s.equals(p)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.length(), n = p.length();</span><br><span class="line">        <span class="type">char</span>[] sChar = s.toCharArray(), pChar = p.toCharArray();</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span> [m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;    <span class="comment">// &quot;&quot; fits &quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;   <span class="comment">// only &quot;x*&quot; can fit &quot;&quot;</span></span><br><span class="line">            <span class="keyword">if</span> (pChar[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pChar[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;  <span class="comment">// don&#x27;t take * or view * as one char or just</span></span><br><span class="line">                                            <span class="comment">// get rid of the char in sChar</span></span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>] || dp[i - <span class="number">1</span>][j - <span class="number">1</span>] || dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (pChar[j - <span class="number">1</span>] == sChar[i - <span class="number">1</span>] || pChar[j - <span class="number">1</span>] == <span class="string">&#x27;?&#x27;</span>) &#123;</span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="jump-game-ii"><a href="#jump-game-ii" class="headerlink" title="jump-game-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/jump-game-ii/#/description">jump-game-ii</a></h4><ul>
<li>给一个元素非负的int数组，每个元素表示最多向后移几步，从index&#x3D;0开始求最少经过几个节点到达末尾（含起点）。</li>
<li>ME：维护多一个一维数组，表示当前点一跳最远可以到达什么索引。贪心法，每次都选当前可达节点中下一步能跳得最远的点。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/28470/concise-o-n-one-loop-java-solution-based-on-greedy/7">这个</a>似乎不需要额外的数组，毕竟每次你只关注『后续节点中最远可达的索引』。<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/3191/o-n-bfs-solution">还有一种方式</a>是考虑成BFS『分层问题』，当前可达的节点属于同一层，一直找到末尾节点所在的层数。</li>
<li>Know part of the idea but fail to implement it bug-freely…because you missed the condition to add step count.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span> || nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">farthest</span> <span class="operator">=</span> <span class="number">0</span>, step = <span class="number">0</span>, currEnd = <span class="number">0</span>, endIndex = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; endIndex; i++) &#123;    <span class="comment">// warning: not nums.length</span></span><br><span class="line">            farthest = Math.max(farthest, nums[i] + i);</span><br><span class="line">            <span class="keyword">if</span> (i == currEnd) &#123;     <span class="comment">// reaches edge means you have to add 1 to go farther</span></span><br><span class="line">                step++;</span><br><span class="line">                currEnd = farthest;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="permutations"><a href="#permutations" class="headerlink" title="permutations"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/permutations/#/description">permutations</a></h4><ul>
<li>给一个各元素不同的int数组，求全排列。</li>
<li>ME：回溯法（或者说带有visited标志的DFS）搞定。</li>
<li>TA：如果面试官要求不能用recursive的方法，那<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/6377/my-ac-simple-iterative-java-python-solution">这个</a>iterative的方法就可以搬出来了。思想是每次借助上一次的结果，把当前元素依次往每个位置插而产生新的排列。由于要利用上一次的结果，那么就在第一重循环之前先给ans放入只有一个nums[0]元素的序列，然后每次取出一个ans中的序列并来一波循环插入新元素。</li>
<li>DFS OK.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span>[] used = <span class="keyword">new</span> <span class="title class_">boolean</span> [nums.length];</span><br><span class="line">        dfs(nums, used, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(), ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">boolean</span>[] used, List&lt;Integer&gt; curr, List&lt;List&lt;Integer&gt;&gt; ans)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (curr.size() == nums.length) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(curr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i] == <span class="literal">false</span>) &#123;</span><br><span class="line">                curr.add(nums[i]);</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line">                dfs(nums, used, curr, ans);</span><br><span class="line">                curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="permutations-ii"><a href="#permutations-ii" class="headerlink" title="permutations-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/permutations-ii">permutations-ii</a></h4><ul>
<li>给一个可能有重复元素的int数组，求全排列，不可以有重复。</li>
<li>ME：也是回溯法，与上一题区别在于需要先排个序，然后每次往里放元素之前先判断是否和前面空闲元素相等，若相等则不能选取，因为前面相等的元素空闲说明这个位置它已经排列过了。</li>
<li>TA：按照上一题的那个iterative的方法<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/101110021/">改造了一下</a>，去重只需要排序+在插入时判断要插入位置前一个字符是否相同即可，相同就跳过了。</li>
<li>Pretty much the same thing to previous one.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);  <span class="comment">// sort for duplication avoidance</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">boolean</span>[] used = <span class="keyword">new</span> <span class="title class_">boolean</span> [nums.length];</span><br><span class="line">        dfs(nums, used, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(), ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">boolean</span>[] used, List&lt;Integer&gt; curr, List&lt;List&lt;Integer&gt;&gt; ans)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (curr.size() == nums.length) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(curr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line">                curr.add(nums[i]);</span><br><span class="line">                dfs(nums, used, curr, ans);</span><br><span class="line">                curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="rotate-image"><a href="#rotate-image" class="headerlink" title="rotate-image"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/rotate-image/#/description">rotate-image</a></h4><ul>
<li>给一个n*n的int数字矩阵，顺时针旋转90°。</li>
<li>ME：直接走in-place了，思路是每一条正方形上边缘的n-1个元素来挪动，沿边的长度挪动n-1次，然后再到内部的正方形去继续移动，直到n-1 &lt; 1，说明只剩一个元素或没有元素了。在纸上写了一堆矩阵找规律，好歹找出来了。</li>
<li>TA：我还以为自己好不容易找到一个还不错的规律，没想到还能通过对角线对称+左右对称搞定。<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/9744/ac-java-in-place-solution-with-explanation-easy-to-understand">这个</a>可以扩展到顺时针（左右swap）、逆时针（上下swap）的通用解法。</li>
<li>fail to come up with the above symmetric method. Even know the idea, I just didn’t make the diagnol symmetric correct. diagnol is from top-left to bottom-right</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="comment">// firstly get diagonal symmetric</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[j][i];</span><br><span class="line">                matrix[j][i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// then flip left and right part</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n / <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[i][n - j - <span class="number">1</span>];</span><br><span class="line">                matrix[i][n - j - <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="group-anagrams"><a href="#group-anagrams" class="headerlink" title="group-anagrams"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/group-anagrams/description/">group-anagrams</a></h4><ul>
<li>给出一个String的数组，找出其中的『同字母异序』字符串并归类存入二维String数组返回。</li>
<li>ME：先对原数组排序，然后对每个字符串转成char数组，计算各位char的ascii码之和并重新排序，将这些整理后的string一个个再存入新的数组，然后再双重循环往后比较。被String默认的sort（compareTo）坑了，他是先找有没有字母不同，然后再看长度。后来利用传入自定义的Comparator，结果超时了。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/24494/share-my-short-java-solution/4">这个方法</a>每次都把原数组中抓到的String转成char[]再排个序，把这个再转为String作为key来查找HashMap&lt;String, List<String>&gt;，每次对应上了就往List里add就可以了，好简单。。。<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/45639/java-beat-100-use-prime-number">这个方法</a>有点像我最开始想采用的，就是利用每个字符串的字母本身形成某种与顺序无关的唯一性，而ascii码相加显然不够我就多弄了点手段，而这个方法利用的是素数来创建key，可以保证字母一样的字符串求出的key相同。利用素数乘积这个想法真的强。</li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/zhouziyu2011/article/details/68948588">自定义Arrays.sort</a>的第二个参数Comparator，需要实现其中的compare方法，用匿名类就可以了。自定义类的排序则是使用Collections.sort。</li>
<li>Once know the sorting method, its done.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="literal">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String str: strs) &#123;</span><br><span class="line">            <span class="type">char</span>[] sChar = str.toCharArray();   <span class="comment">// sort str</span></span><br><span class="line">            Arrays.sort(sChar);             </span><br><span class="line">            <span class="type">String</span> <span class="variable">newStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(sChar);  <span class="comment">// the key to get the index in ans</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(newStr)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> map.get(newStr);</span><br><span class="line">                ans.get(index).add(str);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(newStr, ans.size());</span><br><span class="line">                List&lt;String&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                temp.add(str);</span><br><span class="line">                ans.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="powx-n"><a href="#powx-n" class="headerlink" title="powx-n"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/powx-n/#/description">powx-n</a></h4><ul>
<li>给一个double为底数、一个int为幂，求pow(x, n)。</li>
<li>ME：一开始想直接暴力用循环乘乘乘搞出来，结果超时。小看了一波<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/5425/short-and-easy-to-understand-solution">解答</a>，通过递归解决了，原理是在传入下一层递归之前，底数放大同时缩小指数，毕竟之前超时的版本中最耗时的就是根据指数来循环。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/21837/5-different-choices-when-talk-with-interviewers">这里</a>有一个集锦，列举了五种解法。</li>
<li>取模操作<code>%</code>可以用与操作<code>&amp;</code>代替，因为单数的最后一位必定是一，这样<code>x&amp;1</code>的结果就不是0了。</li>
<li>Wow, there is an update in test cases. Fail to come up with the recusive method.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || x == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == Integer.MIN_VALUE) &#123;   <span class="comment">// warning overflow if simply reverse n in this case</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1.0</span> / x) * myPow(x, n + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            n = -n;</span><br><span class="line">            x = <span class="number">1.0</span> / x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (n &amp; <span class="number">1</span>) != <span class="number">0</span>? x * myPow(x*x, n/<span class="number">2</span>): myPow(x*x, n/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="n-queens"><a href="#n-queens" class="headerlink" title="n-queens"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/n-queens/#/description">n-queens</a></h4><ul>
<li>N皇后问题，国际象棋中的皇后可以任意攻击横+竖+45°的棋子，给一个整数n表示有n个皇后，返回这个n*n棋盘上所有可能的皇后位置。</li>
<li>ME：DFS（或者叫回溯？？），很经典的算法嘛。利用一个辅助的table记录当前放下的这个皇后的杀伤范围（五个方向），然后到下一行去dfs搜索是否有位置放。</li>
<li>TA：都是要用到递归的。<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/19470/my-easy-understanding-java-solution/">这里</a>有一个比较巧妙的validate函数，两个对角线的皇后判别利用的是横纵坐标相加相等（&#x2F;对角）和横纵坐标交叉相加相等（\对角）这种方式。其实后者这个对角线验证用横纵坐标之差相等更好理解&#x3D;_&#x3D;。</li>
<li>It should be a easy problem for DFS…but still fail because of diagonal conflict detection.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[][] table = <span class="keyword">new</span> <span class="title class_">char</span> [n][n];        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                table[i][j] = <span class="string">&#x27;.&#x27;</span>;  <span class="comment">// all . at first</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dfs(table, <span class="number">0</span>, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] table, <span class="type">int</span> col, List&lt;List&lt;String&gt;&gt; ans)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (col == table[<span class="number">0</span>].length) &#123;</span><br><span class="line">            ans.add(generate(table));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; table.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isValid(table, i, col)) &#123;   <span class="comment">// if put Q at (i, col)</span></span><br><span class="line">                table[i][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                dfs(table, col + <span class="number">1</span>, ans);</span><br><span class="line">                table[i][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">char</span>[][] table, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; table.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; y; j++) &#123; <span class="comment">// warning don&#x27;t go further than y</span></span><br><span class="line">                <span class="keyword">if</span> (table[i][j] == <span class="string">&#x27;Q&#x27;</span> </span><br><span class="line">                    &amp;&amp; (i == x || (x + y) == (i + j) || (x - i) == (y - j))) &#123;</span><br><span class="line">                    <span class="comment">// the diagnol judgement is error-tempting</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; <span class="title function_">generate</span><span class="params">(<span class="type">char</span>[][] table)</span> &#123;</span><br><span class="line">        List&lt;String&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; table.length; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">row</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span> (table[i]);</span><br><span class="line">            ret.add(row);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="n-queens-ii"><a href="#n-queens-ii" class="headerlink" title="n-queens-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/n-queens-ii">n-queens-ii</a></h4><ul>
<li>N皇后问题简略版，不用把棋盘输出，只是输出解的个数。</li>
<li>ME：我是没想到更快的办法，还是用table[][]的老路子。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/5962/accepted-java-solution">这个</a>就用到了横纵坐标相加&#x2F;相减的办法来标记主&#x2F;副对角线是否冲突。使用了三个set来维护列和两个对角的占用情况，就不用每次都循环一遍table来更新占用情况了，直接在set.add就好，用完了就remove，快很多。</li>
<li>Actually your initial thought for previous question can be used here, that is to mark the usage on 2 diagnols and rows and cols.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Integer&gt; colSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Integer&gt; diogSet1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Integer&gt; diogSet2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> count, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (colSet.contains(col)</span><br><span class="line">               || diogSet1.contains(row + col)</span><br><span class="line">               || diogSet2.contains(row - col)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// row,col is valid</span></span><br><span class="line">            colSet.add(col);</span><br><span class="line">            diogSet1.add(row + col);</span><br><span class="line">            diogSet2.add(row - col);</span><br><span class="line">            count = dfs(row + <span class="number">1</span>, count, n);</span><br><span class="line">            colSet.remove(col);</span><br><span class="line">            diogSet1.remove(row + col);</span><br><span class="line">            diogSet2.remove(row - col);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="53-maximum-subarray"><a href="#53-maximum-subarray" class="headerlink" title="53. maximum-subarray"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-subarray/#/description">53. maximum-subarray</a></h4><ul>
<li>求一个数组中的sum最大的连续子串。</li>
<li>ME：玛德一道衣洗题想半天，还差点用O(n^2)暴力法搞了。想着用动归的思路维护一个二维数组，但是在找规律的过程中发现并不需要这么大的一个table，每次只用到了当前项和到前一项为止的最大值加上当前项，二者做个比较取较大者，于是一个O(n)，一个curr，一个max就搞定了。这种最优化问题，通常都能用DP的思路来解决。</li>
<li>TA：提示里说不要满足于O(n)的方法，用分治来搞更subtle。自己想了半天没想出来怎么分治，看了<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/42213/my-divide-and-conquer-solution-in-java-under-instruction-of-clrs-o-nlogn/2">这个</a>才明白。分治关键是怎么拆分问题，分成两半后最大子串要么在左半边、要么在右半边、要么在中间交叉的位置。因此，不断划分并求这三个sum，取三者中最大值作为当前划分的最大子串和返回。求交叉位置之和是，就是从mid开始往左累加刷新最大的leftsum、从mid+1开始向右累加刷新最大的rightsum，求left+right即为交叉子串的最大和了。不得不说，不太好懂啊。</li>
<li>Not quite smooth with this question tagged EASY. The divide-and-conquer is even more difficult to come up with.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MIN_VALUE, prev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            prev = Math.max(prev + nums[i], nums[i]);</span><br><span class="line">            ans = Math.max(ans, prev);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getMax(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;    <span class="comment">// end case</span></span><br><span class="line">            <span class="keyword">return</span> nums[left];</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (right + left) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> getMax(nums, left, mid);          <span class="comment">// get max subarray only with left elements</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> getMax(nums, mid + <span class="number">1</span>, right);    <span class="comment">// get max ~ right</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">midMax</span> <span class="operator">=</span> getMidMax(nums, left, mid, right); <span class="comment">// get max sub that uses both left and right</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(leftMax, Math.max(rightMax, midMax));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMidMax</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> Integer.MIN_VALUE, rightMax = Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;    </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> mid; i &gt;= left; i--) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            leftMax = Math.max(sum, leftMax);   <span class="comment">// at least take one element from left</span></span><br><span class="line">        &#125;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> mid + <span class="number">1</span>; i &lt;= right; i++) &#123;    </span><br><span class="line">            sum += nums[i]; </span><br><span class="line">            rightMax = Math.max(sum, rightMax); <span class="comment">// at least take one element from right</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftMax + rightMax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="spiral-matrix"><a href="#spiral-matrix" class="headerlink" title="spiral-matrix"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/spiral-matrix/#/description">spiral-matrix</a></h4><ul>
<li>给一个二维数组表示的int矩阵，螺旋式输出这个矩阵。</li>
<li>ME：就直接按照规则，螺旋式输出，从左到右、从上到下、从右到左、从下到上。然后进入里面一层，一圈一圈遍历。边缘情况就是在四个方向中1切换到2和2切换到3时判断一下是否已经超过了边界，防止重复输出。</li>
<li>TA：似乎玩不出花样了。</li>
<li>Fails with edge cases. this problem uncovers your disability to raise as much special edge cases as possible. Each condition need different constriants on iterating variables.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">0</span>, limit = Math.min((m + <span class="number">1</span>) / <span class="number">2</span>, (n + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">while</span> (level &lt; limit) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> level, j = level;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; n - level) &#123;</span><br><span class="line">                ans.add(matrix[i][j++]);</span><br><span class="line">            &#125;</span><br><span class="line">            j = n - level - <span class="number">1</span>;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span> (i == m - level) &#123;   <span class="comment">// for single line</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; m - level) &#123;</span><br><span class="line">                ans.add(matrix[i++][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            i = m - level - <span class="number">1</span>;</span><br><span class="line">            j--;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; level) &#123;    <span class="comment">// for single column</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= level) &#123;</span><br><span class="line">                ans.add(matrix[i][j--]);</span><br><span class="line">            &#125;</span><br><span class="line">            j = level;</span><br><span class="line">            i--;</span><br><span class="line">            <span class="keyword">while</span> (i &gt; level) &#123;</span><br><span class="line">                ans.add(matrix[i--][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="jump-game"><a href="#jump-game" class="headerlink" title="jump-game"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/jump-game">jump-game</a></h4><ul>
<li>给一个数组，每一个位置表示最大跳多少步，返回boolean看能否从首位跳到末尾。</li>
<li>ME：贪心法，维护一个『当前可到达最远的索引』，能到最后算你赢。</li>
<li>TA：也玩不出什么花样了吧。已然O(n)。</li>
<li>OK. constant space.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, farthest = nums[<span class="number">0</span>], lastIndex = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= farthest) &#123;</span><br><span class="line">            farthest = Math.max(nums[i] + i, farthest);</span><br><span class="line">            <span class="keyword">if</span> (farthest &gt;= lastIndex) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="56-merge-intervals"><a href="#56-merge-intervals" class="headerlink" title="56. merge-intervals"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-intervals/#/description">56. merge-intervals</a></h4><ul>
<li>给一个Interval类的list，将重叠部分进行合并，返回合并之后的list。</li>
<li>ME：自定义根据各Interval的左边界排序，然后判断当前Interval的左边界是否与前一个Interval的右边界有重合，有则将当前Interval的边界进行更新，然后remove掉前一个Interval。AC时发现耗时比较多，大概是这个remove比较不划算吧。但是你说改成LinkedList，那get又变得很不划算了，所以这个办法总的来说就不是很高效。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/4319/a-simple-java-solution/18">这里</a>有一个使用stack的方法，也是先根据左边界排序。然后遍历，若当前的Interval比栈顶的右边界大，直接入栈；否则就更新栈顶的右边界为二者右边界的较大值。很优雅，不过也没有快多少。在<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/117494413/">提交界面</a>倒是看到最快的哪个答案是用一个left和一个right数组来搞的，</li>
<li>自定义类的排序使用Collections.sort，需要指定comparator。在Java8中还有个更简洁的lambda写的comparator。stack转List不需要什么遍历插入，只需要直接构造子传入就可以了。</li>
<li>When knows the method of sorting and stacking, OK.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * public class Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start;</span></span><br><span class="line"><span class="comment"> *     int end;</span></span><br><span class="line"><span class="comment"> *     Interval() &#123; start = 0; end = 0; &#125;</span></span><br><span class="line"><span class="comment"> *     Interval(int s, int e) &#123; start = s; end = e; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Interval&gt; <span class="title function_">merge</span><span class="params">(List&lt;Interval&gt; intervals)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Interval&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(intervals, (a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.start != b.start) &#123;</span><br><span class="line">                <span class="keyword">return</span> a.start - b.start;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> a.end - b.end;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Stack&lt;Interval&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Interval itv: intervals) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                stack.push(itv);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">Interval</span> <span class="variable">curr</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">                <span class="keyword">if</span> (itv.start &gt; curr.end) &#123;</span><br><span class="line">                    stack.push(itv);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    stack.peek().end = Math.max(itv.end, curr.end);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// directly get List from stack with constructor</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Interval&gt;(stack);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Interval&gt; <span class="title function_">merge</span><span class="params">(List&lt;Interval&gt; intervals)</span> &#123;</span><br><span class="line">        List&lt;Interval&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Interval&gt;();</span><br><span class="line">        <span class="keyword">if</span> (intervals == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> intervals.size();</span><br><span class="line">        <span class="type">int</span>[] left = <span class="keyword">new</span> <span class="title class_">int</span> [len];     <span class="comment">// all left boundary</span></span><br><span class="line">        <span class="type">int</span>[] right = <span class="keyword">new</span> <span class="title class_">int</span> [len];    <span class="comment">// all right boundary</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            left[i] = intervals.get(i).start;</span><br><span class="line">            right[i] = intervals.get(i).end;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(left);</span><br><span class="line">        Arrays.sort(right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fast will select right bound and fast+1 is the candidate for next left bound</span></span><br><span class="line">        <span class="comment">// when candidate is valid, store curr interval (slow, fast) and move slow to candidate</span></span><br><span class="line">        <span class="comment">// for next left bound</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>, slow = <span class="number">0</span>; fast &lt; len; fast++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == len - <span class="number">1</span> || left[fast + <span class="number">1</span>] &gt; right[fast]) &#123;</span><br><span class="line">                ans.add(<span class="keyword">new</span> <span class="title class_">Interval</span>(left[slow], right[fast]));</span><br><span class="line">                slow = fast + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="insert-interval"><a href="#insert-interval" class="headerlink" title="insert-interval"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/insert-interval/#/description">insert-interval</a></h4><ul>
<li>给一个互不交叉的Interval类的list，给一个newInterval插入进去，并进行相应的合并if necessary，返回合并之后的list。</li>
<li>ME：遍历原list，取出时与newInterval比较看看是否重叠，若有重叠则合并后作为新的newInterval继续比较，若无重叠则看看谁更小，若newInterval更小说明已经结束，后面都不会有重叠的了，加入结果的ArrayList即可。边缘情况是若从头到尾都没有重叠且都小于newInterval，则需要额外把newInterval加入。</li>
<li>TA：想法都差不多吧，不过你的边缘情况似乎有点多余。因为在判断的时候可以知道什么时候『之后的都不会有重叠的了』，此时跳出循环，把newInterval加入，然后把剩余部分直接塞入结果即可。</li>
<li>With edge case failing at inserting into the very last postion of original list because at first I used non-check binarysearch, which will not get the correct insert position. Implementing verbosely…</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * public class Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start;</span></span><br><span class="line"><span class="comment"> *     int end;</span></span><br><span class="line"><span class="comment"> *     Interval() &#123; start = 0; end = 0; &#125;</span></span><br><span class="line"><span class="comment"> *     Interval(int s, int e) &#123; start = s; end = e; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Interval&gt; <span class="title function_">insert</span><span class="params">(List&lt;Interval&gt; intervals, Interval newInterval)</span> &#123;</span><br><span class="line">        List&lt;Interval&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Interval&gt;();</span><br><span class="line">        <span class="keyword">if</span> (intervals == <span class="literal">null</span> || intervals.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newInterval == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.add(newInterval);</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// find the pos for left bound to insert(equal or small than the start at that index)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> intervals.size();       </span><br><span class="line">        <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">0</span>, hi = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt;= hi) &#123;      <span class="comment">// warning: need to make sure the correctness of insert index</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (newInterval.start &gt; intervals.get(mid).start) &#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newInterval.start == intervals.get(mid).start) &#123;</span><br><span class="line">                lo = mid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hi = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">frontNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// if equals</span></span><br><span class="line">        <span class="keyword">if</span> (lo &lt; len &amp;&amp; intervals.get(lo).start == newInterval.start) &#123;</span><br><span class="line">            frontNum = lo;  <span class="comment">// no overlap for first lo intervals</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lo &gt; <span class="number">0</span>) &#123;   <span class="comment">// compare to prev&#x27;s end bound</span></span><br><span class="line">                <span class="keyword">if</span> (newInterval.start &gt; intervals.get(lo - <span class="number">1</span>).end) &#123;</span><br><span class="line">                    <span class="comment">// no overlap with prev, check </span></span><br><span class="line">                    frontNum = lo;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    frontNum = --lo;    <span class="comment">// lo need to back to prev because of overlap</span></span><br><span class="line">                    newInterval.start = intervals.get(lo).start;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    <span class="comment">// newInterval insert at very first</span></span><br><span class="line">                frontNum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(frontNum);</span><br><span class="line">        <span class="comment">// get the OK part in the front from 0 to frontNum</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; frontNum) &#123;</span><br><span class="line">            ans.add(intervals.get(i++));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// deal with overlapping parts</span></span><br><span class="line">        <span class="comment">// expand newInterval&#x27;s end if overlapping with following intervals</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; len &amp;&amp; newInterval.end &gt;= intervals.get(i).start) &#123;</span><br><span class="line">            newInterval.end = Math.max(newInterval.end, intervals.get(i).end);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(newInterval);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// add the rest non-overlapping intervals</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">            ans.add(intervals.get(i++));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="length-of-last-word"><a href="#length-of-last-word" class="headerlink" title="length-of-last-word"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/length-of-last-word/">length-of-last-word</a></h4><ul>
<li>给一个只包含字母和空格的字符串，返回最后一个独立单词的长度。</li>
<li>ME：从尾巴往前遍历，找到空格或首部即为最后一个单词的长度。</li>
<li>TA：没什么花样，毕竟衣洗题。</li>
<li>OK.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLastWord</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] sChar = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sChar.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; sChar[i] == <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">// actually can use trim at s firstly...</span></span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">anchor</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; sChar[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> anchor - i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="59-spiral-matrix-ii"><a href="#59-spiral-matrix-ii" class="headerlink" title="59. spiral-matrix-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/spiral-matrix-ii/#/description">59. spiral-matrix-ii</a></h4><ul>
<li>给一个整数n，生成一个n*n的二维数组方阵，使得螺旋式遍历的结果为1,2,3,…,n^2。</li>
<li>ME：就按照螺旋的顺序赋值呗。</li>
<li>TA：没啥花样。</li>
<li>OK.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] ans = <span class="keyword">new</span> <span class="title class_">int</span> [n][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">0</span>, end = (n + <span class="number">1</span>) / <span class="number">2</span>, num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (level &lt; end) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> level, j = level; </span><br><span class="line">            <span class="keyword">while</span> (j &lt; n - level) &#123;     <span class="comment">// left to right at top</span></span><br><span class="line">                ans[i][j++] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            j = n - level - <span class="number">1</span>;  </span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span> (i == n) &#123;       <span class="comment">// for single line</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;   </span><br><span class="line">            <span class="keyword">while</span> (i &lt; n - level) &#123;     <span class="comment">// top to bottom at right</span></span><br><span class="line">                ans[i++][j] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            i = n - level - <span class="number">1</span>;</span><br><span class="line">            j--;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; level) &#123;     <span class="comment">// for single column</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= level) &#123;        <span class="comment">// right to left at bottom</span></span><br><span class="line">                ans[i][j--] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            j = level;</span><br><span class="line">            i--;</span><br><span class="line">            <span class="keyword">while</span> (i &gt; level) &#123;         <span class="comment">// bottom to top at left</span></span><br><span class="line">                ans[i--][j] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="permutation-sequence"><a href="#permutation-sequence" class="headerlink" title="permutation-sequence"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/permutation-sequence">permutation-sequence</a></h4><ul>
<li>给两个整数n和k，求这个n产生的全排列中的第k个排列，返回这个字符串。</li>
<li>ME：全排列已经挺熟练的了，先把正常版本的全排列写出来，然后考虑如何加速。既然求的是第k个，那么在确定了当前这一位之后需要看看剩下的选择数还能产生多少可能性，如果这个可能性小于k，说明以当前这一位不能达到第k个排列，因此继续向后找；若这个可能性大于等于k，说明这第k个就落在当前这一位确定的情况下，所以确定这一位，相应更新一下标记数组和剩余可选择数，继续搜索。一开始想一步到位搞了半天，其实应该先把正常的写出来，再考虑怎么优化以适应这道题的要求。</li>
<li>TA：我的方法是recursive的，解答里给出了不少iterative的，例如<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/5081/an-iterative-solution-for-reference">这个</a>，用了一波发现比递归快呢。阶乘没必要每次都求啊，可以直接存入一个阶乘值的数组。</li>
<li>Come up with iterative method, but it seems that months ago I solve it recursively..</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] factorial;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPermutation</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span>[] used = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        factorial = <span class="keyword">new</span> <span class="title class_">int</span> [n + <span class="number">1</span>];</span><br><span class="line">        factorial[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            factorial[i] = factorial[i - <span class="number">1</span>] * i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; factorial[n]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">currK</span> <span class="operator">=</span> <span class="number">0</span>, level = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (level &lt;= n) &#123;</span><br><span class="line">            <span class="comment">// check where is k</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// the number to include</span></span><br><span class="line">            <span class="keyword">while</span> (currK + factorial[n - level] &lt; k) &#123; <span class="comment">// k is still behind</span></span><br><span class="line">                currK += factorial[n - level];  <span class="comment">// take next number as leading element</span></span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// put the #index available number into sb</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j++ == index) &#123;</span><br><span class="line">                        sb.append(i + <span class="number">1</span>);</span><br><span class="line">                        used[i] = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;            </span><br><span class="line">            <span class="comment">// update k and currK for next iteration</span></span><br><span class="line">            k -= currK;</span><br><span class="line">            currK = <span class="number">0</span>;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="rotate-list"><a href="#rotate-list" class="headerlink" title="rotate-list"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/rotate-list/#/description">rotate-list</a></h4><ul>
<li>给一个链表，给一个整数k,要求把链表最右k个元素放到链表最前面。</li>
<li>ME：滑动窗口&#x2F;快慢指针呗，左右指针从伪头部出发，先让右指针移k，之后左指针再开始移，直到右指针来到末尾。调整一下四个位置链表节点的指向即可。但一开始超时，这是因为对于k超出链表长度的情况，没有灵活处理。当右指针已经来到末尾而左指针还没有出发，说明k比较大，那么就用链表长度取个模，再把右指针丢回伪头部重新出发，根据这个新的k来滑动。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/2861/share-my-java-solution-with-explanation">这个</a>也是快慢指针，简化了很多判断，直接把快指针挪到末尾得到长度，然后再让慢指针根据k和链表长度取模的结果移到所需节点，然后操作一发。</li>
<li>Idea is OK, but not able to get it bug-free at once, because of the order that judge the k &#x3D;&#x3D; 0 condition.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">rotateRight</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head, slow = head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (k-- &gt; <span class="number">0</span>) &#123;   <span class="comment">// get the len (if k is larger than k) or move fast k steps firstly</span></span><br><span class="line">            fast = fast.next;</span><br><span class="line">            len++;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">null</span>) &#123; </span><br><span class="line">                fast = head;</span><br><span class="line">                k %= len;       <span class="comment">// adjust k to [0, len)</span></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;   <span class="comment">// warning need to return here not before k % len.</span></span><br><span class="line">                    <span class="keyword">return</span> head;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// move both slow and fast. when fast.next == null, it&#x27;s the last element</span></span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// at this point, slow.next is the new head, and need to link original head to the tail</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> slow.next;</span><br><span class="line">        fast.next = head;</span><br><span class="line">        slow.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="unique-paths"><a href="#unique-paths" class="headerlink" title="unique-paths"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/unique-paths/#/description">unique-paths</a></h4><ul>
<li>给两个整数m和n，表示m*n的棋盘，去从左上角的棋子到达右下角的路径数，棋子每次只能向下或者向右。</li>
<li>ME：找到了规律，在m*n的数组中，每个(i,j)处的值表示到达该处的路径数，除了左边缘和上边缘的路径数为1，其余的位置都由其上方和左方路径数决定，相加即可。一开始没找到这个还用了深度优先，结果超时了。。。</li>
<li>TA：原来我这个思路也能叫作DP了，因为当前结果是依赖前面的运算结果的。<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/5623/java-dp-solution-with-complexity-o-n-m/2">这个</a>可以优化成只是用一维数组。反正我也用不着除了右下角的其他值，那我每次都一波流叠加就行了，不用维护完整的table。</li>
<li>Ummm, not really solved by my own. After know the method of DP, OK.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (m &lt;= <span class="number">0</span> || n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span> [n];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;   <span class="comment">// iterate by row</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;   <span class="comment">// iterate by column</span></span><br><span class="line">                dp[j] = dp[j] + dp[j - <span class="number">1</span>];  <span class="comment">// prev dp[j] means coming from top</span></span><br><span class="line">                                            <span class="comment">// dp[j - 1] means coming from left</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="unique-paths-ii"><a href="#unique-paths-ii" class="headerlink" title="unique-paths-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/unique-paths-ii/#/description">unique-paths-ii</a></h4><ul>
<li>给一个二维数组，0表示可以走、1表示走不通，仍然求左上角到右下角的路径数。</li>
<li>ME：直接给了个二维数组，那就直接在二维数组上操作之。实现起来很快，但是！边缘情况真是搞死我辣，WA了好多次。。因为初始化的时候不能够像上一题一样直接对左边缘和上边缘直接赋值为1了，需要根据障碍情况来赋值，所以也是需要用到前面棋盘的结果的。此外还有终点&#x2F;起点本身就走不通这种小妖精。。。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/10974/short-java-solution">这个</a>同样可以简化成一维数组，只不过就不是in-place了。三楼指出了这个思路下数组的含义：dp[j]表示当前行到达第j列的可能路径数。</li>
<li>Pretty much similar to previous one, but need to pay attention to dimention of dp array(&#x3D; &#x3D;) and when updating each row, you have to consider if the obstacle happens at the very first one so your loop variable cannot start from 1 as it is in previou question.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid == <span class="literal">null</span> || obstacleGrid.length == <span class="number">0</span> || obstacleGrid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> obstacleGrid.length, n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> || obstacleGrid[m - <span class="number">1</span>][n - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">// can&#x27;t be reached if it is natrually blocked</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span> [n];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">// if obstacled, set as 0</span></span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                dp[j] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[j] = dp[j - <span class="number">1</span>];    <span class="comment">// only viable from previous in the same row</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[j] = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;    <span class="comment">// if obstacle is at the first of line</span></span><br><span class="line">                        dp[j] = dp[j - <span class="number">1</span>] + dp[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="minimum-path-sum"><a href="#minimum-path-sum" class="headerlink" title="minimum-path-sum"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-path-sum/#/description">minimum-path-sum</a></h4><ul>
<li>给一个m*n的非负数的矩阵，求一个从左上角到右下角的路径使得经过的数字之和最小，返回这个最小之和。同样每次只能向右或向下移。</li>
<li>ME：还是累加，遍历一遍棋盘，每次更新的时候选择左&#x2F;上之间较小者加上当前位置的数字。</li>
<li>TA：没啥花样了，基本都是DP。</li>
<li>OK. Greedy cannot work because it can only be tempted to choose the smaller one between the only two elements it can see, but optimal might be hidden somewhere else. Here use</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] result = <span class="keyword">new</span> <span class="title class_">int</span> [grid.length][grid[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] temp: result) &#123;</span><br><span class="line">            Arrays.fill(temp, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getMinSum(grid, result, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMinSum</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span>[][] result, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (result[x][y] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result[x][y];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x == grid.length - <span class="number">1</span>) &#123; <span class="comment">// at the bottom row</span></span><br><span class="line">            <span class="keyword">if</span> (y == grid[<span class="number">0</span>].length - <span class="number">1</span>) &#123;  <span class="comment">// at the right most column</span></span><br><span class="line">                result[x][y] = grid[x][y];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;   <span class="comment">// only move right</span></span><br><span class="line">                result[x][y] = grid[x][y] + getMinSum(grid, result, x, y + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (y == grid[<span class="number">0</span>].length - <span class="number">1</span>) &#123;  <span class="comment">// at the right most column</span></span><br><span class="line">                result[x][y] = grid[x][y] + getMinSum(grid, result, x + <span class="number">1</span>, y); <span class="comment">// only move downward</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;        <span class="comment">// try both right and bottom</span></span><br><span class="line">                result[x][y] = grid[x][y]</span><br><span class="line">                    + Math.min(getMinSum(grid, result, x, y + <span class="number">1</span>), getMinSum(grid, result, x + <span class="number">1</span>, y));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result[x][y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="valid-number"><a href="#valid-number" class="headerlink" title="valid-number"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-number/#/description">valid-number</a></h4><ul>
<li>给一个字符串，判断它是否是合法的数字，返回布尔值。</li>
<li>ME：这个跟算法没什么关系吧，就是考虑各种情况，看够不够细心。除了0~9，只可能出现<code>+</code>、<code>-</code>、<code>e</code>、<code>.</code>四种额外字符。写了个helper函数，传入起始位置和这四个符号的flag。、</li>
<li>TA：没啥算法吧。。</li>
<li>Ignoring…</li>
</ul>
<h4 id="plus-one"><a href="#plus-one" class="headerlink" title="plus-one"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/plus-one/#/description">plus-one</a></h4><ul>
<li>给一个数组，每一个索引存储的是对应的一位数字，返回这个数字加1的结果的数组。</li>
<li>ME：搞一个LinkedList负责不断往头部插入当前这一位的数字，进位为0后就直接赋值了。但是我的runtime特别特别慢，只打败1%！估计是LinkedList这里拖后腿了。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/24288/my-simple-java-solution">这个方法</a>告诉你，你的这个LinkedList没有必要，如果没有进位的话直接inplace就可以办到，当这个数字小于9，直接加上1就可以返回原数组了；如果等于9，则改为0后还要往前一位再判断；如果全部都遍历完还是没有返回，说明全是9，那么这时才需要额外申请一个规模大1位数组，直接把首位赋值为1就可以返回了。关键是很可能提前结束循环，不需要完全遍历原数组，节省了很多时间。</li>
<li>List类型存储的都是对象，因此没有办法直接用toArray()方法转成基本数值类型的数组。只能遍历一遍放入。</li>
<li>OK if know the trick to check when to allocate another array with extended size.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] plusOne(<span class="type">int</span>[] digits) &#123;</span><br><span class="line">        <span class="keyword">if</span> (digits == <span class="literal">null</span> || digits.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// add 1 and check if there is a carry.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> digits.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (digits[i] &lt; <span class="number">9</span>) &#123;</span><br><span class="line">                digits[i]++;</span><br><span class="line">                <span class="keyword">return</span> digits;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                digits[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if still not returned, it means the number is 9999...9</span></span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span> [len + <span class="number">1</span>];</span><br><span class="line">        ans[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="67-add-binary"><a href="#67-add-binary" class="headerlink" title="67. add-binary"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/add-binary/#/description">67. add-binary</a></h4><ul>
<li>给两个String表示的二进制数，返回二者相加后的二进制字符串。</li>
<li>ME：学习了一个，注意了提前return，所以这次写出来速度打败98%！两个数组对应位置数字相加再加个进位，超过1就-&#x3D;2并更新进位。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/13698/short-ac-solution-in-java-with-explanation">这个</a>比较简洁，全程用StringBuffer搞，算一位append一位，最后reverse一下即可。</li>
<li>进位的英文是carry。</li>
<li>Fail to come up with the graceful sb and reverse solution. WA because forget the condition where carry will be add to the most significant position.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addBinary</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="literal">null</span> || a.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (b == <span class="literal">null</span> || b.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">char</span>[] aChar = a.toCharArray(), bChar = b.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> aChar.length - <span class="number">1</span>, j = bChar.length - <span class="number">1</span>, carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> carry;    <span class="comment">// from prev result</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                sum += aChar[i--] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                sum += bChar[j--] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(sum % <span class="number">2</span>); <span class="comment">// what&#x27;s left after taking out carry</span></span><br><span class="line">            carry = sum / <span class="number">2</span>;    <span class="comment">// 3,2 -&gt; 1; 1,0 -&gt; 0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry != <span class="number">0</span>) &#123;</span><br><span class="line">            sb.append(carry);   <span class="comment">// warning! the most significant position</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="text-justification"><a href="#text-justification" class="headerlink" title="text-justification"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/text-justification/#/description">text-justification</a></h4><ul>
<li>给一个String的数组和每行的字符数，要求把这些字符串单词依次输出到每一行中，如果到末尾有空余又塞不下后面的单词的话，需要让该行最后一个单词向右靠并尽量让行中的空格平均分布，若无法很平均则前面的空格可以稍多于后面的。</li>
<li>ME：这题说是哈德，其实也一般吧。没啥好说的，先逐步读入单词看看什么时候放不下了，就调用辅助函数将这些单词尽量平均分步，利用取模&#x2F;整数除法计算应该塞多少空格。写完了之后确实没什么好说的，没什么精妙之处。</li>
<li>TA：听说可以用DP，不过高票答案都是和我差不多的。。。</li>
</ul>
<h4 id="sqrtx"><a href="#sqrtx" class="headerlink" title="sqrtx"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sqrtx/#/description">sqrtx</a></h4><ul>
<li>给一个int，返回它的开方。负数直接返回本身。</li>
<li>ME：和之前做过的一个pow有点像，得考虑如何加速。我能想到的就是折半、折半…这样，找到n*n &lt; x的时候，再一点点加，找到合适的值。需要注意的是越界的情况，因为x&#x2F;2得到的n平方一下可能特别大。提交后发现贼慢，只超过2%！</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/24532/3-4-short-lines-integer-newton-every-language">这个</a>总结了个<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division">牛顿法</a>出来，我的思路和它有点像，不过它更优雅，因为没有最后那个++的过程。另外<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/8680/a-binary-search-solution">这个二分查找的方法</a>比较合我心意。另外，一个避免越界的办法是不要用n*n，改成用x&#x2F;n来判断。奇怪的是，我写的这个二分也不快，但是看最快的那个方法基本和我一样啊摊手。<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/2671/share-my-o-log-n-solution-using-bit-manipulation/26">这里</a>还有一个利用位运算的方法，这个真的就是程序员的思路了，先把整数最高位设为1（1&lt;&lt;15）存入h，然后从高到低挪，与一个ans取或运算之后，把这个ans与x&#x2F;ans做比较，若大于说明太大了，ans与h取个异或把这一位1给拿掉，再继续挪h。。这么说可能也不是很好懂吧，确实是比较计算机的思维。位运算确实还是比较快的，打败了77%。还有<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/35357/share-my-2ms-and-4lines-java-code">一个方法</a>是利用<code>sqrt(x) = (2sqrt(x))/2 = 2sqrt(x/4)</code>来求的，边缘情况是非完全平方数的时候，需要将结果加个1再判断一下。一个衣洗题搞出这么多花样，服气。</li>
</ul>
<h4 id="climbing-stairs"><a href="#climbing-stairs" class="headerlink" title="climbing-stairs"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/climbing-stairs/#/description">climbing-stairs</a></h4><ul>
<li>给一个整数n表示阶梯的级数，每次只能跳1或2级，求跳到最高级的路径数。</li>
<li>ME：自从用了DP，根本停不下来，特别是这种带有状态变化的。当前这一级只可能是前一级或前两级跳过来的，因此把这俩的路径数一加就是当前这一级的路径数了。用dfs也可以做，但超时了，而且不太好解释呢。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/5371/basically-it-s-a-fibonacci">高人点出</a>这就是一个斐波那契数列。<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/30638/using-the-fibonacci-formular-to-get-the-answer-directly">这个</a>更是直接套了公式了。</li>
</ul>
<h4 id="simplify-path"><a href="#simplify-path" class="headerlink" title="simplify-path"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/simplify-path/#/description">simplify-path</a></h4><ul>
<li>给一个Unix风格的路径字符串，返回经过简化的路径字符串。例如<code>..</code>, <code>.</code>这些都需要简化。</li>
<li>ME：很容易想到用栈来处理路径中的<code>..</code>，不过一开始并不知道<a target="_blank" rel="noopener" href="http://blog.csdn.net/cuiyaoqiang/article/details/48998235">Stack可以使用List的接口直接转为List</a>，实际上我是直接用一个ArrayList模拟了栈的操作。提示里有两个边缘情况，你自己再回忆一下吧，不剧透了。我这个方法一不小心打败了99%呢。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/7675/java-10-lines-solution-with-stack">这个</a>提醒了我，Stack的遍历顺序是反的，那可以用Deque。同时答主利用了String.split来产生一组根据<code>/</code>划分的字符串集合，然后遍历这些字符串看看是否属于<code>&quot;..&quot;</code>, <code>&quot;.&quot;</code>以及<code>&quot;&quot;</code>，若不是说明是路径名，push即可。前面的三个字符存在一个HashSet中，这个空字符串是为了应对<code>//</code>这种情况。</li>
</ul>
<h4 id="72-edit-distance"><a href="#72-edit-distance" class="headerlink" title="72. edit-distance"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/edit-distance/#/description">72. edit-distance</a></h4><ul>
<li>给两个字符串word1, word2，求使用addition, replacement, removement三种操作的情况下最少多少步可以从word1转换成word2。</li>
<li>ME：卡了很久，搞了一上午，真心不知道怎么搞，情况实在太多太复杂了，一点都不清晰。</li>
<li>TA：原来要用DP啊，关键是我做的时候不知道怎么定义状态就没往这儿想了囧。看了<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/20922/java-dp-solution-o-nm/">这个解释</a>笋干明咗。<code>dp[i][j]</code>表示当前长度i的子字符串1转换成长度j的子字符串2最少需要的操作数。初始条件显然是<code>dp[0][x] = dp[x][0] = x</code>。对于任意一个<code>dp[i][j]</code>，需要由上、左上、左三个方格的计算结果决定，往上<code>dp[i-1][j]</code>表示一个deletion，往左<code>dp[i][j-1]</code>表示一个addition，左上<code>dp[i-1][j-1]</code>表示一个replacement。每次选取三者中最小的，加上1就是当前的最小操作数了。明白了DP原理之后，真的是秒杀。。。以后没思路就考虑是不是得DP一下了。此外，还有一种<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/102294131/">将DP二维数组简化成一维的</a>的，点最快那个可以看到。</li>
</ul>
<h4 id="set-matrix-zeroes"><a href="#set-matrix-zeroes" class="headerlink" title="set-matrix-zeroes"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/set-matrix-zeroes/#/description">set-matrix-zeroes</a></h4><ul>
<li>给一个二维int数组的矩阵，当某元素m[i][j]为0时，将行和列的所有元素都设为0.要求inplace完成。</li>
<li>ME：借助规模分别为m和n的辅助数组记录在哪行、哪列出现了0，后续再遍历到的时候就可以直接设为0了。一开始误会了inplace，还以为完全不可以使用额外的空间。inplace的意思是不允许复制到另外的数组并返回。感觉已经最优，不过时间居然还不是最快，有个循环了两轮的反而更快，大概是判断更少更简洁？？follow up要求使用constant space而不是O(m+n) space。想了一下想不出来。。。</li>
<li>TA：看了<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/15193/my-ac-java-o-1-solution-easy-to-read/">这里</a>才明白，原来O(1) space利用的是每一行&#x2F;每一列的首位元素作为标志为，出现了一个0后对应的行首&#x2F;列首就设为0！需要额外注意的是当行首&#x2F;列首本身就是0的话，得最后再来一波赋值。妙哉啊妙哉！</li>
</ul>
<h4 id="search-a-2d-matrix"><a href="#search-a-2d-matrix" class="headerlink" title="search-a-2d-matrix"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/search-a-2d-matrix/#/description">search-a-2d-matrix</a></h4><ul>
<li>完成一个二维数组版本的二分查找，这个矩阵是已经排好序的，每一行从左到右是递增的，下一行的最小元素也一定比上一行的大。返回布尔值。</li>
<li>ME：警告，我好像又有点忘记了经典的二分查找，赶紧看看<a href="https://bobbyliujb.github.io/2016/11/02/courseraAlgorithmI/">Princeton的笔记</a>。两层二分查找嵌套，利用行首、行末来决定是否真的要换行。</li>
<li>TA：如果不考虑超大的m*n的越界问题（而这个很可能不会发生，毕竟都能存储在内存中，数组的规模又怎么会越界呢？），<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/3227/don-t-treat-it-as-a-2d-matrix-just-treat-it-as-a-sorted-list">这个方法</a>挺好的，直接利用运算把二维的当作一维的来处理了，索引使用了整数除法和模运算。不过<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/3227/don-t-treat-it-as-a-2d-matrix-just-treat-it-as-a-sorted-list/8">这里</a>有大神提到了cache hit，不太明。</li>
</ul>
<h4 id="75-sort-colors"><a href="#75-sort-colors" class="headerlink" title="75. sort-colors"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sort-colors/#/description">75. sort-colors</a></h4><ul>
<li>给一个数组，只含有0，1，2三种元素，排序。</li>
<li>ME：显然木桶排序最快，不过这个我已经很熟了就不想写了，还是老老实实复习了一遍quickSort。没想到followup要求用one-pass解决，我不禁陷入了沉思。。只有三个元素，都知道1是pivot了，那感觉用quickSort的思路，on-pass确实是可以解决的！但是写出来就是不知哪里有问题，借助eclipse才发现是判断的时候错误地使用了&amp;&amp;导致else分支中的情况其实不是预想的。改了之后，果断速度超快。</li>
<li>TA：真是人才济济，这道米迪恩题竟然有人搞出了<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/6968/four-different-solutions">四种解法</a>。第一种桶排序，第二种是定义了n2,n1,n0三个索引，表示在什么位置插入2&#x2F;1&#x2F;0，这个真的妙哉。第三第四似乎差不多，定义两个索引对应0和2的插入位置，若当前位置是0，则与0的索引swap；若为2，则与2的索引swap。0的索引初始在最前，2的索引初始在最末，注意交换后要继续判断新交换过来的这位数字。</li>
</ul>
<h4 id="minimum-window-substring"><a href="#minimum-window-substring" class="headerlink" title="minimum-window-substring"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-window-substring/#/description">minimum-window-substring</a></h4><ul>
<li>给两个字符串s和t，要求在s中找到最短的子字符串使得它可以包含所有在t中出现的字符，就算t中重复那也要在s中重复。要求复杂度在O(n)。</li>
<li>ME：先对t的字符建立一个hashMap，方便获取各字符出现了多少次。但是对于O(n)的解法，我实在没辙，就算是DP那也要建立二维数组啊，那也不是O(n)啊，更何况DP的状态转换也没想出来。。。不愧是哈德题。</li>
<li>TA：你的HashMap完全可以用一个规模为128的数组代替，因为总共字符就128种。他喵的substring题又是双指针破解，要报警辣。<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/30941/here-is-a-10-line-template-that-can-solve-most-substring-problems">这个C++的双指针解答</a>速度超快，而且总结了一个给力的substring问题双指针破解模版，但是简洁的后果就是不太好懂，我也解释不清楚。只可意会不可言传啊。。。</li>
</ul>
<h4 id="combinations"><a href="#combinations" class="headerlink" title="combinations"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/combinations">combinations</a></h4><ul>
<li>给两个整数n和k，k表示组合的元素数，n表示可以有1~n这些数字作为元素，返回所有可能的组合。</li>
<li>ME：DFS秒杀。（还是叫回溯法来着？？？）</li>
<li>TA：回溯法是主流，还有一个<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/12537/a-short-recursive-java-solution-based-on-c-n-k-c-n-1-k-1-c-n-1-k">非主流的递归方法</a>，根据数学公式<code>C(n,k)=C(n-1,k-1)+C(n-1,k)</code>来的，有点头大。还看到了this，很久没见过这个关键字了。。。</li>
</ul>
<h4 id="subsets"><a href="#subsets" class="headerlink" title="subsets"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/subsets/#/description">subsets</a></h4><ul>
<li>给一个元素各不相同的数组，求它的所有不重复的组合。</li>
<li>ME：DFS还可以秒杀。此外，洗澡时还想到一个『利用已有List』的方法，即把当前元素都插入到之前的List末尾，直到全部搞完。</li>
<li>TA：同样有大神<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/46159/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning">总结了general的回溯法解决子集、排列、组合</a>等。还有一种用<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/2764/my-solution-using-bit-manipulation">位运算实现组合的方法</a>，我依稀记得大一的时候有听说过，现在看到才猛然想起来还有此等绝招。</li>
</ul>
<h4 id="word-search"><a href="#word-search" class="headerlink" title="word-search"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/word-search">word-search</a></h4><ul>
<li>给一个char的二维数组，再给一个String，在char[][]中尝试查找这个字符串，不一定是按顺序的查找，而是上下左右任意扭曲，但不能重复使用字符。能找到算你赢。</li>
<li>ME：DFS+状态记录搞定。本来不想搞多一个table的，但是如果只记录『搜索方向』，还是可能出现重复。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/7907/accepted-very-short-java-solution-no-additional-space">这个方法</a>就不需要额外的空间了，因为是直接对原char[][]开刀，利用一个异或操作，char是1byte即8bit的，那么我异或一个256（9bit）就可以让字符不合法了（不过为什么不会越界呢），这样后续操作时碰到不合法的字符就知道它已经被访问过了。访问完之后的复原也很方便，再异或一下256即可。</li>
</ul>
<h4 id="remove-duplicates-from-sorted-array-ii"><a href="#remove-duplicates-from-sorted-array-ii" class="headerlink" title="remove-duplicates-from-sorted-array-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/#/description">remove-duplicates-from-sorted-array-ii</a></h4><ul>
<li>给一个排好序的int数组，对它进行操作使得其中任意元素至多出现两次，返回经过修改后的数组长度。至于该长度之后的内容怎样，并不在意。</li>
<li>ME：之前有过做过类似的，思路就是把不符合『至多出现两次』的元素用后续的元素覆盖掉。这里也用到了双指针去搞，不过效率非常低，只打败了3%orz。</li>
<li>TA：双指针的generalize在<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/7673/share-my-o-n-time-and-o-1-solution-when-duplicates-are-allowed-at-most-k-times">这里</a>，但是不用双指针的<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/46519/short-and-simple-java-solution-easy-to-understand/">这个</a>更加逆天。感到一丝危机，我虽然能写出来，但是代码略长，面试时的时间可没这么多呢。</li>
</ul>
<h4 id="search-in-rotated-sorted-array-ii"><a href="#search-in-rotated-sorted-array-ii" class="headerlink" title="search-in-rotated-sorted-array-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/search-in-rotated-sorted-array-ii/#/description">search-in-rotated-sorted-array-ii</a></h4><ul>
<li>给一个排好序的、但经过一次随机前后rotate的int数组，给一个target，实现高效的查找方法，返回布尔值。</li>
<li>ME：利用之前看到的思路，假设数组的某一半是正常顺序，在进行正常的二分查找时额外判断一下target与两端的大小关系。然而这个思路碰到了重复的情况下比较麻烦，例如<code>[1,1,1,3,1]</code>，前中后三个都相等，这样就没法判断哪一半是正常顺序了，我的办法是把二分查找改造成递归的形式，遇到无法判断的时候，就进入两侧继续二分。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/310/when-there-are-duplicates-the-worst-case-is-o-n-could-we-do-better/2">这个</a>解决duplicate的办法是只用前和中的大小关系判断前半部分还是后半部分排好序了，若前和中相等则直接<code>lo++</code>。</li>
</ul>
<h4 id="remove-duplicates-from-sorted-list-ii"><a href="#remove-duplicates-from-sorted-list-ii" class="headerlink" title="remove-duplicates-from-sorted-list-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/#/description">remove-duplicates-from-sorted-list-ii</a></h4><ul>
<li>给一个排好序的链表，要求移除所有重复出现的元素，保留只出现了一次的元素，返回新链表头。</li>
<li>ME：三指针，一个prev用于保证前面元素的指向，一个slow作为基准，一个fast看看后续是否与基准重复。在最后循环结束后，需要再设置一下prev的next，因为又可以slow和fast怎么找也找不到下一个不重复的元素了，最后一个元素直接指向null准没错。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/5206/my-recursive-java-solution">这里</a>竟然有个recursive的方法，不太好懂。</li>
</ul>
<h4 id="remove-duplicates-from-sorted-list"><a href="#remove-duplicates-from-sorted-list" class="headerlink" title="remove-duplicates-from-sorted-list"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/#/description">remove-duplicates-from-sorted-list</a></h4><ul>
<li>给一个排好序的链表，要求移除多余元素使得所有元素只出现一次。刚好是上一题我理解错题意的时候写出来的。。。</li>
<li>ME：没啥。</li>
<li>TA：也有一个<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/14775/3-line-java-recursive-solution/8">recursive的解答</a>，大神用递归6得飞起。</li>
</ul>
<h4 id="largest-rectangle-in-histogram"><a href="#largest-rectangle-in-histogram" class="headerlink" title="largest-rectangle-in-histogram"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/largest-rectangle-in-histogram/#/description">largest-rectangle-in-histogram</a></h4><ul>
<li>给一个int数组表示柱状图各柱的高度，这些柱状图组成的最大完整矩形面积。</li>
<li>ME：使用暴力O(n^2)超时，不论是老老实实地往后一个个找，还是使用向左向右扩展的方法都是超时，即便跳过重复项也超时。。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/7599/o-n-stack-based-java-solution/21">这个</a>使用Stack即时更新，妙哉啊妙哉！使用栈记录索引，若栈为空则直接入栈，若当前索引对应的高度比栈顶索引的高度小，说明以栈顶元素为宽的矩形的长就在此时确定，计算一下矩形长度就可以把栈顶弹出了，然后继续比较当前索引和栈顶，直到当前索引的高度大于栈顶索引的高度。使用Java自带的Stack会比<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/39151/5ms-o-n-java-solution-explained-beats-96/2">直接用数组模拟栈</a>慢很多。<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/39151/5ms-o-n-java-solution-explained-beats-96">这个方法</a>则是我原本那个方法的一个加速版，我原来的向前后扩展找小于当前索引的位置使用的是一点点挪的办法，而加速就在于用两个额外的数组记录前&#x2F;后的小于当前索引的第一个索引，在记录的过程中『跳跃』式地更新指针，不再是一点点地挪，原来苦苦寻找的加速就在这里！还有一个<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/2424/my-modified-answer-from-geeksforgeeks-in-java/2">分治法</a>最大值要么在左半部分、要么在右半部分、要么在中间交叉部分，这个分类讨论似曾相识啊，前两天才做的<a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-subarray/#/description">maximum-subarray</a>就有个subtle的devide and conquer。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (heights == <span class="literal">null</span> || heights.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxHeight</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        stack.push(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (stack.peek() != -<span class="number">1</span> &amp;&amp; heights[stack.peek()] &gt;= heights[i]) &#123;</span><br><span class="line">                maxHeight = Math.max(maxHeight, heights[stack.poll()] * (i - <span class="number">1</span> - stack.peek()));</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (stack.peek() != -<span class="number">1</span>) &#123;</span><br><span class="line">            maxHeight = Math.max(maxHeight, heights[stack.poll()] * (heights.length - <span class="number">1</span> - stack.peek()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxHeight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="85-maximal-rectangle"><a href="#85-maximal-rectangle" class="headerlink" title="85. maximal-rectangle"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximal-rectangle/#/description">85. maximal-rectangle</a></h4><ul>
<li>给一个二维char数组，只包含0和1两种字符，求矩形所能围成的最大面积使得其中的元素都为1.</li>
<li>ME：憋了半天毫无思路，看了一下tag，提到了HashTable, Stack, DP。</li>
<li>TA：先介绍<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/6650/share-my-dp-solution">这个DP解法</a>，这里的DP不再是死板的x维数组这样，而是通过right, left, height三个一维数组，height[j]维护当前行的第j个元素的从上往下的最长高度，left[j]从左到右维护当前行的第j个元素能到达的最左字符<code>1</code>的索引，right[j]从右到左维护当前行的第j个元素能到达的最右的索引，只有当前元素为1（对应height不为0）的时候才会计算面积。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalRectangle</span><span class="params">(<span class="type">char</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>] == <span class="literal">null</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> matrix.length, cols = matrix[<span class="number">0</span>].length, maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] height = <span class="keyword">new</span> <span class="title class_">int</span>[cols];</span><br><span class="line">        <span class="type">int</span>[] left = <span class="keyword">new</span> <span class="title class_">int</span>[cols];</span><br><span class="line">        <span class="type">int</span>[] right = <span class="keyword">new</span> <span class="title class_">int</span>[cols];</span><br><span class="line">        Arrays.fill(right, cols - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>; row &lt; rows; row++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rightBoundary</span> <span class="operator">=</span> cols - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> cols - <span class="number">1</span>; col &gt;= <span class="number">0</span>; col--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[row][col] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    right[col] = Math.min(right[col], rightBoundary);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right[col] = cols - <span class="number">1</span>;</span><br><span class="line">                    rightBoundary = col - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">leftBoundary</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; cols; col++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[row][col] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    left[col] = Math.max(left[col], leftBoundary);</span><br><span class="line">                    height[col]++;</span><br><span class="line">                    maxArea = Math.max((right[col] - left[col] + <span class="number">1</span>) * height[col], maxArea);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left[col] = <span class="number">0</span>;</span><br><span class="line">                    leftBoundary = col + <span class="number">1</span>;</span><br><span class="line">                    height[col] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>然后介绍<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/21772/my-java-solution-based-on-maximum-rectangle-in-histogram-with-explanation/">这个</a>基于<a target="_blank" rel="noopener" href="https://leetcode.com/problems/largest-rectangle-in-histogram/#/description">上一道题largest-rectangle-in-histogram</a>的解法，柱状图对应于这道题当中的每一列累计的<code>1</code>，这样一转换瞬间就变成做过的题了，妙哉。同样可以<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/102879286/">用两个数组代替Stack</a>，速度奇快。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalRectangle</span><span class="params">(<span class="type">char</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>] == <span class="literal">null</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> matrix.length, cols = matrix[<span class="number">0</span>].length, maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] heights = <span class="keyword">new</span> <span class="title class_">int</span>[cols];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>; row &lt; rows; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; cols; col++) &#123;</span><br><span class="line">                heights[col] = matrix[row][col] == <span class="string">&#x27;1&#x27;</span> ? heights[col] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            maxArea = Math.max(maxArea, getMaxArea(heights));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMaxArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">retVal</span> <span class="operator">=</span> <span class="number">0</span>, len = heights.length;</span><br><span class="line">        stack.push(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (stack.peek() != -<span class="number">1</span> &amp;&amp; heights[i] &lt;= heights[stack.peek()]) &#123;</span><br><span class="line">                retVal = Math.max(retVal, heights[stack.pop()] * (i - stack.peek() - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (stack.peek() != -<span class="number">1</span>) &#123;</span><br><span class="line">            retVal = Math.max(retVal, heights[stack.pop()] * (len - stack.peek() - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="partition-list"><a href="#partition-list" class="headerlink" title="partition-list"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/partition-list/#/description">partition-list</a></h4><ul>
<li>给一个链表，给一个整数x，要求调整链表节点顺序使得链表前面部分都是小于x的、后面部分是大于等于x的。</li>
<li>ME：三指针+伪头部呗，直接在原链表上搞。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/7795/concise-java-code-with-explanation-one-pass">这个</a>定义了两部分的头结点，作为两个子链表来处理，非常好懂，要思考的细节也少一些。</li>
</ul>
<h4 id="scramble-string"><a href="#scramble-string" class="headerlink" title="scramble-string"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/scramble-string/#/description">scramble-string</a></h4><ul>
<li>将一个字符串任意拆分成两个非空的子字符串作为两个子节点，一路拆分下去形成一个二叉树。交换任意一个非叶子节点的两个子节点，形成新的字符串，称为scramble。给两个字符串，判断s2能否由s1这样scramble得到。</li>
<li>ME：一脸懵逼。。。。。。。。。。。。。看了tag，居然又他喵的是DP。。。感觉很多这种毫无头绪的题给的hint都是用DP。又观察了一波，似乎如果字符各不相同的话，只要每个字符都出现了，就一定有办法表示成二叉树的scramble，直接bucket标记就可以搞定。字符如果有重复的情况，似乎也可以？提交了一波，WA，例如abcd和bdac这种完美交错的就不可能了。</li>
<li>TA：竟然可以用<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/19158/accepted-java-solution/">暴力法</a>，不断截取子字符串，只要同时满足前后子串都是scramble的或者经过位置交换后满足前后子串都是scramble的就可以了。事实上这种暴力递归的速度并不慢，<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/36715/simple-iterative-dp-java-solution-with-explanation">这个三维DP的解法</a>还慢一些。为什么一开始想不出DP，因为三维实在不太好画出来。<code>dp[i][j][k]</code>表示<code>s1[i...i+k-1]</code>是否是<code>s2[j...j+k-1]</code>的scramble，k取1时为base case，直接比较s1[i]和s2[j]即可，k取len即为最终结果。DP需要判断所有的情况，给一个分割点q，从1一直遍历到k-1地找当前这个长度k的所有划分情况。循环的边界应取到len。</li>
</ul>
<h4 id="merge-sorted-array"><a href="#merge-sorted-array" class="headerlink" title="merge-sorted-array"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-sorted-array/#/description">merge-sorted-array</a></h4><ul>
<li>给两个排好序的数组，并给出他们原本有多少已排好序数字，将后者合并到前者中。前者的容量一开始已经设为大雨等于两个数组规模之和。</li>
<li>ME：一开始一位要Inplace，想了半天，可以做但是索引搞来搞去的不好写。之后借助了额外的空间Queue来记录A中比B大的元素，但他喵的居然WA，足足改了一上午加一下午，还是没有把这道衣洗题搞出来！实在是不能忍！！！</li>
<li>TA：原来确实可以Inplace，而且根本不用判断那么多情况，自己给自己设套。既然第一个数组尾部有多余的空间，那么可以从后往前塞，这样就防止了正常从前往后比较赋值时元素被覆盖的问题。<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/16946/4ms-c-solution-with-single-loop">这个</a>总共只用了一次循环，比我的三个循环简洁很多。</li>
<li>Queue使用了LinkedList实现类。LinkedList类还可以实现栈的功能。</li>
</ul>
<h4 id="gray-code"><a href="#gray-code" class="headerlink" title="gray-code"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/gray-code">gray-code</a></h4><ul>
<li>给一个整数表示有多少bit，相邻的两个数只有一个bit不同成为grey code，返回符合grey code格式下对应的整数数组。</li>
<li>ME：递归使用之前的计算结果，n bit实际上就是在n-1 bit的基础上，首位为0一波、首位为1逆序一波两个。但隐约觉得似乎有位运算本身的规律？</li>
<li>TA：果然是<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/8557/an-accepted-three-line-solution-in-java">位运算王道</a>。很强。同时，你这个方法还可以『去递归』，就像<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/1011/what-is-the-best-solution-for-gray-code-problem-no-extra-space-used-and-no-recursion/2">这样</a>。所谓优化，除了算法本身，剩下的无非是去递归、减小DP使用的辅助空间等。</li>
</ul>
<h4 id="subsets-ii"><a href="#subsets-ii" class="headerlink" title="subsets-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/subsets-ii/#/description">subsets-ii</a></h4><ul>
<li>给一个含有int的collection，其中的元素可能有重复，返回所有可能的子集。</li>
<li>ME：还是回溯法，在循环开头加了个判断防止重复，若当前元素和之前元素相同则跳过，这样就不会出现你方唱罢我登台的场景。但是，速度好慢。。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/39672/share-my-2ms-java-iteration-solution-very-simple-and-short">这个</a>又是去递归的，只用了两重循环，第一重是每次从原collection中取不重复的元素，第二重就是向已有的结果中添加该元素并存入结果。需要注意的是若当前元素不是重复的，则在第二重循环中就需要把全部结果都取出来并加上当前元素；若是重复元素，则继续往里加就行了，毕竟你还从头加的话实际上前面相同的元素已经干过了。<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/22638/very-simple-and-fast-java-solution">这个</a>和你的一样都是递归，但人家的条件怎么就能精简不少呢？而且你的table也没有必要，因为不可能都循环到后面了还从前面调取元素放进来，那样肯定重复。</li>
</ul>
<h4 id="91-decode-ways"><a href="#91-decode-ways" class="headerlink" title="91. decode-ways"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/decode-ways/#/description">91. decode-ways</a></h4><ul>
<li>给一个纯数字的字符串，看有多少中方式解析成对应的字母A-Z。如<code>12</code>可解析为<code>AB</code>或<code>L</code>两种，返回2。</li>
<li>ME：一开始纯DFS，超时。暗中观察，发现可能是计算有重复的，后一步运算可以用到前一步运算的结果，这时我就想到用DP了。用dp[len+1]的数组记录状态，从右往左刷新，若当前字符为0则直接dp设为0；若为1或2再判断是否属于10~26的两位数范围，符合了就是后一位和后两位dp结果之和（即取一位和取两位两种情况）。不过已经写了递归就先把递归过了，然后改写成iterative，速度一样。</li>
<li>TA：大神们很多用了substring然后转成数值来判断是否属于1~26的，我不太喜欢。</li>
<li>字符串转数字用<code>Integer.valueOf(s.substring(start, end));</code>。</li>
</ul>
<h4 id="reverse-linked-list-ii"><a href="#reverse-linked-list-ii" class="headerlink" title="reverse-linked-list-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-linked-list-ii/#/description">reverse-linked-list-ii</a></h4><ul>
<li>给一个链表，给范围[m, n]，要求in-place, one-pass地将第m个和第n个之间的节点全部反转。</li>
<li>ME：四指针搞起，需要借助伪头部处理反转头结点的问题。prev指向反转之前的一位，用于完成后续反转后指向新的后续头结点；start用于查找第m位，end用于查找第n位，first用于记录开始反转的首位；当找到m之后就开始找n，此时每一个新的end指向的节点都直接作为新的头结点，并调整start, end的指向，需要借助first和newNext完成end后续节点和end本身的更新。这么说有点复杂，在纸上写写就懂了。</li>
<li>TA：看了<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/8976/simple-java-solution-with-clear-explanation">这个</a>发现没必要多出来一个first，因为你的prev已经记录了原本它之后是什么元素，也就是first了。因此每次都更新prev.next就行，所以还是三指针。<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/3250/share-my-java-code">这个</a>就有点争议了，因为额外用了一个sublist的头结点，每次直接把sublist的伪头部指向读入的节点，这样得到的sublist就是一个反了的第m到第n个节点子链表了，再改一下指向拼回去即可。这个挺直接的。</li>
</ul>
<h4 id="restore-ip-addresses"><a href="#restore-ip-addresses" class="headerlink" title="restore-ip-addresses"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/restore-ip-addresses/#/description">restore-ip-addresses</a></h4><ul>
<li>给一个由数字组成的字符串，返回将这些数字通过<code>.</code>分隔形成的所有合法的IP地址。</li>
<li>ME：DFS搞定，每次分别取一位、两位、三位数字，再往后判断。需要特别注意0，出现0就只能取一位了，因为不能出现<code>010</code>这样的IP地址嘛。若原字符串长度小于4或多于12直接就不用管了。但速度好慢。。</li>
<li>TA：大神们又改成了三重循环的Iterative了。<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/6304/my-concise-ac-java-code">这个</a>的思路是在原字符串中插入三个小数点得到四个整数，判断是否在[0, 255]范围内，然后再利用长度的trick处理<code>010</code>的情况，即转成整数后拼接而成的IP地址字符串长度并不是原字符串长度+3，因为开头的0在转成整数的过程中给抹掉了。妙哉！</li>
<li>Integer.parseInt(str)。</li>
</ul>
<h4 id="binary-tree-inorder-traversal"><a href="#binary-tree-inorder-traversal" class="headerlink" title="binary-tree-inorder-traversal"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-inorder-traversal/#/description">binary-tree-inorder-traversal</a></h4><ul>
<li>给一个树的根节点，返回中序遍历的结果。</li>
<li>ME：树的基础了，没啥好说的吧，DFS。</li>
<li>TA：又有大神改成Iterative了。。<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/6478/iterative-solution-in-java-simple-and-readable">这个</a>是基于Stack的，当前节点直接入栈然后一直往左边子树钻，钻到头就把栈顶元素输出，然后再到他的右子树去，继续往左钻。还有一个更神奇的<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/3402/morris-traversal-no-recursion-no-stack">Morris Traversal</a>，不用Stack也不递归，前序&#x2F;中序遍历都可以用（后序略复杂），空间是O(1)，时间是O(N)还是O(NlgN)有点疑惑。更多解析参考<a target="_blank" rel="noopener" href="https://codeoverflow.wordpress.com/tag/morris-inorder-traversal/">这里</a>，和<a target="_blank" rel="noopener" href="http://www.cnblogs.com/AnnieKim/archive/2013/06/15/morristraversal.html">中文的千种后续</a>关键是『让右节点遍历完之后能找到它下一步应该怎么回到还没有打印过的祖先节点』。用到了current和prev两个节点引用：current从根出发，一直往左子树钻，钻不动了说明自己该打印出来了，然后current往右子树钻。若current的左子树不是空，说明当前节点还不能打印，需要在将来告诉左子树的最右节点（因为它一定是子树中最后一个打印的）自己还没有打印、你要回到我这儿，所以设置prev指向current的左子树，然后让prev一直往右钻，直到钻不动就把该子树的右节点指向current。但如果在钻的过程中发现最右子树已经指向了自己，则说明子树全部遍历结束，current该打印了，打印了之后，current再往右子树钻。</li>
<li>Recursive OK, iterative not ok, even if I know about using stack, got endless loop.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span> || !s.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">                s.push(curr);</span><br><span class="line">                curr = curr.left;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = s.pop();</span><br><span class="line">            ans.add(curr.val);</span><br><span class="line">            curr = curr.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="95-unique-binary-search-trees-ii"><a href="#95-unique-binary-search-trees-ii" class="headerlink" title="95. unique-binary-search-trees-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/unique-binary-search-trees-ii/#/description">95. unique-binary-search-trees-ii</a></h4><ul>
<li>只给一个整数n表示二分查找树的节点数，返回所有结构不同的树。而上一问则只是输出不同树的个数，只是个小DP。</li>
<li>ME：我能联想到DP的状态转换，即下一层加入的节点左右子树可以利用之前的结果，而且连右子树的offset都想到了。但是就是写不出来。。。逻辑混乱，写得糊里糊涂的。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/2940/java-solution-with-dp">这个</a>的思路跟你一模一样，你他喵的还用List作为dp，简直是作死。**dp的状态存储用数组！！！**上面这个po主思路很清楚，<code>dp[i]</code>表示当节点数为<code>i</code>个时所有可能形状的树结构，因此初始化时<code>dp[0]</code>的ArrayList直接插入一个null，省去了很多判断。然后开始向后刷新直到长度为n，即为结果。每一次刷新都需要充分使用之前的结果，左子树的节点数从0一直到i-1，右子树节点数对应地就是i-1到0了，右子树的节点的value需要额外刷新一下，因为左子树和当前节点占用掉了j+1，要相应地累加给右子树的所有节点才行。此外，分治法我也一开始就想到了，但是觉得不划算，因为没法记录之前计算的结果，但<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/8410/divide-and-conquer-f-i-g-i-1-g-n-i">这个</a>写出来感觉还行。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">generateTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;TreeNode&gt;[] dp = <span class="keyword">new</span> <span class="title class_">List</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>].add(<span class="literal">null</span>);    <span class="comment">// notation for empty subtree</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// BST: left children all smaller, right all larger.</span></span><br><span class="line">        <span class="comment">// each time fix the root, take prev as left subtree, and prev with offset as right subtree.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">nodeNum</span> <span class="operator">=</span> <span class="number">1</span>; nodeNum &lt;= n; nodeNum++) &#123;</span><br><span class="line">            dp[nodeNum] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;TreeNode&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">leftNum</span> <span class="operator">=</span> <span class="number">0</span>; leftNum &lt; nodeNum; leftNum++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (TreeNode leftNode: dp[leftNum]) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (TreeNode rightNode: dp[nodeNum - leftNum - <span class="number">1</span>]) &#123;</span><br><span class="line">                        <span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(leftNum + <span class="number">1</span>);</span><br><span class="line">                        curr.left = leftNode;</span><br><span class="line">                        curr.right = addOffset(rightNode, leftNum + <span class="number">1</span>);</span><br><span class="line">                        dp[nodeNum].add(curr);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// its kinda tricky to come up with this offset</span></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">addOffset</span><span class="params">(TreeNode node, <span class="type">int</span> offset)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(node.val + offset);</span><br><span class="line">        newNode.left = addOffset(node.left, offset);</span><br><span class="line">        newNode.right = addOffset(node.right, offset);</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Divide and conquer</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">generateTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;TreeNode&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> generate(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> List&lt;TreeNode&gt; <span class="title function_">generate</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        List&lt;TreeNode&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) &#123;      <span class="comment">// recursion end condition</span></span><br><span class="line">            result.add(<span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span> result; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// take i as root val</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line">            List&lt;TreeNode&gt; left = generate(start, i - <span class="number">1</span>);   <span class="comment">// generate all possible left subtree</span></span><br><span class="line">            List&lt;TreeNode&gt; right = generate(i + <span class="number">1</span>, end);    <span class="comment">// gennerate all possible right subtree</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode l: left) &#123;</span><br><span class="line">                <span class="keyword">for</span> (TreeNode r: right) &#123;</span><br><span class="line">                    <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(i);    <span class="comment">// set root val</span></span><br><span class="line">                    node.left = l;</span><br><span class="line">                    node.right = r;</span><br><span class="line">                    result.add(node);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="96-unique-binary-search-trees"><a href="#96-unique-binary-search-trees" class="headerlink" title="96. unique-binary-search-trees"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/unique-binary-search-trees/">96. unique-binary-search-trees</a></h4><ul>
<li>求含有值1～n的BST的可能形状数目。</li>
<li>每次固定root，左子树一定都是小于它的、右子树一定都是大于它的，而总体可能形状恰好就是左右各自形状数目的乘积。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span> [n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;  <span class="comment">// 总节点数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i; j++) &#123;   <span class="comment">// 固定root的值</span></span><br><span class="line">                dp[i] += (dp[j - <span class="number">1</span>] * dp[i - j]);  <span class="comment">// 左侧右j-1个节点、右侧有i-j个节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="97-interleaving-string"><a href="#97-interleaving-string" class="headerlink" title="97. interleaving-string"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/interleaving-string/#/description">97. interleaving-string</a></h4><ul>
<li>给三个字符串s1, s2, s3，判断s3是否由s1和s2拼接而成，这里的拼接可以是交错的，但必须维持字符原本的出现顺序。</li>
<li>ME：一开始直接贪心法递归下去找，取s1的字符往后尝试，碰壁了再取s2的字符尝试，心想怎么这么简单，结果超时。。感觉着有点像之前的棋盘题，当时也是深度搜索超时改成DP就秒了，看了一下tag，果然是DP，但这题的状态转换并不好找。</li>
<li>TA：哇去，我原本非常接近真相了啊，棋盘都画出来了。<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/3532/my-dp-solution-in-c">这个是C++的</a>二维数组的行为s2，列为s1，dp[i][j]表示s3取i+j-1个字符的子字符串是否是s2取i-1个字符、s1取j-1个字符的interleaving。直接双重循环更新这个dp二维数组即可，对于左边缘和上边缘只有一个移动方向，而其余的位置可能来自左边（选择了s1的字符）或上边（选择了s2的字符），这就依赖于之前的状态以及取的这个字符了，这就是DP的状态转换。<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/31991/1ms-tiny-dfs-beats-94-57">DFS如果加上了cache也可以通过</a>，不过这还不如DP来得方便。此外，BFS通常用于求『最小值』类问题，在这里也可以用，比如<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/6562/8ms-c-solution-using-bfs-with-explanation/11">这个</a>，与DFS的区别在于DFS每次先处理一个方向，走不通再return回来走另一条；而BFS则是通过入队，每次都照顾到两个方向。BFS本身并不比DFS快，这里也还是用了一个visited二维数组防止走回头路。</li>
<li>Once know about DP, implementation is OK.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DP</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1 == <span class="literal">null</span> || s2 == <span class="literal">null</span> || s3 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> s1.length(), len2 = s2.length(), len3 = s3.length();</span><br><span class="line">        <span class="keyword">if</span> (len1 + len2 != len3) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] cs1 = s1.toCharArray(), cs2 = s2.toCharArray(), cs3 = s3.toCharArray();</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span> [len1 + <span class="number">1</span>][len2 + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; dp[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>; </span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = cs2[j - <span class="number">1</span>] == cs3[i + j - <span class="number">1</span>] &amp;&amp; dp[i][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                        dp[i][j] = cs1[i - <span class="number">1</span>] == cs3[i + j - <span class="number">1</span>] &amp;&amp; dp[i - <span class="number">1</span>][j];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// take char from s1(move i) or from s2(move j)</span></span><br><span class="line">                        dp[i][j] = (dp[i - <span class="number">1</span>][j] &amp;&amp; cs1[i - <span class="number">1</span>] == cs3[i + j - <span class="number">1</span>])</span><br><span class="line">                            || (dp[i][j - <span class="number">1</span>] &amp;&amp; cs2[j - <span class="number">1</span>] == cs3[i + j - <span class="number">1</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DFS</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1 == <span class="literal">null</span> || s2 == <span class="literal">null</span> || s3 == <span class="literal">null</span> || s1.length() + s2.length() != s3.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] cs1 = s1.toCharArray(), cs2 = s2.toCharArray(), cs3 = s3.toCharArray();</span><br><span class="line">        <span class="type">boolean</span>[][] invalid = <span class="keyword">new</span> <span class="title class_">boolean</span> [cs1.length + <span class="number">1</span>][cs2.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> dfs(cs1, cs2, cs3, <span class="number">0</span>, <span class="number">0</span>, invalid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[] cs1, <span class="type">char</span>[] cs2, <span class="type">char</span>[] cs3, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">boolean</span>[][] invalid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (invalid[i][j]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i + j == cs3.length) &#123;  <span class="comment">// end case: reach the end of s3</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((i &lt; cs1.length &amp;&amp; cs1[i] == cs3[i + j] &amp;&amp; dfs(cs1, cs2, cs3, i + <span class="number">1</span>, j, invalid))</span><br><span class="line">            || (j &lt; cs2.length &amp;&amp; cs2[j] == cs3[i + j] &amp;&amp; dfs(cs1, cs2, cs3, i, j + <span class="number">1</span>, invalid))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        invalid[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BFS</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1 == <span class="literal">null</span> || s2 == <span class="literal">null</span> || s3 == <span class="literal">null</span> || s1.length() + s2.length() != s3.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] cs1 = s1.toCharArray(), cs2 = s2.toCharArray(), cs3 = s3.toCharArray();</span><br><span class="line">        <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span> [cs1.length + <span class="number">1</span>][cs2.length + <span class="number">1</span>];</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span>[] curr = q.poll();</span><br><span class="line">            <span class="keyword">if</span> (visited[curr[<span class="number">0</span>]][curr[<span class="number">1</span>]]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curr[<span class="number">0</span>] + curr[<span class="number">1</span>] == cs3.length) &#123;  <span class="comment">// reaches the end of s3</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curr[<span class="number">0</span>] &lt; cs1.length &amp;&amp; cs1[curr[<span class="number">0</span>]] == cs3[curr[<span class="number">0</span>] + curr[<span class="number">1</span>]]) &#123;</span><br><span class="line">                q.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;curr[<span class="number">0</span>] + <span class="number">1</span>, curr[<span class="number">1</span>]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curr[<span class="number">1</span>] &lt; cs2.length &amp;&amp; cs2[curr[<span class="number">1</span>]] == cs3[curr[<span class="number">0</span>] + curr[<span class="number">1</span>]]) &#123;</span><br><span class="line">                q.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;curr[<span class="number">0</span>], curr[<span class="number">1</span>] + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            visited[curr[<span class="number">0</span>]][curr[<span class="number">1</span>]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="98-validate-binary-search-tree"><a href="#98-validate-binary-search-tree" class="headerlink" title="98. validate-binary-search-tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/validate-binary-search-tree/#/description">98. validate-binary-search-tree</a></h4><ul>
<li>给一个二叉树的根节点，判断这棵树是不是合法的二分查找树。</li>
<li>ME：写了半天，各种边缘条件判断。先左子树再右子树，同时为了保持左子树所有节点都小、右子树所有节点都大，还需要维护min、max，而为了防止出现Integer的MIN&#x2F;MAX_VALUE，我还引入了boolean来标记min和max是否经过修改。</li>
<li>TA：<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/7179/my-simple-java-solution-in-3-lines">这个</a>的思路和你一样，也是需要维护min和max，但它的trick是使用了Long的MIN&#x2F;MAX_VALUE，这样就省去了boolean，不过并不是一个好方法。<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/46016/learn-one-iterative-inorder-traversal-apply-it-to-multiple-tree-questions-java-solution">这个</a>提示你，合法的BST的中序遍历应当是从小到大不含重复元素的序列，因此可以用中序遍历的方法，把每个节点依次入栈，在弹出时用一个prev指向它（对应于中序遍历的靠前的节点），方便之后弹出的元素与他比较，当前必须完美大于prev才是合法的。<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/4659/c-in-order-traversal-and-please-do-not-rely-on-buggy-int_max-int_min-solutions-any-more">这个</a>递归的方法思路是一样的，但不需要Stack，而是用递归搞prev和node两个节点，也是必须prev完美小于当前node。注意在递归入口，prev是不会变的，当开始遍历当前节点的右子树时才会更新到该节点。</li>
<li>WA several times…because coming from next one. quite similar actually.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">TreeNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;   <span class="comment">// warning</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> dfs(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(TreeNode curr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (curr == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!dfs(curr.left)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span> &amp;&amp; prev.val &gt;= curr.val) &#123; <span class="comment">// prev should be smaller than curr normally</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = curr;</span><br><span class="line">        <span class="keyword">return</span> dfs(curr.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="99-recover-binary-search-tree"><a href="#99-recover-binary-search-tree" class="headerlink" title="99. recover-binary-search-tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/recover-binary-search-tree/#/description">99. recover-binary-search-tree</a></h4><ul>
<li>给一个二分查找树的根节点，其中有两个节点调换了顺序，要求恢复成合法的二分查找树。</li>
<li>ME：有点投机取巧的方法，先DFS中序遍历把所有节点存入一个ArrayList，然后Collections.sort排个序，再DFS一次把值全部重新赋一遍。在绝望的时候随便试了一发，都做好TLE的准备了，竟然AC了。不过follow up说，空间O(n)的很容易想到，但如果是O(1)空间要怎么做？</li>
<li>TA：你这么做并不能令人信服。主要的问题是如何找到这两个放错了位置的点呢？<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/3988/no-fancy-algorithm-just-simple-and-powerful-in-order-traversal/">这个</a>告诉你，其实就是把在中序遍历的时候，找逆序对，若是直接相连的两个节点反了，则只有一对逆序对，若不直接相连，则是两对逆序对，把前者的靠前者与后者的靠后者交换即可。使用到了三指针，prev指针实际上是初始化成了一个虚拟的最左子节点，初始值为Integer.MIN_VALUE。至于O(1)，当然就是之前听说过的Morris Traversal。</li>
<li>Prev, first, second. reverse pair.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;    </span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">first</span> <span class="operator">=</span> <span class="literal">null</span>, second = <span class="literal">null</span>;   <span class="comment">// for getting the reverse pair</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.MIN_VALUE);    <span class="comment">// prevent unwanted setting of first</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// inorder</span></span><br><span class="line">        dfs(root.left);</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="literal">null</span> &amp;&amp; prev.val &gt;= root.val) &#123;<span class="comment">// prev is less than curr node normally</span></span><br><span class="line">            first = prev;                           <span class="comment">// if not, prev is the one that misplaced</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (first != <span class="literal">null</span> &amp;&amp; prev.val &gt;= root.val) &#123;<span class="comment">// put curr node as swap target</span></span><br><span class="line">            second = root;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = root;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recoverTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">if</span> (first != <span class="literal">null</span> &amp;&amp; second != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> first.val;</span><br><span class="line">            first.val = second.val;</span><br><span class="line">            second.val = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="100-same-tree"><a href="#100-same-tree" class="headerlink" title="100. same-tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/same-tree/#/description">100. same-tree</a></h4><ul>
<li>OK.给两个二叉树的根节点，判断这两个树是否完全相同。</li>
<li>ME：递归搞定。先判断节点是否为Null，然后判断当前节点的值是否相等，再依次深入左子树、右子树递归判断。但发现我的写法比较慢。。。</li>
<li>TA：你的慢是因为太多if-else嵌套，看<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/4737/five-line-java-solution-with-recursion">这个</a>，思路是一样的，但是省去了很多条件分叉。这又是优化的一个点了。</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
              <a href="/tags/algorithm/" rel="tag"># algorithm</a>
              <a href="/tags/interview/" rel="tag"># interview</a>
              <a href="/tags/leetcode/" rel="tag"># leetcode</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2017/04/14/java_basic/" rel="prev" title="Note for Java">
                  <i class="fa fa-angle-left"></i> Note for Java
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2017/05/14/java_leetcode2/" rel="next" title="Note for LeetCode in Java (101~200)">
                  Note for LeetCode in Java (101~200) <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2016 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="futbol-o"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Bob</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"bobbyliujb","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js" defer></script>

</body>
</html>
