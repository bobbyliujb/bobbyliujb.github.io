<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="java,algorithm,interview,leetcode," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="刷题。祝我好运。">
<meta name="keywords" content="java,algorithm,interview,leetcode">
<meta property="og:type" content="article">
<meta property="og:title" content="Note for LeetCode in Java (401~800)">
<meta property="og:url" content="https://bobbyliujb.github.io/2018/01/05/java_leetcode5/index.html">
<meta property="og:site_name" content="Bobby">
<meta property="og:description" content="刷题。祝我好运。">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2018-01-07T07:54:16.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Note for LeetCode in Java (401~800)">
<meta name="twitter:description" content="刷题。祝我好运。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"hide","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://bobbyliujb.github.io/2018/01/05/java_leetcode5/"/>





  <title>Note for LeetCode in Java (401~800) | Bobby</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Bobby</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://bobbyliujb.github.io/2018/01/05/java_leetcode5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BobbyLiujb">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://ww4.sinaimg.cn/large/9b3a5c2fgw1faysh4xl7ij20bh0bhmy5.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bobby">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Note for LeetCode in Java (401~800)</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-05T16:49:39-08:00">
                2018-01-05
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2018-01-06T23:54:16-08:00">
                2018-01-06
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/" itemprop="url" rel="index">
                    <span itemprop="name">Tech</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/01/05/java_leetcode5/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/01/05/java_leetcode5/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/01/05/java_leetcode5/" class="leancloud_visitors" data-flag-title="Note for LeetCode in Java (401~800)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>刷题。祝我好运。<br><a id="more"></a></p>
<h4 id="686-repeated-string-match"><a href="#686-repeated-string-match" class="headerlink" title="686. repeated-string-match"></a><a href="https://leetcode.com/problems/repeated-string-match/description/" target="_blank" rel="external">686. repeated-string-match</a></h4><ul>
<li>给两个字符串A和B，求A需要重复几次才能让B成为它的substring.</li>
<li>狗家实习的OA，自己想的方法。先看看起始字符都出现在哪些索引，统统入queue；然后先拼一波使得A的长度不小于B；然后从queue中取起始索引，比较看B是否包含其中；如果queue还没用完则还需要拼多一次。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">repeatedStringMatch</span><span class="params">(String A, String B)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (A == <span class="keyword">null</span> || B == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        String AOld = A;</div><div class="line">        Queue&lt;Integer&gt; startIndexQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="keyword">char</span>[] AChar = A.toCharArray(), BChar = B.toCharArray();</div><div class="line">        <span class="keyword">char</span> startChar = BChar[<span class="number">0</span>];</div><div class="line">        <span class="comment">// O(N) get start position</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; AChar.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (AChar[i] == startChar) &#123;</div><div class="line">                startIndexQueue.add(i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> repeatCount = <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (!startIndexQueue.isEmpty() &amp;&amp; A.length() - startIndexQueue.peek() &lt; BChar.length) &#123;</div><div class="line">            A += AOld;     <span class="comment">// append if not long enough            </span></div><div class="line">            repeatCount++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (!startIndexQueue.isEmpty() &amp;&amp; startIndexQueue.peek() + BChar.length &lt;= A.length()) &#123;</div><div class="line">            <span class="keyword">int</span> startIndex = startIndexQueue.poll();</div><div class="line">            <span class="keyword">if</span> (B.equals(A.substring(startIndex, startIndex + BChar.length))) &#123;</div><div class="line">                <span class="keyword">return</span> repeatCount;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// if there is still startIndex in queue, need to repeat and check more</span></div><div class="line">        <span class="keyword">if</span> (!startIndexQueue.isEmpty()) &#123;</div><div class="line">            A += AOld;</div><div class="line">            repeatCount++;</div><div class="line">            <span class="keyword">while</span> (!startIndexQueue.isEmpty()) &#123;</div><div class="line">                <span class="keyword">if</span> (B.equals(A.substring(startIndexQueue.peek(), startIndexQueue.peek() + BChar.length))) &#123;</div><div class="line">                    <span class="keyword">return</span> repeatCount;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    startIndexQueue.poll();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="687-longest-univalue-path"><a href="#687-longest-univalue-path" class="headerlink" title="687. longest-univalue-path"></a><a href="https://leetcode.com/problems/longest-univalue-path/description/" target="_blank" rel="external">687. longest-univalue-path</a></h4><ul>
<li>给一个二叉树，求其中最长的连续边数使得经过的节点值都一样。不一定是完全笔直的路径。</li>
<li>对于左子树和右子树递归调用求最长路径（不取当前节点的情况），然后根据当前节点的值进行DFS（也就是取当前节点的情况）。最后取最大。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestUnivaluePath</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> child = Math.max(longestUnivaluePath(root.left), longestUnivaluePath(root.right));</div><div class="line">        <span class="keyword">return</span> Math.max(child, dfs(root.left, root.val) + dfs(root.right, root.val));</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode node, <span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span> || node.val != val) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(dfs(node.left, val), dfs(node.right, val)); <span class="comment">// two nodes forms one edge</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="689-maximum-sum-of-3-non-overlapping-subarrays"><a href="#689-maximum-sum-of-3-non-overlapping-subarrays" class="headerlink" title="689. maximum-sum-of-3-non-overlapping-subarrays"></a><a href="https://leetcode.com/problems/maximum-sum-of-3-non-overlapping-subarrays/description/" target="_blank" rel="external">689. maximum-sum-of-3-non-overlapping-subarrays</a></h4><ul>
<li>给一个正整数数组，找出三个互不重叠的、size为k的子数组，使得总和最大。返回的形式是每个subarray的起始索引。例如<code>[1,2,1,2,6,7,5,1], k=2</code>则返回<code>[0, 3, 5]</code>。</li>
<li>有唯一解吗？（可能有多个，只需返回最先出现索引）k本身会不会很大？（不会，不大于len/3）</li>
<li>首先是如何快速求某个区间内的和？如果数值都不大的话，可以通过累加把sum都给缓存下来，用的时候直接减一下就行了。然后是如何求subarray的结果？可以用二位dp数组，行表示划分成row个subarray，列表示从0到col处为止能得到的最大的总sum。此外还需要一个二维index数组记录第row个subarray对应的起始位置。从第一个subarray开始循环，固定求size为k的subarray使之和最大，其实就是贪心的思想，只要过程中求的每个subarray的和都最大那么最终的总和就是最大的。在循环过程中就可以不断求总和，为了防止重叠求和时必须求往前k个元素为end的dp结果。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSumOfThreeSubarrays(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</div><div class="line">        <span class="comment">// 动态规划</span></div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 缓存到i为止到所有项之和</span></div><div class="line">        <span class="keyword">int</span>[] sumArray = <span class="keyword">new</span> <span class="keyword">int</span> [nums.length];</div><div class="line">        sumArray[<span class="number">0</span>] = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</div><div class="line">            sumArray[i] = sumArray[i - <span class="number">1</span>] + nums[i];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// dp[i][j]表示求i个non-overlap sum的时候从0~j能得到的最大总sum</span></div><div class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">4</span>][nums.length];</div><div class="line">        <span class="comment">// index[i][j]表示求第i个non-overlap sum的时候的starting index</span></div><div class="line">        <span class="keyword">int</span>[][] index = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">4</span>][nums.length];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;   <span class="comment">// 从求第1个最大的k-size subarray开始直到第3个</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = k - <span class="number">1</span>; j &lt; nums.length; j++) &#123;</div><div class="line">                <span class="keyword">int</span> tempMax = j == k - <span class="number">1</span>? sumArray[j] :   <span class="comment">// 快速求区间内的和</span></div><div class="line">                    sumArray[j] - sumArray[j - k] + dp[i - <span class="number">1</span>][j - k];   <span class="comment">// 加上上一行前一个block为止的最大和</span></div><div class="line">                <span class="keyword">if</span> (j &gt; k - <span class="number">1</span>) &#123;        <span class="comment">// 先直接沿用同一行的前面的结果</span></div><div class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>];</div><div class="line">                    index[i][j] = index[i][j - <span class="number">1</span>];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; tempMax &gt; dp[i][j - <span class="number">1</span>]) &#123;  <span class="comment">// 若发现有更大的就更新当前最大和到dp</span></div><div class="line">                    dp[i][j] = tempMax;</div><div class="line">                    index[i][j] = j - k + <span class="number">1</span>;    <span class="comment">// 同时更新最大和出现的下标</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">3</span>];        </div><div class="line">        ans[<span class="number">2</span>] = index[<span class="number">3</span>][nums.length - <span class="number">1</span>];     <span class="comment">// 最后一行的最后一位就是第三个block的index</span></div><div class="line">        ans[<span class="number">1</span>] = index[<span class="number">2</span>][ans[<span class="number">2</span>] - <span class="number">1</span>];          <span class="comment">// 倒数第二行的index[3]之前的存的就是第二行的</span></div><div class="line">        ans[<span class="number">0</span>] = index[<span class="number">1</span>][ans[<span class="number">1</span>] - <span class="number">1</span>];          </div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="719-find-k-th-smallest-pair-distance"><a href="#719-find-k-th-smallest-pair-distance" class="headerlink" title="719. find-k-th-smallest-pair-distance"></a><a href="https://leetcode.com/problems/find-k-th-smallest-pair-distance/description/" target="_blank" rel="external">719. find-k-th-smallest-pair-distance</a></h4><ul>
<li>给一个int数组，求每两个数之差中第k小的值。例如<code>[1,3,8,4,5,45]</code>，当k = 1，返回1，当k = 3，返回2.</li>
<li>先对所有元素从小到大排序，那么间距最小值为0、最大值为最右减最左。用二分查找的思想，假设mid为第k小的值，然后O(N^2)遍历求有多少对儿数之差小于mid；若对儿数小于k，说明猜的值太小了排太前了；大于k则说明猜太大了。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">smallestDistancePair</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        Arrays.sort(nums);</div><div class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums[nums.length - <span class="number">1</span>] - nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</div><div class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;   <span class="comment">// 猜一个距离</span></div><div class="line">            <span class="keyword">int</span> count = <span class="number">0</span>, left = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> right = <span class="number">1</span>; right &lt; nums.length; right++) &#123;</div><div class="line">                <span class="keyword">while</span> (nums[right] - nums[left] &gt; mid) &#123;</div><div class="line">                    left++;</div><div class="line">                &#125;</div><div class="line">                count += right - left;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (count &lt; k) &#123;        <span class="comment">// 说明猜的不够大</span></div><div class="line">                lo = mid + <span class="number">1</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                hi = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> lo;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="726-number-of-atoms"><a href="#726-number-of-atoms" class="headerlink" title="726. number-of-atoms"></a><a href="https://leetcode.com/problems/number-of-atoms/description/" target="_blank" rel="external">726. number-of-atoms</a></h4><ul>
<li>给一个字符串表示化学物质，统计其中的元素及出现次数，按字典序输出。例如<code>H2(O(Mn)2)3</code>输出<code>H2Mn6O3</code>.</li>
<li>只有1个元素是输出1还是不输出？（不输出数字，只输出元素）</li>
<li>由于含有括号，联想运算符算式就知道要用Stack进行吞吐来处理括号嵌套的情况。如果是字母，就一直找到小写的为止作为元素名字，之后跟着的数字就是count，存入map。若出现左括号，则当前的这个map（保存了括号之前的元素及count）直接入栈，然后用新的map继续统计，一旦遇到右括号，说明当前部分结束(注意需要检查右括号之后还有没有数字)，则与栈顶弹出的map合并一下就好了。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">countOfAtoms</span><span class="params">(String formula)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (formula == <span class="keyword">null</span> || formula.length() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">        &#125;</div><div class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        Stack&lt;Map&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        <span class="keyword">char</span>[] fChar = formula.toCharArray();</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, fLen = fChar.length;</div><div class="line">        <span class="keyword">while</span> (i &lt; fLen) &#123;</div><div class="line">            <span class="keyword">if</span> (fChar[i] == <span class="string">'('</span>) &#123;  <span class="comment">// 将之前的map压栈</span></div><div class="line">                stack.push(map);    </div><div class="line">                map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">                i++;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fChar[i] == <span class="string">')'</span>) &#123;   <span class="comment">// 将当前的合并入之前的map</span></div><div class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">                i++;</div><div class="line">                <span class="comment">// 取括号后的数值</span></div><div class="line">                <span class="keyword">while</span> (i &lt; fLen &amp;&amp; Character.isDigit(fChar[i])) &#123;</div><div class="line">                    count = (<span class="number">10</span> * count) + fChar[i++] - <span class="string">'0'</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</div><div class="line">                    count = <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (!stack.isEmpty()) &#123;</div><div class="line">                    Map&lt;String, Integer&gt; prevMap = stack.pop();</div><div class="line">                    <span class="keyword">for</span> (String atom: map.keySet()) &#123;   <span class="comment">// 取当前map中的atom放入之前的</span></div><div class="line">                        prevMap.put(atom, prevMap.getOrDefault(atom, <span class="number">0</span>) + map.get(atom) * count);</div><div class="line">                    &#125;</div><div class="line">                    map = prevMap;  <span class="comment">// 用回原来的map</span></div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 以字母开头，直到非小写字母为一个原子</span></div><div class="line">                <span class="keyword">int</span> end = i + <span class="number">1</span>;</div><div class="line">                <span class="keyword">while</span> (end &lt; fLen &amp;&amp; Character.isLowerCase(fChar[end])) &#123;</div><div class="line">                    end++;</div><div class="line">                &#125;</div><div class="line">                String atom = formula.substring(i, end);</div><div class="line">                </div><div class="line">                <span class="comment">// 看看字母之后是否跟着数字</span></div><div class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">                <span class="keyword">while</span> (end &lt; fLen &amp;&amp; Character.isDigit(fChar[end])) &#123;</div><div class="line">                    count = <span class="number">10</span> * count + fChar[end++] - <span class="string">'0'</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</div><div class="line">                    count = <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                <span class="comment">// 更新原子数值 </span></div><div class="line">                map.put(atom, map.getOrDefault(atom, <span class="number">0</span>) + count);</div><div class="line">                i = end;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">        List&lt;String&gt; atoms = <span class="keyword">new</span> ArrayList&lt;&gt;(map.keySet());</div><div class="line">        Collections.sort(atoms);    <span class="comment">// 字母顺序</span></div><div class="line">        <span class="keyword">for</span> (String atom: atoms) &#123;</div><div class="line">            sb.append(atom);</div><div class="line">            <span class="keyword">if</span> (map.get(atom) &gt; <span class="number">1</span>) &#123;</div><div class="line">                sb.append(map.get(atom));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sb.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="727-minimum-window-subsequence"><a href="#727-minimum-window-subsequence" class="headerlink" title="727. minimum-window-subsequence"></a><a href="https://leetcode.com/problems/minimum-window-subsequence/description/" target="_blank" rel="external">727. minimum-window-subsequence</a></h4><ul>
<li>给一个source字符串和一个target字符串，求在source的最短子串使得包含target的所有字符（个数和出现顺序都必须一致）。</li>
<li>DP（感觉是野路子，不太好想）。。。纵向行为target，横向列为source，第一行全部初始化为<code>0,1,2....sLen</code>表示从第几位开始取，之后所有值初始化为-1表示无解。然后O(M*N)逐个字符遍历两个字符串，若匹配上了则从左上方取起始位置（看前一个字符的情况），若匹配不上则默认继续取source（直接取左侧的值）。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String S, String T)</span> </span>&#123;</div><div class="line">        <span class="comment">// 动态规划, 行为tLen + 1, 列为sLen + 1, dp[][]表示从dp[i][j]到j到这部分字符串是所求，</span></div><div class="line">        <span class="comment">// 即T[0, j)是S[0, i)的subsequence with substring S[dp[i][j], j).</span></div><div class="line">        <span class="comment">// 初始状态为</span></div><div class="line">        <span class="comment">// 状态转换为，若当前字符不匹配，则根据左侧（即S前一个字符）情况决定起始位置（保证最短）</span></div><div class="line">        <span class="comment">// 若匹配，则依赖于左上方的结果，即T前一个字符的起始位置。</span></div><div class="line">        <span class="keyword">if</span> (S == <span class="keyword">null</span> || T == <span class="keyword">null</span> || S.length() == <span class="number">0</span> || T.length() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">char</span>[] sChar = S.toCharArray();</div><div class="line">        <span class="keyword">char</span>[] tChar = T.toCharArray();</div><div class="line">        <span class="keyword">int</span> sLen = sChar.length, tLen = tChar.length;</div><div class="line">        <span class="keyword">int</span>[][] startFrom = <span class="keyword">new</span> <span class="keyword">int</span> [tLen + <span class="number">1</span>][sLen + <span class="number">1</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= tLen; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= sLen; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</div><div class="line">                    startFrom[i][j] = j;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    startFrom[i][j] = -<span class="number">1</span>;   <span class="comment">// -1表示无解</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tLen; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sLen; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (sChar[j - <span class="number">1</span>] == tChar[i - <span class="number">1</span>]) &#123;</div><div class="line">                    startFrom[i][j] = startFrom[i - <span class="number">1</span>][j - <span class="number">1</span>];</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    startFrom[i][j] = startFrom[i][j - <span class="number">1</span>];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = sLen, minLen = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sLen; j++) &#123;</div><div class="line">            System.out.print(startFrom[tLen][j] + <span class="string">" "</span>);</div><div class="line">            <span class="keyword">if</span> (startFrom[tLen][j] != -<span class="number">1</span>) &#123;</div><div class="line">                <span class="keyword">int</span> currLen = j - startFrom[tLen][j];</div><div class="line">                <span class="keyword">if</span> (currLen &lt; minLen) &#123;</div><div class="line">                    start = startFrom[tLen][j];</div><div class="line">                    end = j;</div><div class="line">                    minLen = currLen;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> minLen == Integer.MAX_VALUE? <span class="string">""</span> : S.substring(start, end);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="729-my-calendar-i"><a href="#729-my-calendar-i" class="headerlink" title="729. my-calendar-i"></a><a href="https://leetcode.com/problems/my-calendar-i/description/" target="_blank" rel="external">729. my-calendar-i</a></h4><ul>
<li>给若干开始时间+结束时间pair，实现book函数判断能否成功添加事件，不能有时间重叠。</li>
<li><p>方法一：暴力法，从头到尾遍历链表，无冲突就插入。效率O(N)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCalendar</span> </span>&#123;</div><div class="line">    <span class="comment">// 定义一个链表，每次遍历所有节点判断有没有重合，没有就插入到末尾</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> start;</div><div class="line">        <span class="keyword">int</span> end;</div><div class="line">        Node next;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.start = start;</div><div class="line">            <span class="keyword">this</span>.end = end;</div><div class="line">            next = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    Node head = <span class="keyword">null</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCalendar</span><span class="params">()</span> </span>&#123;</div><div class="line">        head = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">book</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</div><div class="line">            head = <span class="keyword">new</span> Node(start, end);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> checkAndAdd(<span class="keyword">new</span> Node(start, end));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// brute force: check with every existing intervals and insert at the end</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkAndAdd</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">        Node curr = head;</div><div class="line">        Node prev = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (node.end &gt; curr.start &amp;&amp; node.start &lt; curr.end) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                prev = curr;</div><div class="line">                curr = curr.next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        prev.next = node;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法二：利用TreeMap，对于每个[start, end]对，从TreeMap中找start的floor，取出它对应的end。一旦这个end大于start，就说明有重叠了。同理，也要从TreeMap中找start的ceiling，如果这个ceiling小于end，说明与后面有重叠。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCalendar</span> </span>&#123;</div><div class="line">    <span class="comment">// 维护start-end的TreeMap，每次尝试取输入的start的在TreeeMap中的下界和上界</span></div><div class="line">    <span class="comment">// 分别判断输入的start是否在最大的不大于start的floorStart对应的end之间，</span></div><div class="line">    <span class="comment">// 再判断最小的不小于start的ceilingStart会不会落在end之前</span></div><div class="line">    TreeMap&lt;Integer, Integer&gt; calendar;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCalendar</span><span class="params">()</span> </span>&#123;</div><div class="line">        calendar = <span class="keyword">new</span> TreeMap&lt;&gt;();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">book</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">        <span class="comment">// floorStart, start, floorStart'sEnd</span></div><div class="line">        Integer floorStart = calendar.floorKey(start);</div><div class="line">        <span class="keyword">if</span> (floorStart != <span class="keyword">null</span> &amp;&amp; calendar.get(floorStart) &gt; start) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// start, ceilingStart, end</span></div><div class="line">        Integer ceilingStart = calendar.ceilingKey(start);</div><div class="line">        <span class="keyword">if</span> (ceilingStart != <span class="keyword">null</span> &amp;&amp; ceilingStart &lt; end) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        calendar.put(start, end);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="731-my-calendar-ii"><a href="#731-my-calendar-ii" class="headerlink" title="731. my-calendar-ii"></a><a href="https://leetcode.com/problems/my-calendar-ii/description/" target="_blank" rel="external">731. my-calendar-ii</a></h4><ul>
<li>与729相比变成了不能出现triple的重叠就算是可以book。</li>
<li>注意不能简单地理解为一个interval同时与两个interval重叠，因为<code>[2,6]</code>和<code>[1,3]&amp;[5,7]</code>同时重叠，但没有形成triplet.</li>
<li>同样是维护TreeMap，对于每个新加入的interval，遍历已有的interval并把重叠的部分插入treemap。如果插入时发现有重叠，说明“重叠部分之间也有重叠”，这样就是triple了。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCalendarTwo</span> </span>&#123;</div><div class="line">    <span class="comment">// 原本一位和之前相比就只是多了一个map，这个存不了就尝试另一个map，都不行就说明triple了。</span></div><div class="line">    <span class="comment">// 但题目给的样例都不行，例如最后一个25~55，因为这个overlap分别和两个map里都interval重叠，但是没有形成triple；</span></div><div class="line">    <span class="comment">// 正解应该是用一个list维护所有的interval，然后用treemap只维护当前重叠的部分，如果后续又出现了和list里的重叠，</span></div><div class="line">    <span class="comment">// 就再去treemap中看看有没有第三次重叠。</span></div><div class="line">    <span class="comment">// 注意每次遍历都需要清空TreeMap，因为我在遍历List的时候只关心新加入的这个会不会和别的重叠。</span></div><div class="line">    List&lt;<span class="keyword">int</span>[]&gt; intervals;</div><div class="line">    TreeMap&lt;Integer, Integer&gt; overlap;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCalendarTwo</span><span class="params">()</span> </span>&#123;</div><div class="line">        intervals = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        overlap = <span class="keyword">new</span> TreeMap&lt;&gt;();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">book</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">        overlap.clear();</div><div class="line">        <span class="comment">// 遍历所有interval看看有没有重叠</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] interval: intervals) &#123;</div><div class="line">            <span class="keyword">if</span> (start &gt;= interval[<span class="number">0</span>] &amp;&amp; start &lt; interval[<span class="number">1</span>]) &#123;</div><div class="line">                <span class="comment">// interval:   ________</span></div><div class="line">                <span class="comment">// newInter:     _____...</span></div><div class="line">                <span class="keyword">if</span> (!addOverlap(start, Math.min(end, interval[<span class="number">1</span>]))) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end &gt; interval[<span class="number">0</span>] &amp;&amp; start &lt; interval[<span class="number">0</span>]) &#123;</div><div class="line">                <span class="comment">// interval:   ________</span></div><div class="line">                <span class="comment">// newInter:  ______...</span></div><div class="line">                <span class="keyword">if</span> (!addOverlap(interval[<span class="number">0</span>], Math.min(end, interval[<span class="number">1</span>]))) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        intervals.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;start, end&#125;);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addOverlap</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">        Integer floorStart = overlap.floorKey(start);</div><div class="line">        <span class="keyword">if</span> (floorStart != <span class="keyword">null</span> &amp;&amp; overlap.get(floorStart) &gt; start) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        Integer ceilingStart = overlap.ceilingKey(start);</div><div class="line">        <span class="keyword">if</span> (ceilingStart != <span class="keyword">null</span> &amp;&amp; ceilingStart &lt; end) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        overlap.put(start, end);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="734-sentence-similarity"><a href="#734-sentence-similarity" class="headerlink" title="734. sentence-similarity"></a><a href="https://leetcode.com/problems/sentence-similarity/" target="_blank" rel="external">734. sentence-similarity</a></h4><ul>
<li>给一堆同义词<code>[(&quot;restaurant&quot;, &quot;cafe&quot;), (&quot;ratings&quot;, &quot;reviews&quot;), ...]</code>，再给一些queries<code>[(&quot;restaurant ratings&quot;, &quot;cafe reviews&quot;), ...]</code>，要求返回每个query里的对应词是否都是synonym。同义词没有传递性。</li>
<li>直接把字符串作为key、对应的所有同义词的set作为value存入map，正反都放一次，比如<code>map.get(&quot;restaurant&quot;).add(&quot;cafe&quot;)), map.get(&quot;restaurant&quot;).add(&quot;cafe&quot;)</code>，这样在query的时候就可以直接调用了。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 维护一个总的map，每个单词作为key，对等的单词塞入它维护的Set中</span></div><div class="line"><span class="comment">// 有对称性所以需要正反都加</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">areSentencesSimilar</span><span class="params">(String[] words1, String[] words2, String[][] pairs)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (words1 == <span class="keyword">null</span> || words2 == <span class="keyword">null</span> || pairs == <span class="keyword">null</span></div><div class="line">        || words1.length != words2.length) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    Map&lt;String, Set&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pairs.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (!map.containsKey(pairs[i][<span class="number">0</span>])) &#123;</div><div class="line">            map.put(pairs[i][<span class="number">0</span>], <span class="keyword">new</span> HashSet&lt;&gt;());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!map.containsKey(pairs[i][<span class="number">1</span>])) &#123;</div><div class="line">            map.put(pairs[i][<span class="number">1</span>], <span class="keyword">new</span> HashSet&lt;&gt;());</div><div class="line">        &#125;</div><div class="line">        map.get(pairs[i][<span class="number">0</span>]).add(pairs[i][<span class="number">1</span>]);  <span class="comment">// 构建a-&gt;b</span></div><div class="line">        map.get(pairs[i][<span class="number">1</span>]).add(pairs[i][<span class="number">0</span>]);  <span class="comment">// 构建b-&gt;a</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words1.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (words1[i].equals(words2[i])) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (map.get(words1[i]) == <span class="keyword">null</span> || !map.get(words1[i]).contains(words2[i])) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="737-sentence-similarity-ii"><a href="#737-sentence-similarity-ii" class="headerlink" title="737. sentence-similarity-ii"></a><a href="https://leetcode.com/problems/sentence-similarity-ii/description/" target="_blank" rel="external">737. sentence-similarity-ii</a></h4><ul>
<li>给一堆同义词<code>[(&quot;restaurant&quot;, &quot;cafe&quot;), (&quot;ratings&quot;, &quot;reviews&quot;), ...]</code>，再给一些queries<code>[(&quot;restaurant ratings&quot;, &quot;cafe reviews&quot;), ...]</code>，要求返回每个query里的对应词是否都是synonym。注意这些同义词具有传递性，<code>a=b, b=c -&gt; a=c</code>。</li>
<li><p>方法一：图论题，每个词都是一个节点，对于每个节点维护一个Set，通过DFS遍历所有可达的节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 和前一个版本的区别是这个可以无限传递a=b=c=d...</span></div><div class="line"><span class="comment">// 还是map维护每个单词等价的单词，但匹配不上的话还得看它的set里所有单词对应的单词是否能匹配到</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">areSentencesSimilarTwo</span><span class="params">(String[] words1, String[] words2, String[][] pairs)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (words1 == <span class="keyword">null</span> || words2 == <span class="keyword">null</span> || pairs == <span class="keyword">null</span></div><div class="line">        || words1.length != words2.length) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 表示每个单词直接相连的同义词</span></div><div class="line">    Map&lt;String, Set&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pairs.length; i++) &#123;        <span class="comment">// O(N)</span></div><div class="line">        <span class="keyword">if</span> (!map.containsKey(pairs[i][<span class="number">0</span>])) &#123;</div><div class="line">            map.put(pairs[i][<span class="number">0</span>], <span class="keyword">new</span> HashSet&lt;&gt;());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!map.containsKey(pairs[i][<span class="number">1</span>])) &#123;</div><div class="line">            map.put(pairs[i][<span class="number">1</span>], <span class="keyword">new</span> HashSet&lt;&gt;());</div><div class="line">        &#125;</div><div class="line">        map.get(pairs[i][<span class="number">0</span>]).add(pairs[i][<span class="number">1</span>]);  <span class="comment">// 构建a-&gt;b</span></div><div class="line">        map.get(pairs[i][<span class="number">1</span>]).add(pairs[i][<span class="number">0</span>]);  <span class="comment">// 构建b-&gt;a</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words1.length; i++) &#123;       <span class="comment">// O(N*N)</span></div><div class="line">        <span class="keyword">if</span> (words1[i].equals(words2[i])) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!map.containsKey(words1[i])) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!dfs(words1[i], words2[i], map, <span class="keyword">new</span> HashSet&lt;String&gt;())) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(String start, String end, Map&lt;String, Set&lt;String&gt;&gt; map, Set&lt;String&gt; visited)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (map.get(start).contains(end)) &#123;     <span class="comment">// 终止条件：start连接着end</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    visited.add(start);</div><div class="line">    Set&lt;String&gt; neighbors = map.get(start);</div><div class="line">    <span class="keyword">if</span> (neighbors == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (String neighbor : neighbors) &#123;</div><div class="line">        <span class="keyword">if</span> (!visited.contains(neighbor) &amp;&amp; dfs(neighbor, end, map, visited)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法二：并查集，初始化时每个单词都是自己的root；然后根据同义词关系将前者的老大设为后者。判断句子是否同义时就找两个单词的老大是否相等即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 并查集。初始化时每个单词都是自己的root；然后根据同义词关系将前者的老大设为后者。</span></div><div class="line"><span class="comment">// 判断句子是否同义时就找两个单词的老大是否相等即可</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">areSentencesSimilarTwo</span><span class="params">(String[] words1, String[] words2, String[][] pairs)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (words1.length != words2.length) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="keyword">for</span> (String[] pair : pairs) &#123;     <span class="comment">// 开始时每个老大都是自己</span></div><div class="line">        map.put(pair[<span class="number">0</span>], pair[<span class="number">0</span>]);</div><div class="line">        map.put(pair[<span class="number">1</span>], pair[<span class="number">1</span>]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (String[] pair : pairs) &#123;</div><div class="line">        String par1 = findParent(pair[<span class="number">0</span>], map);</div><div class="line">        String par2 = findParent(pair[<span class="number">1</span>], map);</div><div class="line">        <span class="keyword">if</span> (!par1.equals(par2)) &#123;</div><div class="line">            map.put(par1, par2);    <span class="comment">// par1的老大设为par2</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words1.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (words1[i].equals(words2[i])) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!map.containsKey(words1[i]) || !map.containsKey(words2[i])) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        String par1 = findParent(words1[i], map);</div><div class="line">        String par2 = findParent(words2[i], map);</div><div class="line">        <span class="keyword">if</span> (!par1.equals(par2)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findParent</span><span class="params">(String str, Map&lt;String,String&gt; map)</span></span>&#123;</div><div class="line">        <span class="keyword">while</span> (!str.equals(map.get(str))) &#123; <span class="comment">// 追溯str的老大</span></div><div class="line">            str = map.get(str);              </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> str;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="739-daily-temperatures"><a href="#739-daily-temperatures" class="headerlink" title="739. daily-temperatures"></a><a href="https://leetcode.com/problems/daily-temperatures/description/" target="_blank" rel="external">739. daily-temperatures</a></h4><ul>
<li>给一个int数组表示气温，返回一个数组表示该日最短需要多少天才会有更温暖的日子。例如<code>[73, 74, 75, 71, 69, 72, 76, 73]</code>输出<code>[1, 1, 4, 2, 1, 1, 0, 0]</code>。</li>
<li>解法：维护一个Stack存放索引，每次读入新的温度时就和栈顶对应的温度比较，如果更高，就弹出并设置该索引处的天数。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] temperatures) &#123;</div><div class="line">        <span class="keyword">if</span> (temperatures == <span class="keyword">null</span> || temperatures.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] nextWarmer = <span class="keyword">new</span> <span class="keyword">int</span> [temperatures.length];</div><div class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temperatures.length; i++) &#123;</div><div class="line">            <span class="comment">// 比较当前温度和栈顶索引对应温度 </span></div><div class="line">            <span class="keyword">while</span> (!stack.isEmpty()</div><div class="line">                &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) &#123;</div><div class="line">                <span class="keyword">int</span> index = stack.pop();</div><div class="line">                nextWarmer[index] = i - index;</div><div class="line">            &#125;</div><div class="line">            stack.push(i);                  <span class="comment">// 栈剩下的都比当前大</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</div><div class="line">            nextWarmer[stack.pop()] = <span class="number">0</span>;    <span class="comment">// 其实Java数组原本就是0</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> nextWarmer;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="748-shortest-completing-word"><a href="#748-shortest-completing-word" class="headerlink" title="748. shortest-completing-word"></a><a href="https://leetcode.com/problems/shortest-completing-word/description/" target="_blank" rel="external">748. shortest-completing-word</a></h4><ul>
<li>给一个licensePlate，再给一个words数组，求其中最短的字符串使得licensePlate出现过的字母都有。例如<code>licensePlate = &quot;1s3 PSt&quot;中只用关注S P S T, words = [&quot;step&quot;, &quot;steps&quot;, &quot;stripe&quot;, &quot;stepple&quot;]</code>，输出<code>steps</code>。</li>
<li>licensePlate有哪些字符、确定只关注字母？（-是的）字母大小写？（-忽略大小写）</li>
<li>解法：先统计licensePlate中字母出现次数，然后<code>O(N)</code>遍历字符串数组，对于每一个单词判断是否包含licensePlate的所有字母（<code>O(26)</code>），再找最短的返回。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">int</span> LETTER_NUM = <span class="number">26</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">shortestCompletingWord</span><span class="params">(String licensePlate, String[] words)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (licensePlate == <span class="keyword">null</span> || words == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 统计licensePlate里字母的出现次数</span></div><div class="line">        <span class="keyword">char</span>[] letterCount = <span class="keyword">new</span> <span class="keyword">char</span> [LETTER_NUM];</div><div class="line">        <span class="keyword">char</span>[] lChar = licensePlate.toLowerCase().toCharArray();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lChar.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (Character.isLetter(lChar[i])) &#123;</div><div class="line">                letterCount[lChar[i] - <span class="string">'a'</span>]++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 对于每个单词判断是否complete，然后找最短的</span></div><div class="line">        String ans = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">int</span> minLen = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">for</span> (String word: words) &#123;</div><div class="line">            <span class="keyword">if</span> (checkComplete(word, letterCount)) &#123;</div><div class="line">                <span class="keyword">if</span> (word.length() &lt; minLen) &#123;</div><div class="line">                    minLen = word.length();</div><div class="line">                    ans = word;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 统计当前单词的字母出现次数，然后再一波O（26）和licensePlate的字母Count比较</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkComplete</span><span class="params">(String word, <span class="keyword">char</span>[] letterCount)</span> </span>&#123;</div><div class="line">        <span class="keyword">char</span>[] wChar = word.toCharArray();</div><div class="line">        <span class="keyword">char</span>[] thisCount = <span class="keyword">new</span> <span class="keyword">char</span> [LETTER_NUM];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wChar.length; i++) &#123;</div><div class="line">            thisCount[wChar[i] - <span class="string">'a'</span>]++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LETTER_NUM; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (letterCount[i] &gt; <span class="number">0</span> &amp;&amp; thisCount[i] &lt; letterCount[i]) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>└(^o^)┘</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatRewardImg.png" alt="BobbyLiujb WeChat Pay"/>
        <p>WeChat Pay</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipayRewardImg.png" alt="BobbyLiujb Alipay"/>
        <p>Alipay</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java/" rel="tag"># java</a>
          
            <a href="/tags/algorithm/" rel="tag"># algorithm</a>
          
            <a href="/tags/interview/" rel="tag"># interview</a>
          
            <a href="/tags/leetcode/" rel="tag"># leetcode</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/11/28/udacity/" rel="next" title="有代西滴">
                <i class="fa fa-chevron-left"></i> 有代西滴
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- Go to www.addthis.com/dashboard to customize your tools -->
<div class="addthis_inline_share_toolbox">
  <script type = "text/javascript" src = "//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-593135f4e114024c" async = "async" ></script>
</div>

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://ww4.sinaimg.cn/large/9b3a5c2fgw1faysh4xl7ij20bh0bhmy5.jpg"
               alt="BobbyLiujb" />
          <p class="site-author-name" itemprop="name">BobbyLiujb</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">29</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">categories</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">35</span>
                <span class="site-state-item-name">tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#686-repeated-string-match"><span class="nav-number">1.</span> <span class="nav-text">686. repeated-string-match</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#687-longest-univalue-path"><span class="nav-number">2.</span> <span class="nav-text">687. longest-univalue-path</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#689-maximum-sum-of-3-non-overlapping-subarrays"><span class="nav-number">3.</span> <span class="nav-text">689. maximum-sum-of-3-non-overlapping-subarrays</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#719-find-k-th-smallest-pair-distance"><span class="nav-number">4.</span> <span class="nav-text">719. find-k-th-smallest-pair-distance</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#726-number-of-atoms"><span class="nav-number">5.</span> <span class="nav-text">726. number-of-atoms</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#727-minimum-window-subsequence"><span class="nav-number">6.</span> <span class="nav-text">727. minimum-window-subsequence</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#729-my-calendar-i"><span class="nav-number">7.</span> <span class="nav-text">729. my-calendar-i</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#731-my-calendar-ii"><span class="nav-number">8.</span> <span class="nav-text">731. my-calendar-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#734-sentence-similarity"><span class="nav-number">9.</span> <span class="nav-text">734. sentence-similarity</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#737-sentence-similarity-ii"><span class="nav-number">10.</span> <span class="nav-text">737. sentence-similarity-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#739-daily-temperatures"><span class="nav-number">11.</span> <span class="nav-text">739. daily-temperatures</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#748-shortest-completing-word"><span class="nav-number">12.</span> <span class="nav-text">748. shortest-completing-word</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 &mdash; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">BobbyLiujb</span>

  
</div>


  <div class="powered-by">
    Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
  </div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">
    Theme &mdash;
    <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
      NexT.Mist
    </a>
  </div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  

  

    
      <script id="dsq-count-scr" src="https://bobbyliujb.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://bobbyliujb.github.io/2018/01/05/java_leetcode5/';
          this.page.identifier = '2018/01/05/java_leetcode5/';
          this.page.title = 'Note for LeetCode in Java (401~800)';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://bobbyliujb.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  



	





  










  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("jT7i5auNazMHRONSPUHmcoko-gzGzoHsz", "dEWwuVre5Svmwvjw2DmcIbLy");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  

</body>
</html>
