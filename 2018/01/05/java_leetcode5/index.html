<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222"/>


  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css"/>



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-flash.min.css?v=1.0.2"/>





  <meta http-equiv="Cache-Control" content="no-transform"/>
  <meta http-equiv="Cache-Control" content="no-siteapp"/>
















  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"/>
  






<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2"/>

<link rel="stylesheet" href="/css/main.css?v=6.7.0"/>


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico?v=6.7.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=6.7.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=6.7.0">


  <link rel="mask-icon" href="/images/favicon.ico?v=6.7.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.7.0',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":true,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="刷题。祝我好运。">
<meta name="keywords" content="algorithm,java,interview,leetcode">
<meta property="og:type" content="article">
<meta property="og:title" content="Note for LeetCode in Java (401~800)">
<meta property="og:url" content="https://bobbyliujb.github.io/2018/01/05/java_leetcode5/index.html">
<meta property="og:site_name" content="Bob_波波">
<meta property="og:description" content="刷题。祝我好运。">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-04-14T05:55:44.265Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Note for LeetCode in Java (401~800)">
<meta name="twitter:description" content="刷题。祝我好运。">






  <link rel="canonical" href="https://bobbyliujb.github.io/2018/01/05/java_leetcode5/"/>



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Note for LeetCode in Java (401~800) | Bob_波波</title>
  




  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-118868735-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-118868735-1');
  </script>









  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Bob_波波</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br/>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br/>Tags<span class="badge">39</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br/>Categories<span class="badge">3</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br/>Archives<span class="badge">40</span></a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />Search</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://bobbyliujb.github.io/2018/01/05/java_leetcode5/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bob_波波"/>
      <meta itemprop="description" content="I'm a Software Engineer!"/>
      <meta itemprop="image" content="/images/avatar.jpg"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bob_波波"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Note for LeetCode in Java (401~800)

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-01-05 16:49:39" itemprop="dateCreated datePublished" datetime="2018-01-05T16:49:39-08:00">2018-01-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-04-13 22:55:44" itemprop="dateModified" datetime="2019-04-13T22:55:44-07:00">2019-04-13</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Tech/" itemprop="url" rel="index"><span itemprop="name">Tech</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/01/05/java_leetcode5/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/01/05/java_leetcode5/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/01/05/java_leetcode5/" class="leancloud_visitors" data-flag-title="Note for LeetCode in Java (401~800)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Views: </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Symbols count in article: </span>
                
                <span title="Symbols count in article">228k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">3:58</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>刷题。祝我好运。<br><a id="more"></a></p>
<h4 id="402-remove-k-digits"><a href="#402-remove-k-digits" class="headerlink" title="402. remove-k-digits"></a><a href="https://leetcode.com/problems/remove-k-digits/" target="_blank" rel="external">402. remove-k-digits</a></h4><ul>
<li>给一个纯数字组成的字符串，给一个整数k，要求删除k个数字后得到的数尽可能地小。例如<code>112</code>删除2个后需要得到<code>1</code>。</li>
<li>找到规律，使用stack的思路+贪心法，每次将数字入栈，若当前数字比栈顶小，说明前面的数字应当删除，一直删除到栈顶数字不再比当前数字大，再入栈。最后保留下来的数字不一定删够了k个，需要twick索引只保留一部分栈里剩下的数字。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeKdigits</span><span class="params">(String num, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (num == <span class="keyword">null</span> || num.length() == <span class="number">0</span> || k &gt;= num.length()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">char</span>[] numChars = num.toCharArray();</div><div class="line">        <span class="keyword">char</span>[] newNumChars = <span class="keyword">new</span> <span class="keyword">char</span>[num.length()];</div><div class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numChars.length; i++) &#123;</div><div class="line">            <span class="keyword">while</span> (index &gt; <span class="number">0</span> &amp;&amp; newNumChars[index - <span class="number">1</span>] &gt; numChars[i] &amp;&amp; k &gt; <span class="number">0</span>) &#123;</div><div class="line">                index--;</div><div class="line">                k--;    <span class="comment">// 持续删除直到栈顶数字足够小</span></div><div class="line">            &#125;</div><div class="line">            newNumChars[index++] = numChars[i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (start &lt; index &amp;&amp; newNumChars[start] == <span class="string">'0'</span>) &#123;</div><div class="line">            start++;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 最后剩下index个数字，只保留[start, index - start - k]的部分</span></div><div class="line">        <span class="keyword">return</span> start == index ? <span class="string">"0"</span> : <span class="keyword">new</span> String(newNumChars, start, index - start - k);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="403-frog-jump"><a href="#403-frog-jump" class="headerlink" title="403. frog-jump"></a><a href="https://leetcode.com/problems/frog-jump/description/" target="_blank" rel="external">403. frog-jump</a></h4><ul>
<li>给一个数组表示石头所处的x坐标，青蛙每次只能跳上一次跳跃长度的-1,0,1三种可能，判断能否跳到最后一个石头。例如<code>[0,1,3,5,6,8,12,17]</code>是可以的，而<code>[0,1,2,3,4,8,9,11]</code>就不行。</li>
<li>相当于BFS，每个石头处维护一个set存放他可以跳的长度，然后每次都往后跳看看能否有新的石头，有就更新那个石头的可跳长度。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// BFS，从开头出发，不断更新后续可达石头的新步数，若中途更新到了最后一个石头，就可达</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canCross</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (stones == <span class="keyword">null</span> || stones.length == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (stones[<span class="number">0</span>] != <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 记录每个坐标的石头所能跳的长度</span></div><div class="line">    Map&lt;Integer, Set&lt;Integer&gt;&gt; stone2step = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stones.length; i++) &#123;</div><div class="line">        stone2step.put(stones[i], <span class="keyword">new</span> HashSet&lt;&gt;());</div><div class="line">    &#125;</div><div class="line">    stone2step.get(<span class="number">0</span>).add(<span class="number">1</span>);   <span class="comment">// 第一步起码要能往后挪一步</span></div><div class="line">    </div><div class="line">    <span class="comment">// 从第一个石头开始，往后更新每个石头的能跳步数</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stones.length; i++) &#123;</div><div class="line">        <span class="keyword">int</span> currStone = stones[i];</div><div class="line">        Set&lt;Integer&gt; steps = stone2step.get(currStone);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> step: steps) &#123;</div><div class="line">            <span class="keyword">int</span> newStone = currStone + step;</div><div class="line">            <span class="keyword">if</span> (newStone == stones[stones.length - <span class="number">1</span>]) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            Set&lt;Integer&gt; newStep = stone2step.get(newStone);</div><div class="line">            <span class="keyword">if</span> (newStep != <span class="keyword">null</span>) &#123;   <span class="comment">// 表示有这个新石头的坐标</span></div><div class="line">                newStep.add(step + <span class="number">1</span>);</div><div class="line">                newStep.add(step);</div><div class="line">                <span class="keyword">if</span> (step - <span class="number">1</span> &gt; <span class="number">0</span>) &#123;</div><div class="line">                    newStep.add(step - <span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="404-sum-of-left-leaves"><a href="#404-sum-of-left-leaves" class="headerlink" title="404. sum-of-left-leaves"></a><a href="https://leetcode.com/problems/sum-of-left-leaves/description/" target="_blank" rel="external">404. sum-of-left-leaves</a></h4><ul>
<li>给一个数，求所有左叶子的和。</li>
<li>递归求，只有是左孩子且是叶子才返回node.val。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sumOfLeftLeaves(root, <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode node, <span class="keyword">boolean</span> isLeft)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> isLeft ? node.val : <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sumOfLeftLeaves(node.left, <span class="keyword">true</span>) + sumOfLeftLeaves(node.right, <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="405-convert-a-number-to-hexadecimal"><a href="#405-convert-a-number-to-hexadecimal" class="headerlink" title="405. convert-a-number-to-hexadecimal"></a><a href="https://leetcode.com/problems/convert-a-number-to-hexadecimal/description/" target="_blank" rel="external">405. convert-a-number-to-hexadecimal</a></h4><ul>
<li>将数字转换为十六进制字符串。</li>
<li><p>方法一：利用mask每次只取最后四个bit，然后直接map到字符拼接到hexStr的最前面，然后unsigned shift四位。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">char</span>[] map = &#123;<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>,<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>&#125;;</div><div class="line"><span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">int</span> mask = <span class="number">15</span>;</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toHex</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"0"</span>;</div><div class="line">    &#125;</div><div class="line">    String hexStr = <span class="string">""</span>;</div><div class="line">    <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</div><div class="line">        hexStr = map[(num &amp; mask)] + hexStr;</div><div class="line">        num = (num &gt;&gt;&gt; <span class="number">4</span>);  <span class="comment">// 不保留最高位</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> hexStr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法二：更general的做法，可以推广到十进制转任意进制字符串。不过首先需要转成long并且过滤掉long前面填充的一堆符号位，然后取模得到的就是当前位的数值，直接map到字符；然后继续除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">char</span>[] map = &#123;<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>,<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>&#125;;</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toHex</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"0"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">long</span> longNum = num &amp; <span class="number">0x00000000ffffffffL</span>;   <span class="comment">// 不能直接强制转换，不然会保留符号</span></div><div class="line">    String hexStr = <span class="string">""</span>;</div><div class="line">    <span class="keyword">while</span> (longNum != <span class="number">0</span>) &#123;</div><div class="line">        hexStr = map[(<span class="keyword">int</span>)(longNum % <span class="number">16</span>)] + hexStr;</div><div class="line">        longNum /= <span class="number">16</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> hexStr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="409-valid-word-abbreviation"><a href="#409-valid-word-abbreviation" class="headerlink" title="409. valid-word-abbreviation"></a><a href="https://leetcode.com/problems/valid-word-abbreviation/" target="_blank" rel="external">409. valid-word-abbreviation</a></h4><ul>
<li>给两个字符串word和abbr，word只含有小写字母，abbr除小写字母外含有数字表示可以替换成多少个字母，判断abbr是否是word的简写。例如<code>word</code>可以简写成<code>w2d</code>。</li>
<li>注意corner case，例如<code>w4</code>就不是<code>word</code>的简写了，<code>01</code>也不是<code>a</code>的简写。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validWordAbbreviation</span><span class="params">(String word, String abbr)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (word == <span class="keyword">null</span> || word.length() == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> word == abbr || (word != <span class="keyword">null</span> &amp;&amp; word.equals(abbr));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> indexWord = <span class="number">0</span>, indexAbbr = <span class="number">0</span>, lenAbbr = abbr.length(), lenWord = word.length();</div><div class="line">    <span class="keyword">while</span> (indexAbbr &lt; lenAbbr &amp;&amp; indexWord &lt; lenWord) &#123;</div><div class="line">        <span class="keyword">char</span> c = abbr.charAt(indexAbbr);</div><div class="line">        <span class="keyword">if</span> (Character.isLowerCase(c)) &#123;</div><div class="line">            <span class="keyword">if</span> (word.charAt(indexWord) != c) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            indexWord++;</div><div class="line">            indexAbbr++;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">int</span> num = (<span class="keyword">int</span>)(abbr.charAt(indexAbbr++) - <span class="string">'0'</span>);</div><div class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">while</span> (indexAbbr &lt; lenAbbr &amp;&amp; Character.isDigit(abbr.charAt(indexAbbr))) &#123;</div><div class="line">                num = <span class="number">10</span> * num + (abbr.charAt(indexAbbr++) - <span class="string">'0'</span>);</div><div class="line">            &#125;</div><div class="line">            indexWord += num;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> indexAbbr == lenAbbr &amp;&amp; indexWord == lenWord;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="410-split-array-largest-sum"><a href="#410-split-array-largest-sum" class="headerlink" title="410. split-array-largest-sum"></a><a href="https://leetcode.com/problems/split-array-largest-sum/description/" target="_blank" rel="external">410. split-array-largest-sum</a></h4><ul>
<li>给一个只含有非负整数的int数组和一个subArray数目m，将这个数组分成m个连续subarray，求他们的最大值最小是多少。</li>
<li><p>方法一：在学c++时老师讲过，最大值最小化，经典二分查找问题。一波流求最大值和sum分别作为下界和上界，然后进行二分查找，mid作为targetSum，即如果每个subarray都不超过这个targetSum需要划分成多少个子数组，如果多了说明targetSum太小，需要往前收缩；注意需要尽量biase到尽可能小的targetSum，联想到求first occurance的二分查找。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> m)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 最大值为下界、和为上界进行二分查找</span></div><div class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</div><div class="line">            sum += num;</div><div class="line">            max = Math.max(max, num);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> start = max - <span class="number">1</span>, end = sum + <span class="number">1</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">while</span> (end - start &gt; <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">long</span> mid = start + (end - start) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">int</span> count = getSubarrayCount(nums, mid);</div><div class="line">            <span class="keyword">if</span> (count &lt;= m) &#123;   <span class="comment">// 当前的targetSum太大导致subarray个数过少</span></div><div class="line">                end = mid;      <span class="comment">// biase to front</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                start = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)end;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getSubarrayCount</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">long</span> targetSum)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</div><div class="line">            <span class="keyword">long</span> tempSum = sum + nums[i];</div><div class="line">            <span class="keyword">if</span> (tempSum &lt; targetSum) &#123;</div><div class="line">                sum = tempSum;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (tempSum == targetSum) &#123;</div><div class="line">                    sum = <span class="number">0</span>;        <span class="comment">// 恰好相等，则归零</span></div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    sum = nums[i];</div><div class="line">                &#125;</div><div class="line">                count++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (sum != <span class="number">0</span>) &#123;</div><div class="line">            count++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法二：DP。。。</p>
</li>
</ul>
<h4 id="412-FizzBuzz"><a href="#412-FizzBuzz" class="headerlink" title="412. FizzBuzz"></a><a href="https://leetcode.com/problems/fizz-buzz/description/" target="_blank" rel="external">412. FizzBuzz</a></h4><ul>
<li>根据是否为3、5的倍数输出指定的字符串。skip。</li>
</ul>
<h4 id="416-partition-equal-subset-sum"><a href="#416-partition-equal-subset-sum" class="headerlink" title="416. partition-equal-subset-sum"></a><a href="https://leetcode.com/problems/partition-equal-subset-sum/description/" target="_blank" rel="external">416. partition-equal-subset-sum</a></h4><ul>
<li>给一个只含有正数的int数组，判断是否可以划分成两个和相等的数组。</li>
<li><p>和698类似的暴力做法，直接遍历找所有可能的组合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> sum = IntStream.of(nums).sum();</div><div class="line">        Arrays.sort(nums);</div><div class="line">        <span class="keyword">if</span> (nums[nums.length - <span class="number">1</span>] &gt; sum / <span class="number">2</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sum % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; canPartition(nums, <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length], sum / <span class="number">2</span>, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] visited, <span class="keyword">int</span> targetSum, <span class="keyword">int</span> currSum)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (currSum &gt; targetSum) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (currSum == targetSum) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</div><div class="line">                visited[i] = <span class="keyword">true</span>;</div><div class="line">                <span class="keyword">if</span> (canPartition(nums, visited, targetSum, currSum + nums[i])) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">                visited[i] = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>其实这题想考察的是DP。<code>dp[i][j]</code>表示<code>i</code>个数组成的和为<code>j</code>，期中这<code>i</code>个数不是全部都取。对于<code>dp[i][j]</code>来说如果不取第i个数（对应索引为<code>i - 1</code>），则直接来自<code>dp[i - 1][j]</code>；如果取了第i个数，则是从<code>dp[i - 1][j - nums[i - 1]]</code>转移过来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> sum = IntStream.of(nums).sum();</div><div class="line">        <span class="keyword">if</span> ((sum &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        sum /= <span class="number">2</span>;</div><div class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length + <span class="number">1</span>][sum + <span class="number">1</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= nums.length; i++) &#123;</div><div class="line">            dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sum; j++) &#123;</div><div class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];   <span class="comment">// 假设不取nums[i - 1]到达当前位置</span></div><div class="line">                <span class="keyword">if</span> (j &gt;= nums[i - <span class="number">1</span>]) &#123;    <span class="comment">// 防止数组越界</span></div><div class="line">                    dp[i][j] = dp[i][j] || dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]]; <span class="comment">// 这里只用了前一行，因此其实dp只用一维数组也够了</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dp[nums.length][sum];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="419-battleships-in-a-board"><a href="#419-battleships-in-a-board" class="headerlink" title="419. battleships-in-a-board"></a><a href="https://leetcode.com/problems/battleships-in-a-board/description/" target="_blank" rel="external">419. battleships-in-a-board</a></h4><ul>
<li>给一个二维char数组，其中含有<code>.</code>和<code>X</code>字符，<code>X</code>表示船，船只会横或者竖着放，船之间至少有一个<code>.</code>。求船的个数。</li>
<li>直接算「第一个」出现的<code>X</code>，即左边和上面都不是<code>X</code>的。</li>
</ul>
<h4 id="424-longest-repeating-character-replacement"><a href="#424-longest-repeating-character-replacement" class="headerlink" title="424. longest-repeating-character-replacement"></a><a href="https://leetcode.com/problems/longest-repeating-character-replacement/description/" target="_blank" rel="external">424. longest-repeating-character-replacement</a></h4><ul>
<li>给一个仅包含大写字母的字符串，再给一个k，表示假设可以有k次机会将其中的某些字母任意变成另一个字母，返回最长的相同字母的substring的长度。例如<code>ABAB</code>变2次，最长长度为4（<code>AAAA</code>）；<code>AAABAABB</code>变1次，为6.</li>
<li>这个替换是一一对应的吗？（不是，可以任意换成需要的字符。也就是可以多对一）</li>
<li>双指针 + producer/consumer的方法，快指针先往后求各个字母的计数，同时更新一个出现最多的字母的频数maxCount。当前后两指针所夹字母数大于了maxCount + k，说明已经超过了可以替换的数目，此时就需要挪慢指针来consume计数。至于为什么不需要每次都保持最精确的maxCount，因为我们只关心最大的，当前最大的挪出窗口后，计数肯定是减掉的，那么后续再出现的时候，不会错误地产生更大的计数，最大值再大也大不过历史峰值。<a href="https://discuss.leetcode.com/topic/63494/java-12-lines-o-n-sliding-window-solution-with-explanation/2" target="_blank" rel="external">解释来自这里</a>.<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characterReplacement</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">26</span>];</div><div class="line">        <span class="keyword">char</span>[] sChar = s.toCharArray();</div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, maxCount = <span class="number">0</span>, maxLen = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> end = <span class="number">0</span>; end &lt; sChar.length; end++) &#123;  </div><div class="line">            maxCount = Math.max(maxCount, ++count[sChar[end] - <span class="string">'A'</span>]);   <span class="comment">// 更新最多的字母的频数</span></div><div class="line">            <span class="keyword">while</span> (end - start + <span class="number">1</span> &gt; k + maxCount) &#123;        <span class="comment">// 指针覆盖的字母过多</span></div><div class="line">                count[sChar[start] - <span class="string">'A'</span>]--;    <span class="comment">// 挪动慢指针，并consume掉计数</span></div><div class="line">                start++;</div><div class="line">                <span class="comment">// 注意并不需要重置maxCount，因为当前这样求出来的就是最大的，只有当新的字符超过了历史最大的maxCount才会有更长的长度需要更新</span></div><div class="line">            &#125;</div><div class="line">            maxLen = Math.max(maxLen, end - start + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxLen;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="425-word-squares"><a href="#425-word-squares" class="headerlink" title="425. word-squares"></a><a href="https://leetcode.com/problems/word-squares/description/" target="_blank" rel="external">425. word-squares</a></h4><ul>
<li>给一个wordList，将List中的String放入matrix中使得行、列的单词都来自于这个List。</li>
<li>Trie + DFS，对于每个Trie节点，除了正常的nexts数组、isWord布尔值，额外维护一个List<string>保存以「到达当前TrieNode路径」为prefix的所有word。固定一个word之后，下一个词的prefix可以通过纵向append得到，具体规律见<a href="https://leetcode.com/problems/word-squares/discuss/91333/Explained.-My-Java-solution-using-Trie-126ms-1616" target="_blank" rel="external">这个discussion</a>.<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</div><div class="line">        TrieNode[] nexts;</div><div class="line">        List&lt;String&gt; prefixWords;</div><div class="line">        <span class="keyword">boolean</span> isWord;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</div><div class="line">            nexts = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</div><div class="line">            prefixWords = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            isWord = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</div><div class="line">        TrieNode root;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">(String[] words)</span> </span>&#123;</div><div class="line">            root = <span class="keyword">new</span> TrieNode();</div><div class="line">            <span class="keyword">for</span> (String word : words) &#123; </div><div class="line">                TrieNode curr = root;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</div><div class="line">                    <span class="keyword">int</span> index = word.charAt(i) - <span class="string">'a'</span>;</div><div class="line">                    <span class="keyword">if</span> (curr.nexts[index] == <span class="keyword">null</span>) &#123;</div><div class="line">                        curr.nexts[index] = <span class="keyword">new</span> TrieNode();</div><div class="line">                    &#125;</div><div class="line">                    curr.prefixWords.add(word);</div><div class="line">                    curr = curr.nexts[index];</div><div class="line">                &#125;</div><div class="line">                curr.isWord = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getByPrefix</span><span class="params">(String prefix)</span> </span>&#123;</div><div class="line">            List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            TrieNode curr = root;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.length(); i++) &#123;</div><div class="line">                <span class="keyword">int</span> index = prefix.charAt(i) - <span class="string">'a'</span>;</div><div class="line">                <span class="keyword">if</span> (curr.nexts[index] == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">return</span> ans;</div><div class="line">                &#125;</div><div class="line">                curr = curr.nexts[index];</div><div class="line">            &#125;</div><div class="line">            ans.addAll(curr.prefixWords);</div><div class="line">            <span class="keyword">return</span> ans;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> len, Trie trie, List&lt;List&lt;String&gt;&gt; ans, List&lt;String&gt; curr)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (curr.size() == len) &#123;</div><div class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curr));</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> index = curr.size();</div><div class="line">        StringBuilder prefix = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">for</span> (String s : curr) &#123;</div><div class="line">            prefix.append(s.charAt(index));</div><div class="line">        &#125;</div><div class="line">        List&lt;String&gt; candidates = trie.getByPrefix(prefix.toString());</div><div class="line">        <span class="keyword">for</span> (String candidate : candidates) &#123;</div><div class="line">            curr.add(candidate);</div><div class="line">            dfs(len, trie, ans, curr);</div><div class="line">            curr.remove(curr.size() - <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; wordSquares(String[] words) &#123;</div><div class="line">        List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">if</span> (words == <span class="keyword">null</span> || words.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> ans;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> len = words[<span class="number">0</span>].length();</div><div class="line">        Trie root = <span class="keyword">new</span> Trie(words);</div><div class="line">        List&lt;String&gt; curr = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (String word : words) &#123;</div><div class="line">            curr.add(word);</div><div class="line">            dfs(len, root, ans, curr);</div><div class="line">            curr.remove(curr.size() - <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</string></li>
</ul>
<h4 id="426-convert-binary-search-tree-to-sorted-doubly-linked-list"><a href="#426-convert-binary-search-tree-to-sorted-doubly-linked-list" class="headerlink" title="426. convert-binary-search-tree-to-sorted-doubly-linked-list"></a><a href="https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/description/" target="_blank" rel="external">426. convert-binary-search-tree-to-sorted-doubly-linked-list</a></h4><ul>
<li>给一个BST，将它转换成排好序的循环双向链表（头尾相接），返回头部。可以把左右孩子就看作是当前节点的前后链表节点，不需要额外搞ListNode类。</li>
<li><p>BST要维持顺序，那就是用中序遍历。利用全局变量prev来记录每一个子树的结尾节点，先build左子树，然后把当前节点拼到prev的后面，再去继续build右子树即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Node prev = <span class="keyword">null</span>;</div><div class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    Node dummy = <span class="keyword">new</span> Node();    <span class="comment">// 伪头部的next就是head</span></div><div class="line">    prev = dummy;   </div><div class="line">    buildDoublyList(root);</div><div class="line">    prev.right = dummy.right;</div><div class="line">    dummy.right.left = prev;</div><div class="line">    dummy.left = dummy.right = <span class="keyword">null</span>;    <span class="comment">// 清理dummy</span></div><div class="line">    <span class="keyword">return</span> prev.right;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 执行buildDoublyList后会将node下面的部分都形成双向链表</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildDoublyList</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    buildDoublyList(node.left); <span class="comment">// 先对左子树build一下，prev会指向最后一个节点</span></div><div class="line">    prev.right = node;          <span class="comment">// 将node拼进去</span></div><div class="line">    node.left = prev;</div><div class="line">    prev = node;                <span class="comment">// 左半部分+当前节点的结尾就是node</span></div><div class="line">    buildDoublyList(node.right);<span class="comment">// 继续build右子树</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法二：分治法。先把左右子树的循环双向链表build好，再把当前节点塞到中间，同时把新的前后循环连接一下。注意在分别build的时候，需要把root本身设一个自循环，这样就可以重复使用connect方法了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    Node leftHead = treeToDoublyList(root.left);</div><div class="line">    Node rightHead = treeToDoublyList(root.right);</div><div class="line">    root.left = root;</div><div class="line">    root.right = root;</div><div class="line">    <span class="keyword">return</span> connect(connect(leftHead, root), rightHead);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node leftHead, Node rightHead)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (leftHead == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> rightHead;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (rightHead == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> leftHead;</div><div class="line">    &#125;</div><div class="line">    Node leftTail = leftHead.left;</div><div class="line">    Node rightTail = rightHead.left;</div><div class="line">    leftTail.right = rightHead;</div><div class="line">    rightHead.left = leftTail;</div><div class="line">    leftHead.left = rightTail;</div><div class="line">    rightTail.right = leftHead;</div><div class="line">    <span class="keyword">return</span> leftHead;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="430-flatten-a-multilevel-doubly-linked-list"><a href="#430-flatten-a-multilevel-doubly-linked-list" class="headerlink" title="430. flatten-a-multilevel-doubly-linked-list"></a><a href="https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list/" target="_blank" rel="external">430. flatten-a-multilevel-doubly-linked-list</a></h4><ul>
<li>给一个nested的双向链表，将所有child节点都插入到父节点的后面。</li>
<li><p>方法一：递归，利用一个全局变量存放上一次flatten之后的最后一个节点，对于每一个节点都连到prev后面，然后flatten当前节点的子节点，然后再继续往后。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Node prev = <span class="keyword">null</span>;</div><div class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">flatten</span><span class="params">(Node head)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;    </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</div><div class="line">        prev.next = head;</div><div class="line">        head.prev = prev;</div><div class="line">    &#125;</div><div class="line">    prev = head;</div><div class="line">    Node next = head.next;</div><div class="line">    flatten(head.child);</div><div class="line">    head.child = <span class="keyword">null</span>;</div><div class="line">    flatten(next);</div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法二：简单的遍历，当前节点有child时就到它的child那一层找到尾巴节点接到后面，然后继续遍历即可。但无法保证每个节点只遍历到一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">flatten</span><span class="params">(Node head)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    Node curr = head;</div><div class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (curr.child != <span class="keyword">null</span>) &#123;</div><div class="line">            Node tail = curr.child;     </div><div class="line">            <span class="keyword">while</span> (tail.next != <span class="keyword">null</span>) &#123; <span class="comment">// 找到下一层的尾巴</span></div><div class="line">                tail = tail.next;</div><div class="line">            &#125;</div><div class="line">            tail.next = curr.next;      <span class="comment">// 与下一个节点相连</span></div><div class="line">            <span class="keyword">if</span> (curr.next != <span class="keyword">null</span>) &#123;</div><div class="line">                curr.next.prev = tail;</div><div class="line">            &#125;</div><div class="line">            curr.next = curr.child;</div><div class="line">            curr.child.prev = curr;</div><div class="line">            curr.child = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        curr = curr.next;       <span class="comment">// 继续遍历链表</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法三：用stack记录next节点和child节点（注意push的顺序，保证先处理child节点），每次从stack中取节点连接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">flatten</span><span class="params">(Node head)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    Node prev = <span class="keyword">null</span>;</div><div class="line">    stack.push(head);</div><div class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</div><div class="line">        Node curr = stack.pop();</div><div class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</div><div class="line">            prev.next = curr;</div><div class="line">            curr.prev = prev;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (curr.next != <span class="keyword">null</span>) &#123;</div><div class="line">            stack.push(curr.next);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (curr.child != <span class="keyword">null</span>) &#123;</div><div class="line">            stack.push(curr.child);</div><div class="line">            curr.child = <span class="keyword">null</span>;      </div><div class="line">        &#125;</div><div class="line">        prev = curr;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="437-path-sum-iii"><a href="#437-path-sum-iii" class="headerlink" title="437. path-sum-iii"></a><a href="https://leetcode.com/problems/path-sum-iii/description/" target="_blank" rel="external">437. path-sum-iii</a></h4><ul>
<li>给一个二叉树，给一个目标值sum，求有几条从上往下累加的路径之和等于sum。</li>
<li>递归DFS，每次深入之前都先减掉当前节点的值。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;    <span class="comment">// calculate path num starting from root</span></div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dfs(root, sum)   <span class="comment">// taking the given node</span></div><div class="line">            + pathSum(root.left, sum) + pathSum(root.right, sum); <span class="comment">// start from left/right child</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode node, <span class="keyword">int</span> target)</span> </span>&#123;    <span class="comment">// dig to find path num taking current node</span></div><div class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (node.val == target? <span class="number">1</span> : <span class="number">0</span>) + dfs(node.left, target - node.val) + dfs(node.right, target - node.val);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="438-find-all-anagrams-in-a-string"><a href="#438-find-all-anagrams-in-a-string" class="headerlink" title="438. find-all-anagrams-in-a-string"></a><a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/description/" target="_blank" rel="external">438. find-all-anagrams-in-a-string</a></h4><ul>
<li>给一个字符串s和一个字符串p，求s中所有p的anagram子串的起始位置的List。</li>
<li>双指针 + producer/consumer的方法，map中存放p中每个字符及其对应出现的次数，快指针负责consume直到没有可用的字符（只需要管map中有的字符），这时看看快慢指针所夹字符的个数是否等于p；之后就挪动慢指针provide补回字符。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">// O(N)双指针。先一波流统计p中各个字符出现的频数，然后consume掉map中的字符直到没有available的</span></div><div class="line">    <span class="comment">// 此时判断左右指针之间长度是否等于目标的长度，然后挪动左指针重新往map中加回去，直到出现可选字符</span></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</div><div class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || p == <span class="keyword">null</span> || s.length() == <span class="number">0</span> || p.length() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> ans;</div><div class="line">        &#125;</div><div class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">char</span>[] pChar = p.toCharArray();</div><div class="line">        <span class="keyword">int</span> pLen = pChar.length;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: pChar) &#123;</div><div class="line">            map.put(c, map.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">char</span>[] sChar = s.toCharArray();</div><div class="line">        <span class="keyword">int</span> count = map.size();     <span class="comment">// 还有count个不同的字符可选</span></div><div class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (right &lt; sChar.length) &#123;</div><div class="line">            <span class="keyword">if</span> (map.containsKey(sChar[right])) &#123;</div><div class="line">                map.put(sChar[right], map.get(sChar[right]) - <span class="number">1</span>);</div><div class="line">                <span class="keyword">if</span> (map.get(sChar[right]) == <span class="number">0</span>) &#123;</div><div class="line">                    count--;    <span class="comment">// 可选字符少了一个</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (right - left + <span class="number">1</span> == pLen) &#123;</div><div class="line">                    ans.add(left);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (map.containsKey(sChar[left])) &#123;</div><div class="line">                    map.put(sChar[left], map.get(sChar[left]) + <span class="number">1</span>);</div><div class="line">                    <span class="keyword">if</span> (map.get(sChar[left]) &gt; <span class="number">0</span>) &#123;</div><div class="line">                        count++;    <span class="comment">// 恢复可选字符</span></div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                left++;</div><div class="line">            &#125;</div><div class="line">            right++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="439-ternary-expression-parser"><a href="#439-ternary-expression-parser" class="headerlink" title="439. ternary-expression-parser"></a><a href="https://leetcode.com/problems/ternary-expression-parser/description/" target="_blank" rel="external">439. ternary-expression-parser</a></h4><ul>
<li>给一个三元运算的<code>? :</code>字符串，布尔表达式直接就是T或者F，其余的都是0-9的一位数字，求最终结果。例如<code>F?1:T?4:5</code>最后就是4.</li>
<li><p>方法一：Stack。想到了要用Stack，但是没有想出确切的方法。其实就是需要从后往前遍历，确定最终需要保留的是什么数字就好了，在stack中存放两个值以及问号，这样当下一个字符（准确说是前一个）出现时只需要判断栈顶是否是问号就知道当前字符是作为bool还是值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">parseTernary</span><span class="params">(String expression)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (expression == <span class="keyword">null</span> || expression.length() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">        &#125;</div><div class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;(); <span class="comment">// 存放数值和问号</span></div><div class="line">        <span class="keyword">int</span> len = expression.length();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;    <span class="comment">// 从末尾往前遍历</span></div><div class="line">            <span class="keyword">char</span> curr = expression.charAt(i);</div><div class="line">            <span class="keyword">if</span> (!stack.isEmpty() &amp;&amp; stack.peek() == <span class="string">'?'</span>) &#123;</div><div class="line">                stack.pop();</div><div class="line">                <span class="keyword">char</span> first = stack.pop();</div><div class="line">                <span class="keyword">char</span> second = stack.pop();</div><div class="line">                <span class="keyword">if</span> (curr == <span class="string">'T'</span>) &#123;</div><div class="line">                    stack.push(first);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    stack.push(second);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curr != <span class="string">':'</span>) &#123;</div><div class="line">                stack.push(curr);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> stack.peek() + <span class="string">""</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法二：递归DFS。对于每一个问号都进行计数++，每个冒号进行计数–，这样当计数归0的时候就找到了与问号对应的冒号，然后根据T／F递归找前后其中一部分的结果就好。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">parseTernary</span><span class="params">(String expression)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (expression == <span class="keyword">null</span> || expression.length() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> expression;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">char</span>[] exp = expression.toCharArray();</div><div class="line">        <span class="keyword">return</span> DFS(exp, <span class="number">0</span>, exp.length - <span class="number">1</span>) + <span class="string">""</span>;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">DFS</span><span class="params">(<span class="keyword">char</span>[] c, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (start == end) &#123;</div><div class="line">            <span class="keyword">return</span> c[start];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, i = start;</div><div class="line">        <span class="keyword">for</span> (; i &lt;= end; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (c[i] == <span class="string">'?'</span>) &#123;</div><div class="line">                count++;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c[i] == <span class="string">':'</span>) &#123;</div><div class="line">                count--;</div><div class="line">                <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> c[start] == <span class="string">'T'</span>? DFS(c, start + <span class="number">2</span>, i - <span class="number">1</span>) : DFS(c, i + <span class="number">1</span>, end);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="443-string-compression"><a href="#443-string-compression" class="headerlink" title="443. string-compression"></a><a href="https://leetcode.com/problems/string-compression/description/" target="_blank" rel="external">443. string-compression</a></h4><ul>
<li>给一个字符数组，统计字符出现的个数实现压缩。例如<code>a,a,a,a,a,b,c,c,c,c,c,c,c,c,c,c,c,c,c,c,c,c,c</code>就是<code>a,5,b,c,1,7</code>。要求in-place。</li>
<li>每次从头开始，以第一个为基准往后判断，直到不想等，再根据个数往里塞。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compress</span><span class="params">(<span class="keyword">char</span>[] chars)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (chars == <span class="keyword">null</span> || chars.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, len = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (i &lt; chars.length) &#123;</div><div class="line">            <span class="keyword">char</span> curr = chars[i++];     <span class="comment">// 以第一个字符为判断标准</span></div><div class="line">            chars[len++] = curr;</div><div class="line">            <span class="keyword">int</span> count = <span class="number">1</span>;</div><div class="line">            <span class="keyword">while</span> (i &lt; chars.length &amp;&amp; curr == chars[i]) &#123;  <span class="comment">// 统计个数直到不匹配</span></div><div class="line">                i++;        </div><div class="line">                count++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (count != <span class="number">1</span>) &#123;           <span class="comment">// 超过一个才拼接上数字</span></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> c : Integer.toString(count).toCharArray()) &#123;</div><div class="line">                    chars[len++] = c;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> len;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="444-sequence-reconstruction"><a href="#444-sequence-reconstruction" class="headerlink" title="444. sequence-reconstruction"></a><a href="https://leetcode.com/problems/sequence-reconstruction/description/" target="_blank" rel="external">444. sequence-reconstruction</a></h4><ul>
<li>给一个int数组org，再给一个List of list，这些list是某个original sequence的子序列，问根据这些子序列是否可以唯一地还原成一个完整的序列且正是org.</li>
<li>经典的拓扑排序。用<code>Map&lt;Integer, Set&lt;Integer&gt;&gt;</code>维护邻接关系，用<code>Map&lt;Integer&gt;</code>维护inDegrees关系<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sequenceReconstruction</span><span class="params">(<span class="keyword">int</span>[] org, List&lt;List&lt;Integer&gt;&gt; seqs)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (org == <span class="keyword">null</span> || org.length == <span class="number">0</span> || seqs == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> n = org.length;</div><div class="line">        Map&lt;Integer, Integer&gt; inDegrees = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        Map&lt;Integer, Set&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; seq : seqs) &#123;</div><div class="line">            <span class="keyword">if</span> (seq.size() == <span class="number">1</span>) &#123;   <span class="comment">// 可能存在只有一个节点的seq</span></div><div class="line">                graph.putIfAbsent(seq.get(<span class="number">0</span>), <span class="keyword">new</span> HashSet&lt;&gt;());</div><div class="line">                inDegrees.putIfAbsent(seq.get(<span class="number">0</span>), <span class="number">0</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; seq.size();i++) &#123;   <span class="comment">// 依次取每条seq的节点形成graph</span></div><div class="line">                    graph.putIfAbsent(seq.get(i - <span class="number">1</span>), <span class="keyword">new</span> HashSet&lt;Integer&gt;());</div><div class="line">                    graph.putIfAbsent(seq.get(i), <span class="keyword">new</span> HashSet&lt;Integer&gt;());</div><div class="line">                    <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</div><div class="line">                        inDegrees.put(seq.get(i - <span class="number">1</span>), inDegrees.getOrDefault(seq.get(i - <span class="number">1</span>), <span class="number">0</span>));</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (graph.get(seq.get(i - <span class="number">1</span>)).add(seq.get(i))) &#123;</div><div class="line">                        inDegrees.put(seq.get(i), inDegrees.getOrDefault(seq.get(i), <span class="number">0</span>) + <span class="number">1</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> key : inDegrees.keySet()) &#123;</div><div class="line">            <span class="keyword">if</span> (inDegrees.get(key) == <span class="number">0</span>) &#123;</div><div class="line">                q.offer(key);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (q.size() == <span class="number">1</span>) &#123;     <span class="comment">// 必须保证每次只有一个入度为0的节点</span></div><div class="line">            <span class="keyword">int</span> startIndex = q.poll();</div><div class="line">            <span class="keyword">if</span> (startIndex != org[index]) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (++index == n) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            Set&lt;Integer&gt; neighbors = graph.get(startIndex);</div><div class="line">            <span class="keyword">if</span> (neighbors == <span class="keyword">null</span>) &#123;    <span class="comment">// 没有后续节点可以判断</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : neighbors) &#123;</div><div class="line">                inDegrees.put(neighbor, inDegrees.get(neighbor) - <span class="number">1</span>);</div><div class="line">                <span class="keyword">if</span> (inDegrees.get(neighbor) == <span class="number">0</span>) &#123;</div><div class="line">                    q.offer(neighbor);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> index == n &amp;&amp; index == graph.size();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="445-add-two-numbers-ii"><a href="#445-add-two-numbers-ii" class="headerlink" title="445. add-two-numbers-ii"></a><a href="https://leetcode.com/problems/add-two-numbers-ii/" target="_blank" rel="external">445. add-two-numbers-ii</a></h4><ul>
<li>给两个链表的头节点，每个节点表示一个数位，将两个数字相加得到的链表.</li>
<li>方法一：stack，将节点统统存入之后，逐个pop相加。</li>
<li>方法二：先求得长度，然后根据长度差来加。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span> || l2 == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> l1 == <span class="keyword">null</span> ? l2 : l1;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> len1 = getLen(l1);</div><div class="line">    <span class="keyword">int</span> len2 = getLen(l2);</div><div class="line">    ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">    ListNode next = len1 &gt; len2 ? addTwoNumbers(l1, l2, len1 - len2) : addTwoNumbers(l2, l1, len2 - len1);</div><div class="line">    <span class="keyword">boolean</span> hasCarry = adjustCarry(head, next);</div><div class="line">    <span class="keyword">return</span> hasCarry ? head : next;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2, <span class="keyword">int</span> offset)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    ListNode ret = offset &gt; <span class="number">0</span> ? <span class="keyword">new</span> ListNode(l1.val) : <span class="keyword">new</span> ListNode(l1.val + l2.val);</div><div class="line">    ListNode next = addTwoNumbers(l1.next, offset &gt; <span class="number">0</span> ? l2 : l2.next, offset &gt; <span class="number">0</span> ? offset - <span class="number">1</span> : offset);</div><div class="line">    adjustCarry(ret, next);</div><div class="line">    <span class="keyword">return</span> ret; </div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">adjustCarry</span><span class="params">(ListNode head, ListNode next)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> hasCarry = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.val &gt; <span class="number">9</span>) &#123;</div><div class="line">        hasCarry = <span class="keyword">true</span>;</div><div class="line">        next.val -= <span class="number">10</span>;</div><div class="line">        head.val += <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    head.next = next;</div><div class="line">    <span class="keyword">return</span> hasCarry;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getLen</span><span class="params">(ListNode node)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</div><div class="line">        len++;</div><div class="line">        node = node.next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> len;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="449-serialize-and-deserialize-bst"><a href="#449-serialize-and-deserialize-bst" class="headerlink" title="449. serialize-and-deserialize-bst"></a><a href="https://leetcode.com/problems/serialize-and-deserialize-bst/description/" target="_blank" rel="external">449. serialize-and-deserialize-bst</a></h4><ul>
<li>给一个BST，实现序列化和反序列化，即和String互相转换。</li>
<li>如果只是一个普通的二叉树，直接暴力写preorder和StringBuilder拼接没问题。但对于BST这个条件要怎么用呢？root一定比所有左边节点大、比所有右边节点小，那么在反序列化的时候直接通过val找到属于左边那半部分subtree去build即可。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// Encodes a tree to a single string.</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">        preorder(root, sb);</div><div class="line">        <span class="keyword">return</span> sb.toString();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode root, StringBuilder sb)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        sb.append(root.val);</div><div class="line">        sb.append(<span class="string">","</span>);</div><div class="line">        preorder(root.left, sb);</div><div class="line">        preorder(root.right, sb);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Decodes your encoded data to tree.</span></div><div class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (data == <span class="keyword">null</span> || data.length() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        String[] vals = data.split(<span class="string">","</span>);</div><div class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (String val : vals) &#123;</div><div class="line">            q.offer(Integer.parseInt(val));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> deserialize(q);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">deserialize</span><span class="params">(Queue&lt;Integer&gt; q)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (q.isEmpty()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(q.poll());</div><div class="line">        Queue&lt;Integer&gt; smallerQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="keyword">while</span> (!q.isEmpty() &amp;&amp; q.peek() &lt; root.val) &#123;</div><div class="line">            smallerQueue.offer(q.poll());</div><div class="line">        &#125;</div><div class="line">        root.left = deserialize(smallerQueue);</div><div class="line">        root.right = deserialize(q);</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="450-delete-node-in-a-bst"><a href="#450-delete-node-in-a-bst" class="headerlink" title="450. delete-node-in-a-bst"></a><a href="https://leetcode.com/problems/delete-node-in-a-bst/description/" target="_blank" rel="external">450. delete-node-in-a-bst</a></h4><ul>
<li>给一个BST和一个key，如果存在这个key就删除这个值，返回root（可能会更新）。</li>
<li>经典。首先是搜索这个key，然后就是删除节点。如果这个节点是叶子，直接返回null；如果是单边，返回非空child；如果是双边children，则需要取中序遍历的下一个节点来替换掉当前节点。一种做法是去右子树的最左节点的值放到当前节点，再把该最左节点删除。另一种是真正的替换<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> root;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (key &lt; root.val) &#123;</div><div class="line">            root.left = deleteNode(root.left, key);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root.val) &#123;</div><div class="line">            root.right = deleteNode(root.right, key);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (root.left == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">return</span> root.right;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (root.right == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">return</span> root.left;</div><div class="line">            &#125;</div><div class="line">            TreeNode minNode = getMinNode(root.right);</div><div class="line">            <span class="comment">// 方法一：覆盖value</span></div><div class="line">            <span class="comment">// root.val = minNode.val;</span></div><div class="line">            <span class="comment">// root.right = deleteNode(root.right, minNode.val);</span></div><div class="line"></div><div class="line">            <span class="comment">// 方法二：真正的替换</span></div><div class="line">            minNode.right = deleteNode(root.right, minNode.val);</div><div class="line">            minNode.left = root.left;</div><div class="line">            root = minNode;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">getMinNode</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (root.left != <span class="keyword">null</span>) &#123;</div><div class="line">            root = root.left;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="452-minimum-number-of-arrows-to-burst-balloons"><a href="#452-minimum-number-of-arrows-to-burst-balloons" class="headerlink" title="452. minimum-number-of-arrows-to-burst-balloons"></a><a href="https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/" target="_blank" rel="external">452. minimum-number-of-arrows-to-burst-balloons</a></h4><ul>
<li>给一个二维int数组，每一项表示一个气球的跨度，求最少用几根针可以扎破所有气球，注意气球的边界也算有效扎破范围。例如<code>[[10,16], [2,8], [1,6], [7,12]]</code>就至少需要两根针。</li>
<li><p>贪心做法，既然针蹭到也算扎破，那就按照气球的右边界从小到大排序，然后从头开始遍历，一旦发现当前区间的左边界大于了之前的右边界，就说明前面需要用新的针来继续扎后面的了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (points == <span class="keyword">null</span> || points.length == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    Arrays.sort(points, (a, b) -&gt; a[<span class="number">1</span>] - b[<span class="number">1</span>]);</div><div class="line">    <span class="keyword">int</span> prevPos = points[<span class="number">0</span>][<span class="number">1</span>], arrowCount = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; points.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (points[i][<span class="number">0</span>] &gt; prevPos) &#123;</div><div class="line">            prevPos = points[i][<span class="number">1</span>];</div><div class="line">            arrowCount++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arrowCount;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>相似的题有<a href="https://leetcode.com/problems/merge-intervals" target="_blank" rel="external">56 Merge Intervals</a>, <a href="https://leetcode.com/problems/non-overlapping-intervals" target="_blank" rel="external">435 Non-overlapping Intervals</a>, <a href="https://leetcode.com/problems/meeting-rooms/" target="_blank" rel="external">252 Meeting Rooms</a>, <a href="https://leetcode.com/problems/meeting-rooms-ii/" target="_blank" rel="external">253 Meeting Rooms II</a>.</p>
</li>
</ul>
<h4 id="453-minimum-moves-to-equal-array-elements"><a href="#453-minimum-moves-to-equal-array-elements" class="headerlink" title="453. minimum-moves-to-equal-array-elements"></a><a href="https://leetcode.com/problems/minimum-moves-to-equal-array-elements/description/" target="_blank" rel="external">453. minimum-moves-to-equal-array-elements</a></h4><ul>
<li>给一个int数组，返回move几次能够让每个元素相等。move指的是对某位置以外的所有元素加1.</li>
<li>这题其实是个math problem，<a href="https://discuss.leetcode.com/topic/66737/it-is-a-math-question" target="_blank" rel="external">推导在此</a>，假设所有数之和为sum，最小值为minNum，加了m次达到x，则有<code>sum + m * (n - 1) = x * n</code>以及<code>minNum + m = x</code>，代入抵消一下就得到<code>sum + mn - m = minNum * n + mn</code>，所求的m为<code>sum - minNum * n = SUM(num_i - minNum)</code>。直接根据公式来，先求一波最小值，然后累加即可。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMoves</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> min = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</div><div class="line">            min = Math.min(min, nums[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> minMove = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</div><div class="line">            minMove += (num - min);</div><div class="line">        &#125; </div><div class="line">        <span class="keyword">return</span> minMove;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="454-4sum-ii"><a href="#454-4sum-ii" class="headerlink" title="454. 4sum-ii"></a><a href="https://leetcode.com/problems/4sum-ii/description/" target="_blank" rel="external">454. 4sum-ii</a></h4><ul>
<li>给四个数组，求其中有多少个组合使得<code>A[i] + B[j] + C[k] + D[l] = 0</code>.</li>
<li>Map统计A和B的所有和出现的次数，然后遍历C+D的组合，到map中找对应项。skip。</li>
</ul>
<h4 id="457-circular-array-loop"><a href="#457-circular-array-loop" class="headerlink" title="457. circular-array-loop"></a><a href="https://leetcode.com/problems/circular-array-loop/description/" target="_blank" rel="external">457. circular-array-loop</a></h4><ul>
<li>给一个int数组，从任意一点出发，跳动步数就是数组的值，判断是否存在一个单一方向的、含有多于一个element的loop。数组中不含0.尝试不实用额外空间。</li>
<li>如果可以使用extra space，可以直接用Set记录到过的index以及某个path的index。如果不用额外空间呢？联想LinkedList找loop用快慢指针，这里也是一样。slow每次往后一步、fast每次两步，若全程能保持同一个方向移动且slow和fast相遇，则有loop.注意这里需要filter掉self-loop的元素。为了标记是否访问过而不使用Set，可以利用条件「原数组不含有0元素」，将访问过的元素改成0。保证一个方向的loop则是通过每一步经过的元素是否符号相同来判定的，也就是相乘大于0.<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">circularArrayLoop</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">int</span> n = nums.length, slow = i, fast = getNextIndex(i, nums[i], n);</div><div class="line">            <span class="keyword">while</span> (nums[fast] * nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[getNextIndex(fast, nums[fast], n)] * nums[i] &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (slow == fast) &#123;</div><div class="line">                    <span class="keyword">if</span> (slow == getNextIndex(slow, nums[slow], n)) &#123;    <span class="comment">// 排除只含有一个element的cycle</span></div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">                slow = getNextIndex(slow, nums[slow], n);   <span class="comment">// 慢快指针分别移动一步两步</span></div><div class="line">                fast = getNextIndex(fast, nums[fast], n);</div><div class="line">                fast = getNextIndex(fast, nums[fast], n);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">int</span> j = i, val = nums[i];</div><div class="line">            <span class="keyword">while</span> (nums[j] * val &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">int</span> nextIndex = getNextIndex(j, nums[j], n);</div><div class="line">                nums[j] = <span class="number">0</span>;</div><div class="line">                j = nextIndex;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNextIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> step, <span class="keyword">int</span> len)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> nextIndex = index + step;</div><div class="line">        <span class="keyword">return</span> nextIndex &gt;= <span class="number">0</span> ? nextIndex % len : nextIndex % len + len; <span class="comment">// java的%求的是余数而不是真正的modulo</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="460-Least-Frequently-Used-Cache"><a href="#460-Least-Frequently-Used-Cache" class="headerlink" title="460. Least Frequently Used Cache"></a><a href="https://leetcode.com/problems/lfu-cache/description/" target="_blank" rel="external">460. Least Frequently Used Cache</a></h4><ul>
<li>实现最近最频繁使用的有限容量缓存，到达容量上限时evict最不频繁使用的key，若频繁情况相同则evict掉最早插入的。</li>
<li><p>方法一：优先队列，自定义Cache类，其中包含freq和timestamp，自定义Comparator来维护顺序。cacheMap用于维护正常的键值对缓存，freqMap用于快速获得给定key的freq。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> </span>&#123;</div><div class="line">    <span class="comment">// naive做法：通过自定义Cache维护一个优先队列，排序就是根据freq和timestamp来的，freq小在前、相等则时间戳小的在前。注意需要重载equals和hashCode，才能正常remove。</span></div><div class="line">    <span class="comment">// put：把键值对放入cacheMap，还要新建这个key的freq（第一次为1）并插入freqMap</span></div><div class="line">    <span class="comment">// get: 直接从cacheMap中拿</span></div><div class="line">    <span class="comment">// 在put和get过程中，若key是现有的，则需要更新freq，并存入pq</span></div><div class="line">    <span class="comment">// 当到达容量上限，直接从pq头部poll出来的key对应从map里删掉即可</span></div><div class="line">    <span class="comment">// pq的remove是O(N)的，所以总体是O(capacity)的</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Cache</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> key, freq, timestamp;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Cache</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> freq, <span class="keyword">int</span> timestamp)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.key = key;</div><div class="line">            <span class="keyword">this</span>.freq = freq;</div><div class="line">            <span class="keyword">this</span>.timestamp = timestamp;</div><div class="line">        &#125;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> key == ((Cache)(obj)).key;</div><div class="line">        &#125;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> key;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> capacity, globalTime;</div><div class="line">    Map&lt;Integer, Integer&gt; cacheMap = <span class="keyword">null</span>;</div><div class="line">    Map&lt;Integer, Integer&gt; freqMap = <span class="keyword">null</span>;</div><div class="line">    PriorityQueue&lt;Cache&gt; pq = <span class="keyword">null</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LFUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.capacity = capacity;</div><div class="line">        globalTime = <span class="number">0</span>;</div><div class="line">        cacheMap = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        freqMap = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((c1, c2) -&gt; &#123;</div><div class="line">            <span class="keyword">return</span> c1.freq == c2.freq? c1.timestamp - c2.timestamp: c1.freq - c2.freq;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</div><div class="line">        globalTime++;</div><div class="line">        <span class="keyword">if</span> (cacheMap.containsKey(key)) &#123;</div><div class="line">            update(key);</div><div class="line">            <span class="keyword">return</span> cacheMap.get(key);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> ;</div><div class="line">        &#125;</div><div class="line">        globalTime++;</div><div class="line">        <span class="keyword">if</span> (cacheMap.containsKey(key)) &#123;</div><div class="line">            update(key);</div><div class="line">            cacheMap.put(key, value);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (cacheMap.size() == capacity) &#123;</div><div class="line">            Cache evict = pq.poll();</div><div class="line">            cacheMap.remove(evict.key);</div><div class="line">            freqMap.remove(evict.key);</div><div class="line">        &#125;</div><div class="line">        cacheMap.put(key, value);</div><div class="line">        freqMap.put(key, <span class="number">1</span>);</div><div class="line">        pq.add(<span class="keyword">new</span> Cache(key, <span class="number">1</span>, globalTime));</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> freq = freqMap.get(key);</div><div class="line">        freqMap.put(key, freq + <span class="number">1</span>);</div><div class="line">        Cache c = <span class="keyword">new</span> Cache(key, freq + <span class="number">1</span>, globalTime);</div><div class="line">        pq.remove(c);</div><div class="line">        pq.add(c);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法二：使用LRU中的双向链表，可以使得remove也O(1)。自定义Node，每个位置的Node代表了某个freq值的所有key。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> </span>&#123;</div><div class="line">    <span class="comment">// 自定义双向链表节点Node用于按照freq从大到小存放key</span></div><div class="line">    <span class="comment">// 通过key对应到Node（nodeMap），Node中存放该key的freq。</span></div><div class="line">    <span class="comment">// 若相同的freq对应多个key，则用一个Set存放，为了维持Recent特性，需要保证插入顺序，故用LinkedHashSet</span></div><div class="line">    <span class="comment">// get：从cacheMap中正常取数值，并从nodeMap中拿到这个节点，更新freq并插入到后续位置。</span></div><div class="line">    <span class="comment">// put：有可能是更新原有key的数值，更新cacheMap中value。</span></div><div class="line">    <span class="comment">// put：若是插入新的key，则先看看head是否维护的是freq为0，不是则新建head并插入到最前。</span></div><div class="line">    <span class="comment">// put完之后要统一更新freq.</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">int</span> freq = <span class="number">0</span>;</div><div class="line">        <span class="keyword">public</span> Set&lt;Integer&gt; keySet = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">public</span> Node prev = <span class="keyword">null</span>, next = <span class="keyword">null</span>;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> freq)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.freq = freq;</div><div class="line">            keySet = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</div><div class="line">            prev = <span class="keyword">null</span>;</div><div class="line">            next = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> Node head = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; cacheMap = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">private</span> Map&lt;Integer, Node&gt; nodeMap = <span class="keyword">null</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LFUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.capacity = capacity;</div><div class="line">        cacheMap = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        nodeMap = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (cacheMap.containsKey(key)) &#123;</div><div class="line">            updateFreq(key);</div><div class="line">            <span class="keyword">return</span> cacheMap.get(key);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (cacheMap.containsKey(key)) &#123;</div><div class="line">            cacheMap.put(key, value);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (cacheMap.size() &lt; capacity) &#123;</div><div class="line">                cacheMap.put(key, value);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                deleteOldest();</div><div class="line">                cacheMap.put(key, value);</div><div class="line">            &#125;</div><div class="line">            addToHead(key);</div><div class="line">        &#125;</div><div class="line">        updateFreq(key);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 更新key的freq并加入相应的node中</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateFreq</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</div><div class="line">        Node node = nodeMap.get(key);</div><div class="line">        node.keySet.remove(key);  <span class="comment">// 从当前freq的node中移除然后加入后续node</span></div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (node.next == <span class="keyword">null</span>) &#123;</div><div class="line">            node.next = <span class="keyword">new</span> Node(node.freq + <span class="number">1</span>);</div><div class="line">            node.next.prev = node;</div><div class="line">            node.next.keySet.add(key);    <span class="comment">// 相同freq的key，维持插入顺序</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.next.freq == node.freq + <span class="number">1</span>) &#123;</div><div class="line">            node.next.keySet.add(key);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            Node newFreqNode = <span class="keyword">new</span> Node(node.freq + <span class="number">1</span>);</div><div class="line">            newFreqNode.keySet.add(key);</div><div class="line">            newFreqNode.prev = node;</div><div class="line">            newFreqNode.next = node.next;</div><div class="line">            node.next.prev = newFreqNode;</div><div class="line">            node.next = newFreqNode;</div><div class="line">        &#125;</div><div class="line">        nodeMap.put(key, node.next);   <span class="comment">// 更新后续node</span></div><div class="line">        <span class="keyword">if</span> (node.keySet.size() == <span class="number">0</span>) &#123;</div><div class="line">            deleteNode(node);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// O(1)删除双向链表的节点</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (node.prev == <span class="keyword">null</span>) &#123;</div><div class="line">            head = node.next;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            node.prev.next = node.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) &#123;</div><div class="line">            node.next.prev = node.prev;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 新插入的key要新建freq=0的Node（或原本就有），并作为head</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</div><div class="line">            head = <span class="keyword">new</span> Node(<span class="number">0</span>);</div><div class="line">            head.keySet.add(key);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head.freq &gt; <span class="number">0</span>) &#123;</div><div class="line">            Node newHead = <span class="keyword">new</span> Node(<span class="number">0</span>);</div><div class="line">            newHead.keySet.add(key);</div><div class="line">            newHead.next = head;</div><div class="line">            head.prev = newHead;</div><div class="line">            head = newHead;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            head.keySet.add(key);</div><div class="line">        &#125;</div><div class="line">        nodeMap.put(key, head);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteOldest</span><span class="params">()</span> </span>&#123;   <span class="comment">// 双向链表头就是freq最小的key们</span></div><div class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        Iterator it = head.keySet.iterator(); <span class="comment">// keys中靠前的就是较早插入的</span></div><div class="line">        Integer oldestKey = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (it.hasNext()) &#123;</div><div class="line">            oldestKey = (Integer)it.next();</div><div class="line">            head.keySet.remove(oldestKey);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (head.keySet.size() == <span class="number">0</span>) &#123;</div><div class="line">            deleteNode(head);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (oldestKey != <span class="keyword">null</span>) &#123;</div><div class="line">            cacheMap.remove(oldestKey);</div><div class="line">            nodeMap.remove(oldestKey);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="461-hamming-distance"><a href="#461-hamming-distance" class="headerlink" title="461. hamming-distance"></a><a href="https://leetcode.com/problems/hamming-distance/description/" target="_blank" rel="external">461. hamming-distance</a></h4><ul>
<li>给两个int，求hamming distance. hamming distance指的是两个数不同的bit的个数，例如1001和0011就有两位不同。</li>
<li>异或之后看多少个bit。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n = x ^ y;</div><div class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</div><div class="line">            <span class="keyword">int</span> mask = (<span class="number">1</span> &lt;&lt; i);</div><div class="line">            <span class="keyword">if</span> ((n &amp; mask) != <span class="number">0</span>) &#123;</div><div class="line">                ans++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="463-island-perimeter"><a href="#463-island-perimeter" class="headerlink" title="463. island-perimeter"></a><a href="https://leetcode.com/problems/island-perimeter/description/" target="_blank" rel="external">463. island-perimeter</a></h4><ul>
<li>给一个0/1二维矩阵，求其中为1的island的周长。</li>
<li><p>方法一：BFS，每个1都先算它有四条边，然后根据邻接情况减掉不是边的即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[grid.length][grid[<span class="number">0</span>].length];</div><div class="line">        <span class="keyword">int</span> perimeter = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span> &amp;&amp; !visited[i][j]) &#123;</div><div class="line">                    perimeter += bfs(grid, i, j, visited);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> perimeter;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] dirs = <span class="keyword">new</span> <span class="keyword">int</span>[][] &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">boolean</span>[][] visited)</span> </span>&#123;</div><div class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        q.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i, j&#125;);</div><div class="line">        visited[i][j] = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">int</span> perimeter = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</div><div class="line">            <span class="keyword">int</span>[] curr = q.poll();</div><div class="line">            perimeter += <span class="number">4</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) &#123;</div><div class="line">                <span class="keyword">int</span> row = curr[<span class="number">0</span>] + dir[<span class="number">0</span>], col = curr[<span class="number">1</span>] + dir[<span class="number">1</span>];</div><div class="line">                <span class="keyword">if</span> (isIsland(grid, row, col)) &#123;</div><div class="line">                    perimeter--;</div><div class="line">                    <span class="keyword">if</span> (!visited[row][col]) &#123;</div><div class="line">                        q.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;row, col&#125;);</div><div class="line">                        visited[row][col] = <span class="keyword">true</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> perimeter;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isIsland</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> i &gt;= <span class="number">0</span> &amp;&amp; i &lt; grid.length</div><div class="line">            &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; grid[<span class="number">0</span>].length</div><div class="line">            &amp;&amp; grid[i][j] == <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法二：找规律。对于每一个1的cell，看它的下方和右方neighbor是不是1，记录neighbor数，最后周长就是islands <em> 4 - neighbours </em> 2。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> islands = <span class="number">0</span>, neighbours = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[i].length; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</div><div class="line">                islands++; <span class="comment">// count islands</span></div><div class="line">                <span class="keyword">if</span> (i &lt; grid.length - <span class="number">1</span> &amp;&amp; grid[i + <span class="number">1</span>][j] == <span class="number">1</span>) neighbours++; <span class="comment">// count down neighbours</span></div><div class="line">                <span class="keyword">if</span> (j &lt; grid[i].length - <span class="number">1</span> &amp;&amp; grid[i][j + <span class="number">1</span>] == <span class="number">1</span>) neighbours++; <span class="comment">// count right neighbours</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> islands * <span class="number">4</span> - neighbours * <span class="number">2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="464-can-i-win"><a href="#464-can-i-win" class="headerlink" title="464. can-i-win"></a><a href="https://leetcode.com/problems/can-i-win/description/" target="_blank" rel="external">464. can-i-win</a></h4><ul>
<li>给定一个最大可取的int，再给个目标值target，两个人轮流从<code>[1, int]</code>之间取值，用过的值就不能再用了，两个人取的值不断累加，恰好达到或超过target的人就赢了。问是否能稳赢。</li>
<li>经典的DFS递归。有两个状态需要维护，一个是可选的数字需要用map或者数组bucket存起来，一个是剩余的target。同样为了避免DFS重复计算，需要用一个map将中间结果存起来。如果不加memorize的话时间复杂度<code>O(N!)</code>，相当于从1到N每一步都有N, N-1, N-2…个选择。如果加了memorize，则提升到<code>O(2^N)</code>，相当于1到N每个数字都有取或不取两种状态，可以保证访问过的状态不会重复heo访问，那么就是<code>2^N</code>。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canIWin</span><span class="params">(<span class="keyword">int</span> maxChoosableInteger, <span class="keyword">int</span> desiredTotal)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (desiredTotal &lt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> maxTotal = (<span class="number">1</span> + maxChoosableInteger) * maxChoosableInteger / <span class="number">2</span>; </div><div class="line">        <span class="keyword">if</span> (maxTotal &lt; desiredTotal) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> checkWin(desiredTotal, <span class="keyword">new</span> <span class="keyword">boolean</span> [maxChoosableInteger], <span class="keyword">new</span> HashMap&lt;String, Boolean&gt;());</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkWin</span><span class="params">(<span class="keyword">int</span> total, <span class="keyword">boolean</span>[] bucket, Map&lt;String, Boolean&gt; map)</span> </span>&#123;</div><div class="line">        String state = Arrays.toString(bucket);</div><div class="line">        <span class="keyword">if</span> (map.containsKey(state)) &#123;</div><div class="line">            <span class="keyword">return</span> map.get(state);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucket.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (!bucket[i]) &#123;</div><div class="line">                bucket[i] = <span class="keyword">true</span>;</div><div class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &gt;= total || !checkWin(total - (i + <span class="number">1</span>), bucket, map)) &#123;     <span class="comment">// 超过或者对方必输，我就赢了</span></div><div class="line">                    map.put(state, <span class="keyword">true</span>);</div><div class="line">                    bucket[i] = <span class="keyword">false</span>;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">                bucket[i] = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        map.put(state, <span class="keyword">false</span>);  <span class="comment">// 遍历了所有可能值都不行，必输</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="477-total-hamming-distance"><a href="#477-total-hamming-distance" class="headerlink" title="477. total-hamming-distance"></a><a href="https://leetcode.com/problems/total-hamming-distance/description/" target="_blank" rel="external">477. total-hamming-distance</a></h4><ul>
<li>给一个int数组，求这些数两两之间的hamming distance之和。hamming distance指的是两个数不同的bit的个数，例如1001和0011就有两位不同。</li>
<li>直接用mask每一个bit地看有多少个数x该位为1，然后x乘一下(N - x)就得到该位不同的数的个数了。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalHammingDistance</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</div><div class="line">            <span class="keyword">int</span> mask = (<span class="number">1</span> &lt;&lt; i);</div><div class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</div><div class="line">                <span class="keyword">if</span> ((nums[j] &amp; mask) != <span class="number">0</span>) &#123;</div><div class="line">                    count++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            ans += (count * (nums.length - count));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="480-sliding-window-median"><a href="#480-sliding-window-median" class="headerlink" title="480. sliding-window-median"></a><a href="https://leetcode.com/problems/sliding-window-median/description/" target="_blank" rel="external">480. sliding-window-median</a></h4><ul>
<li>给一个数组，给一个窗口size = k，从前往后滑动窗口，求每一个范围的median。</li>
<li>用两个PriorityQueue分别维护大根堆（存的是较小的值）和小根堆（存的是较大的值），在往里存元素的时候先尝试往minHeap中存<strong>比堆顶大</strong>的值，不行就直接存入maxHeap。两个堆加起来存够k个元素之后，还需要根据两个堆的size进行调整，因为不一定刚好一半一半。匀完了之后，每次从两个堆中取最大、最小值，再根据size = k决定中位数是直接取中间还是求平均。当窗口往后挪了之后，需要从两个堆的其中一个中删除，PriorityQueue的<code>offer, poll, remove</code>是<code>O(logN)</code>的，<code>contains</code>是<code>O(N)</code>的，<code>retreive peek</code>是<code>O(1)</code>的。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">// 和前面的slidingWindowMax单调队列有点像</span></div><div class="line">    <span class="comment">// 用一个单调队列可以求一个最大值/最小值，那么用两个单调队列维护大根堆和小根堆</span></div><div class="line">    <span class="comment">// 分别取一个元素出来，看看是否需要求平均</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] medianSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        Queue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k, Collections.reverseOrder());</div><div class="line">        Queue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k);</div><div class="line">        </div><div class="line">        <span class="keyword">double</span>[] ans = <span class="keyword">new</span> <span class="keyword">double</span>[nums.length - k + <span class="number">1</span>];</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (i &gt;= k) &#123;</div><div class="line">                <span class="keyword">if</span> (minHeap.contains(nums[i - k])) &#123;</div><div class="line">                    minHeap.remove(nums[i - k]);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    maxHeap.remove(nums[i - k]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (minHeap.size() &gt; <span class="number">0</span> &amp;&amp; nums[i] &gt; minHeap.peek()) &#123;</div><div class="line">                minHeap.add(nums[i]);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                maxHeap.add(nums[i]);</div><div class="line">            &#125;</div><div class="line">            adjustHeaps(maxHeap, minHeap);</div><div class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</div><div class="line">                ans[i - (k - <span class="number">1</span>)] = getMedian(maxHeap, minHeap);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">getMedian</span><span class="params">(Queue&lt;Integer&gt; minHeap, Queue&lt;Integer&gt; maxHeap)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> minHeap.size() == maxHeap.size() ? </div><div class="line">            ((<span class="keyword">double</span>)minHeap.peek() + (<span class="keyword">double</span>)maxHeap.peek()) / <span class="number">2.0</span> : </div><div class="line">            minHeap.size() &gt; maxHeap.size() ? minHeap.peek() : maxHeap.peek();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">adjustHeaps</span><span class="params">(Queue&lt;Integer&gt; maxHeap, Queue&lt;Integer&gt; minHeap)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (Math.abs(maxHeap.size() - minHeap.size()) &gt; <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (maxHeap.size() &gt; minHeap.size()) &#123;</div><div class="line">                minHeap.add(maxHeap.poll());</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                maxHeap.add(minHeap.poll());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="482-license-key-formatting"><a href="#482-license-key-formatting" class="headerlink" title="482. license-key-formatting"></a><a href="https://leetcode.com/problems/license-key-formatting/description/" target="_blank" rel="external">482. license-key-formatting</a></h4><ul>
<li>给一个字符串，只含有数字和字母，再给一个K，将字符以K个为一组组成licenseKey。skip.</li>
</ul>
<h4 id="484-find-permutation"><a href="#484-find-permutation" class="headerlink" title="484. find-permutation"></a><a href="https://leetcode.com/problems/find-permutation/description/" target="_blank" rel="external">484. find-permutation</a></h4><ul>
<li>给一个只有D和I的字符串，表示相邻两个数的大小关系下降和上升。求lexicographical最小的、符合这个升降关系的<code>1~n+1</code>的数组。</li>
<li>贪心做法，先一波升序填进去，然后再对应遍历字符串，对于D就一直往后找连续的D，将这一段reverse即可。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findPermutation(String s) &#123;</div><div class="line">    <span class="keyword">int</span> n = s.length(), arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>]; </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) arr[i] = i + <span class="number">1</span>; <span class="comment">// sorted</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; n; h++) &#123;</div><div class="line">        <span class="keyword">if</span> (s.charAt(h) == <span class="string">'D'</span>) &#123;</div><div class="line">            <span class="keyword">int</span> l = h;</div><div class="line">            <span class="keyword">while</span> (h &lt; n &amp;&amp; s.charAt(h) == <span class="string">'D'</span>) h++;</div><div class="line">            reverse(arr, l, h); </div><div class="line">        &#125;   </div><div class="line">    &#125;   </div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;   </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (l &lt; h) &#123;</div><div class="line">        arr[l] ^= arr[h];   <span class="comment">// 酷炫的异或swap整数</span></div><div class="line">        arr[h] ^= arr[l];</div><div class="line">        arr[l] ^= arr[h];</div><div class="line">        l++; h--;</div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="485-max-consecutive-ones"><a href="#485-max-consecutive-ones" class="headerlink" title="485. max-consecutive-ones"></a><a href="https://leetcode.com/problems/max-consecutive-ones/description/" target="_blank" rel="external">485. max-consecutive-ones</a></h4><ul>
<li>给一个只含有0和1的数组，求最多连续出现1的个数。</li>
<li>用一个lastIndex记录上一个出现的1的位置，然后不断往后遍历数组，如果是1就更新count、否则就把lastIndex更新过来。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>, lastIndex = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">1</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (nums[lastIndex] == <span class="number">0</span>) &#123;</div><div class="line">                    lastIndex = i;</div><div class="line">                &#125;</div><div class="line">                max = Math.max(i - lastIndex + <span class="number">1</span>, max);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                lastIndex = i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="486-predict-the-winner"><a href="#486-predict-the-winner" class="headerlink" title="486. predict-the-winner"></a><a href="https://leetcode.com/problems/predict-the-winner/description/" target="_blank" rel="external">486. predict-the-winner</a></h4><ul>
<li>给一个int数组，两个玩家每次可以从两端任取一个数，轮流取完后比较取出数字之和，谁大谁赢（相等则player 1赢）。判断先选数字的player 1是否稳赢(两个玩家都会走最优)</li>
<li>DP。是否赢需要依赖之前选数字的状态，最终胜负并不在意具体的sum是多少，而是比较两个玩家的sum，因此<code>dp[i][j]</code>存储<code>nums[i...j]</code>中此时选择的玩家会比另一个玩家多多少分。相比上一步，当前玩家可以在两端分别选nums[i]或者nums[j]，每次会选让自己分更多的，即<code>Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]</code>（注意上一步存的是另一个玩家比自己多多少分，因此需要取负）.注意到dp每次只会用到左侧和下侧相邻的cell，<a href="https://leetcode.com/problems/predict-the-winner/discuss/96828/JAVA-9-lines-DP-solution-easy-to-understand-with-improvement-to-O(N" target="_blank" rel="external">可以优化成只用一维数组的dp</a>-space-complexity.)。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> n = nums.length;</div><div class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">            dp[i][i] = nums[i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt; n; len++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - len; i++) &#123;</div><div class="line">                <span class="keyword">int</span> j = i + len;</div><div class="line">                dp[i][j] = Math.max(nums[i] - dp[i + <span class="number">1</span>][j], nums[j] - dp[i][j - <span class="number">1</span>]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>] &gt;= <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="487-max-consecutive-ones-ii"><a href="#487-max-consecutive-ones-ii" class="headerlink" title="487. max-consecutive-ones-ii"></a><a href="https://leetcode.com/problems/max-consecutive-ones-ii/description/" target="_blank" rel="external">487. max-consecutive-ones-ii</a></h4><ul>
<li>给一个只含有0和1的数组，至多可以将一个0 flip成1，求最长连续出现1的个数。</li>
<li><p>利用双指针维护一个至多含有一个0的window，当0过多就移动左指针直到恢复。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>, zeroCount = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>; right &lt; nums.length; right++) &#123;</div><div class="line">            <span class="keyword">if</span> (nums[right] == <span class="number">0</span>) &#123;</div><div class="line">                zeroCount++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">while</span> (zeroCount &gt; <span class="number">1</span>) &#123;   <span class="comment">// 将1改为k即可处理flip k个零的情况</span></div><div class="line">                <span class="keyword">if</span> (nums[left] == <span class="number">0</span>) &#123;</div><div class="line">                    zeroCount--;</div><div class="line">                &#125;</div><div class="line">                left++;</div><div class="line">            &#125;</div><div class="line">            max = Math.max(max, right - left + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>follow-up: 如果输入的数组无法全部存入内存？输入将以stream的形式传入，这样的话就不能直接存放整个数组，可以将零出现的index存入queue，当queue的size超过k的时候就说明window中零的个数过多，此时就将left移到<code>q.poll() + 1</code>即可。</p>
</li>
</ul>
<h4 id="490-the-maze"><a href="#490-the-maze" class="headerlink" title="490. the-maze"></a><a href="https://leetcode.com/problems/the-maze/description/" target="_blank" rel="external">490. the-maze</a></h4><ul>
<li>给一个grid，0表示空地1表示障碍物，一颗球在里面滚动，只有碰到障碍物或者边缘才会停下，给起点和终点坐标判断能否到达。BFS. skip.</li>
</ul>
<h4 id="494-target-sum"><a href="#494-target-sum" class="headerlink" title="494. target-sum"></a><a href="https://leetcode.com/problems/target-sum/description/" target="_blank" rel="external">494. target-sum</a></h4><ul>
<li>给一个只含有非负数的int数组和一个target，给这些int加正号或负号进行求和，求共有多少中加符号的方式使得sum等于target。其中所有数的sum不会超过1000，且数组长度不超过20.</li>
<li>注意到了限制“所有数的sum不会超过1000”，就联想到了木桶法。每个bucket[index]表示和为index有多少种方式，那么读入新的数x时将当前index的数加到[index+x]和[index-x]处即可。注意不可对原数组直接操作。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span> || Math.abs(S) &gt; <span class="number">1000</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">2001</span>];      <span class="comment">// 全部平移1000</span></div><div class="line">        <span class="keyword">int</span>[] bucketTemp = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">2001</span>];</div><div class="line">        bucket[<span class="number">1000</span>] = <span class="number">1</span>;                   <span class="comment">// sum = 0初始有一种情况，即空的输入</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucket.length; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (bucket[j] &gt; <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (nums[i] != <span class="number">0</span>) &#123;</div><div class="line">                        bucketTemp[j - nums[i]] += bucket[j];   <span class="comment">// 以当前值为中心点往两边拓展</span></div><div class="line">                        bucketTemp[j + nums[i]] += bucket[j];</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        bucketTemp[j] = bucket[j] * <span class="number">2</span>;          <span class="comment">// 当前值为0则直接翻倍（+0 / -0）</span></div><div class="line">                    &#125;</div><div class="line">                    bucket[j] = <span class="number">0</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketTemp.length; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (bucketTemp[j] != <span class="number">0</span>) &#123;</div><div class="line">                    bucket[j] = bucketTemp[j];</div><div class="line">                    bucketTemp[j] = <span class="number">0</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> bucket[S + <span class="number">1000</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="496-next-greater-element-i"><a href="#496-next-greater-element-i" class="headerlink" title="496. next-greater-element-i"></a><a href="https://leetcode.com/problems/next-greater-element-i/description/" target="_blank" rel="external">496. next-greater-element-i</a></h4><ul>
<li>给两个int数组，都不含重复元素，求nums1中元素在nums2中的next greater.不存在则设为-1.</li>
<li>首先处理一波nums2，从前往后入栈，每次入栈之前需要判断是否小于栈顶，如果大于了栈顶，说明栈中元素的next greater就是当前元素，用一个map存起来（不含重复元素就可以这样搞），最后遍历nums1的时候直接从map中取就可以了。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</div><div class="line">        <span class="keyword">if</span> (nums1 == <span class="keyword">null</span> || nums2 == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums2) &#123;</div><div class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() &lt; num) &#123;</div><div class="line">                map.put(stack.pop(), num);</div><div class="line">            &#125;</div><div class="line">            stack.push(num);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span> [nums1.length];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</div><div class="line">            ans[i] = map.getOrDefault(nums1[i], -<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="498-diagonal-traverse"><a href="#498-diagonal-traverse" class="headerlink" title="498. diagonal-traverse"></a><a href="https://leetcode.com/problems/diagonal-traverse" target="_blank" rel="external">498. diagonal-traverse</a></h4><ul>
<li>给一个matrix，求蛇形遍历后得到的一维数组。</li>
<li>分情况讨论，向右上遍历的时候可能从上、右侧出去，向左下遍历的时候可能从左、下侧出去，对应调整index即可。pass。</li>
</ul>
<h4 id="499-the-maze-iii"><a href="#499-the-maze-iii" class="headerlink" title="499. the-maze-iii"></a><a href="https://leetcode.com/problems/the-maze-iii/description/" target="_blank" rel="external">499. the-maze-iii</a></h4><ul>
<li>给一个grid，0表示空地1表示障碍物，一颗球在里面滚动，只有碰到障碍物或者边缘才会停下，给起点和终点（和另两题的区别是这是一个洞，球滚到这里就会掉进去）坐标，求最短滚过的格子的路径（用u, d, l, r代替走过的上下左右），若有多个最短路径则取lexicographical更小的那个路径，若无法到达则返回<code>impossible</code>.</li>
<li>和前面第二题相比又需要存多一个path的信息，同时PriorityQueue的比较函数也需要更新当滚过的路程一样长时需要比较String。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Point</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Point</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">int</span> row, col, step;</div><div class="line">        String path;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> step, String path)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.row = row;</div><div class="line">            <span class="keyword">this</span>.col = col;</div><div class="line">            <span class="keyword">this</span>.step = step;</div><div class="line">            <span class="keyword">this</span>.path = path;</div><div class="line">        &#125;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Point that)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.step == that.step ? <span class="keyword">this</span>.path.compareTo(that.path) : <span class="keyword">this</span>.step - that.step;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String IMP = <span class="string">"impossible"</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findShortestWay</span><span class="params">(<span class="keyword">int</span>[][] maze, <span class="keyword">int</span>[] ball, <span class="keyword">int</span>[] hole)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (maze == <span class="keyword">null</span> || maze.length == <span class="number">0</span> || maze[<span class="number">0</span>].length == <span class="number">0</span></div><div class="line">           || ball == <span class="keyword">null</span> || ball.length != <span class="number">2</span></div><div class="line">           || hole == <span class="keyword">null</span> || hole.length != <span class="number">2</span>) &#123;</div><div class="line">            <span class="keyword">return</span> IMP;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> rows = maze.length, cols = maze[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</div><div class="line">        PriorityQueue&lt;Point&gt; q = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</div><div class="line">        q.offer(<span class="keyword">new</span> Point(ball[<span class="number">0</span>], ball[<span class="number">1</span>], <span class="number">0</span>, <span class="string">""</span>));</div><div class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</div><div class="line">            Point curr = q.poll();</div><div class="line">            <span class="keyword">if</span> (curr.row == hole[<span class="number">0</span>] &amp;&amp; curr.col == hole[<span class="number">1</span>]) &#123;</div><div class="line">                <span class="keyword">return</span> curr.path;</div><div class="line">            &#125;</div><div class="line">            visited[curr.row][curr.col] = <span class="keyword">true</span>;</div><div class="line">            </div><div class="line">            Point up = getNext(curr, -<span class="number">1</span>, <span class="number">0</span>, maze, hole);</div><div class="line">            <span class="keyword">if</span> (!visited[up.row][up.col]) &#123;</div><div class="line">                up.path += <span class="string">"u"</span>;</div><div class="line">                q.offer(up);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            Point down = getNext(curr, <span class="number">1</span>, <span class="number">0</span>, maze, hole);</div><div class="line">            <span class="keyword">if</span> (!visited[down.row][down.col]) &#123;</div><div class="line">                down.path += <span class="string">"d"</span>;</div><div class="line">                q.offer(down);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            Point left = getNext(curr, <span class="number">0</span>, -<span class="number">1</span>, maze, hole);</div><div class="line">            <span class="keyword">if</span> (!visited[left.row][left.col]) &#123;</div><div class="line">                left.path += <span class="string">"l"</span>;</div><div class="line">                q.offer(left);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            Point right = getNext(curr, <span class="number">0</span>, <span class="number">1</span>, maze, hole);</div><div class="line">            <span class="keyword">if</span> (!visited[right.row][right.col]) &#123;</div><div class="line">                right.path += <span class="string">"r"</span>;</div><div class="line">                q.offer(right);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> IMP;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> Point <span class="title">getNext</span><span class="params">(Point curr, <span class="keyword">int</span> rowShift, <span class="keyword">int</span> colShift, <span class="keyword">int</span>[][] maze, <span class="keyword">int</span>[] hole)</span> </span>&#123;</div><div class="line">        Point next = <span class="keyword">new</span> Point(curr.row, curr.col, curr.step, curr.path);</div><div class="line">        <span class="keyword">while</span> (next.row + rowShift &gt;= <span class="number">0</span> &amp;&amp; next.row + rowShift &lt; maze.length</div><div class="line">               &amp;&amp; next.col + colShift &gt;= <span class="number">0</span> &amp;&amp; next.col + colShift &lt; maze[<span class="number">0</span>].length</div><div class="line">               &amp;&amp; maze[next.row + rowShift][next.col + colShift] == <span class="number">0</span>) &#123;</div><div class="line">            next.row += rowShift;</div><div class="line">            next.col += colShift;</div><div class="line">            next.step++;</div><div class="line">            <span class="keyword">if</span> (next.row == hole[<span class="number">0</span>] &amp;&amp; next.col == hole[<span class="number">1</span>]) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="503-next-greater-element-ii"><a href="#503-next-greater-element-ii" class="headerlink" title="503. next-greater-element-ii"></a><a href="https://leetcode.com/problems//description/" target="_blank" rel="external">503. next-greater-element-ii</a></h4><ul>
<li>给一个circular数组，求每一个元素的下一个更大的元素的索引，如果不存在则设为-1。例如<code>[1,2,1]</code>返回<code>[2,-1,2]</code>。</li>
<li>这种circular性质的，容易想到直接拼接一段重复的元素到后方，转换成普通数组找后续更大值，时间O(N^2)。此外还能利用stack存放索引，首先从后往前把所有元素都丢进去，然后i还是从后往前遍历原数组并与栈顶索引对应的元素比较，直到小于栈顶时才将栈顶存入结果数组。此时还需要将当前索引push到栈中，因为循环的下一步是往前一个，所以需要将当前的元素存入stack作为最接近的next candidate.<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span> [nums.length];</div><div class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;    <span class="comment">// 从后往前将元素入栈</span></div><div class="line">            stack.push(nums[i]);</div><div class="line">            ans[i] = -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;    <span class="comment">// 从后往前找greater</span></div><div class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[i] &gt;= stack.peek()) &#123;</div><div class="line">                stack.pop();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (!stack.isEmpty()) &#123;</div><div class="line">                ans[i] = stack.peek();</div><div class="line">            &#125;</div><div class="line">            stack.push(nums[i]);  <span class="comment">// 因为下一个要遍历i - 1，所以就直接把i给入栈</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="505-the-maze-ii"><a href="#505-the-maze-ii" class="headerlink" title="505. the-maze-ii"></a><a href="https://leetcode.com/problems/the-maze-ii/description/" target="_blank" rel="external">505. the-maze-ii</a></h4><ul>
<li>给一个grid，0表示空地1表示障碍物，一颗球在里面滚动，只有碰到障碍物或者边缘才会停下，给起点和终点坐标，求最短滚过的格子数，若无法到达则返回-1.</li>
<li>仍然是BFS，只不过此时需要利用PriorityQueue代替传统BFS的Queue，这个PQ的比较函数是将从起点滚过距离最短的放在前面，这样率先到达终点的就一定是最短路径。</li>
</ul>
<h4 id="508-most-frequent-subtree-sum"><a href="#508-most-frequent-subtree-sum" class="headerlink" title="508. most-frequent-subtree-sum"></a><a href="https://leetcode.com/problems/most-frequent-subtree-sum/description/" target="_blank" rel="external">508. most-frequent-subtree-sum</a></h4><ul>
<li>给一个二叉树，求所有subtree sum中出现最频繁的，tie则全都输出。</li>
<li>递归求sum过程中直接用map统计出现次数，最后导出来存入数组返回即可。skip。</li>
</ul>
<h4 id="513-find-bottom-left-tree-value"><a href="#513-find-bottom-left-tree-value" class="headerlink" title="513. find-bottom-left-tree-value"></a><a href="https://leetcode.com/problems/find-bottom-left-tree-value/description/" target="_blank" rel="external">513. find-bottom-left-tree-value</a></h4><ul>
<li>给一个二叉树，求最下面一层最左边的节点。</li>
<li><p>方法一：Iterative，从右往左进行层级遍历，最后一个遍历到的节点就是最下层的最左节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        q.offer(root);</div><div class="line">        TreeNode curr = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</div><div class="line">            curr = q.poll();</div><div class="line">            <span class="keyword">if</span> (curr.right != <span class="keyword">null</span>) &#123;</div><div class="line">                q.offer(curr.right);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (curr.left != <span class="keyword">null</span>) &#123;</div><div class="line">                q.offer(curr.left);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> curr.val;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法二：Recursive, 正常地从左到右前序遍历，但是会track深度，第一个达到新的深度的节点就一定是最左边的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, h = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        find(root, <span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">(TreeNode root, <span class="keyword">int</span> level)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (h &lt; level) &#123;</div><div class="line">            ans = root.val;</div><div class="line">            h = level;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</div><div class="line">            find(root.left, level + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</div><div class="line">            find(root.right, level + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="515-find-largest-value-in-each-tree-row"><a href="#515-find-largest-value-in-each-tree-row" class="headerlink" title="515. find-largest-value-in-each-tree-row"></a><a href="https://leetcode.com/problems/find-largest-value-in-each-tree-row/description/" target="_blank" rel="external">515. find-largest-value-in-each-tree-row</a></h4><ul>
<li>给一个树，返回它每一个level节点的最大值。</li>
<li>层级遍历嘛。DFS和BFS。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    List&lt;Integer&gt; levelMax;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">largestValues</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        levelMax = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        dfsLevelMax(root, <span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> levelMax;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfsLevelMax</span><span class="params">(TreeNode node, <span class="keyword">int</span> level)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        updateLevelMax(node.val, level);</div><div class="line">        dfsLevelMax(node.left, level + <span class="number">1</span>);</div><div class="line">        dfsLevelMax(node.right, level + <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateLevelMax</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> level)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (levelMax.size() == level) &#123;</div><div class="line">            levelMax.add(val);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            levelMax.set(level, Math.max(val, levelMax.get(level)));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="516-longest-palindromic-subsequence"><a href="#516-longest-palindromic-subsequence" class="headerlink" title="516. longest-palindromic-subsequence"></a><a href="https://leetcode.com/problems/longest-palindromic-subsequence/description/" target="_blank" rel="external">516. longest-palindromic-subsequence</a></h4><ul>
<li>给一个字符串，求其中最长的自对称的subsequence（顺序与原字符串一样但不一定是连续的）的长度。例如<code>bbbab</code>最长为4（<code>bbbb</code>）。</li>
<li>DP。和647一样也是从后往前更新DP数组，<code>dp[i][j]</code>表示从i到j（inclusive）的最长长度。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">char</span>[] sChar = s.toCharArray();</div><div class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span> [sChar.length][sChar.length];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = sChar.length - <span class="number">1</span>; row &gt;= <span class="number">0</span>; row--) &#123;     <span class="comment">// 从最后一个字符往前更新</span></div><div class="line">            dp[row][row] = <span class="number">1</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = row + <span class="number">1</span>; col &lt; sChar.length; col++) &#123;</div><div class="line">                <span class="keyword">if</span> (sChar[row] == sChar[col]) &#123;</div><div class="line">                    dp[row][col] = <span class="number">2</span> + dp[row + <span class="number">1</span>][col - <span class="number">1</span>];    <span class="comment">// 取中间夹的部分的最长长度加上头尾两个</span></div><div class="line">                    <span class="comment">// compare prev or adding curr palindrome. no worry about exceeding boundary</span></div><div class="line">                &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 不取当前字符</span></div><div class="line">                    dp[row][col] = Math.max(dp[row][col - <span class="number">1</span>], dp[row + <span class="number">1</span>][col]);    <span class="comment">// keep at previous one</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][sChar.length - <span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="518-coin-change-2"><a href="#518-coin-change-2" class="headerlink" title="518. coin-change-2"></a><a href="https://leetcode.com/problems/coin-change-2/description/" target="_blank" rel="external">518. coin-change-2</a></h4><ul>
<li>给一个数组表示有哪些面额的硬币，每个面额的硬币有无限多个可以任取。给定一个目标值，求总共有多少种组合方式。</li>
<li>DP。和前面的那个硬币题类似，这里dp[i]表示达到i这个值有多少组合方式。如果当前硬币的面额是x，则dp[i] = dp[i] + dp[i - x].<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (amount == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (coins == <span class="keyword">null</span> || coins.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// dp[amount]表示凑成amount有几种ways</span></div><div class="line">        <span class="comment">// 对于每个dp[i + coin] = dp[i + coin] + dp[i]</span></div><div class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span> [amount + <span class="number">1</span>];</div><div class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coins.length; i++) &#123;    <span class="comment">// 固定coin值遍历所有可能值</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dp.length; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (j &gt;= coins[i]) &#123;</div><div class="line">                    dp[j] += dp[j - coins[i]];  <span class="comment">// 从j - coins[i]增加到j</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dp[amount];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="523-continuous-subarray-sum"><a href="#523-continuous-subarray-sum" class="headerlink" title="523. continuous-subarray-sum"></a><a href="https://leetcode.com/problems/continuous-subarray-sum/description/" target="_blank" rel="external">523. continuous-subarray-sum</a></h4><ul>
<li>给一个非负int数组和一个非负整数k，判断是否含有长度大于等于2的连续subarray whose sum是k的multiple。可以保证将原数组所有数加起来不会爆int。</li>
<li>方法一：暴力法，求膜的方式O(N^2)两重循环求sum。</li>
<li>方法二：求是否含有一部分使得sum是n*k，那么如果利用Map记录sum对应的索引，一路往后加x%k，当出现前面已经存在的sum的时候，说明这一路加的x刚好膜k得到0，即为k的倍数。注意需要特殊处理0，不可以膜0.<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkSubarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 记录得到当前sum对应的索引</span></div><div class="line">        Map&lt;Integer, Integer&gt; sum2Index = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        sum2Index.put(<span class="number">0</span>, -<span class="number">1</span>);</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</div><div class="line">            sum += nums[i];</div><div class="line">            <span class="keyword">if</span> (k != <span class="number">0</span>) &#123;</div><div class="line">                sum %= k;   <span class="comment">// 膜来处理倍数问题</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (sum2Index.containsKey(sum)) &#123;   <span class="comment">// 说明膜了一波等于0，中间可能有k的倍数</span></div><div class="line">                <span class="keyword">if</span> (i - sum2Index.get(sum) &gt; <span class="number">1</span>) &#123;   <span class="comment">// 注意需要长度大于等于2</span></div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                sum2Index.put(sum, i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="524-longest-word-in-dictionary-through-deleting"><a href="#524-longest-word-in-dictionary-through-deleting" class="headerlink" title="524. longest-word-in-dictionary-through-deleting"></a><a href="https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/description/" target="_blank" rel="external">524. longest-word-in-dictionary-through-deleting</a></h4><ul>
<li>给一个字符串s，给一个单词List，求将s中部分字母删除后能得到的最长的在List中的单词，若长度相等则取lexicographical更短的。</li>
<li>遍历List中的单词，与s比较看是否是subsequence。基本是暴力做法，只不过prune掉了一些情况，只有当candidate比之前的结果更长或者lexicographical order更前才会计算。还有一种做法是先对List进行排序，长度长的在前、字典序小的在前，然后再直接遍历List，第一个subsequence即为所求。</li>
</ul>
<h4 id="525-contiguous-array"><a href="#525-contiguous-array" class="headerlink" title="525. contiguous-array"></a><a href="https://leetcode.com/problems/contiguous-array/description/" target="_blank" rel="external">525. contiguous-array</a></h4><ul>
<li>给一个只含0,1的int数组，求最长subarray的长度使得其中的0,1个数相等。</li>
<li>方法一：暴力破解，固定start和end依次看当前窗口的0,1个数。O(N^2)超时。</li>
<li>方法二：既然需要的是0,1相等的个数而不关心具体位置／顺序，也就是如果经过一波操作之后0和1的个数差回到原点，说明一波操作没有造成什么后果，也就是0，1个数相等。或者更近一步，将0先一波流替换成-1，这样只要sum为0就意味着相等，而且如果当前的sum在之前出现过，说明经过一波操作又回到原点，那么-1,1的个数也是相等的。因此想到用map记录sum出现的各个位置，只记录最早出现的位置，这样一旦后面出现了这个sum就可以求得最长长度了。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</div><div class="line">                nums[i] = -<span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        Map&lt;Integer, Integer&gt; sum2Index = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        sum2Index.put(<span class="number">0</span>, -<span class="number">1</span>);</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, maxLen = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</div><div class="line">            sum += nums[i];</div><div class="line">            <span class="keyword">if</span> (sum2Index.containsKey(sum)) &#123;</div><div class="line">                maxLen = Math.max(maxLen, i - sum2Index.get(sum));</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                sum2Index.put(sum, i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxLen;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="528-random-pick-with-weight"><a href="#528-random-pick-with-weight" class="headerlink" title="528. random-pick-with-weight"></a><a href="https://leetcode.com/problems/random-pick-with-weight/" target="_blank" rel="external">528. random-pick-with-weight</a></h4><ul>
<li>给一个只含有正整数的数组，表示该index所占的权重，实现一个随机生成器按照这个权重来取对应的索引。</li>
<li>利用一个累加数组，将所有权重累加起来。然后根据总和生成随机数，再利用二分查找看看这个数应该落在哪个权重和的区间内，就可以取对应的索引了。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    Random r;</div><div class="line">    <span class="keyword">int</span>[] sums;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span>[] w)</span> </span>&#123;</div><div class="line">        r = <span class="keyword">new</span> Random();</div><div class="line">        sums = <span class="keyword">new</span> <span class="keyword">int</span>[w.length];</div><div class="line">        sums[<span class="number">0</span>] = w[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; w.length; i++) &#123;</div><div class="line">            sums[i] = sums[i - <span class="number">1</span>] + w[i];   <span class="comment">// 累加数组</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pickIndex</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> target = r.nextInt(sums[sums.length - <span class="number">1</span>]) + <span class="number">1</span>;  <span class="comment">// 在1～最终累加和之间取随机数</span></div><div class="line">        <span class="keyword">return</span> binarySearchInsertPos(sums, target);         <span class="comment">// 找随机数所处的区间</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearchInsertPos</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> left = -<span class="number">1</span>, right = nums.length;</div><div class="line">        <span class="keyword">while</span> (right - left &gt; <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</div><div class="line">                right = mid;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                left = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> right;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></div><div class="line"><span class="comment"> * Solution obj = new Solution(w);</span></div><div class="line"><span class="comment"> * int param_1 = obj.pickIndex();</span></div><div class="line"><span class="comment"> */</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="529-minesweeper"><a href="#529-minesweeper" class="headerlink" title="529. minesweeper"></a><a href="https://leetcode.com/problems/minesweeper/description/" target="_blank" rel="external">529. minesweeper</a></h4><ul>
<li>点击一个位置，根据是否有雷更新棋盘。如果是雷，直接改成叉叉并返回；如果没有点开并且周围八个相邻格子有雷，则改成雷的数目并返回；如果周围都没有雷，就扩散到相邻格子继续更新。</li>
<li><p>方法一：根据描述本身就蕴含了递归，所以自然想到DFS。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[][] updateBoard(<span class="keyword">char</span>[][] board, <span class="keyword">int</span>[] click) &#123;</div><div class="line">        <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span></div><div class="line">           || click == <span class="keyword">null</span> || click.length &lt; <span class="number">2</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">char</span> [<span class="number">0</span>][<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> rowCount = board.length, colCount = board[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">int</span> row = click[<span class="number">0</span>], col = click[<span class="number">1</span>];</div><div class="line">        <span class="keyword">if</span> (board[row][col] == <span class="string">'B'</span>) &#123;   <span class="comment">// 已经点开了就直接返回</span></div><div class="line">            <span class="keyword">return</span> board;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (board[row][col] == <span class="string">'M'</span>) &#123;   <span class="comment">// 是雷就gg</span></div><div class="line">            board[row][col] = <span class="string">'X'</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;              <span class="comment">// 计算雷的个数</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = -<span class="number">1</span>; i &lt; <span class="number">2</span>; i++) &#123;</div><div class="line">                <span class="keyword">int</span> tempRow = row + i;</div><div class="line">                <span class="keyword">if</span> (tempRow &lt; <span class="number">0</span> || tempRow &gt;= rowCount) &#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = -<span class="number">1</span>; j &lt; <span class="number">2</span>; j++) &#123;</div><div class="line">                    <span class="keyword">int</span> tempCol = col + j;</div><div class="line">                    <span class="keyword">if</span> (tempCol &lt; <span class="number">0</span> || tempCol &gt;= colCount) &#123;</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (board[tempRow][tempCol] == <span class="string">'M'</span>) &#123;</div><div class="line">                        count++;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</div><div class="line">                board[row][col] = (<span class="keyword">char</span>)(<span class="string">'0'</span> + count);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                board[row][col] = <span class="string">'B'</span>;      <span class="comment">// 改为已经reveal，并扩散到周围unreveal的邻居</span></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = -<span class="number">1</span>; i &lt; <span class="number">2</span>; i++) &#123;</div><div class="line">                    <span class="keyword">int</span> tempRow = row + i;</div><div class="line">                    <span class="keyword">if</span> (tempRow &lt; <span class="number">0</span> || tempRow &gt;= rowCount) &#123;</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = -<span class="number">1</span>; j &lt; <span class="number">2</span>; j++) &#123;</div><div class="line">                        <span class="keyword">int</span> tempCol = col + j;</div><div class="line">                        <span class="keyword">if</span> (tempCol &lt; <span class="number">0</span> || tempCol &gt;= colCount) &#123;</div><div class="line">                            <span class="keyword">continue</span>;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">if</span> (board[tempRow][tempCol] == <span class="string">'E'</span>) &#123;   <span class="comment">// DFS the unrevealed</span></div><div class="line">                            updateBoard(board, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;tempRow, tempCol&#125;);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> board;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法二：BFS，Queue中存放点击之后扩散的点（如果有的话），一直扩散直到Queue为空。但是和DFS需要区别的是，由于BFS会将相邻的所有E的格子都入队，很可能会出现重复，所以就直接在更新时就赋值为B，防止重复入队。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[][] updateBoard(<span class="keyword">char</span>[][] board, <span class="keyword">int</span>[] click) &#123;</div><div class="line">        <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span></div><div class="line">           || click == <span class="keyword">null</span> || click.length &lt; <span class="number">2</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">char</span> [<span class="number">0</span>][<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> rowCount = board.length, colCount = board[<span class="number">0</span>].length;</div><div class="line">        q.add(click);</div><div class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</div><div class="line">            <span class="keyword">int</span>[] curr = q.poll();</div><div class="line">            <span class="keyword">int</span> row = curr[<span class="number">0</span>], col = curr[<span class="number">1</span>];   <span class="comment">// 和DFS相比少了判断为B的步骤</span></div><div class="line">            <span class="keyword">if</span> (board[row][col] == <span class="string">'M'</span>) &#123;</div><div class="line">                board[row][col] = <span class="string">'X'</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = -<span class="number">1</span>; i &lt; <span class="number">2</span>; i++) &#123;</div><div class="line">                    <span class="keyword">int</span> tempRow = row + i;</div><div class="line">                    <span class="keyword">if</span> (tempRow &lt; <span class="number">0</span> || tempRow &gt;= rowCount) &#123;</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = -<span class="number">1</span>; j &lt; <span class="number">2</span>; j++) &#123;</div><div class="line">                        <span class="keyword">int</span> tempCol = col + j;</div><div class="line">                        <span class="keyword">if</span> (tempCol &lt; <span class="number">0</span> || tempCol &gt;= colCount) &#123;</div><div class="line">                            <span class="keyword">continue</span>;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">if</span> (board[tempRow][tempCol] == <span class="string">'M'</span>) &#123;</div><div class="line">                            count++;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</div><div class="line">                    board[row][col] = (<span class="keyword">char</span>)(<span class="string">'0'</span> + count);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    board[row][col] = <span class="string">'B'</span>;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = -<span class="number">1</span>; i &lt; <span class="number">2</span>; i++) &#123;</div><div class="line">                        <span class="keyword">int</span> tempRow = row + i;</div><div class="line">                        <span class="keyword">if</span> (tempRow &lt; <span class="number">0</span> || tempRow &gt;= rowCount) &#123;</div><div class="line">                            <span class="keyword">continue</span>;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = -<span class="number">1</span>; j &lt; <span class="number">2</span>; j++) &#123;</div><div class="line">                            <span class="keyword">int</span> tempCol = col + j;</div><div class="line">                            <span class="keyword">if</span> (tempCol &lt; <span class="number">0</span> || tempCol &gt;= colCount) &#123;</div><div class="line">                                <span class="keyword">continue</span>;</div><div class="line">                            &#125;</div><div class="line">                            <span class="keyword">if</span> (board[tempRow][tempCol] == <span class="string">'E'</span>) &#123;   <span class="comment">// BFS the unrevealed</span></div><div class="line">                                q.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;tempRow, tempCol&#125;);</div><div class="line">                                board[tempRow][tempCol] = <span class="string">'B'</span>;  <span class="comment">// IMPORTANT!!!</span></div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> board;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="535-encode-and-decode-tinyurl"><a href="#535-encode-and-decode-tinyurl" class="headerlink" title="535. encode-and-decode-tinyurl"></a><a href="https://leetcode.com/problems/encode-and-decode-tinyurl/description/" target="_blank" rel="external">535. encode-and-decode-tinyurl</a></h4><ul>
<li>实现一个含有encode和decode方法的类，能够转码和解码tinyURL。</li>
<li>这种映射关系必定需要Map，关键是如何建立这种从长到短的映射？利用随机数随机从一长串字符串中取字符，取够6个即形成了短码。如果这个短码已经存在，就需要再来一次生成新的短码，直到出现新的。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HOST = <span class="string">"http://tinyurl.com/"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CHAR = <span class="string">"abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIMIT = CHAR.length();</div><div class="line">    </div><div class="line">    Map&lt;String, String&gt; url2tiny = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    Map&lt;String, String&gt; tiny2url = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    </div><div class="line">    <span class="comment">// Encodes a URL to a shortened URL.</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">encode</span><span class="params">(String longUrl)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (url2tiny.containsKey(longUrl)) &#123;</div><div class="line">            <span class="keyword">return</span> HOST + url2tiny.get(longUrl);</div><div class="line">        &#125;</div><div class="line">        String ret = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</div><div class="line">                <span class="keyword">int</span> index = (<span class="keyword">int</span>) (Math.random() * LIMIT);</div><div class="line">                sb.append(CHAR.charAt(index));</div><div class="line">            &#125;</div><div class="line">            ret = sb.toString();</div><div class="line">        &#125; <span class="keyword">while</span> (tiny2url.containsKey(ret));</div><div class="line">        </div><div class="line">        url2tiny.put(longUrl, ret);</div><div class="line">        tiny2url.put(ret, longUrl);</div><div class="line">        <span class="keyword">return</span> HOST + ret;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Decodes a shortened URL to its original URL.</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decode</span><span class="params">(String shortUrl)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> tiny2url.get(shortUrl.replace(HOST, <span class="string">""</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></div><div class="line"><span class="comment">// Codec codec = new Codec();</span></div><div class="line"><span class="comment">// codec.decode(codec.encode(url));</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="536-construct-binary-tree-from-string"><a href="#536-construct-binary-tree-from-string" class="headerlink" title="536. construct-binary-tree-from-string"></a><a href="https://leetcode.com/problems/construct-binary-tree-from-string/" target="_blank" rel="external">536. construct-binary-tree-from-string</a></h4><ul>
<li>给一个由数字、<code>-</code>、括号组成的字符串，将它还原成一个二叉树，注意空树由<code>&quot;&quot;</code>表示而不是<code>()</code>。一开始完全无法理解<code>-</code>是干啥的，原来只是用来表示负数，囧。</li>
<li><p>方法一：看到这种括号嵌套就想到利用stack，到<code>(</code>直接忽略，碰到数字或者<code>-</code>则将这个value提取出来后，再看看栈顶节点是否已经有left/right，对应添加上去后再入栈，这样就可以保证后续的孩子节点能够继续连到当前节点，碰到<code>)</code>则说明栈顶节点已经处理完毕，直接弹出即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">str2tree</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</div><div class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span>) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">')'</span>) &#123;</div><div class="line">            stack.pop();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">int</span> start = i;</div><div class="line">            <span class="keyword">while</span> (i &lt; s.length() &amp;&amp; </div><div class="line">                    (Character.isDigit(s.charAt(i)) || s.charAt(i) == <span class="string">'-'</span>)) &#123;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            TreeNode curr = <span class="keyword">new</span> TreeNode(Integer.valueOf(s.substring(start, i)));</div><div class="line">            <span class="keyword">if</span> (!stack.isEmpty()) &#123;</div><div class="line">                <span class="keyword">if</span> (stack.peek().left == <span class="keyword">null</span>) &#123;</div><div class="line">                    stack.peek().left = curr;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    stack.peek().right = curr;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            stack.push(curr);</div><div class="line">            i--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> stack.pop();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法二：更自然的是想到递归，但是这样就不是one-pass的，因为每次需要根据括号的情况找到后续节点对应的字符串，需要不断地count括号，比如<a href="https://leetcode.com/problems/construct-binary-tree-from-string/discuss/100357/Verbose-Java-Solution-Recursion" target="_blank" rel="external">这个</a>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">str2tree</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (i &lt; s.length() &amp;&amp; (Character.isDigit(s.charAt(i)) || s.charAt(i) == <span class="string">'-'</span>)) &#123;</div><div class="line">        i++;</div><div class="line">    &#125;</div><div class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(Integer.valueOf(s.substring(<span class="number">0</span>, i++)));   <span class="comment">// 挪到下一个位置</span></div><div class="line">    <span class="keyword">int</span> count = <span class="number">1</span>, start = i;</div><div class="line">    <span class="keyword">while</span> (i &lt; s.length() &amp;&amp; count &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span>) &#123;</div><div class="line">            count++;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">')'</span>) &#123;</div><div class="line">            count--;</div><div class="line">        &#125;</div><div class="line">        i++;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 此时i指向字符末尾或者(</span></div><div class="line">    <span class="keyword">if</span> (start &lt; i - <span class="number">1</span>) &#123;   <span class="comment">// 取start到i-1部分作为前半部分</span></div><div class="line">        root.left = str2tree(s.substring(start, i - <span class="number">1</span>));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (i + <span class="number">1</span> &lt; s.length() - <span class="number">1</span>) &#123;  <span class="comment">// 取(的后一个字符到)之前的字符</span></div><div class="line">        root.right = str2tree(s.substring(i + <span class="number">1</span>, s.length() - <span class="number">1</span>));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> root;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="540-single-element-in-a-sorted-array"><a href="#540-single-element-in-a-sorted-array" class="headerlink" title="540. single-element-in-a-sorted-array"></a><a href="https://leetcode.com/problems/single-element-in-a-sorted-array/description/" target="_blank" rel="external">540. single-element-in-a-sorted-array</a></h4><ul>
<li>给一个排好序的数组，每个数字都出现了两次except其中一个，求这个毒瘤。要求时间复杂度O(logN)，空间(1).</li>
<li>二分查找，利用pair的特性，以偶数index与下一个元素为判断依据，若元素相等说明毒瘤出现在后半部分，若不想等说明出现在前面。edge case需要考虑单独元素出现在数组首位和末尾的情况。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNonDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (right &gt; left) &#123;</div><div class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span> (mid % <span class="number">2</span> == <span class="number">1</span>) &#123;</div><div class="line">                mid--;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (nums[mid] == nums[mid + <span class="number">1</span>]) &#123;</div><div class="line">                left = mid + <span class="number">2</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                right = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> nums[left];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="543-diameter-of-binary-tree"><a href="#543-diameter-of-binary-tree" class="headerlink" title="543. diameter-of-binary-tree"></a><a href="https://leetcode.com/problems/diameter-of-binary-tree/description/" target="_blank" rel="external">543. diameter-of-binary-tree</a></h4><ul>
<li>Zillow面试题刻骨铭心。给一个二叉树，求其中任意两个节点的path距离中最长长度。例如下面的树就有<code>4-2-1-3</code>和<code>5-2-1-3</code>两个最长路径，都是3.</li>
<li>对于当前节点有取和不取两种情况（但），取根则等于左深度加右深度，不取则在往下求深度的时候就可以顺便用一个全局变量去更新，时间复杂度就为O(N)了。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        getMaxDepth(root);</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMaxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> left = getMaxDepth(root.left);</div><div class="line">        <span class="keyword">int</span> right = getMaxDepth(root.right);</div><div class="line">        </div><div class="line">        max = Math.max(max, left + right);  <span class="comment">// 取根的情况</span></div><div class="line">        <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;   <span class="comment">// 求深度</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="545-boundary-of-binary-tree"><a href="#545-boundary-of-binary-tree" class="headerlink" title="545. boundary-of-binary-tree"></a><a href="https://leetcode.com/problems/boundary-of-binary-tree/description/" target="_blank" rel="external">545. boundary-of-binary-tree</a></h4><ul>
<li>给一个二叉树，求它从左到下方到右的所有boundary的元素。</li>
<li><p>方法一：根据定义来写，则是老老实实先把所有左边界找出来、再把叶子节点找出来、再把右边界节点找出来。需要注意的是在遍历左边界时遵循preorder，当所有的左侧叶子节点都遍历完了再重新潜入一次找所有最下方节点（叶子节点），找完所有叶子结点之后再开始遍历右边界节点，遵循postorder.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> List&lt;Integer&gt; nodes;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">boundaryOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> nodes;</div><div class="line">        &#125;</div><div class="line">        nodes.add(root.val);</div><div class="line">        traverseLeftBoundary(root.left);</div><div class="line">        traverseLeaves(root.left);</div><div class="line">        traverseLeaves(root.right);</div><div class="line">        traverseRightBoundary(root.right);</div><div class="line">        <span class="keyword">return</span> nodes;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traverseLeftBoundary</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        nodes.add(root.val);</div><div class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</div><div class="line">            traverseLeftBoundary(root.left);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            traverseLeftBoundary(root.right);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traverseRightBoundary</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</div><div class="line">            traverseRightBoundary(root.right);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            traverseRightBoundary(root.left);</div><div class="line">        &#125;</div><div class="line">        nodes.add(root.val);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traverseLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</div><div class="line">            nodes.add(root.val);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            traverseLeaves(root.left);</div><div class="line">            traverseLeaves(root.right);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法二：如何one-pass只遍历一次呢？在潜入的时候其实就已经知道节点的身份了：若当前节点是左边界，潜入左child时肯定还是左边界；右边界亦然。若当前节点是左边界，潜入右child时，若左child是null，则当前继续是左边界，也就是一个AND的关系。若当前节点是右边界，潜入左child时，若右child为null，则继续时右边界。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">boundaryOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> ans;</div><div class="line">        &#125;</div><div class="line">        ans.add(root.val);</div><div class="line">        dfs(root.left, <span class="keyword">true</span>, <span class="keyword">false</span>, ans);</div><div class="line">        dfs(root.right, <span class="keyword">false</span>, <span class="keyword">true</span>, ans);</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">boolean</span> isLeft, <span class="keyword">boolean</span> isRight, List&lt;Integer&gt; ans)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (isLeft) &#123;</div><div class="line">            ans.add(root.val);</div><div class="line">        &#125;</div><div class="line">        dfs(root.left, isLeft, isRight &amp;&amp; root.right == <span class="keyword">null</span>, ans);</div><div class="line">        <span class="keyword">if</span> (!isLeft &amp;&amp; !isRight &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</div><div class="line">            ans.add(root.val);</div><div class="line">        &#125;</div><div class="line">        dfs(root.right, isLeft &amp;&amp; root.left == <span class="keyword">null</span>, isRight, ans);</div><div class="line">        <span class="keyword">if</span> (isRight) &#123;</div><div class="line">            ans.add(root.val);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="548-split-array-with-equal-sum"><a href="#548-split-array-with-equal-sum" class="headerlink" title="548. split-array-with-equal-sum"></a><a href="https://leetcode.com/problems/split-array-with-equal-sum/description/" target="_blank" rel="external">548. split-array-with-equal-sum</a></h4><ul>
<li>给一个int数组，判断是否存在三个分割点i, j, k使得被这三个点分割出来的四个部分（不包含分割点）的sum相等。</li>
<li><p>方法一：类似于4sum，利用Set存储在之前出现过的相等的sum，然后固定中间点j，遍历可能的i，将前面两部分相等的sum存入set，然后遍历后半部分k，若也存在两部分相等的和且set中存在，则说明确实可以分成四个相等的部分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">splitArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">7</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] sum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</div><div class="line">        sum[<span class="number">0</span>] = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</div><div class="line">            sum[i] = sum[i - <span class="number">1</span>] + nums[i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">3</span>; j + <span class="number">3</span> &lt; nums.length; j++) &#123;</div><div class="line">            Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + <span class="number">1</span> &lt; j; i++) &#123;</div><div class="line">                <span class="keyword">int</span> sumBeforeI = sum[i - <span class="number">1</span>];</div><div class="line">                <span class="keyword">int</span> sumItoJ = sum[j - <span class="number">1</span>] - sum[i];</div><div class="line">                <span class="keyword">if</span> (sumBeforeI == sumItoJ) &#123;</div><div class="line">                    set.add(sumBeforeI);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>; k + <span class="number">1</span> &lt; nums.length; k++) &#123;</div><div class="line">                <span class="keyword">int</span> sumJtoK = sum[k - <span class="number">1</span>] - sum[j];</div><div class="line">                <span class="keyword">int</span> sumAfterK = sum[nums.length - <span class="number">1</span>] - sum[k];</div><div class="line">                <span class="keyword">if</span> (sumJtoK == sumAfterK &amp;&amp; set.contains(sumJtoK)) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>DFS也可破。枚举所有可能的part sum，然后dfs到后续部分判断是否可以根据这个part sum恰好得到四个部分。注意为了避免无效DFS，需要ignore连续出现的0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">splitArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">7</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> sum = IntStream.of(nums).sum();</div><div class="line">        <span class="keyword">return</span> dfs(nums, <span class="number">0</span>, <span class="number">0</span>, sum, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> target, <span class="keyword">int</span> sumRemain, <span class="keyword">int</span> depth)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (depth == <span class="number">3</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (target == sumRemain)</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> currSum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i + <span class="number">5</span> - (<span class="number">2</span> * depth) &lt; nums.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (i != <span class="number">1</span> &amp;&amp; nums[i - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; nums[i] == <span class="number">0</span>) &#123;       <span class="comment">// 忽略连续出现的0</span></div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            currSum += nums[i - <span class="number">1</span>];</div><div class="line">            <span class="keyword">if</span> ((depth == <span class="number">0</span> || currSum == target)</div><div class="line">                &amp;&amp; dfs(nums, i + <span class="number">1</span>, currSum, sumRemain - currSum - nums[i], depth + <span class="number">1</span>)) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="549-binary-tree-longest-consecutive-sequence-ii"><a href="#549-binary-tree-longest-consecutive-sequence-ii" class="headerlink" title="549. binary-tree-longest-consecutive-sequence-ii"></a><a href="https://leetcode.com/problems/binary-tree-longest-consecutive-sequence-ii/description/" target="_blank" rel="external">549. binary-tree-longest-consecutive-sequence-ii</a></h4><ul>
<li>给一个二叉树，求其中路径最长的连续increasing或decreasing的长度，这个路径不一定是parent-child的，怎么上下左右都行，只要是连续即可。</li>
<li>不论怎么弯折，对于每一个节点来说其实就是看和孩子能否形成increase和decrease，可以则加一下就是一个弯折的路径了。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        helper(root);</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] helper(TreeNode root) &#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] left = helper(root.left), right = helper(root.right);</div><div class="line">        <span class="keyword">int</span> inc = <span class="number">1</span>, dec = <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (root.left.val == root.val + <span class="number">1</span>) &#123;   <span class="comment">// 确认是否能和孩子形成升序/降序列</span></div><div class="line">                inc = left[<span class="number">0</span>] + <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (root.left.val == root.val - <span class="number">1</span>) &#123;</div><div class="line">                dec = left[<span class="number">1</span>] + <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (root.right.val == root.val + <span class="number">1</span>) &#123;</div><div class="line">                inc = Math.max(inc, right[<span class="number">0</span>] + <span class="number">1</span>);  <span class="comment">// 取左右中最大的</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (root.right.val == root.val - <span class="number">1</span>) &#123;</div><div class="line">                dec = Math.max(dec, right[<span class="number">1</span>] + <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        max = Math.max(inc + dec - <span class="number">1</span>, max);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;inc, dec&#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="554-brick-wall"><a href="#554-brick-wall" class="headerlink" title="554. brick-wall"></a><a href="https://leetcode.com/problems/brick-wall/description/" target="_blank" rel="external">554. brick-wall</a></h4><ul>
<li>给一个二维List表示每一行每一块砖各自的长度。求纵向切下来最少穿过的墙的个数。</li>
<li>最少的穿过的个数也就是求穿过最多缝隙的个数，也就事给定一个结束长度，最多的那个即为所求。用Map记录每一行的累加的结尾长度，不断更新最多的那个长度，最后wall的行数减去count即可。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leastBricks</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; wall)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (wall == <span class="keyword">null</span> || wall.size() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; list : wall) &#123;</div><div class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size() - <span class="number">1</span>; i++) &#123;</div><div class="line">                len += list.get(i);</div><div class="line">                map.put(len, map.getOrDefault(len, <span class="number">0</span>) + <span class="number">1</span>); <span class="comment">// 求对应长度结尾的墙有多少</span></div><div class="line">                count = Math.max(count, map.get(len));      <span class="comment">// 更新以len结尾的最多的</span></div><div class="line">                <span class="keyword">if</span> (count == wall.size()) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> wall.size() - count;     <span class="comment">// 减一下就是穿过墙最少的</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="556-next-greater-element-iii"><a href="#556-next-greater-element-iii" class="headerlink" title="556. next-greater-element-iii"></a><a href="https://leetcode.com/problems/next-greater-element-iii/description/" target="_blank" rel="external">556. next-greater-element-iii</a></h4><ul>
<li>给一个32bit的正整数，求十进制中相同数字组成的下一个更大值。例如<code>12</code>的下一个就是<code>21</code>，<code>1342</code>则是<code>1423</code>。</li>
<li>若已经是最大的可能值？（返回-1）</li>
<li>对输入的数字从后往前遍历，找到连续的两个数字使得前面的（<code>i - 1</code>）小于后面的（<code>i</code>），然后再从<code>i + 1</code>开始往后找最小的大于<code>i - 1</code>的数字，互换他俩，最后从i开始往后从小到大排个序即可。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextGreaterElement</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        String s = String.valueOf(n);</div><div class="line">        <span class="keyword">char</span>[] sChar = s.toCharArray();</div><div class="line">        <span class="keyword">int</span> i = sChar.length - <span class="number">1</span>;   <span class="comment">// 从后往前</span></div><div class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (sChar[i - <span class="number">1</span>] &lt; sChar[i]) &#123;      <span class="comment">// 找到第一个连续的顺序对</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            i--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;       <span class="comment">// 到最后都没找到</span></div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> j = i + <span class="number">1</span>, minIndex = i;</div><div class="line">        <span class="keyword">char</span> first = sChar[i - <span class="number">1</span>];</div><div class="line">        <span class="keyword">while</span> (j &lt; sChar.length) &#123;      <span class="comment">// 从i + 1开始从前往后不断更新最小的大于i - 1的元素</span></div><div class="line">            <span class="keyword">if</span> (sChar[j] &lt;= sChar[minIndex] &amp;&amp; sChar[j] &gt; first) &#123;</div><div class="line">                minIndex = j;</div><div class="line">            &#125;</div><div class="line">            j++;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        sChar[i - <span class="number">1</span>] = sChar[minIndex];     <span class="comment">// 交换该ceiling值和i - 1</span></div><div class="line">        sChar[minIndex] = first;</div><div class="line">        </div><div class="line">        Arrays.sort(sChar, i, sChar.length);    <span class="comment">// 从i开始拍个序</span></div><div class="line">        <span class="keyword">long</span> ans = Long.valueOf(<span class="keyword">new</span> String(sChar));</div><div class="line">        <span class="keyword">return</span> ans &gt; Integer.MAX_VALUE? -<span class="number">1</span>: (<span class="keyword">int</span>)ans;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="560-subarray-sum-equals-k"><a href="#560-subarray-sum-equals-k" class="headerlink" title="560. subarray-sum-equals-k"></a><a href="https://leetcode.com/problems/subarray-sum-equals-k/description/" target="_blank" rel="external">560. subarray-sum-equals-k</a></h4><ul>
<li>给一个int数组和一个k，问有多少连续的subarray之和等于k。这些int都在<code>[-1000, 1000]</code>，数组长度最多20000。</li>
<li>一开始想用双指针，但有正有负，更新条件不好搞。正解是使用Map，在计算sum的时候顺便看看之前是否出现过sum - k。这其实和path sum III 很像，都是利用prefix sum.<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        map.put(<span class="number">0</span>, <span class="number">1</span>);</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</div><div class="line">            sum += nums[i];</div><div class="line">            <span class="keyword">if</span> (map.containsKey(sum - k)) &#123;     <span class="comment">// 看之前是否已经出现了</span></div><div class="line">                count += map.get(sum - k);</div><div class="line">            &#125;</div><div class="line">            map.put(sum, map.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="562-longest-line-of-consecutive-one-in-matrix"><a href="#562-longest-line-of-consecutive-one-in-matrix" class="headerlink" title="562. longest-line-of-consecutive-one-in-matrix"></a><a href="https://leetcode.com/problems/longest-line-of-consecutive-one-in-matrix/description/" target="_blank" rel="external">562. longest-line-of-consecutive-one-in-matrix</a></h4><ul>
<li>给一个只含有0和1的二维数组，求横、竖、两个斜对角的连续出现1的最长长度。</li>
<li><p>方法一：O(N^2)从每个点出发往四个方向分别遍历，求最长长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">// O(N^3)：矩阵遍历每个点是N^2，对每个点在扫四个方向是4N</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestLine</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (M == <span class="keyword">null</span> || M.length == <span class="number">0</span> || M[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M.length; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M[<span class="number">0</span>].length; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (M[i][j] == <span class="number">1</span>) &#123;</div><div class="line">                    longest = Math.max(longest, getLongest(M, i, j));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> longest;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 右、下、右下、左下</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">int</span>[][] directions = <span class="keyword">new</span> <span class="keyword">int</span>[][] &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, -<span class="number">1</span>&#125;&#125;; </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getLongest</span><span class="params">(<span class="keyword">int</span>[][] M, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] direction: directions) &#123;</div><div class="line">            <span class="keyword">int</span> len = <span class="number">1</span>;</div><div class="line">            <span class="keyword">int</span> newRow = row + direction[<span class="number">0</span>];</div><div class="line">            <span class="keyword">int</span> newCol = col + direction[<span class="number">1</span>];</div><div class="line">            <span class="comment">// 持续在一个方向上继续走</span></div><div class="line">            <span class="keyword">while</span> (isValidPosition(M, newRow, newCol) &amp;&amp; M[newRow][newCol] == <span class="number">1</span>) &#123;</div><div class="line">                len++;</div><div class="line">                newRow += direction[<span class="number">0</span>];</div><div class="line">                newCol += direction[<span class="number">1</span>];</div><div class="line">            &#125;</div><div class="line">            maxLen = Math.max(maxLen, len);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxLen;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidPosition</span><span class="params">(<span class="keyword">int</span>[][] M, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> row &gt;= <span class="number">0</span> &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp;</div><div class="line">            row &lt; M.length &amp;&amp; col &lt; M[<span class="number">0</span>].length;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法二：类似于DP，记录下四个方向各自的最大长度。参考<a href="https://discuss.leetcode.com/topic/87389/simple-and-concise-java-solution-easy-to-understand-o-m-n-space" target="_blank" rel="external">这个</a>被lz<br>和<a href="https://leetcode.com/problems/n-queens-ii/descrciption/" target="_blank" rel="external">N皇后问题</a>很像。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">// O(N^2)时间，O(M+N)空间</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestLine</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</div><div class="line">        <span class="comment">// validation</span></div><div class="line">        <span class="keyword">if</span> (M == <span class="keyword">null</span> || M.length == <span class="number">0</span> || M[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> rows = M.length, cols = M[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span>[] bucketCol = <span class="keyword">new</span> <span class="keyword">int</span> [cols];</div><div class="line">        <span class="keyword">int</span>[] bucketDiag1 = <span class="keyword">new</span> <span class="keyword">int</span> [rows + cols];</div><div class="line">        <span class="keyword">int</span>[] bucketDiag2 = <span class="keyword">new</span> <span class="keyword">int</span> [rows + cols];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</div><div class="line">            <span class="keyword">int</span> row = <span class="number">0</span>;                <span class="comment">// 新行初始化为0</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (M[i][j] == <span class="number">1</span>) &#123;     <span class="comment">// 当前为1，对应更新bucket</span></div><div class="line">                    row++;</div><div class="line">                    bucketCol[j]++;</div><div class="line">                    bucketDiag1[j + i]++;</div><div class="line">                    bucketDiag2[j - i + M.length]++;</div><div class="line">                    longest = Math.max(longest, row);</div><div class="line">                    longest = Math.max(longest, bucketCol[j]);</div><div class="line">                    longest = Math.max(longest, bucketDiag1[j + i]);</div><div class="line">                    longest = Math.max(longest, bucketDiag2[j - i + M.length]);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    row = <span class="number">0</span>;</div><div class="line">                    bucketCol[j] = <span class="number">0</span>;</div><div class="line">                    bucketDiag1[j + i] = <span class="number">0</span>;</div><div class="line">                    bucketDiag2[j - i + M.length] = <span class="number">0</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> longest;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="567-permutation-in-string"><a href="#567-permutation-in-string" class="headerlink" title="567. permutation-in-string"></a><a href="https://leetcode.com/problems/permutation-in-string/description/" target="_blank" rel="external">567. permutation-in-string</a></h4><ul>
<li>给两个字符串，判断s1的permutation是否包含在s2中，例如<code>s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;</code>返回true，因为s2包含了<code>ba</code>。</li>
<li>其实这个s1的permutation并不用真的一个个求出来，在意的只是s1的每个字符及其出现次数，因此用一个map O(N)扫一波就好了。然后就对s2进行双指针 + producer/consumer操作，如果消耗完map中所有字符的时候恰好前后指针间距等于s1的长度，说明就是permutation的一种了，返回true。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (s1 == <span class="keyword">null</span> || s2 == <span class="keyword">null</span> || s1.length() == <span class="number">0</span> || s2.length() == <span class="number">0</span> ) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">char</span>[] s1Char = s1.toCharArray();</div><div class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> len1 = s1Char.length;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++) &#123;    <span class="comment">// 统计s1中每个字母出现个数，作为producer</span></div><div class="line">            map.put(s1Char[i], map.getOrDefault(s1Char[i], <span class="number">0</span>) + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">char</span>[] s2Char = s2.toCharArray();</div><div class="line">        <span class="keyword">int</span> count = map.size();</div><div class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (right &lt; s2Char.length) &#123;     <span class="comment">// 遍历s2作为consumer消耗字符，直到map中所有字符消耗完</span></div><div class="line">            <span class="keyword">if</span> (map.containsKey(s2Char[right])) &#123;</div><div class="line">                map.put(s2Char[right], map.get(s2Char[right]) - <span class="number">1</span>);</div><div class="line">                <span class="keyword">if</span> (map.get(s2Char[right]) == <span class="number">0</span>) &#123;</div><div class="line">                    count--;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;            <span class="comment">// 左指针补回来，直到map中出现available的字符</span></div><div class="line">                <span class="keyword">if</span> (right - left + <span class="number">1</span> == len1) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (map.containsKey(s2Char[left])) &#123;</div><div class="line">                    map.put(s2Char[left], map.get(s2Char[left]) + <span class="number">1</span>);</div><div class="line">                    <span class="keyword">if</span> (map.get(s2Char[left]) &gt; <span class="number">0</span>) &#123;</div><div class="line">                        count++;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                left++;</div><div class="line">            &#125;</div><div class="line">            right++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="572-subtree-of-another-tree"><a href="#572-subtree-of-another-tree" class="headerlink" title="572. subtree-of-another-tree"></a><a href="https://leetcode.com/problems/subtree-of-another-tree/description/" target="_blank" rel="external">572. subtree-of-another-tree</a></h4><ul>
<li>给两棵树，判断后者是不是前者的子树。子树指的是还有一个任意节点为根的子树，结构、数值完全一样。</li>
<li>递归搞定。先判断两个树是否相同，若相同直接就是子树了。若不同则需要到左右子树进行递归，判断t是否是左／右的子树。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> &amp;&amp; t == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || t == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> isSame(s, t) ? <span class="keyword">true</span> : isSubtree(s.left, t) || isSubtree(s.right, t);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSame</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> &amp;&amp; t == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || t == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> s.val == t.val ? isSame(s.left, t.left) &amp;&amp; isSame(s.right, t.right) : <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="575-distribute-candies"><a href="#575-distribute-candies" class="headerlink" title="575. distribute-candies"></a><a href="https://leetcode.com/problems/distribute-candies/description/" target="_blank" rel="external">575. distribute-candies</a></h4><ul>
<li>给一个数组表示糖果的id，其中可能有重复，且糖果数量一定是偶数。要求将其分成两部分，问如果想尝最多的不同的糖果，有多少种。例如<code>[3,2,2,1,3,1]</code>就有三种，<code>[7,3,1,4,3,7,4,3,7]</code>就有四种。要求时间复杂度最差<code>O(N*lgN)</code>，空间复杂度O(N)。</li>
<li>先排序，然后双指针一个从前往后，一个从后往前。left指针负责将糖果存入set，right则是调取后方的糖果往前替换，当left发现当前糖果吃过了，就从right那里swap过来继续判断，直到出现新的糖果或者穷尽。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxCandy</span><span class="params">(<span class="keyword">int</span>[] candies)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (candies == <span class="keyword">null</span> || candies.length == <span class="number">0</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		&#125;</div><div class="line">		Arrays.sort(candies);</div><div class="line">		Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">		<span class="keyword">int</span> half = candies.length / <span class="number">2</span>;</div><div class="line">		<span class="keyword">int</span> left = <span class="number">0</span>, right = candies.length - <span class="number">1</span>;</div><div class="line">		<span class="keyword">while</span> (left &lt; half) &#123;</div><div class="line">			<span class="keyword">while</span> (set.contains(candies[left]) &amp;&amp; right &gt;= half) &#123;</div><div class="line">				swap(candies, left, right--);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (right &lt; half) &#123;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				set.add(candies[left++]);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		set.add(candies[left]);</div><div class="line">		<span class="keyword">return</span> set.size();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="581-shortest-unsorted-continuous-subarray"><a href="#581-shortest-unsorted-continuous-subarray" class="headerlink" title="581. shortest-unsorted-continuous-subarray"></a><a href="https://leetcode.com/problems/shortest-unsorted-continuous-subarray/description/" target="_blank" rel="external">581. shortest-unsorted-continuous-subarray</a></h4><ul>
<li>给一个部分部分有序的数组，求将其中哪一部分排序之后整个数组就都有序了，求最短的区间的长度。</li>
<li>首先从左往右逆序对，然后从右往左找逆序对。这样就有了一个大致区间，但是还需要找区间内的min和max，分别往前和往后遍历看看是否真的完全符合，否则还需要扩展区间。例如<code>[1,3,6,4,8,2,7,10]</code>在前两步之后找到得失<code>[6,4]</code>和<code>[8,2]</code>实际上前面的3和后面的1都需要加入进来。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 找第一个逆序对</span></div><div class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (left &lt; nums.length) &#123;</div><div class="line">            <span class="keyword">if</span> (nums[left - <span class="number">1</span>] &gt; nums[left]) &#123;</div><div class="line">                left--;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            left++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (left == nums.length) &#123;  <span class="comment">// 说明已经有序了</span></div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (right &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (nums[right - <span class="number">1</span>] &gt; nums[right]) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            right--;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 找[left, right]之间的最小、最大</span></div><div class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</div><div class="line">            min = Math.min(min, nums[i]);</div><div class="line">            max = Math.max(max, nums[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 前面的必须小于min，后面的必须大于max，否则扩散</span></div><div class="line">        <span class="keyword">while</span> (left &gt; <span class="number">0</span> &amp;&amp; nums[left - <span class="number">1</span>] &gt; min) &#123;</div><div class="line">            left--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (right + <span class="number">1</span> &lt; nums.length &amp;&amp; nums[right + <span class="number">1</span>] &lt; max) &#123;</div><div class="line">            right++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> right - left + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="594-longest-harmonious-subsequence"><a href="#594-longest-harmonious-subsequence" class="headerlink" title="594. longest-harmonious-subsequence"></a><a href="https://leetcode.com/problems/longest-harmonious-subsequence/description/" target="_blank" rel="external">594. longest-harmonious-subsequence</a></h4><ul>
<li>给一个int数组，求其中最大和最小值恰好为1的非连续子序列。</li>
<li>用Map存每个值出现的次数，然后遍历Map取key相差1都存在的进行更新。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLHS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</div><div class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : map.keySet()) &#123;</div><div class="line">            <span class="keyword">if</span> (map.containsKey(num + <span class="number">1</span>)) &#123;</div><div class="line">                max = Math.max(max, map.get(num) + map.get(num + <span class="number">1</span>));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="598-range-addition-ii"><a href="#598-range-addition-ii" class="headerlink" title="598. range-addition-ii"></a><a href="https://leetcode.com/problems/range-addition-ii/description/" target="_blank" rel="external">598. range-addition-ii</a></h4><ul>
<li>给一个二维数组的规模m和n，初始值为0，再给一个ops二维数组，每个op表示前x行和前y列都加1.求最终最大值的个数。例如<code>m = 3, n = 3, operations = [[2,2],[3,3]]</code>，那么就是先给左上方<code>2*2</code>加1，再给<code>3*3</code>加1，最后就有4个最大值（2）。</li>
<li>直接找行和列的最小值，相乘即可。m和n甚至都没啥用。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">// 直接找最小的行和列数，相乘即得</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span>[][] ops)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (ops == <span class="keyword">null</span> || ops.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> m * n;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> rowMin = Integer.MAX_VALUE, colMin = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] op : ops) &#123;</div><div class="line">            rowMin = Math.min(op[<span class="number">0</span>], rowMin);</div><div class="line">            colMin = Math.min(op[<span class="number">1</span>], colMin);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> rowMin * colMin;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="600-non-negative-integers-without-consecutive-ones"><a href="#600-non-negative-integers-without-consecutive-ones" class="headerlink" title="600. non-negative-integers-without-consecutive-ones"></a><a href="https://leetcode.com/problems/non-negative-integers-without-consecutive-ones/description/" target="_blank" rel="external">600. non-negative-integers-without-consecutive-ones</a></h4><ul>
<li>给一个正数num，求[0, num]之间的bitString不含连续1的数字的个数。</li>
<li><p>方法一：DP。对于bitString有两种可能，以1结尾或以0结尾。为了不出现连续的1，对于0结尾的数字可以拼上0或1，而对于1结尾的数字就只能拼上0.<a href="https://www.geeksforgeeks.org/count-number-binary-strings-without-consecutive-1s/" target="_blank" rel="external">Geeks4Geeks</a>上面给的是bitString的长度，这里也可以用类似的方法。不过由于这里num的存在可能需要砍掉一部分结果，因此在最后需要多一步判断。如果num中出现了连续的<code>xx00xxx</code>（注意是从右往左遍历），而如果没有这个限制<code>xx10xxx, xx01xxx</code>等都可能算进去，因此需要减去前一个0到最前面的数字位数所保存的endWithOne的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">// 对于一个二进制数字，最后一位可能为1也可能为0.后者可以append数字0或1，而前者只能append数字0了。牵涉到DP了。</span></div><div class="line">    <span class="comment">// end0表示不含连续1的、bit长度为i + 1的、以0结尾的数字个数，end1表示不含连续1的、bit长度为i + 1的、以1结尾的数字的个数</span></div><div class="line">    <span class="comment">// 初始状态为end0[0] = 1, end1[0] = 1.</span></div><div class="line">    <span class="comment">// end0只在最后拼0，因此上一步来自0或1都可以；而end1只拼1，因此上一步只能来自0.</span></div><div class="line">    <span class="comment">// 状态转换为end0[i] = end0[i - 1] + end1[i - 1], end1[i] = end0[i - 1]</span></div><div class="line">    <span class="comment">// 但这是根据bitString长度来的，而题目给的是num，因此最后还需要过滤看看有没有多算</span></div><div class="line">    <span class="comment">// 如果在i, i+1处出现连续的0，说明i往前的部分就多算了，因此根据0～i-1的长度找endWithOne减掉即可。</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findIntegers</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(Integer.toBinaryString(num));</div><div class="line">        <span class="keyword">int</span> n = sb.length();</div><div class="line">        </div><div class="line">        <span class="keyword">int</span>[] endWithZero = <span class="keyword">new</span> <span class="keyword">int</span> [n];</div><div class="line">        <span class="keyword">int</span>[] endWithOne = <span class="keyword">new</span> <span class="keyword">int</span> [n];</div><div class="line">        endWithZero[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">        endWithOne[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</div><div class="line">            endWithZero[i] = endWithZero[i - <span class="number">1</span>] + endWithOne[i - <span class="number">1</span>];</div><div class="line">            endWithOne[i] = endWithZero[i - <span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> count = endWithZero[n - <span class="number">1</span>] + endWithOne[n - <span class="number">1</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (sb.charAt(i) == <span class="string">'1'</span> &amp;&amp; sb.charAt(i - <span class="number">1</span>) == <span class="string">'1'</span>) &#123;   <span class="comment">// x11xx说明已经是最大了，后面都不可能多算了</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sb.charAt(i) == <span class="string">'0'</span> &amp;&amp; sb.charAt(i - <span class="number">1</span>) == <span class="string">'0'</span>) &#123;    <span class="comment">// x00xx说明前一个0处不应该含有endWithOne</span></div><div class="line">                count -= endWithOne[n - <span class="number">1</span> - i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法二：constant space的DP。</p>
</li>
</ul>
<h4 id="604-design-compressed-string-iterator"><a href="#604-design-compressed-string-iterator" class="headerlink" title="604. design-compressed-string-iterator"></a><a href="https://leetcode.com/problems/design-compressed-string-iterator/description/" target="_blank" rel="external">604. design-compressed-string-iterator</a></h4><ul>
<li>给一个字符加数字组成的字符串，实现next、hasNext函数遍历这个字符串。例如<code>L20J3B8</code>这样。</li>
<li>一开始直接根据频数全部存入queue，后来发现如果某个数频数特别大，而实际用不到那么多项就很不划算。因此就自定义类来搞了。写出来是<a href="https://leetcode.com/submissions/detail/135742635/" target="_blank" rel="external">这样</a>.</li>
</ul>
<h4 id="605-can-place-flowers"><a href="#605-can-place-flowers" class="headerlink" title="605. can-place-flowers"></a><a href="https://leetcode.com/problems/can-place-flowers/description/" target="_blank" rel="external">605. can-place-flowers</a></h4><ul>
<li>给一个只含有0和1的数组，1表示该处被种了花，0表示可以种，同时相邻的位置不能同时种花。给一个花数n，判断能否种到所给的花池中。</li>
<li><p>方法一：想到了greedy的方法，每次判断0前后是否都为0，可以就直接设为1.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPlaceFlowers</span><span class="params">(<span class="keyword">int</span>[] flowerbed, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (flowerbed == <span class="keyword">null</span> || flowerbed.length == <span class="number">0</span> || n == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; flowerbed.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (flowerbed[i] == <span class="number">0</span></div><div class="line">                &amp;&amp; (i == flowerbed.length - <span class="number">1</span> || flowerbed[i + <span class="number">1</span>] != <span class="number">1</span>)     <span class="comment">// 后一个为0</span></div><div class="line">                &amp;&amp; (i == <span class="number">0</span> || flowerbed[i - <span class="number">1</span>] != <span class="number">1</span>)) &#123;                     <span class="comment">// 前一个为0</span></div><div class="line">                flowerbed[i] = <span class="number">1</span>;</div><div class="line">                <span class="keyword">if</span> (--n == <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法二：计算0的个数，碰到1就计算前面最多可以放多少0，同时重置计数。注意初始化count = 1，比如<code>0 0 1</code>在碰到1的时候需要保证slot为1，如果count初始化为0就无法得到了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPlaceFlowers</span><span class="params">(<span class="keyword">int</span>[] flowerbed, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (flowerbed == <span class="keyword">null</span> || flowerbed.length == <span class="number">0</span> || n == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">1</span>, slot = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; flowerbed.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (flowerbed[i] == <span class="number">0</span>) &#123;</div><div class="line">                count++;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                slot += (count - <span class="number">1</span>) / <span class="number">2</span>;</div><div class="line">                count = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        slot += count / <span class="number">2</span>;</div><div class="line">        <span class="keyword">return</span> slot &gt;= n;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="606-construct-string-from-binary-tree"><a href="#606-construct-string-from-binary-tree" class="headerlink" title="606. construct-string-from-binary-tree"></a><a href="https://leetcode.com/problems/construct-string-from-binary-tree/description/" target="_blank" rel="external">606. construct-string-from-binary-tree</a></h4><ul>
<li>给一个二叉树，encode成括号分割的字符串。</li>
<li>递归拼接。注意左子树和右子树为空时加不加括号需要加判断。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">tree2str</span><span class="params">(TreeNode t)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">        &#125;</div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">        sb.append(t.val);</div><div class="line">        String left = tree2str(t.left);</div><div class="line">        String right = tree2str(t.right);</div><div class="line">        <span class="keyword">if</span> (left.length() &gt; <span class="number">0</span> || right.length() &gt; <span class="number">0</span>) &#123;</div><div class="line">            sb.append(<span class="string">"("</span>);</div><div class="line">            sb.append(left);</div><div class="line">            sb.append(<span class="string">")"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (right.length() &gt; <span class="number">0</span>) &#123;</div><div class="line">            sb.append(<span class="string">"("</span>);</div><div class="line">            sb.append(right);</div><div class="line">            sb.append(<span class="string">")"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sb.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="609-find-duplicate-file-in-system"><a href="#609-find-duplicate-file-in-system" class="headerlink" title="609. find-duplicate-file-in-system"></a><a href="https://leetcode.com/problems/find-duplicate-file-in-system/description/" target="_blank" rel="external">609. find-duplicate-file-in-system</a></h4><ul>
<li>给一个字符串数组，每个字符串中表示某路径下的所有文件以及内容，求相同文件内容的文件路径并存入List。比较有意思的是follow-up，解答参考<a href="https://discuss.leetcode.com/topic/91430/c-clean-solution-answers-to-follow-up" target="_blank" rel="external">这里</a>：在真实的文件系统中你会选择BFS还是DFS?(BFS。虽然会消耗更多空间，但是可以利用locality提速)如果每个文件内容非常巨大怎么办？（不直接hash文件内容，而是首先根据文件大小判断是否是同一个文件，然后再取文件其中一部分进行hash）</li>
<li>直接以内容为key、路径&amp;文件名为value存入map。最坏时间复杂度是O(N^2 * k)，N是文件个数，k是文件大小。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findDuplicate(String[] paths) &#123;</div><div class="line">        List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">if</span> (paths == <span class="keyword">null</span> || paths.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> ans;</div><div class="line">        &#125;</div><div class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();    <span class="comment">// 以文件内容为key、路径+文件名为value</span></div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (String path : paths) &#123;</div><div class="line">            String[] arr = path.split(<span class="string">"\\s+"</span>);      <span class="comment">// 不可以直接用空格，要正则表达式!!!!!!</span></div><div class="line">            String dir = arr[<span class="number">0</span>];</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</div><div class="line">                <span class="keyword">int</span> start = arr[i].indexOf(<span class="string">"("</span>);</div><div class="line">                String file = arr[i].substring(<span class="number">0</span>, start);</div><div class="line">                String content = arr[i].substring(start, arr[i].length() - <span class="number">1</span>);</div><div class="line">                List&lt;String&gt; temp = map.get(content);</div><div class="line">                <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</div><div class="line">                    temp = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">                &#125;</div><div class="line">                temp.add(dir + <span class="string">"/"</span> + file);</div><div class="line">                map.put(content, temp);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (String content : map.keySet()) &#123;</div><div class="line">            List&lt;String&gt; temp = map.get(content);</div><div class="line">            <span class="keyword">if</span> (temp.size() &gt; <span class="number">1</span>) &#123;</div><div class="line">                ans.add(temp);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="611-valid-triangle-number"><a href="#611-valid-triangle-number" class="headerlink" title="611. valid-triangle-number"></a><a href="https://leetcode.com/problems/cvalid-triangle-number/description/" target="_blank" rel="external">611. valid-triangle-number</a></h4><ul>
<li>给一个int数组表示边长，问这些边可以组成多少个三角形。（这些边可能重复，但是算作不同的边）</li>
<li>三角形任意两边之和大于第三边，这个任意其实指的是起码较小的两边之和大于最大边。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">// 两边之和大于第三边，那么每次都取最小都两个边相加大于最大边即可</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">triangleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        Arrays.sort(nums);  <span class="comment">// 排序</span></div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">2</span>; i--) &#123;</div><div class="line">            <span class="keyword">int</span> left = <span class="number">0</span>, right = i - <span class="number">1</span>;    <span class="comment">// 双指针取比当前指针小的两条边</span></div><div class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</div><div class="line">                <span class="keyword">if</span> (nums[left] + nums[right] &gt; nums[i]) &#123;</div><div class="line">                    count += (right - left);    <span class="comment">// 相当于固定right取left开始的边</span></div><div class="line">                    right --;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    left ++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="621-task-scheduler"><a href="#621-task-scheduler" class="headerlink" title="621. task-scheduler"></a><a href="https://leetcode.com/problems/task-scheduler/description/" target="_blank" rel="external">621. task-scheduler</a></h4><ul>
<li>给一个char数组，每个char表示一个task的名字；然后给一个interval表示相同的task必须经过这么多时间之后才能再次执行。求执行完所有任务所需要的时间。</li>
<li>greedy可解，即以所给的interval作为周期，每次按频数从多到少地放task，如果周期没有用完而后续还有任务则需要把idle的时间也加进去。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Task</span> </span>&#123;</div><div class="line">        <span class="keyword">char</span> name;</div><div class="line">        <span class="keyword">int</span> freq;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(<span class="keyword">char</span> name, <span class="keyword">int</span> freq)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.name = name;</div><div class="line">            <span class="keyword">this</span>.freq = freq;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="keyword">char</span>[] tasks, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (tasks == <span class="keyword">null</span> || tasks.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 统计每个任务的频数</span></div><div class="line">        Map&lt;Character, Task&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : tasks) &#123;</div><div class="line">            <span class="keyword">if</span> (!map.containsKey(c)) &#123;</div><div class="line">                map.put(c, <span class="keyword">new</span> Task(c, <span class="number">1</span>));</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                Task t = map.get(c);</div><div class="line">                t.freq++;</div><div class="line">                map.put(c, t);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 根据频数维护优先队列</span></div><div class="line">        PriorityQueue&lt;Task&gt; q = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; &#123;</div><div class="line">            <span class="keyword">return</span> b.freq == a.freq? a.name - b.name : b.freq - a.freq;     <span class="comment">// freq大的在前</span></div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">for</span> (Character c : map.keySet()) &#123;</div><div class="line">            q.add(map.get(c));</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 以n+1为周期，从pq中根据freq从高到低取task</span></div><div class="line">        <span class="keyword">int</span> totalTime = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</div><div class="line">            List&lt;Task&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            <span class="keyword">int</span> period = n + <span class="number">1</span>;</div><div class="line">            <span class="keyword">while</span> (period &gt; <span class="number">0</span> &amp;&amp; !q.isEmpty()) &#123;</div><div class="line">                Task t = q.poll();</div><div class="line">                t.freq--;</div><div class="line">                temp.add(t);</div><div class="line">                period--;</div><div class="line">                totalTime++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span> (Task t : temp) &#123;</div><div class="line">                <span class="keyword">if</span> (t.freq &gt; <span class="number">0</span>) &#123;</div><div class="line">                    q.add(t);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (!q.isEmpty()) &#123;         <span class="comment">// 后面还有task，确实需要隔多这么多时间</span></div><div class="line">                totalTime += period;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> totalTime;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="622-design-circular-queue-https-leetcode-com-problems-design-circular-queue"><a href="#622-design-circular-queue-https-leetcode-com-problems-design-circular-queue" class="headerlink" title="[622. design-circular-queue] (https://leetcode.com/problems/design-circular-queue/)"></a>[622. design-circular-queue] (<a href="https://leetcode.com/problems/design-circular-queue/" target="_blank" rel="external">https://leetcode.com/problems/design-circular-queue/</a>)</h4><ul>
<li>设计并实现一个循环队列，给定初始长度为k，根据操作（enqueue/dequeue）成功与否返回boolean.</li>
<li>其实不难，只是需要想清楚逻辑。将数组想像成无限长的，利用头尾两个index和len，每次enqueueu挪动尾指针（初始为-1）、dequeue挪动头指针。</li>
</ul>
<h4 id="628-maximum-product-of-three-numbers"><a href="#628-maximum-product-of-three-numbers" class="headerlink" title="628. maximum-product-of-three-numbers"></a><a href="https://leetcode.com/problems/maximum-product-of-three-numbers/description/" target="_blank" rel="external">628. maximum-product-of-three-numbers</a></h4><ul>
<li>给一个int数组，求其中任意三个数的最大乘积（不用考虑越界问题）。</li>
<li>naive的想法是排序后取三个max，但实际上只需要用到三个max<strong>以及两个可能为负数的min</strong>。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> max1 = Integer.MIN_VALUE, max2 = Integer.MIN_VALUE, max3 = Integer.MIN_VALUE, </div><div class="line">            min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</div><div class="line">            <span class="keyword">if</span> (num &lt;= min1) &#123;</div><div class="line">                min2 = min1;</div><div class="line">                min1 = num;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt;= min2) &#123;</div><div class="line">                min2 = num;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (num &gt;= max1) &#123;</div><div class="line">                max3 = max2;</div><div class="line">                max2 = max1;</div><div class="line">                max1 = num;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt;= max2) &#123;</div><div class="line">                max3 = max2;</div><div class="line">                max2 = num;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt;= max3) &#123;</div><div class="line">                max3 = num;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> Math.max(max1 * max2 * max3, max1 * min1 * min2);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="632-smallest-range"><a href="#632-smallest-range" class="headerlink" title="632. smallest-range"></a><a href="https://leetcode.com/problems/smallest-range/description/" target="_blank" rel="external">632. smallest-range</a></h4><ul>
<li>给一个<code>List&lt;List&lt;Integer&gt;&gt;</code>，每行List内部是排好序的，求一个区间使其包括每一行的某个元素。例如<code>[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]</code>，返回<code>[20,24]</code>.</li>
<li>类似于merge k sorted list，自定义一个Node类存放值、所属的行数、所处的列数信息，每次从每个List中取值存入PriorityQueue，然后每次从pq中poll掉元素的下一个作为新的元素存入pq。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123; </div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        <span class="keyword">int</span> row;</div><div class="line">        <span class="keyword">int</span> index;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> row, <span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.val = val;</div><div class="line">            <span class="keyword">this</span>.row = row;</div><div class="line">            <span class="keyword">this</span>.index = index;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] smallestRange(List&lt;List&lt;Integer&gt;&gt; nums) &#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.size() == <span class="number">0</span> || nums.get(<span class="number">0</span>).size() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span> [] &#123;<span class="number">0</span>, Integer.MAX_VALUE&#125;;  <span class="comment">// warning: need to be max at first</span></div><div class="line">        <span class="keyword">int</span> k = nums.size();</div><div class="line">        PriorityQueue&lt;Node&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; a.val - b.val);</div><div class="line">        <span class="comment">// new PriorityQueue&lt;Node&gt;(new Comparator() &#123;</span></div><div class="line">        <span class="comment">// public int compare(Node a, Node b) &#123;</span></div><div class="line">        <span class="comment">//     return a.val - b.val;</span></div><div class="line">        <span class="comment">// &#125;</span></div><div class="line">        <span class="comment">// &#125;);</span></div><div class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</div><div class="line">            <span class="keyword">int</span> currVal = nums.get(i).get(<span class="number">0</span>);</div><div class="line">            max = Math.max(max, currVal);</div><div class="line">            pq.offer(<span class="keyword">new</span> Node(currVal, i, <span class="number">0</span>));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (pq.size() == nums.size()) &#123; <span class="comment">// 已经没有新的元素了加进来说明能跨所有行的间距已经遍历完成</span></div><div class="line">            Node node = pq.poll();</div><div class="line">            <span class="keyword">if</span> (max - node.val &lt; ans[<span class="number">1</span>] - ans[<span class="number">0</span>]) &#123;     <span class="comment">// 发现间距更小的window就更新</span></div><div class="line">                ans[<span class="number">1</span>] = max;</div><div class="line">                ans[<span class="number">0</span>] = node.val;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (node.index + <span class="number">1</span> &lt; nums.get(node.row).size()) &#123;</div><div class="line">                Node nextNode = <span class="keyword">new</span> Node(nums.get(node.row).get(node.index + <span class="number">1</span>), node.row, node.index + <span class="number">1</span>);</div><div class="line">                <span class="keyword">if</span> (nextNode.val &gt; max) &#123;</div><div class="line">                    max = nextNode.val;</div><div class="line">                &#125;</div><div class="line">                pq.offer(nextNode);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="633-sum-of-square-numbers"><a href="#633-sum-of-square-numbers" class="headerlink" title="633. sum-of-square-numbers"></a><a href="https://leetcode.com/problems/sum-of-square-numbers/description/" target="_blank" rel="external">633. sum-of-square-numbers</a></h4><ul>
<li>给一个非负数，判断它是否是两个整数的平方和。</li>
<li><p>方法一：类似two sum，把每个整数的平方和存入set，判断set中是否有target - curr即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgeSquareSum</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (c &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> sqrtC = (<span class="keyword">int</span>) Math.sqrt(c);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= sqrtC; i++) &#123;</div><div class="line">            set.add(i * i);</div><div class="line">            <span class="keyword">if</span> (set.contains(c - i * i)) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法二：双指针，同时从0和sqrt(num)出发往中间逼近，若平方和大了则左移右指针、若小了则右移左指针。但</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgeSquareSum</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (c &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = (<span class="keyword">int</span>) Math.sqrt(c);</div><div class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</div><div class="line">        <span class="keyword">int</span> curr = left * left + right * right;</div><div class="line">        <span class="keyword">if</span> (curr &gt; c) &#123;</div><div class="line">            right--;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curr &lt; c) &#123;</div><div class="line">            left++;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="636-exclusive-time-of-functions"><a href="#636-exclusive-time-of-functions" class="headerlink" title="636. exclusive-time-of-functions"></a><a href="https://leetcode.com/problems/exclusive-time-of-functions/description/" target="_blank" rel="external">636. exclusive-time-of-functions</a></h4><ul>
<li>给一个log数组，每个log包含<code>function_id:start_or_end:timestamp</code>形式的字符串，求每个function执行时间长度。注意这些function的执行可能嵌套、也可能递归调用。</li>
<li>经典的Stack题，需要用Stack记录function_id，这样在后续log来的时候，如果是start，说明栈顶函数暂停执行了，需要先把它的时间存起来（当前时间戳减去之前的时间戳）；如果是end，说明栈顶函数彻底执行完了，此时的时间计算需要加上end的这个时间戳。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] exclusiveTime(<span class="keyword">int</span> n, List&lt;String&gt; logs) &#123;</div><div class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span> [n];</div><div class="line">        <span class="keyword">if</span> (logs == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> ans;</div><div class="line">        &#125;</div><div class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> prev = <span class="number">0</span>;           <span class="comment">// 记录上一次log的时间戳</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; logs.size(); i++) &#123;</div><div class="line">            String[] log = logs.get(i).split(<span class="string">":"</span>);</div><div class="line">            <span class="keyword">if</span> (log[<span class="number">1</span>].equals(<span class="string">"start"</span>)) &#123;</div><div class="line">                <span class="keyword">int</span> curr = Integer.valueOf(log[<span class="number">2</span>]);</div><div class="line">                <span class="keyword">if</span> (!stack.isEmpty()) &#123;</div><div class="line">                    ans[stack.peek()] += (curr - prev); </div><div class="line">                &#125;</div><div class="line">                prev = curr;</div><div class="line">                stack.push(Integer.valueOf(log[<span class="number">0</span>]));</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">int</span> curr = Integer.valueOf(log[<span class="number">2</span>]);</div><div class="line">                ans[stack.pop()] += (curr - prev + <span class="number">1</span>);  <span class="comment">// end包含当前这个时间点，因此要加1</span></div><div class="line">                prev = curr + <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="637-average-of-levels-in-binary-tree"><a href="#637-average-of-levels-in-binary-tree" class="headerlink" title="637. average-of-levels-in-binary-tree"></a><a href="https://leetcode.com/problems/average-of-levels-in-binary-tree/description/" target="_blank" rel="external">637. average-of-levels-in-binary-tree</a></h4><ul>
<li>给一个二叉树，求每一层的平均数。</li>
<li>还是层级遍历的变形，主要是防止求平均值的时候越界，用了double，这样求平均值的时候也方便很多。写出来是<a href="https://leetcode.com/submissions/detail/136075057/" target="_blank" rel="external">这样</a>。</li>
</ul>
<h4 id="646-maximum-length-of-pair-chain"><a href="#646-maximum-length-of-pair-chain" class="headerlink" title="646. maximum-length-of-pair-chain"></a><a href="https://leetcode.com/problems/maximum-length-of-pair-chain/description/" target="_blank" rel="external">646. maximum-length-of-pair-chain</a></h4><ul>
<li>给一个pair的数组，每个pair可以作为chain的节点。节点<code>[c, d]</code>能够连到<code>[a, b]</code>后面的条件是<code>b &lt; c</code>。求最长的链长度。</li>
<li>DP。<code>len[i]</code>表示以pair[i]结尾的链的长度，那么在双重循环时，就需要找到pairs[j]使得<code>pairs[j][1] &lt; pairs[i][0]</code>。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLongestChain</span><span class="params">(<span class="keyword">int</span>[][] pairs)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (pairs == <span class="keyword">null</span> || pairs.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        Arrays.sort(pairs, (a, b) -&gt; &#123;</div><div class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">int</span>[] len = <span class="keyword">new</span> <span class="keyword">int</span> [pairs.length];     <span class="comment">// len[i]表示以pairs[i]结尾的链的长度</span></div><div class="line">        Arrays.fill(len, <span class="number">1</span>);</div><div class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pairs.length; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (pairs[i][<span class="number">0</span>] &gt; pairs[j][<span class="number">1</span>]) &#123;</div><div class="line">                    len[i] = Math.max(len[i], len[j] + <span class="number">1</span>);  <span class="comment">// 上一个节点为pairs[j]</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            maxLen = Math.max(maxLen, len[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxLen;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="647-palindromic-substrings"><a href="#647-palindromic-substrings" class="headerlink" title="647. palindromic-substrings"></a><a href="https://leetcode.com/problems/palindromic-substrings/description/" target="_blank" rel="external">647. palindromic-substrings</a></h4><ul>
<li>给一个字符串，求其中自对称的子串的个数。例如<code>aaa</code>就有6个，<code>aba</code>就有4个。</li>
<li>DP。<code>dp[i][j]</code>表示从第i个字符到第j个字符是否对称，当判断第<code>i</code>和第<code>j</code>个字符的时候，如果相等则需要用到<code>i + 1</code>到<code>j - 1</code>之间的结果（若也对称则当前这个也是对称的），因此需要从后往前递推更新DP数组才行。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">char</span>[] sChar = s.toCharArray();</div><div class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span> [sChar.length][sChar.length];  <span class="comment">// dp[i][j] means take substr from i to j</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = dp.length - <span class="number">1</span>; row &gt;= <span class="number">0</span>; row--) &#123;    <span class="comment">// 从最后一行开始往前</span></div><div class="line">            dp[row][row] = <span class="keyword">true</span>;    <span class="comment">// 最后一列设为true</span></div><div class="line">            count++;                <span class="comment">// 每个字符本身是自对称的</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = row + <span class="number">1</span>; col &lt; dp.length; col++) &#123;   <span class="comment">// 只更新对角线之后的元素</span></div><div class="line">                <span class="keyword">if</span> (sChar[col] == sChar[row]) &#123;</div><div class="line">                    dp[row][col] = row + <span class="number">1</span> &gt; col - <span class="number">1</span> || dp[row + <span class="number">1</span>][col - <span class="number">1</span>];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (dp[row][col]) &#123;</div><div class="line">                    count++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="648-replace-words"><a href="#648-replace-words" class="headerlink" title="648. replace-words"></a><a href="https://leetcode.com/problems/replace-words/description/" target="_blank" rel="external">648. replace-words</a></h4><ul>
<li>给一个List的dict表示词根，然后给一个sentence String，将其中以词根开头的单词替换成词根，返回修改后的String。</li>
<li><p>方法一：直接用Set存放这些词根，然后split之后暴力取每一个单词，再逐一取字符append判断是否在Set中，有就替换过去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceWords</span><span class="params">(List&lt;String&gt; dict, String sentence)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (dict == <span class="keyword">null</span> || dict.size() == <span class="number">0</span> || sentence == <span class="keyword">null</span> || sentence.length() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> sentence;</div><div class="line">        &#125;</div><div class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> minLen = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">for</span> (String str : dict) &#123;</div><div class="line">            set.add(str);</div><div class="line">            minLen = Math.min(str.length(), minLen);</div><div class="line">        &#125;</div><div class="line">        String[] words = sentence.split(<span class="string">"\\s+"</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</div><div class="line">            <span class="keyword">int</span> wordLen = words[i].length();</div><div class="line">            <span class="keyword">if</span> (wordLen &lt; minLen) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            StringBuilder temp = <span class="keyword">new</span> StringBuilder(words[i].substring(<span class="number">0</span>, minLen));</div><div class="line">            <span class="keyword">if</span> (set.contains(temp.toString())) &#123;</div><div class="line">                words[i] = temp.toString();</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = minLen; j &lt; wordLen; j++) &#123;</div><div class="line">                temp.append(words[i].charAt(j));</div><div class="line">                <span class="keyword">if</span> (set.contains(temp.toString())) &#123;</div><div class="line">                    words[i] = temp.toString();</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">for</span> (String word : words) &#123;</div><div class="line">            sb.append(word);</div><div class="line">            sb.append(<span class="string">" "</span>);</div><div class="line">        &#125;</div><div class="line">        sb.setLength(sb.length() - <span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> sb.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法二：使用Trie，将dict中的所有词根都存入Trie，然后还是取出来判断这些word是否有前缀出现在Trie中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> isWord;</div><div class="line">        TrieNode[] next;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</div><div class="line">            next = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</div><div class="line">            Arrays.fill(next, <span class="keyword">null</span>);</div><div class="line">            isWord = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceWords</span><span class="params">(List&lt;String&gt; dict, String sentence)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (dict == <span class="keyword">null</span> || dict.size() == <span class="number">0</span> || sentence == <span class="keyword">null</span> || sentence.length() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> sentence;</div><div class="line">        &#125;</div><div class="line">        TrieNode root = buildTrie(dict);</div><div class="line">        String[] words = sentence.split(<span class="string">"\\s+"</span>);</div><div class="line">        StringBuilder ans = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</div><div class="line">            String prefix = getPrefix(root, words[i]);</div><div class="line">            ans.append(prefix == <span class="keyword">null</span> ? words[i] : prefix);</div><div class="line">            ans.append(<span class="string">' '</span>);</div><div class="line">        &#125;</div><div class="line">        ans.setLength(ans.length() - <span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> ans.toString();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> TrieNode <span class="title">buildTrie</span><span class="params">(List&lt;String&gt; dict)</span> </span>&#123;</div><div class="line">        TrieNode root = <span class="keyword">new</span> TrieNode();</div><div class="line">        <span class="keyword">for</span> (String str : dict) &#123;</div><div class="line">            insert(root, str);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(TrieNode root, String word)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : word.toCharArray()) &#123;</div><div class="line">            <span class="keyword">if</span> (root.next[c - <span class="string">'a'</span>] == <span class="keyword">null</span>) &#123;</div><div class="line">                root.next[c - <span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</div><div class="line">            &#125;</div><div class="line">            root = root.next[c - <span class="string">'a'</span>];</div><div class="line">        &#125;</div><div class="line">        root.isWord = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// return the prefix in trie if exist, or null if not.</span></div><div class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getPrefix</span><span class="params">(TrieNode root, String word)</span> </span>&#123;</div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : word.toCharArray()) &#123;</div><div class="line">            <span class="keyword">if</span> (root.next[c - <span class="string">'a'</span>] == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">            sb.append(c);</div><div class="line">            <span class="keyword">if</span> (root.next[c - <span class="string">'a'</span>].isWord) &#123;</div><div class="line">                <span class="keyword">return</span> sb.toString();</div><div class="line">            &#125;</div><div class="line">            root = root.next[c - <span class="string">'a'</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> root.isWord ? word : <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="652-find-duplicate-subtrees"><a href="#652-find-duplicate-subtrees" class="headerlink" title="652. find-duplicate-subtrees"></a><a href="https://leetcode.com/problems/find-duplicate-subtrees/description/" target="_blank" rel="external">652. find-duplicate-subtrees</a></h4><ul>
<li><p>给一个二叉树，返回一个包含所有duplicate的子树根节点的List。例如下面的树就有2-4和4两个duplicate的子树。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">    1</div><div class="line">   / \</div><div class="line">  2   3</div><div class="line"> /   / \</div><div class="line">4   2   4</div><div class="line">   /</div><div class="line">  4</div></pre></td></tr></table></figure>
</li>
<li><p>利用encoding tree的思路，对于每一个节点为root的树都进行一波类似前序遍历点操作，将遍历结果encode成字符串作为key、计数作为value存入map。一旦出现了两次就加入结果List。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">findDuplicateSubtrees</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        List&lt;TreeNode&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        check(root, map, ans);</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">check</span><span class="params">(TreeNode node, Map&lt;String, Integer&gt; map, List&lt;TreeNode&gt; ans)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 通过前序遍历拼接出pattern并存入map</span></div><div class="line">        String pattern = node.val + <span class="string">","</span> + check(node.left, map, ans) + <span class="string">","</span> + check(node.right, map, ans);</div><div class="line">        <span class="keyword">int</span> count = map.getOrDefault(pattern, <span class="number">0</span>) + <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (count == <span class="number">2</span>) &#123;       <span class="comment">// the second one</span></div><div class="line">            ans.add(node);</div><div class="line">        &#125;</div><div class="line">        map.put(pattern, count);</div><div class="line">        <span class="keyword">return</span> pattern;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="653-two-sum-iv-input-is-a-bst"><a href="#653-two-sum-iv-input-is-a-bst" class="headerlink" title="653. two-sum-iv-input-is-a-bst"></a><a href="https://leetcode.com/problems/two-sum-iv-input-is-a-bst/description/" target="_blank" rel="external">653. two-sum-iv-input-is-a-bst</a></h4><ul>
<li>给一个二叉搜索树和一个sum值，判断树中是否存在两个node之和等于sum。</li>
<li><p>朴素想法，对于每个可能的值进行O(logN)的搜索，因此总的时间复杂度就是O(NlogN)，而空间复杂度如果考虑递归栈的话就是O(TreeHeight)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findTarget</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> dfs(root, root, k);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(TreeNode node, TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> target = k - node.val;</div><div class="line">        <span class="keyword">if</span> (target != node.val &amp;&amp; search(root, target)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;    </div><div class="line">            <span class="keyword">return</span> dfs(node.left, root, k) || dfs(node.right, root, k);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (root.val == val) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; root.val) &#123;</div><div class="line">            <span class="keyword">return</span> search(root.left, val);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> search(root.right, val);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法二：用BST中序遍历转换成有序数组，再用双指针分别从头和尾往中间找。时间O(N)，空间O(N).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findTarget</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        inorder(root, list);</div><div class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = list.size() - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (left &lt; right) &#123;  <span class="comment">// 双指针查找有序数组中的pair</span></div><div class="line">            <span class="keyword">int</span> sum = list.get(left) + list.get(right);</div><div class="line">            <span class="keyword">if</span> (sum &lt; k) &#123;</div><div class="line">                left++;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; k) &#123;</div><div class="line">                right--;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        inorder(root.left, list);</div><div class="line">        list.add(root.val);</div><div class="line">        inorder(root.right, list);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="654-maximum-binary-tree"><a href="#654-maximum-binary-tree" class="headerlink" title="654. maximum-binary-tree"></a><a href="https://leetcode.com/problems/maximum-binary-tree/" target="_blank" rel="external">654. maximum-binary-tree</a></h4><ul>
<li>给一个不重复的int数组表示的二叉树节点value，最大值作为root，左侧子数组对应root左子树，右侧子数组对应root右子树，重新建树并返回root节点。</li>
<li><p>方法一：直接递归解决，但是时间复杂度最坏情况是O(N^2)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> constructMaximumBinaryTree(nums, <span class="number">0</span>, nums.length);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (start == end) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> maxIndex = start;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt; end; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[maxIndex]) &#123;</div><div class="line">            maxIndex = i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(nums[maxIndex]);</div><div class="line">    root.left = constructMaximumBinaryTree(nums, start, maxIndex);</div><div class="line">    root.right = constructMaximumBinaryTree(nums, maxIndex + <span class="number">1</span>, end);</div><div class="line">    <span class="keyword">return</span> root;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法二：利用Stack可以达到O(N)时间复杂度，关键是发现规律，即「当前节点的左孩子一定是在左侧大于它的最远节点右侧的小于当前val的最左节点，同理右孩子一定是在右边较大节点左侧的小于当前节点值的最右节点」。在Stack中需要栈底到栈顶是从大到小的，一旦新的节点更大，就要不断pop，同时将此时pop出来的节点作为新节点的左节点，这样就能实现第一个要求。第二个要求则是在插入的时候，将栈顶的右孩子暂时指向新节点，同时将新节点入栈，之后如果有比新节点更大但没有前一个节点大的节点加入，则又回指向该节点了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</div><div class="line">        TreeNode curr = <span class="keyword">new</span> TreeNode(nums[i]);</div><div class="line">        <span class="comment">// 将左边小于当前节点的值作为当前节点的左孩子</span></div><div class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek().val &lt; curr.val) &#123;</div><div class="line">            curr.left = stack.pop();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 找到左边第一个大于当前节点的值，当前节点作为它的右孩子</span></div><div class="line">        <span class="keyword">if</span> (!stack.isEmpty()) &#123;</div><div class="line">            stack.peek().right = curr;</div><div class="line">        &#125;</div><div class="line">        stack.push(curr);</div><div class="line">    &#125;</div><div class="line">    TreeNode root = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;  <span class="comment">// 栈顶是root</span></div><div class="line">        root = stack.pop();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> root;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="657-judge-route-circle"><a href="#657-judge-route-circle" class="headerlink" title="657. judge-route-circle"></a><a href="https://leetcode.com/problems/judge-route-circle/description/" target="_blank" rel="external">657. judge-route-circle</a></h4><ul>
<li>给一个字符串表示一个移动的seq，判断最终是否回到远点。skip.</li>
</ul>
<h4 id="658-find-k-closest-elements"><a href="#658-find-k-closest-elements" class="headerlink" title="658. find-k-closest-elements"></a><a href="https://leetcode.com/problems/find-k-closest-elements/description/" target="_blank" rel="external">658. find-k-closest-elements</a></h4><ul>
<li>在一个排好序的数组中，找距离x最近的k个元素，若有tie则尽量取更小的值。</li>
<li>二分查找找到x所在位置/若x存在则应该处在的index，然后取它左边的元素作为left、本身作为right，双指针前后取即可。为了提高insert效率，使用linkedlist的addfirst。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findClosestElements</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        LinkedList&lt;Integer&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> ans;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> pos = binarySearch(arr, x);</div><div class="line">        <span class="keyword">int</span> left = pos - <span class="number">1</span>, right = pos;</div><div class="line">        <span class="keyword">while</span> (ans.size() &lt; k &amp;&amp; left &gt;= <span class="number">0</span> &amp;&amp; right &lt; arr.length) &#123;</div><div class="line">            <span class="keyword">if</span> (x - arr[left] &lt;= arr[right] - x) &#123;  <span class="comment">// delta相等时尽量取小的</span></div><div class="line">                ans.addFirst(arr[left--]);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                ans.add(arr[right++]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (ans.size() &lt; k &amp;&amp; left &gt;= <span class="number">0</span>) &#123;</div><div class="line">            ans.addFirst(arr[left--]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (ans.size() &lt; k &amp;&amp; right &lt; arr.length) &#123;</div><div class="line">            ans.add(arr[right++]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> left = -<span class="number">1</span>, right = arr.length;</div><div class="line">        <span class="keyword">while</span> (right - left &gt; <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span> (target &lt;= arr[mid]) &#123;</div><div class="line">                right = mid;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                left = mid;    </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> right;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="662-maximum-width-of-binary-tree"><a href="#662-maximum-width-of-binary-tree" class="headerlink" title="662. maximum-width-of-binary-tree"></a><a href="https://leetcode.com/problems/maximum-width-of-binary-tree/description/" target="_blank" rel="external">662. maximum-width-of-binary-tree</a></h4><ul>
<li>给一个二叉树，求最大宽度，即最左节点和最右节点之间的间隔。</li>
<li>在dfs过程中记录最左节点的id（类似于数组存储二叉树的形式），然后在遍历过程中根据level和当前id求间隔。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">widthOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        List&lt;Integer&gt; leftMostIds = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">return</span> dfs(root, <span class="number">1</span>, <span class="number">0</span>, leftMostIds);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode node, <span class="keyword">int</span> nodeId, <span class="keyword">int</span> level, List&lt;Integer&gt; leftMostIds)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (level &gt;= leftMostIds.size()) &#123;  <span class="comment">// 每一个level最左的node id</span></div><div class="line">            leftMostIds.add(nodeId);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> Math.max(nodeId - leftMostIds.get(level) + <span class="number">1</span>, </div><div class="line">                        Math.max(dfs(node.left, <span class="number">2</span> * nodeId, level + <span class="number">1</span>, leftMostIds), </div><div class="line">                                dfs(node.right, <span class="number">2</span> * nodeId + <span class="number">1</span>, level + <span class="number">1</span>, leftMostIds)));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="669-trim-a-binary-search-tree"><a href="#669-trim-a-binary-search-tree" class="headerlink" title="669. trim-a-binary-search-tree"></a><a href="https://leetcode.com/problems/trim-a-binary-search-tree/description/" target="_blank" rel="external">669. trim-a-binary-search-tree</a></h4><ul>
<li>给一个BST和一个值域[L, R]，只保留BST中属于该值域的节点。递归搞定，skip。</li>
</ul>
<h4 id="670-maximum-swap"><a href="#670-maximum-swap" class="headerlink" title="670. maximum-swap"></a><a href="https://leetcode.com/problems/maximum-swap/description/" target="_blank" rel="external">670. maximum-swap</a></h4><ul>
<li>给一个非负数，求至多将其中两个digit互换位置之后所能得到的最大数。例如<code>9987</code>就是本身，<code>9978</code>是<code>9987</code>，<code>958469</code>是<code>998465</code>.</li>
<li>暗中观察规律就是找其中一个小的数字并找在它右侧的最大数，交换。因此首先需要记录每个数字最后出现的位置，然后从原数字第一位开始遍历，从最大的数字开始比较，一旦找到比自己大且排在自己后面的数字就可以直接交换位置了。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumSwap</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">char</span>[] numStr = Integer.toString(num).toCharArray();</div><div class="line">        <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">10</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numStr.length; i++) &#123;</div><div class="line">            bucket[numStr[i] - <span class="string">'0'</span>] = i;    <span class="comment">// 每个数字最后出现的位置</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 找到最靠右的、比当前数字大的数字，交换位置即可</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numStr.length; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">9</span>; index &gt; numStr[i] - <span class="string">'0'</span>; index--) &#123;   <span class="comment">// 注意只跟比当前数字大的比位置</span></div><div class="line">                <span class="keyword">if</span> (bucket[index] &gt; i) &#123;    <span class="comment">// 在当前位置之后</span></div><div class="line">                    <span class="keyword">char</span> temp = numStr[bucket[index]];</div><div class="line">                    numStr[bucket[index]] = numStr[i];  </div><div class="line">                    numStr[i] = temp;</div><div class="line">                    <span class="keyword">return</span> Integer.valueOf(<span class="keyword">new</span> String(numStr));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> num;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="671-second-minimum-node-in-a-binary-tree"><a href="#671-second-minimum-node-in-a-binary-tree" class="headerlink" title="671. second-minimum-node-in-a-binary-tree"></a><a href="https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/description/" target="_blank" rel="external">671. second-minimum-node-in-a-binary-tree</a></h4><ul>
<li>给一个特殊的二叉树，每一个节点只有0或2个children，且值是两个子节点的较小值。求树中第二小的值，若没有，返回-1.</li>
<li>既然找的是比最小值大的最小的值，就用递归的方法在左右两边分别找比最小值的大的最小值，然后比较一下即可。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findSecondMinimumValue</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || root.left == <span class="keyword">null</span> || root.right == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> leftLeastGreater = getLeastGreater(root.left, root.val);</div><div class="line">        <span class="keyword">int</span> rightLeastGreater = getLeastGreater(root.right, root.val);</div><div class="line">        <span class="keyword">int</span> min = Math.min(leftLeastGreater, rightLeastGreater);</div><div class="line">        <span class="keyword">if</span> (leftLeastGreater &gt; root.val &amp;&amp; rightLeastGreater &gt; root.val) &#123;</div><div class="line">            <span class="keyword">return</span> min;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> leftLeastGreater == root.val ? (rightLeastGreater == root.val ? -<span class="number">1</span> : rightLeastGreater) : leftLeastGreater;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getLeastGreater</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> root.val;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> leftLeastGreater = getLeastGreater(root.left, val);</div><div class="line">        <span class="keyword">int</span> rightLeastGreater = getLeastGreater(root.right, val);</div><div class="line">        <span class="keyword">if</span> (leftLeastGreater &gt; val &amp;&amp; rightLeastGreater &gt; val) &#123;</div><div class="line">            <span class="keyword">return</span> Math.min(leftLeastGreater, rightLeastGreater);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (leftLeastGreater &gt; val) &#123;</div><div class="line">            <span class="keyword">return</span> leftLeastGreater;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> rightLeastGreater;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="673-number-of-longest-increasing-subsequence"><a href="#673-number-of-longest-increasing-subsequence" class="headerlink" title="673. number-of-longest-increasing-subsequence"></a><a href="https://leetcode.com/problems/number-of-longest-increasing-subsequence/description/" target="_blank" rel="external">673. number-of-longest-increasing-subsequence</a></h4><ul>
<li>给一个数组，求其中最长递增的subsequence的个数。如<code>[1,3,5,4,7]</code>中有两个长度为4的subsequence。</li>
<li>DP。用一个len[k]数组记录以k结尾的字符处的最长长度，<code>count[k]</code>记录对应的计数。双重循环时，当<code>nums[i] &gt; nums[j]</code>，若<code>len[j] + 1 &gt; len[i]</code>则需要更新i处的长度，同时count也直接更新；若<code>len[j] + 1 == len[i]</code>，则说明刚好从j过来可以形成递增sequence，直接累加就行了（一开始以为是<a href="https://leetcode.com/problems/longest-increasing-subsequence/description/" target="_blank" rel="external">lc300求长度</a>，就用stack做了，然而stack这个greedy做法也是错误的，还是需要上DP。。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNumberOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] len = <span class="keyword">new</span> <span class="keyword">int</span> [nums.length];</div><div class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span> [nums.length];</div><div class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>, ans = <span class="number">0</span>;</div><div class="line">        Arrays.fill(len, <span class="number">1</span>);</div><div class="line">        Arrays.fill(count, <span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;        <span class="comment">// 保证递增关系</span></div><div class="line">                    <span class="keyword">int</span> tempLen = len[j] + <span class="number">1</span>;   <span class="comment">// 递增后的长度</span></div><div class="line">                    <span class="keyword">if</span> (tempLen &gt; len[i]) &#123;     </div><div class="line">                        len[i] = tempLen;</div><div class="line">                        count[i] = count[j];</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tempLen == len[i]) &#123;     <span class="comment">// 从j跳过来的递增</span></div><div class="line">                        count[i] += count[j];</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            maxLen = Math.max(len[i], maxLen);      <span class="comment">// 记录最大长度，后续用于对比并累计count</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (len[i] == maxLen) &#123;</div><div class="line">                ans += count[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="674-longest-continuous-increasing-subsequence"><a href="#674-longest-continuous-increasing-subsequence" class="headerlink" title="674. longest-continuous-increasing-subsequence"></a><a href="https://leetcode.com/problems/longest-continuous-increasing-subsequence/description/" target="_blank" rel="external">674. longest-continuous-increasing-subsequence</a></h4><ul>
<li>给一个数组，求其中最长递增的连续subarray的长度。如<code>[1,2,3,4,5,6,5,4,3,4,5]</code>就是6，<code>[2,2,2,2,2]</code>就是1.</li>
<li>贪心法，只有大于前面元素才更新，一旦小于就更新到总的里面。注意最后返回之前还要取一次max。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>, curr = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</div><div class="line">                curr++;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                ans = Math.max(ans, curr);</div><div class="line">                curr = <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> Math.max(ans, curr);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="676-implement-magic-dictionary"><a href="#676-implement-magic-dictionary" class="headerlink" title="676. implement-magic-dictionary"></a><a href="https://leetcode.com/problems/implement-magic-dictionary/description/" target="_blank" rel="external">676. implement-magic-dictionary</a></h4><ul>
<li>实现<code>buildDict</code>和<code>search</code>方法，search时判断能否通过「替换一个字符」的方式使得修改后的字符串包含在dict中，返回boolean。例如给<code>[&quot;hello&quot;, &quot;leetcode&quot;]</code>，搜索<code>hhllo</code>就返回true、搜索<code>hello</code>返回false。</li>
<li><p>方法一：dict就想到选择map，在build时对于每个字符串，将其中每个字符替换成特殊字符如<code>*</code>，将替换后的字符串作为key、被替换的字符作为value存入map。如果出现相同的key，则说明这个位置可以放任何字符（例如<code>hello, hallo</code>的第二位）；在搜索时也是对每个字符替换，然后看map中有没有，判断一下当前字符是否是value的字符（防止indentical）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MagicDictionary</span> </span>&#123;</div><div class="line">    <span class="comment">// 将每个单词的每个字符都替换成*之后，插入map，key是替换后的字符串，value是被替换掉的那个字符</span></div><div class="line">    <span class="comment">// 如果出现替换过后的key一样，则该位可以放任意字符，因为例如hello和hallo只有在第二位不同，如果替换后是h*llo可以任选一个，一定是true。</span></div><div class="line">    Map&lt;String, Character&gt; map = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">/** Initialize your data structure here. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MagicDictionary</span><span class="params">()</span> </span>&#123;</div><div class="line">        map = <span class="keyword">new</span> HashMap&lt;String, Character&gt;();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/** Build a dictionary through a list of words */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildDict</span><span class="params">(String[] dict)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (dict == <span class="keyword">null</span> || dict.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (String word : dict) &#123;</div><div class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder(word);</div><div class="line">            <span class="keyword">int</span> len = word.length();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">                sb.setCharAt(i, <span class="string">'*'</span>);</div><div class="line">                Character c = map.get(sb.toString());</div><div class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</div><div class="line">                    map.put(sb.toString(), word.charAt(i));</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    map.put(sb.toString(), <span class="string">'*'</span>);    <span class="comment">// 表示可以放任何字符</span></div><div class="line">                &#125;</div><div class="line">                sb.setCharAt(i, word.charAt(i));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (word == <span class="keyword">null</span> || word.length() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> len = word.length();</div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(word);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">            sb.setCharAt(i, <span class="string">'*'</span>);</div><div class="line">            Character c = map.get(sb.toString());</div><div class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; (c == <span class="string">'*'</span> || c != word.charAt(i))) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            sb.setCharAt(i, word.charAt(i));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法二：使用Trie。build的时候就正常地创建Trie，然后在search的时候逐个位置替换26个字符，每换一次就在Trie中搜索。Trie的效率感觉不高啊，感觉有square级别。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MagicDictionary</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</div><div class="line">        TrieNode[] children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</div><div class="line">        <span class="keyword">boolean</span> isWord;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    &#125;</div><div class="line">    TrieNode root;</div><div class="line">    <span class="comment">/** Initialize your data structure here. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MagicDictionary</span><span class="params">()</span> </span>&#123;</div><div class="line">        root = <span class="keyword">new</span> TrieNode();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/** Build a dictionary through a list of words */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildDict</span><span class="params">(String[] dict)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (String s : dict) &#123;</div><div class="line">            TrieNode node = root;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</div><div class="line">                <span class="keyword">if</span> (node.children[c - <span class="string">'a'</span>] == <span class="keyword">null</span>) &#123;</div><div class="line">                    node.children[c - <span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</div><div class="line">                &#125;</div><div class="line">                node = node.children[c - <span class="string">'a'</span>];</div><div class="line">            &#125;</div><div class="line">            node.isWord = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</div><div class="line">        <span class="keyword">char</span>[] arr = word.toCharArray();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>; c++) &#123;</div><div class="line">                <span class="keyword">if</span> (arr[i] == c) &#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">char</span> org = arr[i];</div><div class="line">                arr[i] = c;</div><div class="line">                <span class="keyword">if</span> (checkTrie(<span class="keyword">new</span> String(arr), root)) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">                arr[i] = org;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkTrie</span><span class="params">(String s, TrieNode root)</span> </span>&#123;</div><div class="line">        TrieNode node = root;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</div><div class="line">            <span class="keyword">if</span> (node.children[c - <span class="string">'a'</span>] == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            node = node.children[c - <span class="string">'a'</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> node.isWord;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="678-valid-parenthesis-string"><a href="#678-valid-parenthesis-string" class="headerlink" title="678. valid-parenthesis-string"></a><a href="https://leetcode.com/problems/valid-parenthesis-string/" target="_blank" rel="external">678. valid-parenthesis-string</a></h4><ul>
<li>给一个只含有<code>(</code>, <code>*</code>, <code>)</code>的字符串，其中<code>*</code>可以是任何一种括号，或者为空，判断字符串是否合法。</li>
<li><p>方法一：与传统的valid parenthesis相比就是多了一个<code>*</code>，那就把它分别带入左右和空三种情况递归判断即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkValidString</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> check(s.toCharArray(), <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">char</span>[] charArray, <span class="keyword">int</span> start, <span class="keyword">int</span> leftCount)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (leftCount &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; charArray.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (charArray[i] == <span class="string">'('</span>) &#123;</div><div class="line">            leftCount++;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (charArray[i] == <span class="string">')'</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (leftCount == <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            leftCount--;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> check(charArray, i + <span class="number">1</span>, leftCount + <span class="number">1</span>)</div><div class="line">                || check(charArray, i + <span class="number">1</span>, leftCount - <span class="number">1</span>)</div><div class="line">                || check(charArray, i + <span class="number">1</span>, leftCount);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> leftCount == <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法二：延续stack的做法，左括号和星号<strong>的index</strong>入栈，每次遇到右括号先把左括号的stack弹出。最后比较左括号的星号栈的索引大小即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkValidString</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    Stack&lt;Integer&gt; leftIds = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    Stack&lt;Integer&gt; starIds = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</div><div class="line">        <span class="keyword">char</span> c = s.charAt(i);</div><div class="line">        <span class="keyword">if</span> (c == <span class="string">'('</span>) &#123;</div><div class="line">            leftIds.push(i);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'*'</span>) &#123;</div><div class="line">            starIds.push(i);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (leftIds.isEmpty() &amp;&amp; starIds.isEmpty()) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!leftIds.isEmpty()) &#123;</div><div class="line">                leftIds.pop();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                starIds.pop();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (!leftIds.isEmpty() &amp;&amp; !starIds.isEmpty()) &#123;</div><div class="line">        <span class="keyword">if</span> (starIds.pop() &lt; leftIds.pop()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> leftIds.isEmpty();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法三：从左到右扫一遍，分别统计左括号和星号，优先匹配左括号，当左括号不够时再调用右括号；但是这样一波无法判断<code>(*()</code>这样的情况，因为星号始终是当成左的。因此需要再从右往左走一波，把星号当成有括号。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkValidString</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, leftStar = <span class="number">0</span>, right = <span class="number">0</span>, rightStar = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</div><div class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span>) &#123;</div><div class="line">            left++;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">'*'</span>) &#123;</div><div class="line">            leftStar++;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</div><div class="line">                left--;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (leftStar &gt; <span class="number">0</span>) &#123;</div><div class="line">                leftStar--;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">')'</span>) &#123;</div><div class="line">            right++;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">'*'</span>) &#123;</div><div class="line">            rightStar++;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (right &gt; <span class="number">0</span>) &#123;</div><div class="line">                right--;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rightStar &gt; <span class="number">0</span>) &#123;</div><div class="line">                rightStar--;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="680-valid-palindrome-ii"><a href="#680-valid-palindrome-ii" class="headerlink" title="680. valid-palindrome-ii"></a><a href="https://leetcode.com/problems/valid-palindrome-ii/description/" target="_blank" rel="external">680. valid-palindrome-ii</a></h4><ul>
<li>给一个字符串，判断能否通过“最多删掉一个字符”形成自对称字符串。例如<code>aba</code>本身就是，<code>abca</code>可以通过删掉b或c变成自对称。</li>
<li>直接前后指针往中间并拢，一旦发现不同的字符就把不同的两个字符分别遮住继续判断，如果还不行那就一定不能自对称了。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validPalindrome</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = s.length() - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</div><div class="line">            <span class="keyword">if</span> (s.charAt(left) != s.charAt(right)) &#123;    <span class="comment">// 发现对应位置不匹配，尝试遮掉其中一个继续判断</span></div><div class="line">                <span class="keyword">return</span> isPalin(s, left + <span class="number">1</span>, right) || isPalin(s, left, right - <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">            left++;</div><div class="line">            right--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalin</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</div><div class="line">            <span class="keyword">if</span> (s.charAt(left++) != s.charAt(right--)) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="681-next-closest-time"><a href="#681-next-closest-time" class="headerlink" title="681. next-closest-time"></a><a href="https://leetcode.com/problems/next-closest-time/description/" target="_blank" rel="external">681. next-closest-time</a></h4><ul>
<li>给一个字符串表示时间，求由这些数组组成的、下一个最近的时间（数字可无限使用）。</li>
<li>greedy方法，从末尾开始替换，如果有恰好比他大的数字，替换之后直接就返回了。否则就替换成这些数字中最小的数字。注意每一个位置的限制都不同，例如第二位就需要根据第一位是否为2来决定最大值是3还是9.<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">nextClosestTime</span><span class="params">(String time)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (time == <span class="keyword">null</span> || time.length() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">char</span>[] digits = getDigits(time.split(<span class="string">":"</span>));</div><div class="line">        <span class="keyword">char</span>[] digitsOrigin = Arrays.copyOf(digits, digits.length);</div><div class="line">        <span class="keyword">char</span>[] ans = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">5</span>];</div><div class="line">        ans[<span class="number">0</span>] = digitsOrigin[<span class="number">0</span>];</div><div class="line">        ans[<span class="number">1</span>] = digitsOrigin[<span class="number">1</span>];</div><div class="line">        ans[<span class="number">2</span>] = <span class="string">':'</span>;</div><div class="line">        ans[<span class="number">3</span>] = digitsOrigin[<span class="number">2</span>];</div><div class="line">        ans[<span class="number">4</span>] = digitsOrigin[<span class="number">3</span>];</div><div class="line">        Arrays.sort(digits);</div><div class="line">        </div><div class="line">        ans[<span class="number">4</span>] = getNextGreater(digitsOrigin[<span class="number">3</span>], <span class="string">'9'</span>, digits);</div><div class="line">        <span class="keyword">if</span> (ans[<span class="number">4</span>] &gt; digitsOrigin[<span class="number">3</span>]) &#123;</div><div class="line">            <span class="keyword">return</span> String.valueOf(ans);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        ans[<span class="number">3</span>] = getNextGreater(digitsOrigin[<span class="number">2</span>], <span class="string">'5'</span>, digits);</div><div class="line">        <span class="keyword">if</span> (ans[<span class="number">3</span>] &gt; digitsOrigin[<span class="number">2</span>]) &#123;</div><div class="line">            <span class="keyword">return</span> String.valueOf(ans);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        ans[<span class="number">1</span>] = getNextGreater(digitsOrigin[<span class="number">1</span>], digitsOrigin[<span class="number">0</span>] == <span class="string">'2'</span> ? <span class="string">'3'</span> : <span class="string">'9'</span>, digits);</div><div class="line">        <span class="keyword">if</span> (ans[<span class="number">1</span>] &gt; digitsOrigin[<span class="number">1</span>]) &#123;</div><div class="line">            <span class="keyword">return</span> String.valueOf(ans);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        ans[<span class="number">0</span>] = getNextGreater(digitsOrigin[<span class="number">0</span>], <span class="string">'2'</span>, digits);</div><div class="line">        <span class="keyword">return</span> String.valueOf(ans);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] getDigits(String[] timeSplitted) &#123;</div><div class="line">        <span class="keyword">char</span>[] digits = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">4</span>];</div><div class="line">        digits[<span class="number">0</span>] = (<span class="keyword">char</span>)(<span class="string">'0'</span> + Integer.parseInt(timeSplitted[<span class="number">0</span>]) / <span class="number">10</span>);</div><div class="line">        digits[<span class="number">1</span>] = (<span class="keyword">char</span>)(<span class="string">'0'</span> + Integer.parseInt(timeSplitted[<span class="number">0</span>]) % <span class="number">10</span>);</div><div class="line">        digits[<span class="number">2</span>] = (<span class="keyword">char</span>)(<span class="string">'0'</span> + Integer.parseInt(timeSplitted[<span class="number">1</span>]) / <span class="number">10</span>);</div><div class="line">        digits[<span class="number">3</span>] = (<span class="keyword">char</span>)(<span class="string">'0'</span> + Integer.parseInt(timeSplitted[<span class="number">1</span>]) % <span class="number">10</span>);</div><div class="line">        <span class="keyword">return</span> digits;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">char</span> <span class="title">getNextGreater</span><span class="params">(<span class="keyword">char</span> curr, <span class="keyword">char</span> limit, <span class="keyword">char</span>[] digits)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> pos = Arrays.binarySearch(digits, curr) + <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (pos &lt; <span class="number">4</span> &amp;&amp; digits[pos] &lt;= limit &amp;&amp; digits[pos] == curr) &#123;</div><div class="line">            pos++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> pos &lt; <span class="number">4</span> &amp;&amp; digits[pos] &lt;= limit ? digits[pos] : digits[<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="682-baseball-game"><a href="#682-baseball-game" class="headerlink" title="682. baseball-game"></a><a href="https://leetcode.com/problems/baseball-game/description/" target="_blank" rel="external">682. baseball-game</a></h4><ul>
<li>定义一个积分规则，没有什么好说的，用List即可。</li>
</ul>
<h4 id="683-k-empty-slots"><a href="#683-k-empty-slots" class="headerlink" title="683. k-empty-slots"></a><a href="https://leetcode.com/problems/k-empty-slots/description/" target="_blank" rel="external">683. k-empty-slots</a></h4><ul>
<li>给一个flowers数组表示第<code>i + 1</code>天，开花的索引是<code>flowers[i]</code>。再给一个k，问是否存在某一天使得存在连续k个花未开且左右两边都已经开放，返回这个天数，若不存在则返回-1。</li>
<li><p>方法一：维护一个days数组表示该index的花在第<code>days[index]</code>天开。需要求得一个子序列<code>left, left+1, left+2, ..., left+k, right</code>使得days[left]和days[right]开放时间比中间任何一个都要早。从左往右遍历days数组，一旦发现中间某天开花时间早于left或者right就说明这个子序列中断了，更新left为i即可。时间空间都是O(N).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kEmptySlots</span><span class="params">(<span class="keyword">int</span>[] flowers, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (flowers == <span class="keyword">null</span> || flowers.length &lt;= k) &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] days = <span class="keyword">new</span> <span class="keyword">int</span>[flowers.length];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; flowers.length; i++) &#123;</div><div class="line">            days[flowers[i] - <span class="number">1</span>] = i + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = k + <span class="number">1</span>, ans = Integer.MAX_VALUE;   <span class="comment">// 从左开始往右遍历</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; right &lt; days.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (days[i] &lt; days[left] || days[i] &lt;= days[right]) &#123;  <span class="comment">// 若其中某个i开花时刻早于左或者右侧window，就以该处为新的起点</span></div><div class="line">                <span class="keyword">if</span> (i == right) &#123;   <span class="comment">// 若遍历到right都没有问题，就是一个新的ans</span></div><div class="line">                    ans = Math.min(ans, Math.max(days[left], days[right]));</div><div class="line">                &#125;</div><div class="line">                left = i;</div><div class="line">                right = i + k + <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans == Integer.MAX_VALUE ? -<span class="number">1</span> : ans;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法二：利用TreeSet存储flowers，随着天数增加，利用TreeSet的lower找小于该索引处的最大值、利用higher找大于该索引的最小值，这样求出来就能碰到完美等于k的子序列了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kEmptySlots</span><span class="params">(<span class="keyword">int</span>[] flowers, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (flowers == <span class="keyword">null</span> || flowers.length &lt;= k) &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        TreeSet&lt;Integer&gt; bloomIndex = <span class="keyword">new</span> TreeSet&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> day = <span class="number">0</span>; day &lt; flowers.length; day++) &#123;</div><div class="line">            bloomIndex.add(flowers[day]);</div><div class="line">            Integer left = bloomIndex.lower(flowers[day]);</div><div class="line">            Integer right = bloomIndex.higher(flowers[day]);</div><div class="line">            <span class="keyword">if</span> ((left != <span class="keyword">null</span> &amp;&amp; flowers[day] - left == k + <span class="number">1</span>)</div><div class="line">            || (right != <span class="keyword">null</span> &amp;&amp; right - flowers[day] == k + <span class="number">1</span>)) &#123;</div><div class="line">                <span class="keyword">return</span> day + <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="684-redundant-connection"><a href="#684-redundant-connection" class="headerlink" title="684. redundant-connection"></a><a href="https://leetcode.com/problems/redundant-connection/description/" target="_blank" rel="external">684. redundant-connection</a></h4><ul>
<li>给一系列边组成<strong>无向图</strong>，其中恰好多了一个边使图无法形成树，求多出来的这个边即最后出现的这个边。例如<code>[[1,2], [2,3], [3,4], [1,4], [1,5]]</code>，返回<code>[1,4]</code>。</li>
<li>并查集，维护每个节点的祖先，首次出现时默认以自己为祖先，然后就判断edge中的两个节点祖先是否一样，一样就说明成环了，否则就把前者的祖先指向后者的祖先。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">// 并查集：维护一个Map，表示每个编号的点的祖先</span></div><div class="line">    <span class="comment">// 一旦找到两个点的祖先一样，就说明这个边就是让前面成环的，直接返回</span></div><div class="line">    <span class="comment">// 若祖先不同，则直接将前者的祖先归位后者祖先的后代，这样就把两个部分直接合并了，后面判断成环就可以直接判断</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findRedundantConnection(<span class="keyword">int</span>[][] edges) &#123;</div><div class="line">        <span class="keyword">if</span> (edges == <span class="keyword">null</span> || edges.length == <span class="number">0</span> || edges[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        Map&lt;Integer, Integer&gt; parentMap = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] edge: edges) &#123;</div><div class="line">            <span class="keyword">int</span> from = edge[<span class="number">0</span>];</div><div class="line">            <span class="keyword">int</span> to = edge[<span class="number">1</span>];</div><div class="line">            <span class="keyword">if</span> (!parentMap.containsKey(from)) &#123;</div><div class="line">                parentMap.put(from, from);      <span class="comment">// 刚开始设为本身</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (!parentMap.containsKey(to)) &#123;</div><div class="line">                parentMap.put(to, to);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">int</span> fromParent = findParent(parentMap, from);</div><div class="line">            <span class="keyword">int</span> toParent = findParent(parentMap, to);</div><div class="line">            <span class="keyword">if</span> (fromParent == toParent) &#123;       <span class="comment">// 二者的祖先是一样的说明成环了</span></div><div class="line">                <span class="keyword">return</span> edge;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                parentMap.put(fromParent, toParent);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">2</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findParent</span><span class="params">(Map&lt;Integer, Integer&gt; parentMap, <span class="keyword">int</span> node)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> parent = parentMap.get(node);</div><div class="line">        <span class="keyword">if</span> (parent != node) &#123;</div><div class="line">            parentMap.put(node, findParent(parentMap, parent));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> parentMap.get(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="685-redundant-connection-ii"><a href="#685-redundant-connection-ii" class="headerlink" title="685. redundant-connection-ii"></a><a href="https://leetcode.com/problems/redundant-connection-ii/description/" target="_blank" rel="external">685. redundant-connection-ii</a></h4><ul>
<li>给一系列边组成<strong>有向图</strong>，其中恰好多了一个边使图无法形成rooted tree，求多出来的这个边即最后出现的这个边。例如<code>[[2,1],[3,1],[4,2],[1,4]]</code>，返回<code>[2,1]</code>。</li>
<li>与684相比这里的边都是有向的了，有两种情况来判别边invalid：形成了环，或者一个节点同时有两个parent节点。做法分为两步：首先check看是否有节点有两个parent，有的话就设为candidate A和B，并把B设置为invalid（设一个节点为0即可）；然后进行union-find，如果此时树已经是valid的了，就直接返回candidate B（因为是后出现的）。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findRedundantDirectedConnection(<span class="keyword">int</span>[][] edges) &#123;</div><div class="line">        <span class="keyword">if</span> (edges == <span class="keyword">null</span> || edges.length == <span class="number">0</span> || edges[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] candidate1 = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">2</span>];</div><div class="line">        <span class="keyword">int</span>[] candidate2 = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">2</span>];     <span class="comment">// 后出现的</span></div><div class="line">        <span class="keyword">int</span>[] parent = <span class="keyword">new</span> <span class="keyword">int</span> [edges.length + <span class="number">1</span>];</div><div class="line">        </div><div class="line">        <span class="comment">// 先找有没有节点有两个parent</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (parent[edges[i][<span class="number">1</span>]] == <span class="number">0</span>) &#123;     <span class="comment">// 设置每个孩子节点的parent</span></div><div class="line">                parent[edges[i][<span class="number">1</span>]] = edges[i][<span class="number">0</span>];</div><div class="line">            &#125; <span class="keyword">else</span> &#123;            <span class="comment">// 发现有重复设置的情况</span></div><div class="line">                candidate2[<span class="number">0</span>] = edges[i][<span class="number">0</span>];</div><div class="line">                candidate2[<span class="number">1</span>] = edges[i][<span class="number">1</span>];</div><div class="line">                candidate1[<span class="number">0</span>] = parent[edges[i][<span class="number">1</span>]];    <span class="comment">// 原本存的parent是谁</span></div><div class="line">                candidate1[<span class="number">1</span>] = edges[i][<span class="number">1</span>];</div><div class="line">                edges[i][<span class="number">1</span>] = <span class="number">0</span>;        <span class="comment">// 这个孩子节点暂时设为无效的节点值，比如0</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 重新初始化parent，设为本身</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.length; i++) &#123;</div><div class="line">            parent[i] = i;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</div><div class="line">            <span class="keyword">if</span> (edge[<span class="number">1</span>] == <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">int</span> father = edge[<span class="number">0</span>], child = edge[<span class="number">1</span>];  <span class="comment">// 前-&gt;后</span></div><div class="line">            <span class="keyword">if</span> (root(parent, father) == child) &#123;      <span class="comment">// 判断两个节点是不是连到一起了，注意这里是直接判断是否以child作为parent，而不像上一题两个节点都要求parent</span></div><div class="line">                <span class="keyword">if</span> (candidate1[<span class="number">0</span>] == <span class="number">0</span>) &#123;      <span class="comment">// 没有多parent的情况</span></div><div class="line">                    <span class="keyword">return</span> edge;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">return</span> candidate1;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            parent[child] = father;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> candidate2;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">root</span><span class="params">(<span class="keyword">int</span>[] parent, <span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (parent[i] != i) &#123;</div><div class="line">            parent[i] = parent[parent[i]];</div><div class="line">            i = parent[i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> i;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="686-repeated-string-match"><a href="#686-repeated-string-match" class="headerlink" title="686. repeated-string-match"></a><a href="https://leetcode.com/problems/repeated-string-match/description/" target="_blank" rel="external">686. repeated-string-match</a></h4><ul>
<li>给两个字符串A和B，求A需要重复几次才能让B成为它的substring.</li>
<li><p>狗家实习的OA，自己想的方法。先看看起始字符都出现在哪些索引，统统入queue；然后先拼一波使得A的长度不小于B；然后从queue中取起始索引，比较看B是否包含其中；如果queue还没用完则还需要拼多一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">repeatedStringMatch</span><span class="params">(String A, String B)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (A == <span class="keyword">null</span> || B == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        String AOld = A;</div><div class="line">        Queue&lt;Integer&gt; startIndexQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="keyword">char</span>[] AChar = A.toCharArray(), BChar = B.toCharArray();</div><div class="line">        <span class="keyword">char</span> startChar = BChar[<span class="number">0</span>];</div><div class="line">        <span class="comment">// O(N) get start position</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; AChar.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (AChar[i] == startChar) &#123;</div><div class="line">                startIndexQueue.add(i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> repeatCount = <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (!startIndexQueue.isEmpty() &amp;&amp; A.length() - startIndexQueue.peek() &lt; BChar.length) &#123;</div><div class="line">            A += AOld;     <span class="comment">// append if not long enough            </span></div><div class="line">            repeatCount++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (!startIndexQueue.isEmpty() &amp;&amp; startIndexQueue.peek() + BChar.length &lt;= A.length()) &#123;</div><div class="line">            <span class="keyword">int</span> startIndex = startIndexQueue.poll();</div><div class="line">            <span class="keyword">if</span> (B.equals(A.substring(startIndex, startIndex + BChar.length))) &#123;</div><div class="line">                <span class="keyword">return</span> repeatCount;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// if there is still startIndex in queue, need to repeat and check more</span></div><div class="line">        <span class="keyword">if</span> (!startIndexQueue.isEmpty()) &#123;</div><div class="line">            A += AOld;</div><div class="line">            repeatCount++;</div><div class="line">            <span class="keyword">while</span> (!startIndexQueue.isEmpty()) &#123;</div><div class="line">                <span class="keyword">if</span> (B.equals(A.substring(startIndexQueue.peek(), startIndexQueue.peek() + BChar.length))) &#123;</div><div class="line">                    <span class="keyword">return</span> repeatCount;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    startIndexQueue.poll();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>或者直接用拼接的方式，一直拼接A直到超过B的长度，然后看是否包含。如果不包含还需要额外的一次拼接再看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">repeatedStringMatch</span><span class="params">(String A, String B)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">    <span class="keyword">while</span> (sb.length() &lt; B.length()) &#123;</div><div class="line">        sb.append(A);</div><div class="line">        count++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (sb.toString().contains(B)) <span class="keyword">return</span> count;</div><div class="line">    <span class="keyword">if</span> (sb.append(A).toString().contains(B)) <span class="keyword">return</span> ++count;</div><div class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="687-longest-univalue-path"><a href="#687-longest-univalue-path" class="headerlink" title="687. longest-univalue-path"></a><a href="https://leetcode.com/problems/longest-univalue-path/description/" target="_blank" rel="external">687. longest-univalue-path</a></h4><ul>
<li>给一个二叉树，求其中最长的连续边数使得经过的节点值都一样。不一定是完全笔直的路径。</li>
<li><p>对于左子树和右子树递归调用求最长路径（不取当前节点的情况），然后根据当前节点的值进行DFS（也就是取当前节点的情况）。最后取最大。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestUnivaluePath</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> child = Math.max(longestUnivaluePath(root.left), longestUnivaluePath(root.right));</div><div class="line">        <span class="keyword">return</span> Math.max(child, dfs(root.left, root.val) + dfs(root.right, root.val));</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode node, <span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span> || node.val != val) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(dfs(node.left, val), dfs(node.right, val)); <span class="comment">// two nodes forms one edge</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>但是上面的这个方法存在大量重复访问节点，时间复杂度O(N^2)。因此考虑和之前diameter题一样，使用全局变量求最大path，同时在dfs每步直接将两侧中较大深度返回给上一层。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> maxLen = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestUnivaluePath</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        dfs(root, root.val);</div><div class="line">        <span class="keyword">return</span> maxLen;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode node, <span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> left = dfs(node.left, node.val);</div><div class="line">        <span class="keyword">int</span> right = dfs(node.right, node.val);</div><div class="line">        maxLen = Math.max(maxLen, left + right);    <span class="comment">// 取当前node为转折点</span></div><div class="line">        <span class="keyword">return</span> node.val == val ? Math.max(left, right) + <span class="number">1</span> : <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="688-knight-probability-in-chessboard"><a href="#688-knight-probability-in-chessboard" class="headerlink" title="688. knight-probability-in-chessboard"></a><a href="https://leetcode.com/problems/knight-probability-in-chessboard/" target="_blank" rel="external">688. knight-probability-in-chessboard</a></h4><ul>
<li>给一个整数N表示是<code>N*N</code>的棋盘，其中一个knight/马在坐标(r, c)，问走K步后它还在棋盘有效范围内的概率是多少。</li>
<li>概率就是走到棋盘上的情况数/总的情况数即<code>8^K</code>种走法。当前位置取决于上一步的位置，但是我们并不知道上一步有多少种走法，因此想到bottom-up的DP方法，即假设当前是走完K步之后的位置，可以从之前的哪些位置走过来呢，倒推上一步的走法，然后再继续倒推。注意只有上一步是在有效棋盘内才能update。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">int</span>[][] moves = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, -<span class="number">2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;-<span class="number">1</span>, -<span class="number">2</span>&#125;, &#123;-<span class="number">2</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">2</span>, -<span class="number">1</span>&#125;&#125;;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">knightProbability</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!isValid(r, c, N)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0.0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">double</span>[][] dp = <span class="keyword">new</span> <span class="keyword">double</span>[N][N];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">double</span>[] row : dp) &#123;</div><div class="line">            Arrays.fill(row, <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; K; k++) &#123;</div><div class="line">            <span class="keyword">double</span>[][] dpFrom = <span class="keyword">new</span> <span class="keyword">double</span>[N][N];</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span>[] move : moves) &#123;  <span class="comment">// 倒推：从i, j跳到当前位置的</span></div><div class="line">                        <span class="keyword">int</span> row = i + move[<span class="number">0</span>];</div><div class="line">                        <span class="keyword">int</span> col = j + move[<span class="number">1</span>];</div><div class="line">                        <span class="keyword">if</span> (isValid(row, col, N)) &#123; <span class="comment">// 需要得到跳过来的那个位置的情况数</span></div><div class="line">                            dpFrom[i][j] = dp[row][col] + dpFrom[i][j];</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            dp = dpFrom;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dp[r][c] / Math.pow(<span class="number">8</span>, K);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> N)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> r &gt;= <span class="number">0</span> &amp;&amp; r &lt; N &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; N;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="689-maximum-sum-of-3-non-overlapping-subarrays"><a href="#689-maximum-sum-of-3-non-overlapping-subarrays" class="headerlink" title="689. maximum-sum-of-3-non-overlapping-subarrays"></a><a href="https://leetcode.com/problems/maximum-sum-of-3-non-overlapping-subarrays/description/" target="_blank" rel="external">689. maximum-sum-of-3-non-overlapping-subarrays</a></h4><ul>
<li>给一个正整数数组，找出三个互不重叠的、size为k的子数组，使得总和最大。返回的形式是每个subarray的起始索引。例如<code>[1,2,1,2,6,7,5,1], k=2</code>则返回<code>[0, 3, 5]</code>。</li>
<li>有唯一解吗？（可能有多个，只需返回最先出现索引）k本身会不会很大？（不会，不大于len/3）</li>
<li>首先是如何快速求某个区间内的和？如果数值都不大的话，可以通过累加把sum都给缓存下来，用的时候直接减一下就行了。然后是如何求subarray的结果？可以用二位dp数组，行表示划分成row个subarray，列表示从0到col处为止能得到的最大的总sum。此外还需要一个二维index数组记录第row个subarray对应的起始位置。从第一个subarray开始循环，固定求size为k的subarray使之和最大，其实就是贪心的思想，只要过程中求的每个subarray的和都最大那么最终的总和就是最大的。在循环过程中就可以不断求总和，为了防止重叠求和时必须求往前k个元素为end的dp结果。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSumOfThreeSubarrays(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</div><div class="line">        <span class="comment">// 动态规划</span></div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 缓存到i为止到所有项之和</span></div><div class="line">        <span class="keyword">int</span>[] sumArray = <span class="keyword">new</span> <span class="keyword">int</span> [nums.length];</div><div class="line">        sumArray[<span class="number">0</span>] = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</div><div class="line">            sumArray[i] = sumArray[i - <span class="number">1</span>] + nums[i];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// dp[i][j]表示求i个non-overlap sum的时候从0~j能得到的最大总sum</span></div><div class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">4</span>][nums.length];</div><div class="line">        <span class="comment">// index[i][j]表示求第i个non-overlap sum的时候的starting index</span></div><div class="line">        <span class="keyword">int</span>[][] index = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">4</span>][nums.length];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;   <span class="comment">// 从求第1个最大的k-size subarray开始直到第3个</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = k - <span class="number">1</span>; j &lt; nums.length; j++) &#123;</div><div class="line">                <span class="keyword">int</span> tempMax = j == k - <span class="number">1</span>? sumArray[j] :   <span class="comment">// 快速求区间内的和</span></div><div class="line">                    sumArray[j] - sumArray[j - k] + dp[i - <span class="number">1</span>][j - k];   <span class="comment">// 加上上一行前一个block为止的最大和</span></div><div class="line">                <span class="keyword">if</span> (j &gt; k - <span class="number">1</span>) &#123;        <span class="comment">// 先直接沿用同一行的前面的结果</span></div><div class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>];</div><div class="line">                    index[i][j] = index[i][j - <span class="number">1</span>];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; tempMax &gt; dp[i][j - <span class="number">1</span>]) &#123;  <span class="comment">// 若发现有更大的就更新当前最大和到dp</span></div><div class="line">                    dp[i][j] = tempMax;</div><div class="line">                    index[i][j] = j - k + <span class="number">1</span>;    <span class="comment">// 同时更新最大和出现的下标</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">3</span>];        </div><div class="line">        ans[<span class="number">2</span>] = index[<span class="number">3</span>][nums.length - <span class="number">1</span>];     <span class="comment">// 最后一行的最后一位就是第三个block的index</span></div><div class="line">        ans[<span class="number">1</span>] = index[<span class="number">2</span>][ans[<span class="number">2</span>] - <span class="number">1</span>];          <span class="comment">// 倒数第二行的index[3]之前的存的就是第二行的</span></div><div class="line">        ans[<span class="number">0</span>] = index[<span class="number">1</span>][ans[<span class="number">1</span>] - <span class="number">1</span>];          </div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="690-employee-importance"><a href="#690-employee-importance" class="headerlink" title="690. employee-importance"></a><a href="https://leetcode.com/problems/employee-importance/description/" target="_blank" rel="external">690. employee-importance</a></h4><ul>
<li>给一个List of Employee，包含id、importance、下属List等属性。给定id，求这个id对应员工及其所有下属（不一定是直接下属）的imp之和。</li>
<li>DFS。用一个Map先存储id-Employee的键值对，然后可以给定一个id快速访问到该Employee的信息，然后DFS递归搞定。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">// Employee info</span></div><div class="line"><span class="comment">class Employee &#123;</span></div><div class="line"><span class="comment">    // It's the unique id of each node;</span></div><div class="line"><span class="comment">    // unique id of this employee</span></div><div class="line"><span class="comment">    public int id;</span></div><div class="line"><span class="comment">    // the importance value of this employee</span></div><div class="line"><span class="comment">    public int importance;</span></div><div class="line"><span class="comment">    // the id of direct subordinates</span></div><div class="line"><span class="comment">    public List&lt;Integer&gt; subordinates;</span></div><div class="line"><span class="comment">&#125;;</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getImportance</span><span class="params">(List&lt;Employee&gt; employees, <span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (employees == <span class="keyword">null</span> || employees.size() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        Map&lt;Integer, Employee&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (Employee e : employees) &#123;</div><div class="line">            map.put(e.id, e);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> getImp(map, id);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getImp</span><span class="params">(Map&lt;Integer, Employee&gt; map, <span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!map.containsKey(id)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        Employee e = map.get(id);</div><div class="line">        <span class="keyword">int</span> imp = e.importance;</div><div class="line">        <span class="keyword">for</span> (Integer i : e.subordinates) &#123;</div><div class="line">            imp += getImp(map, i);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> imp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="692-top-k-frequent-words"><a href="#692-top-k-frequent-words" class="headerlink" title="692. top-k-frequent-words"></a><a href="https://leetcode.com/problems/top-k-frequent-words/description/" target="_blank" rel="external">692. top-k-frequent-words</a></h4><ul>
<li>给一个String数组，求出现频率top k的字符串。</li>
<li><p>跟<a href="https://leetcode.com/problems/top-k-frequent-elements/description/" target="_blank" rel="external">347</a>类似。先用Map存每个单词出现的频数，再自定义根据频数minHeap存这些Map.Entry，然后每次都check堆的规模，一旦大于k就直接把最小的poll出来，这样就保证在minHeap中的一定是top k.最后就直接逆序插入结果List。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">topKFrequent</span><span class="params">(String[] words, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">if</span> (words == <span class="keyword">null</span> || words.length == <span class="number">0</span> || k == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> ans;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 统计每个单词出现的频数</span></div><div class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (String word : words) &#123;</div><div class="line">            <span class="keyword">if</span> (!map.containsKey(word)) &#123;</div><div class="line">                map.put(word, <span class="number">1</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                map.put(word, map.get(word) + <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 将entry按照频数从小到大插入PQ，若规模&gt;k则直接poll掉最小的</span></div><div class="line">        PriorityQueue&lt;Map.Entry&lt;String, Integer&gt;&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; &#123;</div><div class="line">            <span class="keyword">return</span> a.getValue() != b.getValue()? </div><div class="line">                a.getValue() - b.getValue() : b.getKey().compareTo(a.getKey());</div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; e : map.entrySet()) &#123;</div><div class="line">            pq.offer(e);</div><div class="line">            <span class="keyword">if</span> (pq.size() &gt; k) &#123;</div><div class="line">                pq.poll();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 取PQ元素，逆序插入结果</span></div><div class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</div><div class="line">            ans.add(<span class="number">0</span>, pq.poll().getKey());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>follow-up：如果给定的输入不是一个完整的数组，而是一个stream，即每次都只能取得一个单词，然后立即返回top k，如何改进？</p>
</li>
<li>关键在于无法在最开始就获得完整的频数统计Map，在插入minHeap的时候就无法知道后续的Entry需不需要覆盖PQ中的值。因此需要一个额外的Map记录具体哪些Entry目前被存放在minHeap中；当新的单词出现，就先更新map中的项，然后再看看它是否在PQ中，在则需要更新（我只能想到把k个元素全抖出来再加进去），不在则跟minHeap的peek比较决定是否需要替换。这样时间是O(N)的统计频数、O(logN)的插入minHeap、O(KlogK)的更新(?)和最后O(K)的倒入List。</li>
</ul>
<h4 id="694-number-of-distinct-islands"><a href="#694-number-of-distinct-islands" class="headerlink" title="694. number-of-distinct-islands"></a><a href="https://leetcode.com/problems/number-of-distinct-islands/description/" target="_blank" rel="external">694. number-of-distinct-islands</a></h4><ul>
<li>给一个grid，其中含有0和1，求所有distinct的连续1的团簇的个数，distinct指的是通过位移无法完全匹配的连续的1的区域。</li>
<li>与统计number of island的区别在于这里的island需要通过某种方式辨别该形状是否出现过，联想到encode方法，利用上下左右标记走过的路程。对于DFS，需要额外标出回溯的字母。对于BFS，也需要在结束当前节点的邻接点enqueue后加上标记符。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] directions = <span class="keyword">new</span> <span class="keyword">int</span>[][] &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span>[] directionsChar = <span class="keyword">new</span> <span class="keyword">char</span>[] &#123;<span class="string">'u'</span>, <span class="string">'d'</span>, <span class="string">'l'</span>, <span class="string">'r'</span>&#125;;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinctIslands</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> rowTotal = grid.length, colTotal = grid[<span class="number">0</span>].length;</div><div class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowTotal; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; colTotal; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</div><div class="line">                    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">                    <span class="comment">// dfs(grid, i, j, sb, 'o');</span></div><div class="line">                    bfs(grid, i, j, sb);</div><div class="line">                    set.add(sb.toString());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> set.size();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> row, <span class="keyword">int</span> col, StringBuilder sb)</span> </span>&#123;</div><div class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        q.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;row, col&#125;);</div><div class="line">        grid[row][col] = <span class="number">0</span>;     <span class="comment">// BFS在加入queue的时候就要将grid标记为已访问了</span></div><div class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</div><div class="line">            <span class="keyword">int</span>[] curr = q.poll();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; directions.length; i++) &#123;</div><div class="line">                <span class="keyword">int</span> rowNeighbor = curr[<span class="number">0</span>] + directions[i][<span class="number">0</span>];</div><div class="line">                <span class="keyword">int</span> colNeighbor = curr[<span class="number">1</span>] + directions[i][<span class="number">1</span>];</div><div class="line">                <span class="keyword">if</span> (validatePos(grid, rowNeighbor, colNeighbor)) &#123;</div><div class="line">                    grid[rowNeighbor][colNeighbor] = <span class="number">0</span>;</div><div class="line">                    q.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;rowNeighbor, colNeighbor&#125;);</div><div class="line">                    sb.append(directionsChar[i]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            sb.append(<span class="string">','</span>); <span class="comment">// 表示将当前的所有neighbor都enqueue了</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> row, <span class="keyword">int</span> col, StringBuilder sb, <span class="keyword">char</span> dir)</span> </span>&#123;</div><div class="line">        grid[row][col] = <span class="number">0</span>;</div><div class="line">        sb.append(dir);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; directions.length; i++) &#123;</div><div class="line">            <span class="keyword">int</span> rowNeighbor = row + directions[i][<span class="number">0</span>];</div><div class="line">            <span class="keyword">int</span> colNeighbor = col + directions[i][<span class="number">1</span>];</div><div class="line">            <span class="keyword">if</span> (validatePos(grid, rowNeighbor, colNeighbor)) &#123;</div><div class="line">                dfs(grid, rowNeighbor, colNeighbor, sb, directionsChar[i]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        sb.append(<span class="string">'b'</span>);     <span class="comment">// Trick!!! DFS回溯的时候需要标出来，不然无法区分是否回溯之后的位移</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validatePos</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> row &gt;= <span class="number">0</span> &amp;&amp; row &lt; grid.length &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; grid[<span class="number">0</span>].length &amp;&amp; grid[row][col] == <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="695-max-area-of-island"><a href="#695-max-area-of-island" class="headerlink" title="695. max-area-of-island"></a><a href="https://leetcode.com/problems/max-area-of-island/description/" target="_blank" rel="external">695. max-area-of-island</a></h4><ul>
<li>给一个grid，表示水和小岛，求最大的岛的面积。DFS搞定，skip。</li>
</ul>
<h4 id="696-count-binary-substrings"><a href="#696-count-binary-substrings" class="headerlink" title="696. count-binary-substrings"></a><a href="https://leetcode.com/problems/count-binary-substrings/description/" target="_blank" rel="external">696. count-binary-substrings</a></h4><ul>
<li>给一个只含有0和1的字符串，求其中有多少个子字符串使得0和1分别连续出现且个数相等，例如<code>01</code>, <code>1100</code>就满足要求。</li>
<li>从头到尾遍历，然后双指针扩散判断。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countBinarySubstrings</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">2</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">1</span>, ans = <span class="number">0</span>;       <span class="comment">// 同时比较相邻两个字符</span></div><div class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</div><div class="line">            <span class="keyword">if</span> (s.charAt(left) != s.charAt(right)) &#123;    <span class="comment">// 往左和右分别扩展</span></div><div class="line">                <span class="keyword">char</span> charLeft = s.charAt(left), charRight = s.charAt(right);</div><div class="line">                <span class="keyword">int</span> i = left - <span class="number">1</span>, j = right + <span class="number">1</span>, count = <span class="number">1</span>;</div><div class="line">                <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i) == charLeft &amp;&amp; </div><div class="line">                       j &lt; s.length() &amp;&amp; s.charAt(j) == charRight) &#123;</div><div class="line">                    i--;</div><div class="line">                    j++;</div><div class="line">                    count++;</div><div class="line">                &#125;</div><div class="line">                ans += count;</div><div class="line">            &#125;</div><div class="line">            left++;</div><div class="line">            right++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="698-partition-to-k-equal-sum-subsets"><a href="#698-partition-to-k-equal-sum-subsets" class="headerlink" title="698. partition-to-k-equal-sum-subsets"></a><a href="https://leetcode.com/problems/partition-to-k-equal-sum-subsets/description/" target="_blank" rel="external">698. partition-to-k-equal-sum-subsets</a></h4><ul>
<li>给一个只含有(0, 10000)的int数组和一个k，判断是否可以将该数组划分为k个相等sum的partition。</li>
<li><p>似乎是个NP-hard的问题。只能用暴力办法，DFS+标记数组，每次累加过后进入下一层看看是否达到了targetSum，达到了就清空继续往后找新的一组subset.最后如果只剩下一组了，直接返回true，因为此时其他k - 1个组都已经达到targetSum了，当前的<code>sum = k * targetSum - (k - 1) * targetSum = targetSum</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span> || k &gt; nums.length || k &lt; <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> sum = IntStream.of(nums).sum();  <span class="comment">// Java8的stream!</span></div><div class="line">        <span class="keyword">if</span> (sum % k != <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> targetSum = sum / k;</div><div class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</div><div class="line">        <span class="keyword">return</span> checkPartition(nums, visited, <span class="number">0</span>, targetSum, <span class="number">0</span>, k);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkPartition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] visited, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> targetSum, <span class="keyword">int</span> currSum, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;    <span class="comment">// 提前break</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (currSum == targetSum) &#123;</div><div class="line">            <span class="keyword">return</span> checkPartition(nums, visited, <span class="number">0</span>, targetSum, <span class="number">0</span>, k - <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; nums.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</div><div class="line">                visited[i] = <span class="keyword">true</span>;</div><div class="line">                <span class="keyword">if</span> (checkPartition(nums, visited, i + <span class="number">1</span>, targetSum, currSum + nums[i], k)) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">                visited[i] = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法二：更快的做法是先对数组排序，然后存k个bucket，每个bucket从后往前取元素不断累加.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span> || k &gt; nums.length || k &lt; <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</div><div class="line">            sum += num;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (sum % k != <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> targetSum = sum / k;</div><div class="line">        Arrays.sort(nums);</div><div class="line">        <span class="keyword">return</span> checkPartition(nums, targetSum, <span class="keyword">new</span> <span class="keyword">int</span>[k], nums.length - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkPartition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> targetSum, <span class="keyword">int</span>[] buckets, <span class="keyword">int</span> numsIndex)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (numsIndex &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> bucket : buckets) &#123;</div><div class="line">                <span class="keyword">if</span> (bucket != targetSum) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buckets.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (buckets[i] + nums[numsIndex] &lt;= targetSum) &#123;</div><div class="line">                buckets[i] += nums[numsIndex];</div><div class="line">                <span class="keyword">if</span> (checkPartition(nums, targetSum, buckets, numsIndex - <span class="number">1</span>)) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">                buckets[i] -= nums[numsIndex];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>follow-up: 如果去掉正数的限制，允许出现负数和0？</p>
</li>
<li>上面的方法只考虑了直接累积叠加，无法解决负数问题。因此需要引入一个elementCount来统计当前这一波存入了多少element，当达到targetSum的时候需要判断当前这一波是否真的存入了元素。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span> || k &gt; nums.length || k &lt; <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> sum = IntStream.of(nums).sum();</div><div class="line">        <span class="keyword">if</span> (sum % k != <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> targetSum = sum / k;</div><div class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</div><div class="line">        <span class="keyword">return</span> checkPartition(nums, visited, <span class="number">0</span>, targetSum, <span class="number">0</span>, k, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkPartition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] visited, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> targetSum, <span class="keyword">int</span> currSum, <span class="keyword">int</span> k, <span class="keyword">int</span> elementCount)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;      <span class="comment">// 必须算完才行</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (currSum == targetSum &amp;&amp; elementCount &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> checkPartition(nums, visited, <span class="number">0</span>, targetSum, <span class="number">0</span>, k - <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; nums.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</div><div class="line">                visited[i] = <span class="keyword">true</span>;</div><div class="line">                <span class="keyword">if</span> (checkPartition(nums, visited, i + <span class="number">1</span>, targetSum, currSum + nums[i], k, elementCount + <span class="number">1</span>)) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">                visited[i] = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="699-falling-squares"><a href="#699-falling-squares" class="headerlink" title="699. falling-squares"></a><a href="https://leetcode.com/problems/falling-squares/description/" target="_blank" rel="external">699. falling-squares</a></h4><ul>
<li>给一个二维数组，每一行表示一个方块的起始坐标和边长。方块按照数组的顺序下落，方块底部可以粘在下面的方块上，无限堆叠，求一个List表示当前已下落的所有方块中的最大高度。</li>
<li><p>方法一：naive的O(N^2)暴力遍历法。对于每个方块都往前遍历所有的方块求当前方块的高度，然后和List的前一个元素比较，获取最大高度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Square</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> left, right, height;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Square</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> height)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.left = left;</div><div class="line">            <span class="keyword">this</span>.right = right;</div><div class="line">            <span class="keyword">this</span>.height = height;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">fallingSquares</span><span class="params">(<span class="keyword">int</span>[][] positions)</span> </span>&#123;</div><div class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">if</span> (positions == <span class="keyword">null</span> || positions.length == <span class="number">0</span> || positions[<span class="number">0</span>].length &lt; <span class="number">2</span>) &#123;</div><div class="line">            <span class="keyword">return</span> ans;</div><div class="line">        &#125;</div><div class="line">        Square[] squares = <span class="keyword">new</span> Square[positions.length];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; positions.length; i++) &#123;</div><div class="line">            squares[i] = <span class="keyword">new</span> Square(positions[i][<span class="number">0</span>], positions[i][<span class="number">0</span>] + positions[i][<span class="number">1</span>], positions[i][<span class="number">1</span>]);</div><div class="line">            <span class="keyword">int</span> currHeight = getHeight(squares, i);</div><div class="line">            squares[i].height = currHeight;</div><div class="line">            ans.add(Math.max(i &gt; <span class="number">0</span> ? ans.get(i - <span class="number">1</span>) : <span class="number">0</span>, currHeight));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(Square[] squares, <span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> maxHeight = squares[i].height;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (squares[i].left &gt;= squares[j].right || squares[i].right &lt;= squares[j].left) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            maxHeight = Math.max(maxHeight, squares[i].height + squares[j].height);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxHeight;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法二：TreeMap</p>
</li>
<li>方法三：Segment Tree</li>
</ul>
<h4 id="703-kth-largest-element-in-a-stream"><a href="#703-kth-largest-element-in-a-stream" class="headerlink" title="703. kth-largest-element-in-a-stream"></a><a href="https://leetcode.com/problems/kth-largest-element-in-a-stream/description/" target="_blank" rel="external">703. kth-largest-element-in-a-stream</a></h4><ul>
<li>实现一个能handle stream of int的类，调用add时能返回第k大的数。</li>
<li>和求top k element一个道理，PriorityQueue搞定。skip.</li>
</ul>
<h4 id="708-insert-into-a-cyclic-sorted-list"><a href="#708-insert-into-a-cyclic-sorted-list" class="headerlink" title="708. insert-into-a-cyclic-sorted-list"></a><a href="https://leetcode.com/problems/insert-into-a-cyclic-sorted-list/" target="_blank" rel="external">708. insert-into-a-cyclic-sorted-list</a></h4><ul>
<li>给一个环状链表的任意一个节点，这个链表是从小到大有序的，插入一个新节点，返回原本给的那个节点。若一开始为null，则返回新插入的节点。</li>
<li>方法一：各种条件判断，边缘情况讨论，各种if，没有成功。</li>
<li>方法二：先走一波找到最大的节点，即给的节点开始往后走，一旦当前节点比后续节点大了就说明拐点到了。暂时将最大节点与后续节点断开，后续节点就是最小节点，在它之前插入一个dummy节点，以方便插入，然后从dummy开始往后一个个看，一旦当前节点不比要插入的节点小了，就是插入位置了，或者一直到最后都没找到插入点，就插在末尾。最后再把最大节点接回最小节点即可，注意需要判断最大节点有没有变化，即看看之前的那个「最大节点」后面是否为null。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">insert</span><span class="params">(Node head, <span class="keyword">int</span> insertVal)</span> </span>&#123;</div><div class="line">        Node newNode = <span class="keyword">new</span> Node(insertVal, <span class="keyword">null</span>);</div><div class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</div><div class="line">            head = newNode;</div><div class="line">            head.next = newNode;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 1. 找到最大的节点，变成单向链表</span></div><div class="line">        Node curr = head;</div><div class="line">        <span class="keyword">while</span> (curr.next != head &amp;&amp; curr.val &lt;= curr.next.val) &#123;</div><div class="line">            curr = curr.next;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 2. 将最大节点断开，从dummy开始往后找插入点</span></div><div class="line">        Node maxNode = curr, dummy = <span class="keyword">new</span> Node(Integer.MIN_VALUE, curr.next);</div><div class="line">        maxNode.next = <span class="keyword">null</span>;    <span class="comment">// 最大之后就是最小的了，断开</span></div><div class="line">        curr = dummy;           <span class="comment">// dummy之后就是最小节点</span></div><div class="line">        <span class="keyword">while</span> (curr.next != <span class="keyword">null</span> &amp;&amp; curr.next.val &lt; insertVal) &#123;</div><div class="line">            curr = curr.next;</div><div class="line">        &#125;</div><div class="line">        newNode.next = curr.next;</div><div class="line">        curr.next = newNode;</div><div class="line">        Node newMax = maxNode.next == <span class="keyword">null</span> ? maxNode : maxNode.next;</div><div class="line">        newMax.next = dummy.next;</div><div class="line">        <span class="keyword">return</span> head;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="711-number-of-distinct-islands-ii"><a href="#711-number-of-distinct-islands-ii" class="headerlink" title="711. number-of-distinct-islands-ii"></a><a href="https://leetcode.com/problems/number-of-distinct-islands-ii/description/" target="_blank" rel="external">711. number-of-distinct-islands-ii</a></h4><ul>
<li>给一个二维grid表示小岛，求其中形状distinct的小岛数量。这些形状可以任意平移、轴对称、翻转。</li>
<li>暴力方法，遍历完一个小岛的时候就将所有的轴对称、翻转形式统统列出来，然后根据某个统一标准取一个root form来代表所有这些形状，这里就直接使用encode之后字典序最小的作为key。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">int</span>[][] directions = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">int</span>[][] transitions = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;&#125;;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinctIslands2</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> rowTotal = grid.length, colTotal = grid[<span class="number">0</span>].length;</div><div class="line">        Set&lt;String&gt; islandSet = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowTotal; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; colTotal; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</div><div class="line">                    List&lt;<span class="keyword">int</span>[]&gt; island = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">                    dfs(grid, i, j, island);</div><div class="line">                    islandSet.add(getRootShape(island));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> islandSet.size();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> row, <span class="keyword">int</span> col, List&lt;<span class="keyword">int</span>[]&gt; island)</span> </span>&#123;</div><div class="line">        island.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;row, col&#125;);</div><div class="line">        grid[row][col] = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] direction : directions) &#123;</div><div class="line">            <span class="keyword">int</span> rowNeighbor = row + direction[<span class="number">0</span>];</div><div class="line">            <span class="keyword">int</span> colNeighbor = col + direction[<span class="number">1</span>];</div><div class="line">            <span class="keyword">if</span> (validatePos(grid, rowNeighbor, colNeighbor)) &#123;</div><div class="line">                dfs(grid, rowNeighbor, colNeighbor, island);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validatePos</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> row &gt;= <span class="number">0</span> &amp;&amp; row &lt; grid.length &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; grid[<span class="number">0</span>].length &amp;&amp; grid[row][col] == <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getRootShape</span><span class="params">(List&lt;<span class="keyword">int</span>[]&gt; island)</span> </span>&#123;</div><div class="line">        List&lt;String&gt; shapes = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="comment">// 对于shape中的一个点，总共有八种形式</span></div><div class="line">        <span class="comment">// (x, y), (x, -y), (-x, y), (-x, -y)</span></div><div class="line">        <span class="comment">// (y, x), (-y, x), (y, -x), (-y, -x)</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] transition : transitions) &#123;</div><div class="line">            List&lt;<span class="keyword">int</span>[]&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            List&lt;<span class="keyword">int</span>[]&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] point : island) &#123;</div><div class="line">                list1.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;point[<span class="number">0</span>] * transition[<span class="number">0</span>], point[<span class="number">1</span>] * transition[<span class="number">1</span>]&#125;);</div><div class="line">                list2.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;point[<span class="number">1</span>] * transition[<span class="number">1</span>], point[<span class="number">0</span>] * transition[<span class="number">0</span>]&#125;);</div><div class="line">            &#125;</div><div class="line">            shapes.add(getKey(list1));  <span class="comment">// 获取每个方向上的root encode形式</span></div><div class="line">            shapes.add(getKey(list2));</div><div class="line">        &#125;</div><div class="line">        Collections.sort(shapes);       <span class="comment">// 用最小的代表所有这些shape</span></div><div class="line">        <span class="keyword">return</span> shapes.get(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getKey</span><span class="params">(List&lt;<span class="keyword">int</span>[]&gt; points)</span> </span>&#123;</div><div class="line">        Collections.sort(points, (a, b) -&gt; a[<span class="number">0</span>] != b[<span class="number">0</span>] ? a[<span class="number">0</span>] - b[<span class="number">0</span>] : a[<span class="number">1</span>] - b[<span class="number">1</span>]);</div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">int</span> row = points.get(<span class="number">0</span>)[<span class="number">0</span>], col = points.get(<span class="number">0</span>)[<span class="number">1</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] point : points) &#123;</div><div class="line">            <span class="comment">// 注意是与最小的那个点的delta作为坐标，即相对坐标</span></div><div class="line">            sb.append(point[<span class="number">0</span>] - row).append(<span class="string">','</span>).append(point[<span class="number">1</span>] - col).append(<span class="string">';'</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sb.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="714-best-time-to-buy-and-sell-stock-with-transaction-fee"><a href="#714-best-time-to-buy-and-sell-stock-with-transaction-fee" class="headerlink" title="714. best-time-to-buy-and-sell-stock-with-transaction-fee"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/" target="_blank" rel="external">714. best-time-to-buy-and-sell-stock-with-transaction-fee</a></h4><ul>
<li>给一个数组表示股票价格，每次交易（买卖完成算一次）都会收取手续费。求最大收益。</li>
<li>（思路来自覃超说算法）DP。<code>profit[i][0]</code>表示第i天<strong>不持有</strong>股票手头的资金，<code>profit[i][1]</code>表示第i天<strong>持有</strong>股票手头的资金.初始化时第一天如果不持有股票则手头为0，若持有股票则需要消耗资金，因此是<code>-price[0]</code>。之后的状态转换为<code>profit[i][0] = profit[i - 1][0]（前一天也没有买入）和profit[i - 1][1] + prices[i]（前一天是持有的，今天卖出）的较大者</code>。类似地，<code>profit[i][1] = profit[i - 1][1]（前一天也持有）和profit[i - 1][0] - prices[i]（前一天没有，今天买入）的较大者</code>。最后返回最后一天不持有股票的profit即可。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[][] profit = <span class="keyword">new</span> <span class="keyword">int</span> [prices.length][<span class="number">2</span>];</div><div class="line">        profit[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">        profit[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; profit.length; i++) &#123;</div><div class="line">            profit[i][<span class="number">0</span>] = Math.max(profit[i - <span class="number">1</span>][<span class="number">0</span>], profit[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i] - fee);</div><div class="line">            profit[i][<span class="number">1</span>] = Math.max(profit[i - <span class="number">1</span>][<span class="number">1</span>], profit[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> profit[prices.length - <span class="number">1</span>][<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="719-find-k-th-smallest-pair-distance"><a href="#719-find-k-th-smallest-pair-distance" class="headerlink" title="719. find-k-th-smallest-pair-distance"></a><a href="https://leetcode.com/problems/find-k-th-smallest-pair-distance/description/" target="_blank" rel="external">719. find-k-th-smallest-pair-distance</a></h4><ul>
<li>给一个int数组，求每两个数之差中第k小的值。例如<code>[1,3,8,4,5,45]</code>，当k = 1，返回1，当k = 3，返回2.</li>
<li>先对所有元素从小到大排序，那么间距最小值为0、最大值为最右减最左。用二分查找的思想，假设mid为第k小的值，然后O(N^2)遍历求有多少对儿数之差小于mid；若对儿数小于k，说明猜的值太小了排太前了；大于k则说明猜太大了。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">smallestDistancePair</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        Arrays.sort(nums);</div><div class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums[nums.length - <span class="number">1</span>] - nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</div><div class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;   <span class="comment">// 猜一个距离</span></div><div class="line">            <span class="keyword">int</span> count = <span class="number">0</span>, left = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> right = <span class="number">1</span>; right &lt; nums.length; right++) &#123;</div><div class="line">                <span class="keyword">while</span> (nums[right] - nums[left] &gt; mid) &#123;</div><div class="line">                    left++;</div><div class="line">                &#125;</div><div class="line">                count += right - left;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (count &lt; k) &#123;        <span class="comment">// 说明猜的不够大</span></div><div class="line">                lo = mid + <span class="number">1</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                hi = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> lo;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="720-longest-word-in-dictionary"><a href="#720-longest-word-in-dictionary" class="headerlink" title="720. longest-word-in-dictionary"></a><a href="https://leetcode.com/problems/longest-word-in-dictionary/description/" target="_blank" rel="external">720. longest-word-in-dictionary</a></h4><ul>
<li>给一个string数组，只含有小写字母，这些word可能形成链式如<code>a, ap, app, appl, apple</code>，求能形成链式的最长的单词，若有多个则取lexicographical最小的。</li>
<li>用sort + Set的方式比较trivial。还有<a href="https://leetcode.com/problems/longest-word-in-dictionary/discuss/109113/Java-Solution-with-Trie-+-BFS" target="_blank" rel="external">一种Trie + DFS/BFS的</a>更考察基本功，构建trie之后从root节点开始尝试从后往前遍历邻接点并更新最长word，这样就可以保证是lexicograpchical最小的了。</li>
</ul>
<h4 id="721-accounts-merge"><a href="#721-accounts-merge" class="headerlink" title="721. accounts-merge"></a><a href="https://leetcode.com/problems/accounts-merge/description/" target="_blank" rel="external">721. accounts-merge</a></h4><ul>
<li>给一堆字符串List，每个List中首先是名字，然后是这个人的各种邮箱。最后放回经过merge的姓名、邮箱List，并且要求将邮箱从小到大排序。</li>
<li><p>这种多对一的关系查找，特别适合用并查集。首先将每个邮箱的parent设为自己，然后将每个List靠后面的邮箱统一把parent设成第一个邮箱。然后利用TreeSet实现邮箱的排序，最后导出到List返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; accountsMerge(List&lt;List&lt;String&gt;&gt; accounts) &#123;</div><div class="line">        List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">if</span> (accounts == <span class="keyword">null</span> || accounts.size() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> ans;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 初始化并查集，并存放每个email的主人</span></div><div class="line">        Map&lt;String, String&gt; parent = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        Map&lt;String, String&gt; emailOwner = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (List&lt;String&gt; account : accounts) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; account.size(); i++) &#123;</div><div class="line">                parent.put(account.get(i), account.get(i));     <span class="comment">// 老大初始化为自己</span></div><div class="line">                emailOwner.put(account.get(i), account.get(<span class="number">0</span>));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 将同一个人的邮箱存入并查集map</span></div><div class="line">        <span class="keyword">for</span> (List&lt;String&gt; account : accounts) &#123;</div><div class="line">            String root = find(parent, account.get(<span class="number">1</span>));</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; account.size(); i++) &#123;</div><div class="line">                parent.put(find(parent, account.get(i)), root);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 将同属一个老大的email存入TreeSet以排序</span></div><div class="line">        Map&lt;String, Set&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (List&lt;String&gt; account : accounts) &#123;</div><div class="line">            String root = find(parent, account.get(<span class="number">1</span>));</div><div class="line">            <span class="keyword">if</span> (!map.containsKey(root)) &#123;</div><div class="line">                map.put(root, <span class="keyword">new</span> TreeSet&lt;String&gt;());</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; account.size(); i++) &#123;</div><div class="line">                map.get(root).add(account.get(i));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 最后导出到List中返回</span></div><div class="line">        <span class="keyword">for</span> (String email : map.keySet()) &#123;</div><div class="line">            String owner = emailOwner.get(email);</div><div class="line">            List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(map.get(email));</div><div class="line">            list.add(<span class="number">0</span>, owner);</div><div class="line">            ans.add(list);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">find</span><span class="params">(Map&lt;String, String&gt; parent, String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (!parent.get(s).equals(s)) &#123;</div><div class="line">            parent.put(s, parent.get(parent.get(s)));   <span class="comment">// 将当前的parent设为"parent的parent"</span></div><div class="line">            s = parent.get(s);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> s;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>其实更直白的看，这题就是个图论题，整理出图的联通部分。首先是构建graph，每个邮箱都是节点，用Set存每一行所给邮箱组成的subgraph，每个邮箱都用Set存放可达邻居（需要双向添加）。然后开始DFS或BFS搜索图，将每一行的第一个邮箱作为起点，把所有可达的邮箱都加进来，在这个过程中需要标记visited。之后如果再遇到visited的邮箱就说明已经在之前“可达”掉了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; accountsMerge(List&lt;List&lt;String&gt;&gt; accounts) &#123;</div><div class="line">        <span class="comment">// build the graph</span></div><div class="line">        Map&lt;String,Set&lt;String&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (List&lt;String&gt; ls : accounts) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ls.size();i ++) &#123;</div><div class="line">                <span class="keyword">if</span> (!graph.containsKey(ls.get(i))) graph.put(ls.get(i), <span class="keyword">new</span> HashSet&lt;String&gt;());</div><div class="line">                graph.get(ls.get(i)).add(ls.get(<span class="number">1</span>));</div><div class="line">                graph.get(ls.get(<span class="number">1</span>)).add(ls.get(i));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// traverse the graph, find out all the connected subgraph</span></div><div class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (List&lt;String&gt; ls : accounts) &#123;</div><div class="line">            <span class="keyword">if</span> (!visited.contains(ls.get(<span class="number">1</span>))) &#123;</div><div class="line">                List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">                bfs(graph, visited, ls.get(<span class="number">1</span>), ans); <span class="comment">// or dfs(graph,visited,ls.get(1),ans)</span></div><div class="line">                Collections.sort(ans);</div><div class="line">                ans.add(<span class="number">0</span>,ls.get(<span class="number">0</span>));</div><div class="line">                result.add(ans);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Map&lt;String, Set&lt;String&gt;&gt; graph, Set&lt;String&gt; visited, String s, List&lt;String&gt; ans)</span> </span>&#123;</div><div class="line">        ans.add(s);</div><div class="line">        visited.add(s);</div><div class="line">        <span class="keyword">for</span> (String str : graph.get(s)) &#123;</div><div class="line">            <span class="keyword">if</span> (!visited.contains(str)) &#123;</div><div class="line">                dfs(graph, visited, str, ans);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Map&lt;String, Set&lt;String&gt;&gt; graph, Set&lt;String&gt; visited, String s, List&lt;String&gt; ans)</span> </span>&#123;</div><div class="line">        Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        q.add(s);</div><div class="line">        visited.add(s);</div><div class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</div><div class="line">            String t = q.poll();</div><div class="line">            ans.add(t);</div><div class="line">            <span class="keyword">for</span> (String str : graph.get(t)) &#123;</div><div class="line">                <span class="keyword">if</span> (!visited.contains(str)) &#123;</div><div class="line">                    q.add(str);</div><div class="line">                    visited.add(str);</div><div class="line">                &#125; </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="722-remove-comments"><a href="#722-remove-comments" class="headerlink" title="722. remove-comments"></a><a href="https://leetcode.com/problems/remove-comments/description/" target="_blank" rel="external">722. remove-comments</a></h4><ul>
<li>给一个string数组，每一个string代表一行C++代码，要求将其中的comment清除。可以保证这些comment不会存在于字符串中。</li>
<li>没什么意思。用一个inComment布尔值存放当前是否在注释块中。遍历每行代码的时候若仍在注释块中则关注<code>*/</code>；正常状态下则先关注是否是<code>//</code>，这样后续就不用继续append了，否则关注<code>/*</code>。</li>
</ul>
<h4 id="724-find-pivot-index"><a href="#724-find-pivot-index" class="headerlink" title="724. find-pivot-index"></a><a href="https://leetcode.com/problems/find-pivot-index/description/" target="_blank" rel="external">724. find-pivot-index</a></h4><ul>
<li>给一个int数组，求其中一个index使得左侧数字之和与右侧数字之和相等。zillow面试原题，维护leftSum和rightSum即可。</li>
</ul>
<h4 id="726-number-of-atoms"><a href="#726-number-of-atoms" class="headerlink" title="726. number-of-atoms"></a><a href="https://leetcode.com/problems/number-of-atoms/description/" target="_blank" rel="external">726. number-of-atoms</a></h4><ul>
<li>给一个字符串表示化学物质，统计其中的元素及出现次数，按字典序输出。例如<code>H2(O(Mn)2)3</code>输出<code>H2Mn6O3</code>.</li>
<li>只有1个元素是输出1还是不输出？（不输出数字，只输出元素）</li>
<li>由于含有括号，联想运算符算式就知道要用Stack进行吞吐来处理括号嵌套的情况。如果是字母，就一直找到小写的为止作为元素名字，之后跟着的数字就是count，存入map。若出现左括号，则当前的这个map（保存了括号之前的元素及count）直接入栈，然后用新的map继续统计，一旦遇到右括号，说明当前部分结束(注意需要检查右括号之后还有没有数字)，则与栈顶弹出的map合并一下就好了。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">countOfAtoms</span><span class="params">(String formula)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (formula == <span class="keyword">null</span> || formula.length() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">        &#125;</div><div class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        Stack&lt;Map&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        <span class="keyword">char</span>[] fChar = formula.toCharArray();</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, fLen = fChar.length;</div><div class="line">        <span class="keyword">while</span> (i &lt; fLen) &#123;</div><div class="line">            <span class="keyword">if</span> (fChar[i] == <span class="string">'('</span>) &#123;  <span class="comment">// 将之前的map压栈</span></div><div class="line">                stack.push(map);    </div><div class="line">                map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">                i++;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fChar[i] == <span class="string">')'</span>) &#123;   <span class="comment">// 将当前的合并入之前的map</span></div><div class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">                i++;</div><div class="line">                <span class="comment">// 取括号后的数值</span></div><div class="line">                <span class="keyword">while</span> (i &lt; fLen &amp;&amp; Character.isDigit(fChar[i])) &#123;</div><div class="line">                    count = (<span class="number">10</span> * count) + fChar[i++] - <span class="string">'0'</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</div><div class="line">                    count = <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (!stack.isEmpty()) &#123;</div><div class="line">                    Map&lt;String, Integer&gt; prevMap = stack.pop();</div><div class="line">                    <span class="keyword">for</span> (String atom: map.keySet()) &#123;   <span class="comment">// 取当前map中的atom放入之前的</span></div><div class="line">                        prevMap.put(atom, prevMap.getOrDefault(atom, <span class="number">0</span>) + map.get(atom) * count);</div><div class="line">                    &#125;</div><div class="line">                    map = prevMap;  <span class="comment">// 用回原来的map</span></div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 以字母开头，直到非小写字母为一个原子</span></div><div class="line">                <span class="keyword">int</span> end = i + <span class="number">1</span>;</div><div class="line">                <span class="keyword">while</span> (end &lt; fLen &amp;&amp; Character.isLowerCase(fChar[end])) &#123;</div><div class="line">                    end++;</div><div class="line">                &#125;</div><div class="line">                String atom = formula.substring(i, end);</div><div class="line">                </div><div class="line">                <span class="comment">// 看看字母之后是否跟着数字</span></div><div class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">                <span class="keyword">while</span> (end &lt; fLen &amp;&amp; Character.isDigit(fChar[end])) &#123;</div><div class="line">                    count = <span class="number">10</span> * count + fChar[end++] - <span class="string">'0'</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</div><div class="line">                    count = <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                <span class="comment">// 更新原子数值 </span></div><div class="line">                map.put(atom, map.getOrDefault(atom, <span class="number">0</span>) + count);</div><div class="line">                i = end;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">        List&lt;String&gt; atoms = <span class="keyword">new</span> ArrayList&lt;&gt;(map.keySet());</div><div class="line">        Collections.sort(atoms);    <span class="comment">// 字母顺序</span></div><div class="line">        <span class="keyword">for</span> (String atom: atoms) &#123;</div><div class="line">            sb.append(atom);</div><div class="line">            <span class="keyword">if</span> (map.get(atom) &gt; <span class="number">1</span>) &#123;</div><div class="line">                sb.append(map.get(atom));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sb.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="727-minimum-window-subsequence"><a href="#727-minimum-window-subsequence" class="headerlink" title="727. minimum-window-subsequence"></a><a href="https://leetcode.com/problems/minimum-window-subsequence/description/" target="_blank" rel="external">727. minimum-window-subsequence</a></h4><ul>
<li>给一个source字符串和一个target字符串，求在source的最短子串使得包含target的所有字符（个数和出现顺序都必须一致）。</li>
<li>DP（感觉是野路子，不太好想）。。。纵向行为target，横向列为source，第一行全部初始化为<code>0,1,2....sLen</code>表示从第几位开始取，之后所有值初始化为-1表示无解。然后O(M*N)逐个字符遍历两个字符串，若匹配上了则从左上方取起始位置（看前一个字符的情况），若匹配不上则默认继续取source（直接取左侧的值）。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String S, String T)</span> </span>&#123;</div><div class="line">        <span class="comment">// 动态规划, 行为tLen + 1, 列为sLen + 1, dp[][]表示从dp[i][j]到j到这部分字符串是所求，</span></div><div class="line">        <span class="comment">// 即T[0, j)是S[0, i)的subsequence with substring S[dp[i][j], j).</span></div><div class="line">        <span class="comment">// 初始状态为</span></div><div class="line">        <span class="comment">// 状态转换为，若当前字符不匹配，则根据左侧（即S前一个字符）情况决定起始位置（保证最短）</span></div><div class="line">        <span class="comment">// 若匹配，则依赖于左上方的结果，即T前一个字符的起始位置。</span></div><div class="line">        <span class="keyword">if</span> (S == <span class="keyword">null</span> || T == <span class="keyword">null</span> || S.length() == <span class="number">0</span> || T.length() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">char</span>[] sChar = S.toCharArray();</div><div class="line">        <span class="keyword">char</span>[] tChar = T.toCharArray();</div><div class="line">        <span class="keyword">int</span> sLen = sChar.length, tLen = tChar.length;</div><div class="line">        <span class="keyword">int</span>[][] startFrom = <span class="keyword">new</span> <span class="keyword">int</span> [tLen + <span class="number">1</span>][sLen + <span class="number">1</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= tLen; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= sLen; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</div><div class="line">                    startFrom[i][j] = j;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    startFrom[i][j] = -<span class="number">1</span>;   <span class="comment">// -1表示无解</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tLen; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sLen; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (sChar[j - <span class="number">1</span>] == tChar[i - <span class="number">1</span>]) &#123;</div><div class="line">                    startFrom[i][j] = startFrom[i - <span class="number">1</span>][j - <span class="number">1</span>];</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    startFrom[i][j] = startFrom[i][j - <span class="number">1</span>];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = sLen, minLen = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sLen; j++) &#123;</div><div class="line">            System.out.print(startFrom[tLen][j] + <span class="string">" "</span>);</div><div class="line">            <span class="keyword">if</span> (startFrom[tLen][j] != -<span class="number">1</span>) &#123;</div><div class="line">                <span class="keyword">int</span> currLen = j - startFrom[tLen][j];</div><div class="line">                <span class="keyword">if</span> (currLen &lt; minLen) &#123;</div><div class="line">                    start = startFrom[tLen][j];</div><div class="line">                    end = j;</div><div class="line">                    minLen = currLen;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> minLen == Integer.MAX_VALUE? <span class="string">""</span> : S.substring(start, end);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="729-my-calendar-i"><a href="#729-my-calendar-i" class="headerlink" title="729. my-calendar-i"></a><a href="https://leetcode.com/problems/my-calendar-i/description/" target="_blank" rel="external">729. my-calendar-i</a></h4><ul>
<li>给若干开始时间+结束时间pair，实现book函数判断能否成功添加事件，不能有时间重叠。</li>
<li><p>方法一：暴力法，从头到尾遍历链表，无冲突就插入。效率O(N)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCalendar</span> </span>&#123;</div><div class="line">    <span class="comment">// 定义一个链表，每次遍历所有节点判断有没有重合，没有就插入到末尾</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> start;</div><div class="line">        <span class="keyword">int</span> end;</div><div class="line">        Node next;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.start = start;</div><div class="line">            <span class="keyword">this</span>.end = end;</div><div class="line">            next = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    Node head = <span class="keyword">null</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCalendar</span><span class="params">()</span> </span>&#123;</div><div class="line">        head = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">book</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</div><div class="line">            head = <span class="keyword">new</span> Node(start, end);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> checkAndAdd(<span class="keyword">new</span> Node(start, end));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// brute force: check with every existing intervals and insert at the end</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkAndAdd</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">        Node curr = head;</div><div class="line">        Node prev = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (node.end &gt; curr.start &amp;&amp; node.start &lt; curr.end) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                prev = curr;</div><div class="line">                curr = curr.next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        prev.next = node;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法二：利用TreeMap，对于每个[start, end]对，从TreeMap中找start的floor，取出它对应的end。一旦这个end大于start，就说明有重叠了。同理，也要从TreeMap中找start的ceiling，如果这个ceiling小于end，说明与后面有重叠。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCalendar</span> </span>&#123;</div><div class="line">    <span class="comment">// 维护start-end的TreeMap，每次尝试取输入的start的在TreeeMap中的下界和上界</span></div><div class="line">    <span class="comment">// 分别判断输入的start是否在最大的不大于start的floorStart对应的end之间，</span></div><div class="line">    <span class="comment">// 再判断最小的不小于start的ceilingStart会不会落在end之前</span></div><div class="line">    TreeMap&lt;Integer, Integer&gt; calendar;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCalendar</span><span class="params">()</span> </span>&#123;</div><div class="line">        calendar = <span class="keyword">new</span> TreeMap&lt;&gt;();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">book</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">        <span class="comment">// floorStart, start, floorStart'sEnd</span></div><div class="line">        Integer floorStart = calendar.floorKey(start);</div><div class="line">        <span class="keyword">if</span> (floorStart != <span class="keyword">null</span> &amp;&amp; calendar.get(floorStart) &gt; start) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// start, ceilingStart, end</span></div><div class="line">        Integer ceilingStart = calendar.ceilingKey(start);</div><div class="line">        <span class="keyword">if</span> (ceilingStart != <span class="keyword">null</span> &amp;&amp; ceilingStart &lt; end) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        calendar.put(start, end);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="731-my-calendar-ii"><a href="#731-my-calendar-ii" class="headerlink" title="731. my-calendar-ii"></a><a href="https://leetcode.com/problems/my-calendar-ii/description/" target="_blank" rel="external">731. my-calendar-ii</a></h4><ul>
<li>与729相比变成了不能出现triple的重叠就算是可以book。</li>
<li>注意不能简单地理解为一个interval同时与两个interval重叠，因为<code>[2,6]</code>和<code>[1,3]&amp;[5,7]</code>同时重叠，但没有形成triplet.</li>
<li>同样是维护TreeMap，对于每个新加入的interval，遍历已有的interval并把重叠的部分插入treemap。如果插入时发现有重叠，说明“重叠部分之间也有重叠”，这样就是triple了。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCalendarTwo</span> </span>&#123;</div><div class="line">    <span class="comment">// 原本一位和之前相比就只是多了一个map，这个存不了就尝试另一个map，都不行就说明triple了。</span></div><div class="line">    <span class="comment">// 但题目给的样例都不行，例如最后一个25~55，因为这个overlap分别和两个map里都interval重叠，但是没有形成triple；</span></div><div class="line">    <span class="comment">// 正解应该是用一个list维护所有的interval，然后用treemap只维护当前重叠的部分，如果后续又出现了和list里的重叠，</span></div><div class="line">    <span class="comment">// 就再去treemap中看看有没有第三次重叠。</span></div><div class="line">    <span class="comment">// 注意每次遍历都需要清空TreeMap，因为我在遍历List的时候只关心新加入的这个会不会和别的重叠。</span></div><div class="line">    List&lt;<span class="keyword">int</span>[]&gt; intervals;</div><div class="line">    TreeMap&lt;Integer, Integer&gt; overlap;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCalendarTwo</span><span class="params">()</span> </span>&#123;</div><div class="line">        intervals = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        overlap = <span class="keyword">new</span> TreeMap&lt;&gt;();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">book</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">        overlap.clear();</div><div class="line">        <span class="comment">// 遍历所有interval看看有没有重叠</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] interval: intervals) &#123;</div><div class="line">            <span class="keyword">if</span> (start &gt;= interval[<span class="number">0</span>] &amp;&amp; start &lt; interval[<span class="number">1</span>]) &#123;</div><div class="line">                <span class="comment">// interval:   ________</span></div><div class="line">                <span class="comment">// newInter:     _____...</span></div><div class="line">                <span class="keyword">if</span> (!addOverlap(start, Math.min(end, interval[<span class="number">1</span>]))) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end &gt; interval[<span class="number">0</span>] &amp;&amp; start &lt; interval[<span class="number">0</span>]) &#123;</div><div class="line">                <span class="comment">// interval:   ________</span></div><div class="line">                <span class="comment">// newInter:  ______...</span></div><div class="line">                <span class="keyword">if</span> (!addOverlap(interval[<span class="number">0</span>], Math.min(end, interval[<span class="number">1</span>]))) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        intervals.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;start, end&#125;);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addOverlap</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">        Integer floorStart = overlap.floorKey(start);</div><div class="line">        <span class="keyword">if</span> (floorStart != <span class="keyword">null</span> &amp;&amp; overlap.get(floorStart) &gt; start) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        Integer ceilingStart = overlap.ceilingKey(start);</div><div class="line">        <span class="keyword">if</span> (ceilingStart != <span class="keyword">null</span> &amp;&amp; ceilingStart &lt; end) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        overlap.put(start, end);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="733-flood-fill"><a href="#733-flood-fill" class="headerlink" title="733. flood-fill"></a><a href="https://leetcode.com/problems/flood-fill/description/" target="_blank" rel="external">733. flood-fill</a></h4><ul>
<li>给一个二维int数组，其中包含0-65535的值。给定坐标i，j，和一个newColor，将该cell周围和它值相等的cell都赋值为newColor.</li>
<li>DFS，直接赋值。需要注意如果原色和newColor相等就直接返回了，否则会stack overflow。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] floodFill(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</div><div class="line">        <span class="keyword">if</span> (image == <span class="keyword">null</span> || image.length == <span class="number">0</span> || image[<span class="number">0</span>].length == <span class="number">0</span> || image[sr][sc] == newColor) &#123; <span class="comment">// warning!!</span></div><div class="line">            <span class="keyword">return</span> image;</div><div class="line">        &#125;</div><div class="line">        dfs(image, sr, sc, image[sr][sc], newColor);</div><div class="line">        <span class="keyword">return</span> image;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> i &lt; <span class="number">0</span> || i &gt;= image.length || j &lt; <span class="number">0</span> || j &gt;= image[<span class="number">0</span>].length ? -<span class="number">1</span> : image[i][j];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> oldColor, <span class="keyword">int</span> newColor)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (getValue(image, i, j) != oldColor) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        image[i][j] = newColor;</div><div class="line">        dfs(image, i - <span class="number">1</span>, j, oldColor, newColor);</div><div class="line">        dfs(image, i + <span class="number">1</span>, j, oldColor, newColor);</div><div class="line">        dfs(image, i, j - <span class="number">1</span>, oldColor, newColor);</div><div class="line">        dfs(image, i, j + <span class="number">1</span>, oldColor, newColor);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="734-sentence-similarity"><a href="#734-sentence-similarity" class="headerlink" title="734. sentence-similarity"></a><a href="https://leetcode.com/problems/sentence-similarity/" target="_blank" rel="external">734. sentence-similarity</a></h4><ul>
<li>给一堆同义词<code>[(&quot;restaurant&quot;, &quot;cafe&quot;), (&quot;ratings&quot;, &quot;reviews&quot;), ...]</code>，再给一些queries<code>[(&quot;restaurant ratings&quot;, &quot;cafe reviews&quot;), ...]</code>，要求返回每个query里的对应词是否都是synonym。同义词没有传递性。</li>
<li>直接把字符串作为key、对应的所有同义词的set作为value存入map，正反都放一次，比如<code>map.get(&quot;restaurant&quot;).add(&quot;cafe&quot;)), map.get(&quot;restaurant&quot;).add(&quot;cafe&quot;)</code>，这样在query的时候就可以直接调用了。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 维护一个总的map，每个单词作为key，对等的单词塞入它维护的Set中</span></div><div class="line"><span class="comment">// 有对称性所以需要正反都加</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">areSentencesSimilar</span><span class="params">(String[] words1, String[] words2, String[][] pairs)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (words1 == <span class="keyword">null</span> || words2 == <span class="keyword">null</span> || pairs == <span class="keyword">null</span></div><div class="line">        || words1.length != words2.length) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    Map&lt;String, Set&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pairs.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (!map.containsKey(pairs[i][<span class="number">0</span>])) &#123;</div><div class="line">            map.put(pairs[i][<span class="number">0</span>], <span class="keyword">new</span> HashSet&lt;&gt;());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!map.containsKey(pairs[i][<span class="number">1</span>])) &#123;</div><div class="line">            map.put(pairs[i][<span class="number">1</span>], <span class="keyword">new</span> HashSet&lt;&gt;());</div><div class="line">        &#125;</div><div class="line">        map.get(pairs[i][<span class="number">0</span>]).add(pairs[i][<span class="number">1</span>]);  <span class="comment">// 构建a-&gt;b</span></div><div class="line">        map.get(pairs[i][<span class="number">1</span>]).add(pairs[i][<span class="number">0</span>]);  <span class="comment">// 构建b-&gt;a</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words1.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (words1[i].equals(words2[i])) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (map.get(words1[i]) == <span class="keyword">null</span> || !map.get(words1[i]).contains(words2[i])) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="735-asteroid-collision"><a href="#735-asteroid-collision" class="headerlink" title="735. asteroid-collision"></a><a href="https://leetcode.com/problems/asteroid-collision/description/" target="_blank" rel="external">735. asteroid-collision</a></h4><ul>
<li>给一个int数组，表示原子。正数向右移动，负数向左移动，可能会发生碰撞，如果绝对值相等则会抵消，否则绝对值更大的会把小的给干掉。求碰撞完后的数组。</li>
<li><p>直接用一个List，正数直接存，负数就需要与list中末尾的元素比较，如果是负就直接push，是正就需要比较看看谁更大。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] asteroidCollision(<span class="keyword">int</span>[] asteroids) &#123;</div><div class="line">        <span class="keyword">if</span> (asteroids == <span class="keyword">null</span> || asteroids.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> asteroids;</div><div class="line">        &#125;</div><div class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> asteroid : asteroids) &#123;</div><div class="line">            <span class="keyword">if</span> (asteroid &lt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">boolean</span> needAdd = <span class="keyword">true</span>;</div><div class="line">                <span class="keyword">while</span> (!list.isEmpty()) &#123;</div><div class="line">                    <span class="keyword">if</span> (list.get(list.size() - <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (-asteroid &gt; list.get(list.size() - <span class="number">1</span>)) &#123;</div><div class="line">                        list.remove(list.size() - <span class="number">1</span>);</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (-asteroid == list.get(list.size() - <span class="number">1</span>)) &#123;</div><div class="line">                        list.remove(list.size() - <span class="number">1</span>);</div><div class="line">                        needAdd = <span class="keyword">false</span>;</div><div class="line">                        <span class="keyword">break</span>;   <span class="comment">// cancelled with each other</span></div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        needAdd = <span class="keyword">false</span>;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (needAdd) &#123;</div><div class="line">                    list.add(asteroid);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                list.add(asteroid);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret.length; i++) &#123;</div><div class="line">            ret[i] = list.get(i);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ret;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>更巧妙的做法是直接用一个数组模拟stack，然后用加法判断是否抵消。每次都强行取栈顶元素出来，如果没有被干掉就再放回去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] asteroidCollision(<span class="keyword">int</span>[] asteroids) &#123;</div><div class="line">        <span class="keyword">if</span> (asteroids == <span class="keyword">null</span> || asteroids.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> asteroids;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] stack = <span class="keyword">new</span> <span class="keyword">int</span>[asteroids.length + <span class="number">1</span>];</div><div class="line">        <span class="keyword">int</span> size = <span class="number">1</span>;</div><div class="line">        stack[<span class="number">0</span>] = -<span class="number">1</span>;  <span class="comment">// 第一个放负数placeholder让pop终止</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> asteroid : asteroids) &#123;</div><div class="line">            <span class="keyword">while</span> (stack[size - <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; asteroid &lt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">int</span> sum = asteroid + stack[size - <span class="number">1</span>];</div><div class="line">                <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;      <span class="comment">// 负数被干掉了</span></div><div class="line">                    asteroid = stack[size - <span class="number">1</span>];</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</div><div class="line">                    asteroid = <span class="number">0</span>;</div><div class="line">                &#125;</div><div class="line">                size--;     <span class="comment">// 始终pop栈顶</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (asteroid != <span class="number">0</span>) &#123;</div><div class="line">                stack[size++] = asteroid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> Arrays.copyOfRange(stack, <span class="number">1</span>, size);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="737-sentence-similarity-ii"><a href="#737-sentence-similarity-ii" class="headerlink" title="737. sentence-similarity-ii"></a><a href="https://leetcode.com/problems/sentence-similarity-ii/description/" target="_blank" rel="external">737. sentence-similarity-ii</a></h4><ul>
<li>给一堆同义词<code>[(&quot;restaurant&quot;, &quot;cafe&quot;), (&quot;ratings&quot;, &quot;reviews&quot;), ...]</code>，再给一些queries<code>[(&quot;restaurant ratings&quot;, &quot;cafe reviews&quot;), ...]</code>，要求返回每个query里的对应词是否都是synonym。注意这些同义词具有传递性，<code>a=b, b=c -&gt; a=c</code>。</li>
<li><p>方法一：图论题，每个词都是一个节点，对于每个节点维护一个Set，通过DFS遍历所有可达的节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 和前一个版本的区别是这个可以无限传递a=b=c=d...</span></div><div class="line"><span class="comment">// 还是map维护每个单词等价的单词，但匹配不上的话还得看它的set里所有单词对应的单词是否能匹配到</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">areSentencesSimilarTwo</span><span class="params">(String[] words1, String[] words2, String[][] pairs)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (words1 == <span class="keyword">null</span> || words2 == <span class="keyword">null</span> || pairs == <span class="keyword">null</span></div><div class="line">        || words1.length != words2.length) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 表示每个单词直接相连的同义词</span></div><div class="line">    Map&lt;String, Set&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pairs.length; i++) &#123;        <span class="comment">// O(N)</span></div><div class="line">        <span class="keyword">if</span> (!map.containsKey(pairs[i][<span class="number">0</span>])) &#123;</div><div class="line">            map.put(pairs[i][<span class="number">0</span>], <span class="keyword">new</span> HashSet&lt;&gt;());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!map.containsKey(pairs[i][<span class="number">1</span>])) &#123;</div><div class="line">            map.put(pairs[i][<span class="number">1</span>], <span class="keyword">new</span> HashSet&lt;&gt;());</div><div class="line">        &#125;</div><div class="line">        map.get(pairs[i][<span class="number">0</span>]).add(pairs[i][<span class="number">1</span>]);  <span class="comment">// 构建a-&gt;b</span></div><div class="line">        map.get(pairs[i][<span class="number">1</span>]).add(pairs[i][<span class="number">0</span>]);  <span class="comment">// 构建b-&gt;a</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words1.length; i++) &#123;       <span class="comment">// O(N*N)</span></div><div class="line">        <span class="keyword">if</span> (words1[i].equals(words2[i])) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!map.containsKey(words1[i])) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!dfs(words1[i], words2[i], map, <span class="keyword">new</span> HashSet&lt;String&gt;())) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(String start, String end, Map&lt;String, Set&lt;String&gt;&gt; map, Set&lt;String&gt; visited)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (map.get(start).contains(end)) &#123;     <span class="comment">// 终止条件：start连接着end</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    visited.add(start);</div><div class="line">    Set&lt;String&gt; neighbors = map.get(start);</div><div class="line">    <span class="keyword">if</span> (neighbors == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (String neighbor : neighbors) &#123;</div><div class="line">        <span class="keyword">if</span> (!visited.contains(neighbor) &amp;&amp; dfs(neighbor, end, map, visited)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法二：并查集，初始化时每个单词都是自己的root；然后根据同义词关系将前者的老大设为后者。判断句子是否同义时就找两个单词的老大是否相等即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 并查集。初始化时每个单词都是自己的root；然后根据同义词关系将前者的老大设为后者。</span></div><div class="line"><span class="comment">// 判断句子是否同义时就找两个单词的老大是否相等即可</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">areSentencesSimilarTwo</span><span class="params">(String[] words1, String[] words2, String[][] pairs)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (words1.length != words2.length) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="keyword">for</span> (String[] pair : pairs) &#123;     <span class="comment">// 开始时每个老大都是自己</span></div><div class="line">        map.put(pair[<span class="number">0</span>], pair[<span class="number">0</span>]);</div><div class="line">        map.put(pair[<span class="number">1</span>], pair[<span class="number">1</span>]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (String[] pair : pairs) &#123;</div><div class="line">        String par1 = findParent(pair[<span class="number">0</span>], map);</div><div class="line">        String par2 = findParent(pair[<span class="number">1</span>], map);</div><div class="line">        <span class="keyword">if</span> (!par1.equals(par2)) &#123;</div><div class="line">            map.put(par1, par2);    <span class="comment">// par1的老大设为par2</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words1.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (words1[i].equals(words2[i])) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!map.containsKey(words1[i]) || !map.containsKey(words2[i])) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        String par1 = findParent(words1[i], map);</div><div class="line">        String par2 = findParent(words2[i], map);</div><div class="line">        <span class="keyword">if</span> (!par1.equals(par2)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findParent</span><span class="params">(String str, Map&lt;String,String&gt; map)</span></span>&#123;</div><div class="line">        <span class="keyword">while</span> (!str.equals(map.get(str))) &#123; <span class="comment">// 追溯str的老大</span></div><div class="line">            str = map.get(str);              </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> str;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="739-daily-temperatures"><a href="#739-daily-temperatures" class="headerlink" title="739. daily-temperatures"></a><a href="https://leetcode.com/problems/daily-temperatures/description/" target="_blank" rel="external">739. daily-temperatures</a></h4><ul>
<li>给一个int数组表示气温，返回一个数组表示该日最短需要多少天才会有更温暖的日子。例如<code>[73, 74, 75, 71, 69, 72, 76, 73]</code>输出<code>[1, 1, 4, 2, 1, 1, 0, 0]</code>。</li>
<li>解法：维护一个Stack存放索引，每次读入新的温度时就和栈顶对应的温度比较，如果更高，就弹出并设置该索引处的天数。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] temperatures) &#123;</div><div class="line">        <span class="keyword">if</span> (temperatures == <span class="keyword">null</span> || temperatures.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] nextWarmer = <span class="keyword">new</span> <span class="keyword">int</span> [temperatures.length];</div><div class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temperatures.length; i++) &#123;</div><div class="line">            <span class="comment">// 比较当前温度和栈顶索引对应温度 </span></div><div class="line">            <span class="keyword">while</span> (!stack.isEmpty()</div><div class="line">                &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) &#123;</div><div class="line">                <span class="keyword">int</span> index = stack.pop();</div><div class="line">                nextWarmer[index] = i - index;</div><div class="line">            &#125;</div><div class="line">            stack.push(i);                  <span class="comment">// 栈剩下的都比当前大</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</div><div class="line">            nextWarmer[stack.pop()] = <span class="number">0</span>;    <span class="comment">// 其实Java数组原本就是0</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> nextWarmer;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="742-closest-leaf-in-a-binary-tree"><a href="#742-closest-leaf-in-a-binary-tree" class="headerlink" title="742. closest-leaf-in-a-binary-tree"></a><a href="https://leetcode.com/problems/closest-leaf-in-a-binary-tree/description/" target="_blank" rel="external">742. closest-leaf-in-a-binary-tree</a></h4><ul>
<li>给一个二叉树和一个其中必定存在的值k，求这个节点到最近的leaf节点的距离。注意不是BST。</li>
<li>纯粹用Tree来思考有点困难，需要抽象成graph来思考：给定一个target点，怎么找最近的满足一定条件的neighbor？BFS。因此先dfs一波找到target节点，同时记录target节点怎么往parent走。然后从target节点开始BFS找最近的leaf节点即可。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findClosestLeaf</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        Map&lt;TreeNode, TreeNode&gt; prevNodeMap = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        Set&lt;TreeNode&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">        </div><div class="line">        TreeNode targetNode = dfs(root, k, prevNodeMap);</div><div class="line">        </div><div class="line">        q.offer(targetNode);</div><div class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</div><div class="line">            TreeNode curr = q.poll();</div><div class="line">            visited.add(curr);</div><div class="line">            <span class="keyword">if</span> (curr.left == <span class="keyword">null</span> &amp;&amp; curr.right == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">return</span> curr.val;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (curr.left != <span class="keyword">null</span> &amp;&amp; !visited.contains(curr.left)) &#123;</div><div class="line">                q.offer(curr.left);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (curr.right != <span class="keyword">null</span> &amp;&amp; !visited.contains(curr.right)) &#123;</div><div class="line">                q.offer(curr.right);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (prevNodeMap.containsKey(curr) &amp;&amp; !visited.contains(prevNodeMap.get(curr))) &#123;</div><div class="line">                q.offer(prevNodeMap.get(curr));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> k, Map&lt;TreeNode, TreeNode&gt; prevNodeMap)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root.val == k) &#123;</div><div class="line">            <span class="keyword">return</span> root;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</div><div class="line">            prevNodeMap.put(root.left, root);</div><div class="line">            TreeNode left = dfs(root.left, k, prevNodeMap);</div><div class="line">            <span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">return</span> left;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</div><div class="line">            prevNodeMap.put(root.right, root);</div><div class="line">            TreeNode right = dfs(root.right, k, prevNodeMap);</div><div class="line">            <span class="keyword">if</span> (right != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">return</span> right;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="743-network-delay-time"><a href="#743-network-delay-time" class="headerlink" title="743. network-delay-time"></a><a href="https://leetcode.com/problems/network-delay-time/description/" target="_blank" rel="external">743. network-delay-time</a></h4><ul>
<li>总共有1、2、3、…、N个节点，给一个times数组表示从node A到node B需要传播的时间，给定起始点K，求最长需要消耗的时间。类似于求最短路，BFS搞定。注意需要更新到达节点所需要的时间。</li>
</ul>
<h4 id="744-find-smallest-letter-greater-than-target"><a href="#744-find-smallest-letter-greater-than-target" class="headerlink" title="744. find-smallest-letter-greater-than-target"></a><a href="https://leetcode.com/problems/find-smallest-letter-greater-than-target/description/" target="_blank" rel="external">744. find-smallest-letter-greater-than-target</a></h4><ul>
<li>给一个排好序的a-z的char数组，给一个target，求比他大的字符，若是最后一个则wrap到前面如比z大的就是最前面的字符。</li>
<li>二分查找，找last occurence，直接返回「下一个」字符。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">nextGreatestLetter</span><span class="params">(<span class="keyword">char</span>[] letters, <span class="keyword">char</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (letters == <span class="keyword">null</span> || letters.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> target;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> start = -<span class="number">1</span>, end = letters.length;</div><div class="line">        <span class="keyword">while</span> (end - start &gt; <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span> (letters[mid] &lt;= target) &#123;   <span class="comment">// 相等也要把start往后推，找到最后一个occurence</span></div><div class="line">                start = mid;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                end = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 不论start处是不是target，直接返回下一位即可</span></div><div class="line">        <span class="keyword">return</span> start &lt; letters.length - <span class="number">1</span> ? letters[start + <span class="number">1</span>] : letters[<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="745-prefix-and-suffix-search"><a href="#745-prefix-and-suffix-search" class="headerlink" title="745. prefix-and-suffix-search"></a><a href="https://leetcode.com/problems/prefix-and-suffix-search/description/" target="_blank" rel="external">745. prefix-and-suffix-search</a></h4><ul>
<li>给一个字符串数组，之后给一些query，这些query含有前缀和后缀（0～10个字符），求符合前缀的单词的索引。</li>
<li>有多个答案怎么办？返回最后一个出现的。</li>
<li><p>方法一：encode的方式将每个单词所有可能的前缀后缀组合作为key存入map，索引作为value，这样在query的时候直接再encode一下就可以直接get了。初始化时间复杂度O(N <em> wordLen^2)，query时间复杂度O(1)，空间占用O(N </em> wordLen^2).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordFilter</span> </span>&#123;</div><div class="line">    Map&lt;String, Integer&gt; map;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WordFilter</span><span class="params">(String[] words)</span> </span>&#123; </div><div class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; words.length; index++) &#123;</div><div class="line">            <span class="keyword">int</span> wordLen = words[index].length();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span> &amp;&amp; i &lt;= wordLen; i++) &#123;</div><div class="line">                String front = words[index].substring(<span class="number">0</span>, i);</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">10</span> &amp;&amp; j &lt;= wordLen; j++) &#123;</div><div class="line">                    String back = words[index].substring(wordLen - j);  <span class="comment">// 组成"a...#p.."的key</span></div><div class="line">                    map.put(front + <span class="string">"#"</span> + back, index);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(String prefix, String suffix)</span> </span>&#123;</div><div class="line">        String key = prefix + <span class="string">"#"</span> + suffix;</div><div class="line">        <span class="keyword">return</span> map.containsKey(key)? map.get(key) : -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法二：拆分成两个map，一个专门维护前缀、一个专门维护后缀，value都是索引的List。在query的时候需要把两个List取出来，然后O(N)扫描看看有没有交点。初始化时间复杂度O(N <em> wordLen)，query时间复杂度O(N)，空间占用O(N </em> wordLen).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordFilter</span> </span>&#123;</div><div class="line">    Map&lt;String, List&lt;Integer&gt;&gt; mapPrefix;</div><div class="line">    Map&lt;String, List&lt;Integer&gt;&gt; mapSuffix;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WordFilter</span><span class="params">(String[] words)</span> </span>&#123; </div><div class="line">        mapPrefix = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        mapSuffix = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; words.length; index++) &#123;</div><div class="line">            <span class="keyword">int</span> wordLen = words[index].length();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span> &amp;&amp; i &lt;= wordLen; i++) &#123;</div><div class="line">                String front = words[index].substring(<span class="number">0</span>, i);</div><div class="line">                <span class="keyword">if</span> (!mapPrefix.containsKey(front)) &#123;</div><div class="line">                    mapPrefix.put(front, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</div><div class="line">                &#125;</div><div class="line">                mapPrefix.get(front).add(index);</div><div class="line">                </div><div class="line">                String back = words[index].substring(wordLen - i);</div><div class="line">                <span class="keyword">if</span> (!mapSuffix.containsKey(back)) &#123;</div><div class="line">                    mapSuffix.put(back, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</div><div class="line">                &#125;</div><div class="line">                mapSuffix.get(back).add(index);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(String prefix, String suffix)</span> </span>&#123;</div><div class="line">        List&lt;Integer&gt; listPrefix = mapPrefix.get(prefix);</div><div class="line">        List&lt;Integer&gt; listSuffix = mapSuffix.get(suffix);</div><div class="line">        <span class="keyword">if</span> (listPrefix == <span class="keyword">null</span> || listSuffix == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> i = listPrefix.size() - <span class="number">1</span>, j = listSuffix.size() - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;          <span class="comment">// 因为要返回最后一个，所以要从后往前找交点</span></div><div class="line">            <span class="keyword">if</span> (listPrefix.get(i) &gt; listSuffix.get(j)) &#123;</div><div class="line">                i--;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (listPrefix.get(i) &lt; listSuffix.get(j)) &#123;</div><div class="line">                j--;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> listPrefix.get(i);   <span class="comment">// 注意不能直接对Integer用==判断相等！</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法三：直接使用内建函数startsWith和endsWith。初始化时间复杂度O(1)，query时间复杂度O(N * wordLen)，空间占用O(1).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordFilter</span> </span>&#123;</div><div class="line">    String[] words;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WordFilter</span><span class="params">(String[] words)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.words = words;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(String prefix, String suffix)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = words.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">            <span class="keyword">if</span> (words[i].startsWith(prefix) &amp;&amp; words[i].endsWith(suffix)) &#123;</div><div class="line">                <span class="keyword">return</span> i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="748-shortest-completing-word"><a href="#748-shortest-completing-word" class="headerlink" title="748. shortest-completing-word"></a><a href="https://leetcode.com/problems/shortest-completing-word/description/" target="_blank" rel="external">748. shortest-completing-word</a></h4><ul>
<li>给一个licensePlate，再给一个words数组，求其中最短的字符串使得licensePlate出现过的字母都有。例如<code>licensePlate = &quot;1s3 PSt&quot;中只用关注S P S T, words = [&quot;step&quot;, &quot;steps&quot;, &quot;stripe&quot;, &quot;stepple&quot;]</code>，输出<code>steps</code>。</li>
<li>licensePlate有哪些字符、确定只关注字母？（-是的）字母大小写？（-忽略大小写）</li>
<li>解法：先统计licensePlate中字母出现次数，然后<code>O(N)</code>遍历字符串数组，对于每一个单词判断是否包含licensePlate的所有字母（<code>O(26)</code>），再找最短的返回。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">int</span> LETTER_NUM = <span class="number">26</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">shortestCompletingWord</span><span class="params">(String licensePlate, String[] words)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (licensePlate == <span class="keyword">null</span> || words == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 统计licensePlate里字母的出现次数</span></div><div class="line">        <span class="keyword">char</span>[] letterCount = <span class="keyword">new</span> <span class="keyword">char</span> [LETTER_NUM];</div><div class="line">        <span class="keyword">char</span>[] lChar = licensePlate.toLowerCase().toCharArray();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lChar.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (Character.isLetter(lChar[i])) &#123;</div><div class="line">                letterCount[lChar[i] - <span class="string">'a'</span>]++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 对于每个单词判断是否complete，然后找最短的</span></div><div class="line">        String ans = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">int</span> minLen = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">for</span> (String word: words) &#123;</div><div class="line">            <span class="keyword">if</span> (checkComplete(word, letterCount)) &#123;</div><div class="line">                <span class="keyword">if</span> (word.length() &lt; minLen) &#123;</div><div class="line">                    minLen = word.length();</div><div class="line">                    ans = word;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 统计当前单词的字母出现次数，然后再一波O（26）和licensePlate的字母Count比较</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkComplete</span><span class="params">(String word, <span class="keyword">char</span>[] letterCount)</span> </span>&#123;</div><div class="line">        <span class="keyword">char</span>[] wChar = word.toCharArray();</div><div class="line">        <span class="keyword">char</span>[] thisCount = <span class="keyword">new</span> <span class="keyword">char</span> [LETTER_NUM];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wChar.length; i++) &#123;</div><div class="line">            thisCount[wChar[i] - <span class="string">'a'</span>]++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LETTER_NUM; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (letterCount[i] &gt; <span class="number">0</span> &amp;&amp; thisCount[i] &lt; letterCount[i]) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="750-number-of-corner-rectangles"><a href="#750-number-of-corner-rectangles" class="headerlink" title="750. number-of-corner-rectangles"></a><a href="https://leetcode.com/problems/number-of-corner-rectangles/description/" target="_blank" rel="external">750. number-of-corner-rectangles</a></h4><ul>
<li>给一个只含有0和1的二维数组，求其中四个1所能组成矩形的个数。矩形的边必须横、竖两个方向。</li>
<li>扫描线的思路，取两个行，同时扫竖线，统计同时出现1的pair数作为竖线，然后把这些竖线组合一下即可。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">// 两行一起往右挪找是否有同时为1的，然后根据该平行线的pair数简单排列组合就可以了</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countCornerRectangles</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length - <span class="number">1</span>; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; grid.length; j++) &#123;</div><div class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; grid[<span class="number">0</span>].length; k++) &#123;</div><div class="line">                    <span class="keyword">if</span> (grid[i][k] == <span class="number">1</span> &amp;&amp; grid[j][k] == <span class="number">1</span>) &#123;   <span class="comment">// 两平行线同一列同为1</span></div><div class="line">                        count++;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                ans += count * (count - <span class="number">1</span>) / <span class="number">2</span>;     <span class="comment">// combination</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="752-open-the-lock"><a href="#752-open-the-lock" class="headerlink" title="752. open-the-lock"></a><a href="https://leetcode.com/problems/open-the-lock/description/" target="_blank" rel="external">752. open-the-lock</a></h4><ul>
<li>假如有一个锁头从<code>0000</code>开始转，每次只能只能转四位中的一位，给一个String数组表示这些数字不可以转到，给一个target表示最终开锁的密码。求最短需要多少次才能开锁，不可能打开则返回-1。</li>
<li><p>这种最短路径问题就想到了BFS，不过需要小心的是target本身不可达以及起始点就不可达的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">openLock</span><span class="params">(String[] deadends, String target)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (deadends == <span class="keyword">null</span> || deadends.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (String deadend : deadends) &#123;</div><div class="line">            visited.add(deadend);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (visited.contains(target)) &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        Queue&lt;StringBuilder&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        StringBuilder start = <span class="keyword">new</span> StringBuilder(<span class="string">"0000"</span>);</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (visited.contains(start.toString())) &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        q.offer(start);</div><div class="line">        visited.add(start.toString());</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</div><div class="line">            <span class="keyword">int</span> size = q.size();</div><div class="line">            count++;</div><div class="line">            <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</div><div class="line">                StringBuilder curr = q.poll();</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</div><div class="line">                    <span class="keyword">char</span> c = curr.charAt(i);</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = -<span class="number">1</span>; j &lt;= <span class="number">1</span>; j += <span class="number">2</span>) &#123;</div><div class="line">                        <span class="keyword">if</span> (c == <span class="string">'0'</span> &amp;&amp; j == -<span class="number">1</span>) &#123;</div><div class="line">                            curr.setCharAt(i, <span class="string">'9'</span>);</div><div class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'9'</span> &amp;&amp; j == <span class="number">1</span>) &#123;</div><div class="line">                            curr.setCharAt(i, <span class="string">'0'</span>);</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            curr.setCharAt(i, (<span class="keyword">char</span>)(c + j));</div><div class="line">                        &#125;</div><div class="line">                        String currStr = curr.toString();</div><div class="line">                        <span class="keyword">if</span> (!visited.contains(currStr)) &#123;</div><div class="line">                            <span class="keyword">if</span> (currStr.equals(target)) &#123;</div><div class="line">                                <span class="keyword">return</span> count;</div><div class="line">                            &#125;</div><div class="line">                            q.offer(<span class="keyword">new</span> StringBuilder(currStr));</div><div class="line">                            visited.add(currStr);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    curr.setCharAt(i, c);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>以上是basic的BFS，如果要提速，可以进行<a href="https://leetcode.com/problems/open-the-lock/discuss/110237/Regular-java-BFS-solution-and-2-end-BFS-solution-with-improvement" target="_blank" rel="external">双向的BFS</a>，也就是维护两个Set，一个begin作为开始、一个end作为结束，每次switch角色，搞完begin就将end补过来、将当前begin的邻居点作为新的end。</p>
</li>
</ul>
<h4 id="759-employee-free-time"><a href="#759-employee-free-time" class="headerlink" title="759. employee-free-time"></a><a href="https://leetcode.com/problems/employee-free-time/description/" target="_blank" rel="external">759. employee-free-time</a></h4><ul>
<li>给一个List of List，每一个子List存放每个employee的工作时间，求所有employee的共同空闲时间。没有则返回空List。</li>
<li>直接将List flatten，然后按照工作开始时间从小到大排序，再往后依次取工作时间，若当前开始时间比之前的结束时间长，说明出现了空闲时间；否则需要更新prev的end，保证prev的结束时间cover到所有结束时间，即取max。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Interval&gt; <span class="title">employeeFreeTime</span><span class="params">(List&lt;List&lt;Interval&gt;&gt; schedule)</span> </span>&#123;</div><div class="line">    List&lt;Interval&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="keyword">if</span> (schedule == <span class="keyword">null</span> || schedule.size() == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">    List&lt;Interval&gt; workingTimes = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    schedule.forEach(e -&gt; workingTimes.addAll(e));</div><div class="line">    Collections.sort(workingTimes, (a, b) -&gt; a.start - b.start);</div><div class="line">    Interval prev = workingTimes.get(<span class="number">0</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; workingTimes.size(); i++) &#123;</div><div class="line">        <span class="keyword">if</span> (workingTimes.get(i).start &gt; prev.end) &#123;</div><div class="line">            ans.add(<span class="keyword">new</span> Interval(prev.end, workingTimes.get(i).start));</div><div class="line">            prev = workingTimes.get(i);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            prev.end = Math.max(prev.end, workingTimes.get(i).end);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ans;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="760-find-anagram-mappings"><a href="#760-find-anagram-mappings" class="headerlink" title="760. find-anagram-mappings"></a><a href="https://leetcode.com/problems/find-anagram-mappings/description/" target="_blank" rel="external">760. find-anagram-mappings</a></h4><ul>
<li>给两个数组，求对应出现的位置。skip.</li>
</ul>
<h4 id="763-partition-labels"><a href="#763-partition-labels" class="headerlink" title="763. partition-labels"></a><a href="https://leetcode.com/problems/partition-labels/description/" target="_blank" rel="external">763. partition-labels</a></h4><ul>
<li>给一个字符串，尝试将它进行partition使得每个字符至多只出现在一个partition，划分处尽量多的partition，求每个partition的长度。</li>
<li>方法一：LinkedHashMap搞定。统计每个字符出现的初始位置和最后一次出现的位置，然后遍历，当前后无法相连则说明这是一个新的partition。</li>
<li>方法二：不需要对每一个字母同时存放start和end，而是对于一个partition维护start和end。遍历字符串时若当前索引正是当前字符的最后一次出现的索引，且到达了当前partition的end，说明partition结束；否则需要适当更新end。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">partitionLabels</span><span class="params">(String S)</span> </span>&#123;</div><div class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">if</span> (S == <span class="keyword">null</span> || S.length() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> ans;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] lastOccurance = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); i++) &#123;</div><div class="line">            lastOccurance[S.charAt(i) - <span class="string">'a'</span>] = i;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;     </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); i++) &#123;</div><div class="line">            <span class="keyword">int</span> index = S.charAt(i) - <span class="string">'a'</span>;</div><div class="line">            <span class="keyword">if</span> (lastOccurance[index] != i) &#123;</div><div class="line">                <span class="keyword">if</span> (lastOccurance[index] &gt; end) &#123;</div><div class="line">                    end = lastOccurance[index]; <span class="comment">// 若有更靠后的索引则更新end</span></div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (i == end) &#123;</div><div class="line">                    ans.add(end - start + <span class="number">1</span>);</div><div class="line">                    end = i + <span class="number">1</span>;</div><div class="line">                    start = i + <span class="number">1</span>;  <span class="comment">// start只在每个partition开始时更新一次</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="764-largest-plus-sign"><a href="#764-largest-plus-sign" class="headerlink" title="764. largest-plus-sign"></a><a href="https://leetcode.com/problems/largest-plus-sign/description/" target="_blank" rel="external">764. largest-plus-sign</a></h4><ul>
<li>给定N表示棋盘的长和宽，默认棋盘中每个cell都是1，再给一些坐标表示该处是0。求棋盘中最大的加号的长度。</li>
<li>可以利用grid本身记录上下左右四个方向最长延伸出去多长。最原始的想法是每个方向都维护一个二维数组专门记录到该cell的最长长度是多少，不过经过改进可以将所有的计算都合并到一个grid中完成。开始时初始化每个cell的长度都为N，然后直接从前、后、上、下同时更新，不过每一步循环中更新的其实是四个不同的cell，最后循环结束时每个cell都会被更新四次。时间复杂度O(N^2)。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">orderOfLargestPlusSign</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span>[][] mines)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (N &lt; <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[][] grid = <span class="keyword">new</span> <span class="keyword">int</span> [N][N];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</div><div class="line">            Arrays.fill(grid[i], N);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] mine : mines) &#123;</div><div class="line">            grid[mine[<span class="number">0</span>]][mine[<span class="number">1</span>]] = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, k = N - <span class="number">1</span>, l = <span class="number">0</span>, r = <span class="number">0</span>, t = <span class="number">0</span>, b = <span class="number">0</span>; j &lt; N; j++, k--) &#123;</div><div class="line">                <span class="comment">// 分别统计左右、上下有多少延伸出去的长度，每个cell会被访问到4次，每次都取min</span></div><div class="line">                grid[i][j] = Math.min(grid[i][j], l = grid[i][j] == <span class="number">0</span> ? <span class="number">0</span> : l + <span class="number">1</span>);</div><div class="line">                grid[i][k] = Math.min(grid[i][k], r = grid[i][k] == <span class="number">0</span> ? <span class="number">0</span> : r + <span class="number">1</span>);</div><div class="line">                grid[j][i] = Math.min(grid[j][i], t = grid[j][i] == <span class="number">0</span> ? <span class="number">0</span> : t + <span class="number">1</span>);</div><div class="line">                grid[k][i] = Math.min(grid[k][i], b = grid[k][i] == <span class="number">0</span> ? <span class="number">0</span> : b + <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</div><div class="line">                ans = Math.max(grid[i][j], ans);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="765-couples-holding-hands"><a href="#765-couples-holding-hands" class="headerlink" title="765. couples-holding-hands"></a><a href="https://leetcode.com/problems/couples-holding-hands/description/" target="_blank" rel="external">765. couples-holding-hands</a></h4><ul>
<li>给一个int数组表示每个位置坐的人，假设0-1, 2-3, 4-5…是一对，问最少通过几次交换座位可以让没对情侣都相邻而坐。</li>
<li>可以用greedy的办法，每发现一个坐错位置的人，就让他和应该在这个位置的人swap一次。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSwapsCouples</span><span class="params">(<span class="keyword">int</span>[] row)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (row == <span class="keyword">null</span> || row.length == <span class="number">0</span> || row.length % <span class="number">2</span> != <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] pos = <span class="keyword">new</span> <span class="keyword">int</span>[row.length];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row.length; i++) &#123;</div><div class="line">            pos[row[i]] = i;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row.length; i += <span class="number">2</span>) &#123;</div><div class="line">            <span class="keyword">int</span> expected = row[i] % <span class="number">2</span> == <span class="number">0</span> ? row[i] + <span class="number">1</span> : row[i] - <span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span> (row[i + <span class="number">1</span>] != expected) &#123;</div><div class="line">                pos[row[i + <span class="number">1</span>]] = pos[expected];</div><div class="line">                row[pos[expected]] = row[i + <span class="number">1</span>];</div><div class="line">                count++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="767-reorganize-string"><a href="#767-reorganize-string" class="headerlink" title="767. reorganize-string"></a><a href="https://leetcode.com/problems/reorganize-string/description/" target="_blank" rel="external">767. reorganize-string</a></h4><ul>
<li>给一个只含有小写字母的字符串，将这些字符重新排列使得相邻字母不同，若不存在则返回””;</li>
<li>greedy，先统计每一个字符出现的次数，存入priorityqueue使得次数多的先取，取后若仍有剩余则需要更新次数并重新放回pq。注意若当前取出的次数最多的字母是上一次append的，则需要取第二多的字符，若没有后续字符说明没法这么存，返回””即可。</li>
</ul>
<h4 id="768-max-chunks-to-make-sorted-ii"><a href="#768-max-chunks-to-make-sorted-ii" class="headerlink" title="768. max-chunks-to-make-sorted-ii"></a><a href="https://leetcode.com/problems/max-chunks-to-make-sorted-ii/description/" target="_blank" rel="external">768. max-chunks-to-make-sorted-ii</a></h4><ul>
<li>给一个int数组，将这个数组分成若干个chunk后在每个chunk内部排序之后拼接能得到sorted的数组，求最多划分成多少个这样的chunk。</li>
<li>形成chunk的条件是「chunk中最大值小于等于右侧所有数的最小值」。因此维护两个数组存放当前位置的左侧最大值和右侧最小值即可。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxChunksToSorted</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span>[] maxOfLeft = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];    <span class="comment">// 左侧的最大值</span></div><div class="line">        maxOfLeft[<span class="number">0</span>] = arr[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</div><div class="line">            maxOfLeft[i] = Math.max(maxOfLeft[i - <span class="number">1</span>], arr[i]);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span>[] minOfRight = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];   <span class="comment">// 右侧的最小值</span></div><div class="line">        minOfRight[arr.length - <span class="number">1</span>] = arr[arr.length - <span class="number">1</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">            minOfRight[i] = Math.min(minOfRight[i + <span class="number">1</span>], arr[i]);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;<span class="comment">// 当左侧最大值都小于右侧最小值，说明当前位之前都可以自己排个序了</span></div><div class="line">            <span class="keyword">if</span> (maxOfLeft[i] &lt;= minOfRight[i + <span class="number">1</span>]) &#123;</div><div class="line">                count++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> count + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="769-max-chunks-to-make-sorted"><a href="#769-max-chunks-to-make-sorted" class="headerlink" title="769. max-chunks-to-make-sorted"></a><a href="https://leetcode.com/problems/max-chunks-to-make-sorted/description/" target="_blank" rel="external">769. max-chunks-to-make-sorted</a></h4><ul>
<li>给一个int数组，其中含有元素<code>[0, 1, ..., arr.length - 1]</code>（顺序不一定是这样的，是一个permutation），将这个数组分成若干个chunk后在每个chunk内部排序之后拼接能得到sorted的数组，求最多划分成多少个这样的chunk。如<code>[4,3,2,1,0]</code>必须整个作为一个chunk排序，<code>[1,0,2,3,4]</code>则分成<code>[1, 0], [2], [3], [4]</code>来排序。</li>
<li>既然元素和index是能对应填充的，考虑他们之间的关系。要想形成chunk，必须chunk的最大值在最右侧index的左侧，维护一个max即可。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxChunksToSorted</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, max = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</div><div class="line">            max = Math.max(max, arr[i]);</div><div class="line">            <span class="keyword">if</span> (i == max) &#123;</div><div class="line">                count++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="776-split-bst"><a href="#776-split-bst" class="headerlink" title="776. split-bst"></a><a href="https://leetcode.com/problems/split-bst/description/" target="_blank" rel="external">776. split-bst</a></h4><ul>
<li>给一个BST和一个value，这个value不一定存在于BST中，要求以这个value为临界点将BST分成小于等于&amp;大于两部分。</li>
<li>在split的时候比较节点与value，若value更大则split点会出现在右子树且split后会得到两个split之后的子树，需要将小于等于的那个子树拼接到当前节点的右侧。若value不大于当前节点，则需要到左子树去搜索split点，同样需要将split之后较大的那个子树拼接到当前子树的左侧。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> TreeNode[] splitBST(TreeNode root, <span class="keyword">int</span> V) &#123;</div><div class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode[] &#123;<span class="keyword">null</span>, <span class="keyword">null</span>&#125;;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (root.val &lt;= V) &#123;</div><div class="line">        TreeNode[] splitted = splitBST(root.right, V);</div><div class="line">        root.right = splitted[<span class="number">0</span>];</div><div class="line">        splitted[<span class="number">0</span>] = root;</div><div class="line">        <span class="keyword">return</span> splitted;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        TreeNode[] splitted = splitBST(root.left, V);</div><div class="line">        root.left = splitted[<span class="number">1</span>];</div><div class="line">        splitted[<span class="number">1</span>] = root;</div><div class="line">        <span class="keyword">return</span> splitted;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="785-is-graph-bipartite"><a href="#785-is-graph-bipartite" class="headerlink" title="785. is-graph-bipartite"></a><a href="https://leetcode.com/problems/is-graph-bipartite/description/" target="_blank" rel="external">785. is-graph-bipartite</a></h4><ul>
<li>给一个数组，每个index对应着该node的所有邻接点。问这个graph能否只用两个颜色给node上色使得相邻两个点的颜色都不一样。</li>
<li><p>方法一：DFS。对于每一个点都一波直接深度搜索上色，用一个数组存储上色状态，0表示未访问过，-1和1分别表示两个颜色，在dfs时对于当前的点若已经访问过就判断是否符合当前给定的颜色，若未访问则直接上色并DFS到它所有邻接点。需要注意可能有若干独立的cluster，因此不能一次DFS搜索就结束了，而是需要一个循环保证对所有未访问过的点都进行一次DFS。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (graph == <span class="keyword">null</span> || graph.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] colors = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (colors[i] == <span class="number">0</span> &amp;&amp; !checkColor(graph, colors, -<span class="number">1</span>, i)) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkColor</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span>[] colors, <span class="keyword">int</span> currColor, <span class="keyword">int</span> currNode)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (colors[currNode] != <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> colors[currNode] == currColor;</div><div class="line">        &#125;</div><div class="line">        colors[currNode] = currColor;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : graph[currNode]) &#123;</div><div class="line">            <span class="keyword">if</span> (!checkColor(graph, colors, -currColor, neighbor)) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法二：BFS，还是用queue存放所有邻接点然后逐一上色。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (graph == <span class="keyword">null</span> || graph.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] colors = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length; i++) &#123;    <span class="comment">// 只check没有访问过的点，即各个独立的cluster</span></div><div class="line">            <span class="keyword">if</span> (colors[i] == <span class="number">0</span> &amp;&amp; !checkColor(graph, colors, -<span class="number">1</span>, i)) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkColor</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span>[] colors, <span class="keyword">int</span> currColor, <span class="keyword">int</span> currNode)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (colors[currNode] != <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> colors[currNode] == currColor;</div><div class="line">        &#125;</div><div class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> color = currColor;</div><div class="line">        q.offer(currNode);</div><div class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</div><div class="line">            <span class="keyword">int</span> size = q.size();</div><div class="line">            <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">int</span> node = q.poll();</div><div class="line">                <span class="keyword">if</span> (colors[node] != <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (colors[node] != color) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    colors[node] = color;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : graph[node]) &#123;</div><div class="line">                    <span class="keyword">if</span> (colors[neighbor] == <span class="number">0</span>) q.offer(neighbor);   <span class="comment">// 避免回头路</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            color = -color;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="787-cheapest-flights-within-k-stops"><a href="#787-cheapest-flights-within-k-stops" class="headerlink" title="787. cheapest-flights-within-k-stops"></a><a href="https://leetcode.com/problems/cheapest-flights-within-k-stops/description/" target="_blank" rel="external">787. cheapest-flights-within-k-stops</a></h4><ul>
<li>给一组city和航班信息，在最多stop k次的情况下求从src到dst最便宜的航班价格。</li>
<li>经典grpah最短路问题，首先用Map记录每一个city的邻居city航班，然后从src出发BFS，维护一个minPrice数组，发现更低价格时就更新对应city的到达所需价格。在BFS过程中，每扩散一轮就算作stop一次，利用一个flightCount保证最多停k次。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCheapestPrice</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] flights, <span class="keyword">int</span> src, <span class="keyword">int</span> dst, <span class="keyword">int</span> K)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (flights == <span class="keyword">null</span> || flights.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        Map&lt;Integer, List&lt;<span class="keyword">int</span>[]&gt;&gt; flightMap = getGraph(flights);</div><div class="line">        <span class="keyword">int</span>[] minPrices = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">        Arrays.fill(minPrices, Integer.MAX_VALUE);</div><div class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> flightCount = K + <span class="number">1</span>;</div><div class="line">        q.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;src, <span class="number">0</span>&#125;);</div><div class="line">        <span class="keyword">while</span> (!q.isEmpty() &amp;&amp; flightCount-- &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">int</span> size = q.size();</div><div class="line">            <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">int</span>[] currCity = q.poll();</div><div class="line">                List&lt;<span class="keyword">int</span>[]&gt; neighbors = flightMap.get(currCity[<span class="number">0</span>]);</div><div class="line">                <span class="keyword">if</span> (neighbors == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span>[] neighbor : neighbors) &#123;</div><div class="line">                    <span class="keyword">int</span> price = currCity[<span class="number">1</span>] + neighbor[<span class="number">2</span>];</div><div class="line">                    <span class="keyword">if</span> (price &lt; minPrices[neighbor[<span class="number">1</span>]]) &#123;</div><div class="line">                        minPrices[neighbor[<span class="number">1</span>]] = price;</div><div class="line">                        q.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;neighbor[<span class="number">1</span>], price&#125;);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> minPrices[dst] == Integer.MAX_VALUE ? -<span class="number">1</span> : minPrices[dst];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> Map&lt;Integer, List&lt;<span class="keyword">int</span>[]&gt;&gt; getGraph(<span class="keyword">int</span>[][] flights) &#123;</div><div class="line">        Map&lt;Integer, List&lt;<span class="keyword">int</span>[]&gt;&gt; flightMap = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] flight : flights) &#123;</div><div class="line">            flightMap.putIfAbsent(flight[<span class="number">0</span>], <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;());</div><div class="line">            flightMap.get(flight[<span class="number">0</span>]).add(flight);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> flightMap;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="791-custom-sort-string"><a href="#791-custom-sort-string" class="headerlink" title="791. custom-sort-string"></a><a href="https://leetcode.com/problems/custom-sort-string/description/" target="_blank" rel="external">791. custom-sort-string</a></h4><ul>
<li>给两个String，S只含有不重复的小写字母表示custom定义的顺序，需要将T按照这个给定顺序进行排序，对于没有出现过的字母随便放哪里都可以。</li>
<li>方法一：遍历S，在循环内层遍历T，遇到当前字符就往前swap，时间复杂度O(N^2).</li>
<li>方法二：木桶排序，既然只会出现小写字母，就用26个木桶统计出现个数，然后遍历S取处相应的append即可，最后再把S中没有的字母拼接到最后即可。时间O(N).</li>
</ul>
<h4 id="795-number-of-subarrays-with-bounded-maximum"><a href="#795-number-of-subarrays-with-bounded-maximum" class="headerlink" title="795. number-of-subarrays-with-bounded-maximum"></a><a href="https://leetcode.com/problems/number-of-subarrays-with-bounded-maximum/description/" target="_blank" rel="external">795. number-of-subarrays-with-bounded-maximum</a></h4><ul>
<li>给一个数组和一个范围[L, R]，求该数组有多少个子数组，使得子数组的最大值落在[L, R]中。</li>
<li><p>首先想到DP，<code>dp[i][j]</code>表示从i到j的子数组的最大值，O(N^2)遍历的时候就可以顺便判断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSubarrayBoundedMax</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (A == <span class="keyword">null</span> || A.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> len  = A.length, ans = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len][len];</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; len; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (i == j) &#123;</div><div class="line">                    dp[i][j] = A[j];</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    dp[i][j] = Math.max(dp[i][j - <span class="number">1</span>], A[j]);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (dp[i][j] &gt;= L &amp;&amp; dp[i][j] &lt;= R) &#123;</div><div class="line">                    ans++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>follow-up：进一步优化，不使用额外的空间，同时时间复杂度降到O(N).</p>
</li>
<li>子数组的总量是一定的，既然求的是range，那首先求所有数都不超过max的子数组数量，然后求所有数都不超过(min - 1)的子数组的数量，两个一减就得到了在[min, max]之间的子数组的数量。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSubarrayBoundedMax</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (A == <span class="keyword">null</span> || A.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> countSubarray(A, R) - countSubarray(A, L - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countSubarray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> max)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>, total = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</div><div class="line">            curr = num &lt;= max ? curr + <span class="number">1</span> : <span class="number">0</span>;</div><div class="line">            total += curr;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> total;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="796-rotate-string"><a href="#796-rotate-string" class="headerlink" title="796. rotate-string"></a><a href="https://leetcode.com/problems/rotate-string/description/" target="_blank" rel="external">796. rotate-string</a></h4><ul>
<li>给两个String，判断A能否通过shift变成B。</li>
<li>经典。观察可以得出A拼接上自身之后必须包含B才能保证shift得到B。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">rotateString</span><span class="params">(String A, String B)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> A != <span class="keyword">null</span> &amp;&amp; B != <span class="keyword">null</span> &amp;&amp; A.length() == B.length() &amp;&amp; (A + A).contains(B);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    

    
    
    

    

    
      
    
    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>└(^o^)┘</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechat.png" alt="Bob_波波 WeChat Pay"/>
        <p>WeChat Pay</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.png" alt="Bob_波波 Alipay"/>
        <p>Alipay</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/algorithm/" rel="tag"><i class="fa fa-tag"></i> algorithm</a>
          
            <a href="/tags/java/" rel="tag"><i class="fa fa-tag"></i> java</a>
          
            <a href="/tags/interview/" rel="tag"><i class="fa fa-tag"></i> interview</a>
          
            <a href="/tags/leetcode/" rel="tag"><i class="fa fa-tag"></i> leetcode</a>
          
        </div>
      

      
      
        <div class="post-widgets">
        

        

        
          
          <div class="social_share">
            
            
               <div id="needsharebutton-postbottom">
                 <span class="btn">
                    <i class="fa fa-share-alt" aria-hidden="true"></i>
                 </span>
               </div>
            
          </div>
        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/11/28/udacity/" rel="next" title="有代西滴">
                <i class="fa fa-chevron-left"></i> 有代西滴
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/01/05/java_leetcode6/" rel="prev" title="Note for LeetCode in Java (800+)">
                Note for LeetCode in Java (800+) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Bob_波波"/>
            
              <p class="site-author-name" itemprop="name">Bob_波波</p>
              <p class="site-description motion-element" itemprop="description">I'm a Software Engineer!</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">40</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">39</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#402-remove-k-digits"><span class="nav-text">402. remove-k-digits</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#403-frog-jump"><span class="nav-text">403. frog-jump</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#404-sum-of-left-leaves"><span class="nav-text">404. sum-of-left-leaves</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#405-convert-a-number-to-hexadecimal"><span class="nav-text">405. convert-a-number-to-hexadecimal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#409-valid-word-abbreviation"><span class="nav-text">409. valid-word-abbreviation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#410-split-array-largest-sum"><span class="nav-text">410. split-array-largest-sum</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#412-FizzBuzz"><span class="nav-text">412. FizzBuzz</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#416-partition-equal-subset-sum"><span class="nav-text">416. partition-equal-subset-sum</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#419-battleships-in-a-board"><span class="nav-text">419. battleships-in-a-board</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#424-longest-repeating-character-replacement"><span class="nav-text">424. longest-repeating-character-replacement</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#425-word-squares"><span class="nav-text">425. word-squares</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#426-convert-binary-search-tree-to-sorted-doubly-linked-list"><span class="nav-text">426. convert-binary-search-tree-to-sorted-doubly-linked-list</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#430-flatten-a-multilevel-doubly-linked-list"><span class="nav-text">430. flatten-a-multilevel-doubly-linked-list</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#437-path-sum-iii"><span class="nav-text">437. path-sum-iii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#438-find-all-anagrams-in-a-string"><span class="nav-text">438. find-all-anagrams-in-a-string</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#439-ternary-expression-parser"><span class="nav-text">439. ternary-expression-parser</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#443-string-compression"><span class="nav-text">443. string-compression</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#444-sequence-reconstruction"><span class="nav-text">444. sequence-reconstruction</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#445-add-two-numbers-ii"><span class="nav-text">445. add-two-numbers-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#449-serialize-and-deserialize-bst"><span class="nav-text">449. serialize-and-deserialize-bst</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#450-delete-node-in-a-bst"><span class="nav-text">450. delete-node-in-a-bst</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#452-minimum-number-of-arrows-to-burst-balloons"><span class="nav-text">452. minimum-number-of-arrows-to-burst-balloons</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#453-minimum-moves-to-equal-array-elements"><span class="nav-text">453. minimum-moves-to-equal-array-elements</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#454-4sum-ii"><span class="nav-text">454. 4sum-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#457-circular-array-loop"><span class="nav-text">457. circular-array-loop</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#460-Least-Frequently-Used-Cache"><span class="nav-text">460. Least Frequently Used Cache</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#461-hamming-distance"><span class="nav-text">461. hamming-distance</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#463-island-perimeter"><span class="nav-text">463. island-perimeter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#464-can-i-win"><span class="nav-text">464. can-i-win</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#477-total-hamming-distance"><span class="nav-text">477. total-hamming-distance</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#480-sliding-window-median"><span class="nav-text">480. sliding-window-median</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#482-license-key-formatting"><span class="nav-text">482. license-key-formatting</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#484-find-permutation"><span class="nav-text">484. find-permutation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#485-max-consecutive-ones"><span class="nav-text">485. max-consecutive-ones</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#486-predict-the-winner"><span class="nav-text">486. predict-the-winner</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#487-max-consecutive-ones-ii"><span class="nav-text">487. max-consecutive-ones-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#490-the-maze"><span class="nav-text">490. the-maze</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#494-target-sum"><span class="nav-text">494. target-sum</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#496-next-greater-element-i"><span class="nav-text">496. next-greater-element-i</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#498-diagonal-traverse"><span class="nav-text">498. diagonal-traverse</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#499-the-maze-iii"><span class="nav-text">499. the-maze-iii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#503-next-greater-element-ii"><span class="nav-text">503. next-greater-element-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#505-the-maze-ii"><span class="nav-text">505. the-maze-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#508-most-frequent-subtree-sum"><span class="nav-text">508. most-frequent-subtree-sum</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#513-find-bottom-left-tree-value"><span class="nav-text">513. find-bottom-left-tree-value</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#515-find-largest-value-in-each-tree-row"><span class="nav-text">515. find-largest-value-in-each-tree-row</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#516-longest-palindromic-subsequence"><span class="nav-text">516. longest-palindromic-subsequence</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#518-coin-change-2"><span class="nav-text">518. coin-change-2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#523-continuous-subarray-sum"><span class="nav-text">523. continuous-subarray-sum</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#524-longest-word-in-dictionary-through-deleting"><span class="nav-text">524. longest-word-in-dictionary-through-deleting</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#525-contiguous-array"><span class="nav-text">525. contiguous-array</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#528-random-pick-with-weight"><span class="nav-text">528. random-pick-with-weight</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#529-minesweeper"><span class="nav-text">529. minesweeper</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#535-encode-and-decode-tinyurl"><span class="nav-text">535. encode-and-decode-tinyurl</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#536-construct-binary-tree-from-string"><span class="nav-text">536. construct-binary-tree-from-string</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#540-single-element-in-a-sorted-array"><span class="nav-text">540. single-element-in-a-sorted-array</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#543-diameter-of-binary-tree"><span class="nav-text">543. diameter-of-binary-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#545-boundary-of-binary-tree"><span class="nav-text">545. boundary-of-binary-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#548-split-array-with-equal-sum"><span class="nav-text">548. split-array-with-equal-sum</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#549-binary-tree-longest-consecutive-sequence-ii"><span class="nav-text">549. binary-tree-longest-consecutive-sequence-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#554-brick-wall"><span class="nav-text">554. brick-wall</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#556-next-greater-element-iii"><span class="nav-text">556. next-greater-element-iii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#560-subarray-sum-equals-k"><span class="nav-text">560. subarray-sum-equals-k</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#562-longest-line-of-consecutive-one-in-matrix"><span class="nav-text">562. longest-line-of-consecutive-one-in-matrix</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#567-permutation-in-string"><span class="nav-text">567. permutation-in-string</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#572-subtree-of-another-tree"><span class="nav-text">572. subtree-of-another-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#575-distribute-candies"><span class="nav-text">575. distribute-candies</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#581-shortest-unsorted-continuous-subarray"><span class="nav-text">581. shortest-unsorted-continuous-subarray</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#594-longest-harmonious-subsequence"><span class="nav-text">594. longest-harmonious-subsequence</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#598-range-addition-ii"><span class="nav-text">598. range-addition-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#600-non-negative-integers-without-consecutive-ones"><span class="nav-text">600. non-negative-integers-without-consecutive-ones</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#604-design-compressed-string-iterator"><span class="nav-text">604. design-compressed-string-iterator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#605-can-place-flowers"><span class="nav-text">605. can-place-flowers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#606-construct-string-from-binary-tree"><span class="nav-text">606. construct-string-from-binary-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#609-find-duplicate-file-in-system"><span class="nav-text">609. find-duplicate-file-in-system</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#611-valid-triangle-number"><span class="nav-text">611. valid-triangle-number</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#621-task-scheduler"><span class="nav-text">621. task-scheduler</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#622-design-circular-queue-https-leetcode-com-problems-design-circular-queue"><span class="nav-text">[622. design-circular-queue] (https://leetcode.com/problems/design-circular-queue/)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#628-maximum-product-of-three-numbers"><span class="nav-text">628. maximum-product-of-three-numbers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#632-smallest-range"><span class="nav-text">632. smallest-range</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#633-sum-of-square-numbers"><span class="nav-text">633. sum-of-square-numbers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#636-exclusive-time-of-functions"><span class="nav-text">636. exclusive-time-of-functions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#637-average-of-levels-in-binary-tree"><span class="nav-text">637. average-of-levels-in-binary-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#646-maximum-length-of-pair-chain"><span class="nav-text">646. maximum-length-of-pair-chain</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#647-palindromic-substrings"><span class="nav-text">647. palindromic-substrings</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#648-replace-words"><span class="nav-text">648. replace-words</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#652-find-duplicate-subtrees"><span class="nav-text">652. find-duplicate-subtrees</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#653-two-sum-iv-input-is-a-bst"><span class="nav-text">653. two-sum-iv-input-is-a-bst</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#654-maximum-binary-tree"><span class="nav-text">654. maximum-binary-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#657-judge-route-circle"><span class="nav-text">657. judge-route-circle</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#658-find-k-closest-elements"><span class="nav-text">658. find-k-closest-elements</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#662-maximum-width-of-binary-tree"><span class="nav-text">662. maximum-width-of-binary-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#669-trim-a-binary-search-tree"><span class="nav-text">669. trim-a-binary-search-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#670-maximum-swap"><span class="nav-text">670. maximum-swap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#671-second-minimum-node-in-a-binary-tree"><span class="nav-text">671. second-minimum-node-in-a-binary-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#673-number-of-longest-increasing-subsequence"><span class="nav-text">673. number-of-longest-increasing-subsequence</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#674-longest-continuous-increasing-subsequence"><span class="nav-text">674. longest-continuous-increasing-subsequence</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#676-implement-magic-dictionary"><span class="nav-text">676. implement-magic-dictionary</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#678-valid-parenthesis-string"><span class="nav-text">678. valid-parenthesis-string</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#680-valid-palindrome-ii"><span class="nav-text">680. valid-palindrome-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#681-next-closest-time"><span class="nav-text">681. next-closest-time</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#682-baseball-game"><span class="nav-text">682. baseball-game</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#683-k-empty-slots"><span class="nav-text">683. k-empty-slots</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#684-redundant-connection"><span class="nav-text">684. redundant-connection</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#685-redundant-connection-ii"><span class="nav-text">685. redundant-connection-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#686-repeated-string-match"><span class="nav-text">686. repeated-string-match</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#687-longest-univalue-path"><span class="nav-text">687. longest-univalue-path</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#688-knight-probability-in-chessboard"><span class="nav-text">688. knight-probability-in-chessboard</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#689-maximum-sum-of-3-non-overlapping-subarrays"><span class="nav-text">689. maximum-sum-of-3-non-overlapping-subarrays</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#690-employee-importance"><span class="nav-text">690. employee-importance</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#692-top-k-frequent-words"><span class="nav-text">692. top-k-frequent-words</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#694-number-of-distinct-islands"><span class="nav-text">694. number-of-distinct-islands</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#695-max-area-of-island"><span class="nav-text">695. max-area-of-island</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#696-count-binary-substrings"><span class="nav-text">696. count-binary-substrings</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#698-partition-to-k-equal-sum-subsets"><span class="nav-text">698. partition-to-k-equal-sum-subsets</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#699-falling-squares"><span class="nav-text">699. falling-squares</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#703-kth-largest-element-in-a-stream"><span class="nav-text">703. kth-largest-element-in-a-stream</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#708-insert-into-a-cyclic-sorted-list"><span class="nav-text">708. insert-into-a-cyclic-sorted-list</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#711-number-of-distinct-islands-ii"><span class="nav-text">711. number-of-distinct-islands-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#714-best-time-to-buy-and-sell-stock-with-transaction-fee"><span class="nav-text">714. best-time-to-buy-and-sell-stock-with-transaction-fee</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#719-find-k-th-smallest-pair-distance"><span class="nav-text">719. find-k-th-smallest-pair-distance</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#720-longest-word-in-dictionary"><span class="nav-text">720. longest-word-in-dictionary</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#721-accounts-merge"><span class="nav-text">721. accounts-merge</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#722-remove-comments"><span class="nav-text">722. remove-comments</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#724-find-pivot-index"><span class="nav-text">724. find-pivot-index</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#726-number-of-atoms"><span class="nav-text">726. number-of-atoms</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#727-minimum-window-subsequence"><span class="nav-text">727. minimum-window-subsequence</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#729-my-calendar-i"><span class="nav-text">729. my-calendar-i</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#731-my-calendar-ii"><span class="nav-text">731. my-calendar-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#733-flood-fill"><span class="nav-text">733. flood-fill</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#734-sentence-similarity"><span class="nav-text">734. sentence-similarity</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#735-asteroid-collision"><span class="nav-text">735. asteroid-collision</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#737-sentence-similarity-ii"><span class="nav-text">737. sentence-similarity-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#739-daily-temperatures"><span class="nav-text">739. daily-temperatures</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#742-closest-leaf-in-a-binary-tree"><span class="nav-text">742. closest-leaf-in-a-binary-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#743-network-delay-time"><span class="nav-text">743. network-delay-time</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#744-find-smallest-letter-greater-than-target"><span class="nav-text">744. find-smallest-letter-greater-than-target</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#745-prefix-and-suffix-search"><span class="nav-text">745. prefix-and-suffix-search</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#748-shortest-completing-word"><span class="nav-text">748. shortest-completing-word</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#750-number-of-corner-rectangles"><span class="nav-text">750. number-of-corner-rectangles</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#752-open-the-lock"><span class="nav-text">752. open-the-lock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#759-employee-free-time"><span class="nav-text">759. employee-free-time</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#760-find-anagram-mappings"><span class="nav-text">760. find-anagram-mappings</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#763-partition-labels"><span class="nav-text">763. partition-labels</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#764-largest-plus-sign"><span class="nav-text">764. largest-plus-sign</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#765-couples-holding-hands"><span class="nav-text">765. couples-holding-hands</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#767-reorganize-string"><span class="nav-text">767. reorganize-string</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#768-max-chunks-to-make-sorted-ii"><span class="nav-text">768. max-chunks-to-make-sorted-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#769-max-chunks-to-make-sorted"><span class="nav-text">769. max-chunks-to-make-sorted</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#776-split-bst"><span class="nav-text">776. split-bst</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#785-is-graph-bipartite"><span class="nav-text">785. is-graph-bipartite</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#787-cheapest-flights-within-k-stops"><span class="nav-text">787. cheapest-flights-within-k-stops</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#791-custom-sort-string"><span class="nav-text">791. custom-sort-string</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#795-number-of-subarrays-with-bounded-maximum"><span class="nav-text">795. number-of-subarrays-with-bounded-maximum</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#796-rotate-string"><span class="nav-text">796. rotate-string</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-futbol-o"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bob_波波</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a></div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="Total Visitors">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="site-pv" title="Total Views">
      <i class="fa fa-history"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    

    

    

    
      <div>
        <!-- Go to www.addthis.com/dashboard to customize your tools -->
<div class="addthis_inline_share_toolbox">
  <script type = "text/javascript" src = "//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-593135f4e114024c" async = "async" ></script>
</div>

      </div>
    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=6.7.0"></script>

  <script src="/js/src/motion.js?v=6.7.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.7.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.7.0"></script>



  
  <script src="/js/src/scrollspy.js?v=6.7.0"></script>
<script src="/js/src/post-details.js?v=6.7.0"></script>



  


  <script src="/js/src/bootstrap.js?v=6.7.0"></script>



  

  
    <script id="dsq-count-scr" src="https://bobbyliujb.disqus.com/count.js" async></script>
  

  
    <script>
      var disqus_config = function () {
        this.page.url = "https://bobbyliujb.github.io/2018/01/05/java_leetcode5/";
        this.page.identifier = "2018/01/05/java_leetcode5/";
        this.page.title = 'Note for LeetCode in Java (401~800)';
        };
      function loadComments () {
        var d = document, s = d.createElement('script');
        s.src = 'https://bobbyliujb.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      }
      
        loadComments();
      
    </script>
  













  

  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-circle-o-notch fa-spin fa-3x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('10');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script>
    
    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url }) })
        .done(function ({ results }) {
          if (results.length > 0) {
            var counter = results[0];
            
            Counter('put', `/classes/Counter/${counter.objectId}`, JSON.stringify({ time: { "__op":"Increment", "amount":1 } }))
            
            .done(function () {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(counter.time + 1);
            })
            
            .fail(function ({ responseJSON }) {
                console.log('Failed to save Visitor num, with error message: ' + responseJSON.error);
            })
          } else {
            
              var $element = $(document.getElementById(url));
              $element.find('.leancloud-visitors-count').text('Counter not initialized! See more at console err msg.');
              console.error('ATTENTION! LeanCloud counter has security bug, see here how to solve it: https://github.com/theme-next/hexo-leancloud-counter-security. \n But you also can use LeanCloud without security, by set \'security\' option to \'false\'.');
            
          }
        })
      .fail(function ({ responseJSON }) {
        console.log('LeanCloud Counter Error:' + responseJSON.code + " " + responseJSON.error);
      });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + "jT7i5auNazMHRONSPUHmcoko-gzGzoHsz")
        .done(function ({ api_server }) {
          var Counter = function (method, url, data) {
            return $.ajax({
              method: method,
              url: `https://${api_server}/1.1${url}`,
              headers: {
                'X-LC-Id': "jT7i5auNazMHRONSPUHmcoko-gzGzoHsz",
                'X-LC-Key': "dEWwuVre5Svmwvjw2DmcIbLy",
                'Content-Type': 'application/json',
              },
              data: data,
            });
          };
          
          addCount(Counter);
          
        })
    });
  </script>



  

  

  

  

  
  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>
  <script>
    
      pbOptions = {};
      
        pbOptions.iconStyle = "box";
      
        pbOptions.boxForm = "horizontal";
      
        pbOptions.position = "topCenter";
      
        pbOptions.networks = "Linkedin,Weibo,Wechat,Twitter,Facebook,Pinterest,GooglePlus,Evernote,Reddit,Douban,QQZone,Mailto";
      
      new needShareButton('#needsharebutton-postbottom', pbOptions);
    
    
  </script>


  

  

  

  

  

  

  

</body>
</html>
