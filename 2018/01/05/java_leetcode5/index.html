<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="java,algorithm,interview,leetcode," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="刷题。祝我好运。">
<meta name="keywords" content="java,algorithm,interview,leetcode">
<meta property="og:type" content="article">
<meta property="og:title" content="Note for LeetCode in Java (401~800)">
<meta property="og:url" content="https://bobbyliujb.github.io/2018/01/05/java_leetcode5/index.html">
<meta property="og:site_name" content="Bobby">
<meta property="og:description" content="刷题。祝我好运。">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2018-01-14T07:59:08.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Note for LeetCode in Java (401~800)">
<meta name="twitter:description" content="刷题。祝我好运。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"hide","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://bobbyliujb.github.io/2018/01/05/java_leetcode5/"/>





  <title>Note for LeetCode in Java (401~800) | Bobby</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Bobby</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://bobbyliujb.github.io/2018/01/05/java_leetcode5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BobbyLiujb">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://ww4.sinaimg.cn/large/9b3a5c2fgw1faysh4xl7ij20bh0bhmy5.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bobby">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Note for LeetCode in Java (401~800)</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-05T16:49:39-08:00">
                2018-01-05
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2018-01-13T23:59:08-08:00">
                2018-01-13
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/" itemprop="url" rel="index">
                    <span itemprop="name">Tech</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/01/05/java_leetcode5/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/01/05/java_leetcode5/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/01/05/java_leetcode5/" class="leancloud_visitors" data-flag-title="Note for LeetCode in Java (401~800)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>刷题。祝我好运。<br><a id="more"></a></p>
<h4 id="403-frog-jump"><a href="#403-frog-jump" class="headerlink" title="403. frog-jump"></a><a href="https://leetcode.com/problems/frog-jump/description/" target="_blank" rel="external">403. frog-jump</a></h4><ul>
<li>给一个数组表示石头所处的x坐标，青蛙每次只能跳上一次跳跃长度的-1,0,1三种可能，判断能否跳到最后一个石头。例如<code>[0,1,3,5,6,8,12,17]</code>是可以的，而<code>[0,1,2,3,4,8,9,11]</code>就不行。</li>
<li>相当于BFS，每个石头处维护一个set存放他可以跳的长度，然后每次都往后跳看看能否有新的石头，有就更新那个石头的可跳长度。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// BFS，从开头出发，不断更新后续可达石头的新步数，若中途更新到了最后一个石头，就可达</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canCross</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (stones == <span class="keyword">null</span> || stones.length == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (stones[<span class="number">0</span>] != <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 记录每个坐标的石头所能跳的长度</span></div><div class="line">    Map&lt;Integer, Set&lt;Integer&gt;&gt; stone2step = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stones.length; i++) &#123;</div><div class="line">        stone2step.put(stones[i], <span class="keyword">new</span> HashSet&lt;&gt;());</div><div class="line">    &#125;</div><div class="line">    stone2step.get(<span class="number">0</span>).add(<span class="number">1</span>);   <span class="comment">// 第一步起码要能往后挪一步</span></div><div class="line">    </div><div class="line">    <span class="comment">// 从第一个石头开始，往后更新每个石头的能跳步数</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stones.length; i++) &#123;</div><div class="line">        <span class="keyword">int</span> currStone = stones[i];</div><div class="line">        Set&lt;Integer&gt; steps = stone2step.get(currStone);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> step: steps) &#123;</div><div class="line">            <span class="keyword">int</span> newStone = currStone + step;</div><div class="line">            <span class="keyword">if</span> (newStone == stones[stones.length - <span class="number">1</span>]) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            Set&lt;Integer&gt; newStep = stone2step.get(newStone);</div><div class="line">            <span class="keyword">if</span> (newStep != <span class="keyword">null</span>) &#123;   <span class="comment">// 表示有这个新石头的坐标</span></div><div class="line">                newStep.add(step + <span class="number">1</span>);</div><div class="line">                newStep.add(step);</div><div class="line">                <span class="keyword">if</span> (step - <span class="number">1</span> &gt; <span class="number">0</span>) &#123;</div><div class="line">                    newStep.add(step - <span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="405-convert-a-number-to-hexadecimal"><a href="#405-convert-a-number-to-hexadecimal" class="headerlink" title="405. convert-a-number-to-hexadecimal"></a><a href="https://leetcode.com/problems/convert-a-number-to-hexadecimal/description/" target="_blank" rel="external">405. convert-a-number-to-hexadecimal</a></h4><ul>
<li>将数字转换为十六进制字符串。</li>
<li><p>方法一：利用mask每次只取最后四个bit，然后直接map到字符拼接到hexStr的最前面，然后unsigned shift四位。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">char</span>[] map = &#123;<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>,<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>&#125;;</div><div class="line"><span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">int</span> mask = <span class="number">15</span>;</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toHex</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"0"</span>;</div><div class="line">    &#125;</div><div class="line">    String hexStr = <span class="string">""</span>;</div><div class="line">    <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</div><div class="line">        hexStr = map[(num &amp; mask)] + hexStr;</div><div class="line">        num = (num &gt;&gt;&gt; <span class="number">4</span>);  <span class="comment">// 不保留最高位</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> hexStr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法二：更general的做法，可以推广到十进制转任意进制字符串。不过首先需要转成long并且过滤掉long前面填充的一堆符号位，然后取模得到的就是当前位的数值，直接map到字符；然后继续除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">char</span>[] map = &#123;<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>,<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>&#125;;</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toHex</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"0"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">long</span> longNum = num &amp; <span class="number">0x00000000ffffffffL</span>;   <span class="comment">// 不能直接强制转换，不然会保留符号</span></div><div class="line">    String hexStr = <span class="string">""</span>;</div><div class="line">    <span class="keyword">while</span> (longNum != <span class="number">0</span>) &#123;</div><div class="line">        hexStr = map[(<span class="keyword">int</span>)(longNum % <span class="number">16</span>)] + hexStr;</div><div class="line">        longNum /= <span class="number">16</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> hexStr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="424-longest-repeating-character-replacement"><a href="#424-longest-repeating-character-replacement" class="headerlink" title="424. longest-repeating-character-replacement"></a><a href="https://leetcode.com/problems/longest-repeating-character-replacement/description/" target="_blank" rel="external">424. longest-repeating-character-replacement</a></h4><ul>
<li>给一个仅包含大写字母的字符串，再给一个k，表示假设可以有k次机会将其中的某些字母任意变成另一个字母，返回最长的相同字母的substring的长度。例如<code>ABAB</code>变2次，最长长度为4（<code>AAAA</code>）；<code>AAABAABB</code>变1次，为6.</li>
<li>这个替换是一一对应的吗？（不是，可以任意换成需要的字符。也就是可以多对一）</li>
<li>双指针 + producer/consumer的方法，快指针先往后求各个字母的计数，同时更新一个出现最多的字母的频数maxCount。当前后两指针所夹字母数大于了maxCount + k，说明已经超过了可以替换的数目，此时就需要挪慢指针来consume计数。至于为什么不需要每次都保持最精确的maxCount，因为我们只关心最大的，当前最大的挪出窗口后，计数肯定是减掉的，那么后续再出现的时候，不会错误地产生更大的计数，最大值再大也大不过历史峰值。<a href="https://discuss.leetcode.com/topic/63494/java-12-lines-o-n-sliding-window-solution-with-explanation/2" target="_blank" rel="external">解释来自这里</a>.<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characterReplacement</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">26</span>];</div><div class="line">        <span class="keyword">char</span>[] sChar = s.toCharArray();</div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, maxCount = <span class="number">0</span>, maxLen = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> end = <span class="number">0</span>; end &lt; sChar.length; end++) &#123;  </div><div class="line">            maxCount = Math.max(maxCount, ++count[sChar[end] - <span class="string">'A'</span>]);   <span class="comment">// 更新最多的字母的频数</span></div><div class="line">            <span class="keyword">while</span> (end - start + <span class="number">1</span> &gt; k + maxCount) &#123;        <span class="comment">// 指针覆盖的字母过多</span></div><div class="line">                count[sChar[start] - <span class="string">'A'</span>]--;    <span class="comment">// 挪动慢指针，并consume掉计数</span></div><div class="line">                start++;</div><div class="line">                <span class="comment">// 注意并不需要重置maxCount，因为当前这样求出来的就是最大的，只有当新的字符超过了历史最大的maxCount才会有更长的长度需要更新</span></div><div class="line">            &#125;</div><div class="line">            maxLen = Math.max(maxLen, end - start + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxLen;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="437-path-sum-iii"><a href="#437-path-sum-iii" class="headerlink" title="437. path-sum-iii"></a><a href="https://leetcode.com/problems/path-sum-iii/description/" target="_blank" rel="external">437. path-sum-iii</a></h4><ul>
<li>给一个二叉树，给一个目标值sum，求有几条从上往下累加的路径之和等于sum。</li>
<li>递归DFS，每次深入之前都先减掉当前节点的值。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;    <span class="comment">// calculate path num starting from root</span></div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dfs(root, sum)   <span class="comment">// taking the given node</span></div><div class="line">            + pathSum(root.left, sum) + pathSum(root.right, sum); <span class="comment">// start from left/right child</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode node, <span class="keyword">int</span> target)</span> </span>&#123;    <span class="comment">// dig to find path num taking current node</span></div><div class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (node.val == target? <span class="number">1</span> : <span class="number">0</span>) + dfs(node.left, target - node.val) + dfs(node.right, target - node.val);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="438-find-all-anagrams-in-a-string"><a href="#438-find-all-anagrams-in-a-string" class="headerlink" title="438. find-all-anagrams-in-a-string"></a><a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/description/" target="_blank" rel="external">438. find-all-anagrams-in-a-string</a></h4><ul>
<li>给一个字符串s和一个字符串p，求s中所有p的anagram子串的起始位置的List。</li>
<li>双指针 + producer/consumer的方法，map中存放p中每个字符及其对应出现的次数，快指针负责consume直到没有可用的字符（只需要管map中有的字符），这时看看快慢指针所夹字符的个数是否等于p；之后就挪动慢指针provide补回字符。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">// O(N)双指针。先一波流统计p中各个字符出现的频数，然后consume掉map中的字符直到没有available的</span></div><div class="line">    <span class="comment">// 此时判断左右指针之间长度是否等于目标的长度，然后挪动左指针重新往map中加回去，直到出现可选字符</span></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</div><div class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || p == <span class="keyword">null</span> || s.length() == <span class="number">0</span> || p.length() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> ans;</div><div class="line">        &#125;</div><div class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">char</span>[] pChar = p.toCharArray();</div><div class="line">        <span class="keyword">int</span> pLen = pChar.length;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: pChar) &#123;</div><div class="line">            map.put(c, map.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">char</span>[] sChar = s.toCharArray();</div><div class="line">        <span class="keyword">int</span> count = map.size();     <span class="comment">// 还有count个不同的字符可选</span></div><div class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (right &lt; sChar.length) &#123;</div><div class="line">            <span class="keyword">if</span> (map.containsKey(sChar[right])) &#123;</div><div class="line">                map.put(sChar[right], map.get(sChar[right]) - <span class="number">1</span>);</div><div class="line">                <span class="keyword">if</span> (map.get(sChar[right]) == <span class="number">0</span>) &#123;</div><div class="line">                    count--;    <span class="comment">// 可选字符少了一个</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (right - left + <span class="number">1</span> == pLen) &#123;</div><div class="line">                    ans.add(left);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (map.containsKey(sChar[left])) &#123;</div><div class="line">                    map.put(sChar[left], map.get(sChar[left]) + <span class="number">1</span>);</div><div class="line">                    <span class="keyword">if</span> (map.get(sChar[left]) &gt; <span class="number">0</span>) &#123;</div><div class="line">                        count++;    <span class="comment">// 恢复可选字符</span></div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                left++;</div><div class="line">            &#125;</div><div class="line">            right++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="453-minimum-moves-to-equal-array-elements"><a href="#453-minimum-moves-to-equal-array-elements" class="headerlink" title="453. minimum-moves-to-equal-array-elements"></a><a href="https://leetcode.com/problems/minimum-moves-to-equal-array-elements/description/" target="_blank" rel="external">453. minimum-moves-to-equal-array-elements</a></h4><ul>
<li>给一个int数组，返回move几次能够让每个元素相等。move指的是对某位置以外的所有元素加1.</li>
<li>这题其实是个math problem，<a href="https://discuss.leetcode.com/topic/66737/it-is-a-math-question" target="_blank" rel="external">推导在此</a>，假设所有数之和为sum，最小值为minNum，加了m次达到x，则有<code>sum + m * (n - 1) = x * n</code>以及<code>minNum + m = x</code>，代入抵消一下就得到<code>sum + mn - m = minNum * n + mn</code>，所求的m为<code>sum - minNum * n = SUM(num_i - minNum)</code>。直接根据公式来，先求一波最小值，然后累加即可。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMoves</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> min = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</div><div class="line">            min = Math.min(min, nums[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> minMove = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</div><div class="line">            minMove += (num - min);</div><div class="line">        &#125; </div><div class="line">        <span class="keyword">return</span> minMove;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="460-Least-Frequently-Used-Cache"><a href="#460-Least-Frequently-Used-Cache" class="headerlink" title="460. Least Frequently Used Cache"></a><a href="https://leetcode.com/problems/lfu-cache/description/" target="_blank" rel="external">460. Least Frequently Used Cache</a></h4><ul>
<li>实现最近最频繁使用的有限容量缓存，到达容量上限时evict最不频繁使用的key，若频繁情况相同则evict掉最早插入的。</li>
<li><p>方法一：优先队列，自定义Cache类，其中包含freq和timestamp，自定义Comparator来维护顺序。cacheMap用于维护正常的键值对缓存，freqMap用于快速获得给定key的freq。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> </span>&#123;</div><div class="line">    <span class="comment">// naive做法：通过自定义Cache维护一个优先队列，排序就是根据freq和timestamp来的，freq小在前、相等则时间戳小的在前。注意需要重载equals和hashCode，才能正常remove。</span></div><div class="line">    <span class="comment">// put：把键值对放入cacheMap，还要新建这个key的freq（第一次为1）并插入freqMap</span></div><div class="line">    <span class="comment">// get: 直接从cacheMap中拿</span></div><div class="line">    <span class="comment">// 在put和get过程中，若key是现有的，则需要更新freq，并存入pq</span></div><div class="line">    <span class="comment">// 当到达容量上限，直接从pq头部poll出来的key对应从map里删掉即可</span></div><div class="line">    <span class="comment">// pq的remove是O(N)的，所以总体是O(capacity)的</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Cache</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> key, freq, timestamp;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Cache</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> freq, <span class="keyword">int</span> timestamp)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.key = key;</div><div class="line">            <span class="keyword">this</span>.freq = freq;</div><div class="line">            <span class="keyword">this</span>.timestamp = timestamp;</div><div class="line">        &#125;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> key == ((Cache)(obj)).key;</div><div class="line">        &#125;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> key;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> capacity, globalTime;</div><div class="line">    Map&lt;Integer, Integer&gt; cacheMap = <span class="keyword">null</span>;</div><div class="line">    Map&lt;Integer, Integer&gt; freqMap = <span class="keyword">null</span>;</div><div class="line">    PriorityQueue&lt;Cache&gt; pq = <span class="keyword">null</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LFUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.capacity = capacity;</div><div class="line">        globalTime = <span class="number">0</span>;</div><div class="line">        cacheMap = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        freqMap = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((c1, c2) -&gt; &#123;</div><div class="line">            <span class="keyword">return</span> c1.freq == c2.freq? c1.timestamp - c2.timestamp: c1.freq - c2.freq;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</div><div class="line">        globalTime++;</div><div class="line">        <span class="keyword">if</span> (cacheMap.containsKey(key)) &#123;</div><div class="line">            update(key);</div><div class="line">            <span class="keyword">return</span> cacheMap.get(key);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> ;</div><div class="line">        &#125;</div><div class="line">        globalTime++;</div><div class="line">        <span class="keyword">if</span> (cacheMap.containsKey(key)) &#123;</div><div class="line">            update(key);</div><div class="line">            cacheMap.put(key, value);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (cacheMap.size() == capacity) &#123;</div><div class="line">            Cache evict = pq.poll();</div><div class="line">            cacheMap.remove(evict.key);</div><div class="line">            freqMap.remove(evict.key);</div><div class="line">        &#125;</div><div class="line">        cacheMap.put(key, value);</div><div class="line">        freqMap.put(key, <span class="number">1</span>);</div><div class="line">        pq.add(<span class="keyword">new</span> Cache(key, <span class="number">1</span>, globalTime));</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> freq = freqMap.get(key);</div><div class="line">        freqMap.put(key, freq + <span class="number">1</span>);</div><div class="line">        Cache c = <span class="keyword">new</span> Cache(key, freq + <span class="number">1</span>, globalTime);</div><div class="line">        pq.remove(c);</div><div class="line">        pq.add(c);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法二：使用LRU中的双向链表，可以使得remove也O(1)。自定义Node，每个位置的Node代表了某个freq值的所有key。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> </span>&#123;</div><div class="line">    <span class="comment">// 自定义双向链表节点Node用于按照freq从大到小存放key</span></div><div class="line">    <span class="comment">// 通过key对应到Node（nodeMap），Node中存放该key的freq。</span></div><div class="line">    <span class="comment">// 若相同的freq对应多个key，则用一个Set存放，为了维持Recent特性，需要保证插入顺序，故用LinkedHashSet</span></div><div class="line">    <span class="comment">// get：从cacheMap中正常取数值，并从nodeMap中拿到这个节点，更新freq并插入到后续位置。</span></div><div class="line">    <span class="comment">// put：有可能是更新原有key的数值，更新cacheMap中value。</span></div><div class="line">    <span class="comment">// put：若是插入新的key，则先看看head是否维护的是freq为0，不是则新建head并插入到最前。</span></div><div class="line">    <span class="comment">// put完之后要统一更新freq.</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">int</span> freq = <span class="number">0</span>;</div><div class="line">        <span class="keyword">public</span> Set&lt;Integer&gt; keySet = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">public</span> Node prev = <span class="keyword">null</span>, next = <span class="keyword">null</span>;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> freq)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.freq = freq;</div><div class="line">            keySet = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</div><div class="line">            prev = <span class="keyword">null</span>;</div><div class="line">            next = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> Node head = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; cacheMap = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">private</span> Map&lt;Integer, Node&gt; nodeMap = <span class="keyword">null</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LFUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.capacity = capacity;</div><div class="line">        cacheMap = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        nodeMap = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (cacheMap.containsKey(key)) &#123;</div><div class="line">            updateFreq(key);</div><div class="line">            <span class="keyword">return</span> cacheMap.get(key);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (cacheMap.containsKey(key)) &#123;</div><div class="line">            cacheMap.put(key, value);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (cacheMap.size() &lt; capacity) &#123;</div><div class="line">                cacheMap.put(key, value);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                deleteOldest();</div><div class="line">                cacheMap.put(key, value);</div><div class="line">            &#125;</div><div class="line">            addToHead(key);</div><div class="line">        &#125;</div><div class="line">        updateFreq(key);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 更新key的freq并加入相应的node中</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateFreq</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</div><div class="line">        Node node = nodeMap.get(key);</div><div class="line">        node.keySet.remove(key);  <span class="comment">// 从当前freq的node中移除然后加入后续node</span></div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (node.next == <span class="keyword">null</span>) &#123;</div><div class="line">            node.next = <span class="keyword">new</span> Node(node.freq + <span class="number">1</span>);</div><div class="line">            node.next.prev = node;</div><div class="line">            node.next.keySet.add(key);    <span class="comment">// 相同freq的key，维持插入顺序</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.next.freq == node.freq + <span class="number">1</span>) &#123;</div><div class="line">            node.next.keySet.add(key);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            Node newFreqNode = <span class="keyword">new</span> Node(node.freq + <span class="number">1</span>);</div><div class="line">            newFreqNode.keySet.add(key);</div><div class="line">            newFreqNode.prev = node;</div><div class="line">            newFreqNode.next = node.next;</div><div class="line">            node.next.prev = newFreqNode;</div><div class="line">            node.next = newFreqNode;</div><div class="line">        &#125;</div><div class="line">        nodeMap.put(key, node.next);   <span class="comment">// 更新后续node</span></div><div class="line">        <span class="keyword">if</span> (node.keySet.size() == <span class="number">0</span>) &#123;</div><div class="line">            deleteNode(node);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// O(1)删除双向链表的节点</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (node.prev == <span class="keyword">null</span>) &#123;</div><div class="line">            head = node.next;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            node.prev.next = node.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) &#123;</div><div class="line">            node.next.prev = node.prev;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 新插入的key要新建freq=0的Node（或原本就有），并作为head</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</div><div class="line">            head = <span class="keyword">new</span> Node(<span class="number">0</span>);</div><div class="line">            head.keySet.add(key);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head.freq &gt; <span class="number">0</span>) &#123;</div><div class="line">            Node newHead = <span class="keyword">new</span> Node(<span class="number">0</span>);</div><div class="line">            newHead.keySet.add(key);</div><div class="line">            newHead.next = head;</div><div class="line">            head.prev = newHead;</div><div class="line">            head = newHead;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            head.keySet.add(key);</div><div class="line">        &#125;</div><div class="line">        nodeMap.put(key, head);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteOldest</span><span class="params">()</span> </span>&#123;   <span class="comment">// 双向链表头就是freq最小的key们</span></div><div class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        Iterator it = head.keySet.iterator(); <span class="comment">// keys中靠前的就是较早插入的</span></div><div class="line">        Integer oldestKey = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (it.hasNext()) &#123;</div><div class="line">            oldestKey = (Integer)it.next();</div><div class="line">            head.keySet.remove(oldestKey);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (head.keySet.size() == <span class="number">0</span>) &#123;</div><div class="line">            deleteNode(head);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (oldestKey != <span class="keyword">null</span>) &#123;</div><div class="line">            cacheMap.remove(oldestKey);</div><div class="line">            nodeMap.remove(oldestKey);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="480-sliding-window-median"><a href="#480-sliding-window-median" class="headerlink" title="480. sliding-window-median"></a><a href="https://leetcode.com/problems/sliding-window-median/description/" target="_blank" rel="external">480. sliding-window-median</a></h4><ul>
<li>给一个数组，给一个窗口size = k，从前往后滑动窗口，求每一个范围的median。</li>
<li>用两个PriorityQueue分别维护大根堆（存的是较小的值）和小根堆（存的是较大的值），在往里存元素的时候先尝试往minHeap中存<strong>比堆顶大</strong>的值，不行就直接存入maxHeap。两个堆加起来存够k个元素之后，还需要根据两个堆的size进行调整，因为不一定刚好一半一半。匀完了之后，每次从两个堆中取最大、最小值，再根据size = k决定中位数是直接取中间还是求平均。当窗口往后挪了之后，需要从两个堆的其中一个中删除，PriorityQueue的<code>offer, poll, remove</code>是<code>O(logN)</code>的，<code>contains</code>是<code>O(N)</code>的，<code>retreive peek</code>是<code>O(1)</code>的。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">// 和前面的slidingWindowMax单调队列有点像</span></div><div class="line">    <span class="comment">// 用一个单调队列可以求一个最大值/最小值，那么用两个单调队列维护大根堆和小根堆</span></div><div class="line">    <span class="comment">// 分别取一个元素出来，看看是否需要求平均</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] medianSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        Queue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k, Collections.reverseOrder());</div><div class="line">        Queue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k);</div><div class="line">        </div><div class="line">        <span class="keyword">double</span>[] ans = <span class="keyword">new</span> <span class="keyword">double</span>[nums.length - k + <span class="number">1</span>];</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (i &gt;= k) &#123;</div><div class="line">                <span class="keyword">if</span> (minHeap.contains(nums[i - k])) &#123;</div><div class="line">                    minHeap.remove(nums[i - k]);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    maxHeap.remove(nums[i - k]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (minHeap.size() &gt; <span class="number">0</span> &amp;&amp; nums[i] &gt; minHeap.peek()) &#123;</div><div class="line">                minHeap.add(nums[i]);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                maxHeap.add(nums[i]);</div><div class="line">            &#125;</div><div class="line">            adjustHeaps(maxHeap, minHeap);</div><div class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</div><div class="line">                ans[i - (k - <span class="number">1</span>)] = getMedian(maxHeap, minHeap);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">getMedian</span><span class="params">(Queue&lt;Integer&gt; minHeap, Queue&lt;Integer&gt; maxHeap)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> minHeap.size() == maxHeap.size() ? </div><div class="line">            ((<span class="keyword">double</span>)minHeap.peek() + (<span class="keyword">double</span>)maxHeap.peek()) / <span class="number">2.0</span> : </div><div class="line">            minHeap.size() &gt; maxHeap.size() ? minHeap.peek() : maxHeap.peek();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">adjustHeaps</span><span class="params">(Queue&lt;Integer&gt; maxHeap, Queue&lt;Integer&gt; minHeap)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (Math.abs(maxHeap.size() - minHeap.size()) &gt; <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (maxHeap.size() &gt; minHeap.size()) &#123;</div><div class="line">                minHeap.add(maxHeap.poll());</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                maxHeap.add(minHeap.poll());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="496-next-greater-element-i"><a href="#496-next-greater-element-i" class="headerlink" title="496. next-greater-element-i"></a><a href="https://leetcode.com/problems/next-greater-element-i/description/" target="_blank" rel="external">496. next-greater-element-i</a></h4><ul>
<li>给两个int数组，都不含重复元素，求nums1中元素在nums2中的next greater.不存在则设为-1.</li>
<li>首先处理一波nums2，从前往后入栈，每次入栈之前需要判断是否小于栈顶，如果大于了栈顶，说明栈中元素的next greater就是当前元素，用一个map存起来（不含重复元素就可以这样搞），最后遍历nums1的时候直接从map中取就可以了。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</div><div class="line">        <span class="keyword">if</span> (nums1 == <span class="keyword">null</span> || nums2 == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums2) &#123;</div><div class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() &lt; num) &#123;</div><div class="line">                map.put(stack.pop(), num);</div><div class="line">            &#125;</div><div class="line">            stack.push(num);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span> [nums1.length];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</div><div class="line">            ans[i] = map.getOrDefault(nums1[i], -<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="503-next-greater-element-ii"><a href="#503-next-greater-element-ii" class="headerlink" title="503. next-greater-element-ii"></a><a href="https://leetcode.com/problems//description/" target="_blank" rel="external">503. next-greater-element-ii</a></h4><ul>
<li>给一个circular数组，求每一个元素的下一个更大的元素的索引，如果不存在则设为-1。例如<code>[1,2,1]</code>返回<code>[2,-1,2]</code>。</li>
<li>这种circular性质的，容易想到直接拼接一段重复的元素到后方，转换成普通数组找后续更大值，时间O(N^2)。此外还能利用stack存放索引，首先从后往前把所有元素都丢进去，然后i还是从后往前遍历原数组并与栈顶索引对应的元素比较，直到小于栈顶时才将栈顶存入结果数组。此时还需要将当前索引push到栈中，因为循环的下一步是往前一个，所以需要将当前的元素存入stack作为最接近的next candidate.<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span> [nums.length];</div><div class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;    <span class="comment">// 从后往前将索引入栈</span></div><div class="line">            stack.push(nums[i]);</div><div class="line">            ans[i] = -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;    <span class="comment">// 从后往前找greater</span></div><div class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[i] &gt;= stack.peek()) &#123;</div><div class="line">                stack.pop();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (!stack.isEmpty()) &#123;</div><div class="line">                ans[i] = stack.peek();</div><div class="line">            &#125;</div><div class="line">            stack.push(nums[i]);  <span class="comment">// 因为下一个要遍历i - 1，所以就直接把i给入栈</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="515-find-largest-value-in-each-tree-row"><a href="#515-find-largest-value-in-each-tree-row" class="headerlink" title="515. find-largest-value-in-each-tree-row"></a><a href="https://leetcode.com/problems/find-largest-value-in-each-tree-row/description/" target="_blank" rel="external">515. find-largest-value-in-each-tree-row</a></h4><ul>
<li>给一个树，返回它每一个level节点的最大值。</li>
<li>层级遍历嘛。DFS和BFS。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    List&lt;Integer&gt; levelMax;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">largestValues</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        levelMax = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        dfsLevelMax(root, <span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> levelMax;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfsLevelMax</span><span class="params">(TreeNode node, <span class="keyword">int</span> level)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        updateLevelMax(node.val, level);</div><div class="line">        dfsLevelMax(node.left, level + <span class="number">1</span>);</div><div class="line">        dfsLevelMax(node.right, level + <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateLevelMax</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> level)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (levelMax.size() == level) &#123;</div><div class="line">            levelMax.add(val);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            levelMax.set(level, Math.max(val, levelMax.get(level)));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="516-longest-palindromic-subsequence"><a href="#516-longest-palindromic-subsequence" class="headerlink" title="516. longest-palindromic-subsequence"></a><a href="https://leetcode.com/problems/longest-palindromic-subsequence/description/" target="_blank" rel="external">516. longest-palindromic-subsequence</a></h4><ul>
<li>给一个字符串，求其中最长的自对称的subsequence（顺序与原字符串一样但不一定是连续的）的长度。例如<code>bbbab</code>最长为4（<code>bbbb</code>）。</li>
<li>DP。和647一样也是从后往前更新DP数组，<code>dp[i][j]</code>表示从i到j（inclusive）的最长长度。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">char</span>[] sChar = s.toCharArray();</div><div class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span> [sChar.length][sChar.length];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = sChar.length - <span class="number">1</span>; row &gt;= <span class="number">0</span>; row--) &#123;     <span class="comment">// 从最后一个字符往前更新</span></div><div class="line">            dp[row][row] = <span class="number">1</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = row + <span class="number">1</span>; col &lt; sChar.length; col++) &#123;</div><div class="line">                <span class="keyword">if</span> (sChar[row] == sChar[col]) &#123;</div><div class="line">                    dp[row][col] = <span class="number">2</span> + dp[row + <span class="number">1</span>][col - <span class="number">1</span>];    <span class="comment">// 取中间夹的部分的最长长度加上头尾两个</span></div><div class="line">                    <span class="comment">// compare prev or adding curr palindrome. no worry about exceeding boundary</span></div><div class="line">                &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 不取当前字符</span></div><div class="line">                    dp[row][col] = Math.max(dp[row][col - <span class="number">1</span>], dp[row + <span class="number">1</span>][col]);    <span class="comment">// keep at previous one</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][sChar.length - <span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="529-minesweeper"><a href="#529-minesweeper" class="headerlink" title="529. minesweeper"></a><a href="https://leetcode.com/problems/minesweeper/description/" target="_blank" rel="external">529. minesweeper</a></h4><ul>
<li>点击一个位置，根据是否有雷更新棋盘。如果是雷，直接改成叉叉并返回；如果没有点开并且周围八个相邻格子有雷，则改成雷的数目并返回；如果周围都没有雷，就扩散到相邻格子继续更新。</li>
<li><p>方法一：根据描述本身就蕴含了递归，所以自然想到DFS。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[][] updateBoard(<span class="keyword">char</span>[][] board, <span class="keyword">int</span>[] click) &#123;</div><div class="line">        <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span></div><div class="line">           || click == <span class="keyword">null</span> || click.length &lt; <span class="number">2</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">char</span> [<span class="number">0</span>][<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> rowCount = board.length, colCount = board[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">int</span> row = click[<span class="number">0</span>], col = click[<span class="number">1</span>];</div><div class="line">        <span class="keyword">if</span> (board[row][col] == <span class="string">'B'</span>) &#123;   <span class="comment">// 已经点开了就直接返回</span></div><div class="line">            <span class="keyword">return</span> board;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (board[row][col] == <span class="string">'M'</span>) &#123;   <span class="comment">// 是雷就gg</span></div><div class="line">            board[row][col] = <span class="string">'X'</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;              <span class="comment">// 计算雷的个数</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = -<span class="number">1</span>; i &lt; <span class="number">2</span>; i++) &#123;</div><div class="line">                <span class="keyword">int</span> tempRow = row + i;</div><div class="line">                <span class="keyword">if</span> (tempRow &lt; <span class="number">0</span> || tempRow &gt;= rowCount) &#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = -<span class="number">1</span>; j &lt; <span class="number">2</span>; j++) &#123;</div><div class="line">                    <span class="keyword">int</span> tempCol = col + j;</div><div class="line">                    <span class="keyword">if</span> (tempCol &lt; <span class="number">0</span> || tempCol &gt;= colCount) &#123;</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (board[tempRow][tempCol] == <span class="string">'M'</span>) &#123;</div><div class="line">                        count++;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</div><div class="line">                board[row][col] = (<span class="keyword">char</span>)(<span class="string">'0'</span> + count);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                board[row][col] = <span class="string">'B'</span>;      <span class="comment">// 改为已经reveal，并扩散到周围unreveal的邻居</span></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = -<span class="number">1</span>; i &lt; <span class="number">2</span>; i++) &#123;</div><div class="line">                    <span class="keyword">int</span> tempRow = row + i;</div><div class="line">                    <span class="keyword">if</span> (tempRow &lt; <span class="number">0</span> || tempRow &gt;= rowCount) &#123;</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = -<span class="number">1</span>; j &lt; <span class="number">2</span>; j++) &#123;</div><div class="line">                        <span class="keyword">int</span> tempCol = col + j;</div><div class="line">                        <span class="keyword">if</span> (tempCol &lt; <span class="number">0</span> || tempCol &gt;= colCount) &#123;</div><div class="line">                            <span class="keyword">continue</span>;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">if</span> (board[tempRow][tempCol] == <span class="string">'E'</span>) &#123;   <span class="comment">// DFS the unrevealed</span></div><div class="line">                            updateBoard(board, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;tempRow, tempCol&#125;);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> board;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法二：BFS，Queue中存放点击之后扩散的点（如果有的话），一直扩散直到Queue为空。但是和DFS需要区别的是，由于BFS会将相邻的所有E的格子都入队，很可能会出现重复，所以就直接在更新时就赋值为B，防止重复入队。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[][] updateBoard(<span class="keyword">char</span>[][] board, <span class="keyword">int</span>[] click) &#123;</div><div class="line">        <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span></div><div class="line">           || click == <span class="keyword">null</span> || click.length &lt; <span class="number">2</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">char</span> [<span class="number">0</span>][<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> rowCount = board.length, colCount = board[<span class="number">0</span>].length;</div><div class="line">        q.add(click);</div><div class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</div><div class="line">            <span class="keyword">int</span>[] curr = q.poll();</div><div class="line">            <span class="keyword">int</span> row = curr[<span class="number">0</span>], col = curr[<span class="number">1</span>];   <span class="comment">// 和DFS相比少了判断为B的步骤</span></div><div class="line">            <span class="keyword">if</span> (board[row][col] == <span class="string">'M'</span>) &#123;</div><div class="line">                board[row][col] = <span class="string">'X'</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = -<span class="number">1</span>; i &lt; <span class="number">2</span>; i++) &#123;</div><div class="line">                    <span class="keyword">int</span> tempRow = row + i;</div><div class="line">                    <span class="keyword">if</span> (tempRow &lt; <span class="number">0</span> || tempRow &gt;= rowCount) &#123;</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = -<span class="number">1</span>; j &lt; <span class="number">2</span>; j++) &#123;</div><div class="line">                        <span class="keyword">int</span> tempCol = col + j;</div><div class="line">                        <span class="keyword">if</span> (tempCol &lt; <span class="number">0</span> || tempCol &gt;= colCount) &#123;</div><div class="line">                            <span class="keyword">continue</span>;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">if</span> (board[tempRow][tempCol] == <span class="string">'M'</span>) &#123;</div><div class="line">                            count++;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</div><div class="line">                    board[row][col] = (<span class="keyword">char</span>)(<span class="string">'0'</span> + count);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    board[row][col] = <span class="string">'B'</span>;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = -<span class="number">1</span>; i &lt; <span class="number">2</span>; i++) &#123;</div><div class="line">                        <span class="keyword">int</span> tempRow = row + i;</div><div class="line">                        <span class="keyword">if</span> (tempRow &lt; <span class="number">0</span> || tempRow &gt;= rowCount) &#123;</div><div class="line">                            <span class="keyword">continue</span>;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = -<span class="number">1</span>; j &lt; <span class="number">2</span>; j++) &#123;</div><div class="line">                            <span class="keyword">int</span> tempCol = col + j;</div><div class="line">                            <span class="keyword">if</span> (tempCol &lt; <span class="number">0</span> || tempCol &gt;= colCount) &#123;</div><div class="line">                                <span class="keyword">continue</span>;</div><div class="line">                            &#125;</div><div class="line">                            <span class="keyword">if</span> (board[tempRow][tempCol] == <span class="string">'E'</span>) &#123;   <span class="comment">// BFS the unrevealed</span></div><div class="line">                                q.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;tempRow, tempCol&#125;);</div><div class="line">                                board[tempRow][tempCol] = <span class="string">'B'</span>;  <span class="comment">// IMPORTANT!!!</span></div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> board;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="543-diameter-of-binary-tree"><a href="#543-diameter-of-binary-tree" class="headerlink" title="543. diameter-of-binary-tree"></a><a href="https://leetcode.com/problems/diameter-of-binary-tree/description/" target="_blank" rel="external">543. diameter-of-binary-tree</a></h4><ul>
<li>Zillow面试题刻骨铭心。给一个二叉树，求其中任意两个节点的path距离中最长长度。例如下面的树就有<code>4-2-1-3</code>和<code>5-2-1-3</code>两个最长路径，都是3.</li>
<li>对于当前节点有取和不取两种情况（但），取根则等于左深度加右深度，不取则在往下求深度的时候就可以顺便用一个全局变量去更新，时间复杂度就为O(N)了。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        getMaxDepth(root);</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMaxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> left = getMaxDepth(root.left);</div><div class="line">        <span class="keyword">int</span> right = getMaxDepth(root.right);</div><div class="line">        </div><div class="line">        max = Math.max(max, left + right);  <span class="comment">// 取根的情况</span></div><div class="line">        <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;   <span class="comment">// 求深度</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="556-next-greater-element-iii"><a href="#556-next-greater-element-iii" class="headerlink" title="556. next-greater-element-iii"></a><a href="https://leetcode.com/problems/next-greater-element-iii/description/" target="_blank" rel="external">556. next-greater-element-iii</a></h4><ul>
<li>给一个32bit的正整数，求十进制中相同数字组成的下一个更大值。例如<code>12</code>的下一个就是<code>21</code>，<code>1342</code>则是<code>1423</code>。</li>
<li>若已经是最大的可能值？（返回-1）</li>
<li>对输入的数字从后往前遍历，找到连续的两个数字使得前面的（<code>i - 1</code>）小于后面的（<code>i</code>），然后再从<code>i + 1</code>开始往后找最小的大于<code>i - 1</code>的数字，互换他俩，最后从i开始往后从小到大排个序即可。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextGreaterElement</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        String s = String.valueOf(n);</div><div class="line">        <span class="keyword">char</span>[] sChar = s.toCharArray();</div><div class="line">        <span class="keyword">int</span> i = sChar.length - <span class="number">1</span>;   <span class="comment">// 从后往前</span></div><div class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (sChar[i - <span class="number">1</span>] &lt; sChar[i]) &#123;      <span class="comment">// 找到第一个连续的顺序对</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            i--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;       <span class="comment">// 到最后都没找到</span></div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> j = i + <span class="number">1</span>, minIndex = i;</div><div class="line">        <span class="keyword">char</span> first = sChar[i - <span class="number">1</span>];</div><div class="line">        <span class="keyword">while</span> (j &lt; sChar.length) &#123;      <span class="comment">// 从i + 1开始从前往后不断更新最小的大于i - 1的元素</span></div><div class="line">            <span class="keyword">if</span> (sChar[j] &lt;= sChar[minIndex] &amp;&amp; sChar[j] &gt; first) &#123;</div><div class="line">                minIndex = j;</div><div class="line">            &#125;</div><div class="line">            j++;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        sChar[i - <span class="number">1</span>] = sChar[minIndex];     <span class="comment">// 交换该ceiling值和i - 1</span></div><div class="line">        sChar[minIndex] = first;</div><div class="line">        </div><div class="line">        Arrays.sort(sChar, i, sChar.length);    <span class="comment">// 从i开始拍个序</span></div><div class="line">        <span class="keyword">long</span> ans = Long.valueOf(<span class="keyword">new</span> String(sChar));</div><div class="line">        <span class="keyword">return</span> ans &gt; Integer.MAX_VALUE? -<span class="number">1</span>: (<span class="keyword">int</span>)ans;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="562-longest-line-of-consecutive-one-in-matrix"><a href="#562-longest-line-of-consecutive-one-in-matrix" class="headerlink" title="562. longest-line-of-consecutive-one-in-matrix"></a><a href="https://leetcode.com/problems/longest-line-of-consecutive-one-in-matrix/description/" target="_blank" rel="external">562. longest-line-of-consecutive-one-in-matrix</a></h4><ul>
<li>给一个只含有0和1的二维数组，求横、竖、两个斜对角的连续出现1的最长长度。</li>
<li><p>方法一：O(N^2)从每个点出发往四个方向分别遍历，求最长长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">// O(N^3)：矩阵遍历每个点是N^2，对每个点在扫四个方向是4N</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestLine</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (M == <span class="keyword">null</span> || M.length == <span class="number">0</span> || M[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M.length; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M[<span class="number">0</span>].length; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (M[i][j] == <span class="number">1</span>) &#123;</div><div class="line">                    longest = Math.max(longest, getLongest(M, i, j));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> longest;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 右、下、右下、左下</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">int</span>[][] directions = <span class="keyword">new</span> <span class="keyword">int</span>[][] &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, -<span class="number">1</span>&#125;&#125;; </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getLongest</span><span class="params">(<span class="keyword">int</span>[][] M, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] direction: directions) &#123;</div><div class="line">            <span class="keyword">int</span> len = <span class="number">1</span>;</div><div class="line">            <span class="keyword">int</span> newRow = row + direction[<span class="number">0</span>];</div><div class="line">            <span class="keyword">int</span> newCol = col + direction[<span class="number">1</span>];</div><div class="line">            <span class="comment">// 持续在一个方向上继续走</span></div><div class="line">            <span class="keyword">while</span> (isValidPosition(M, newRow, newCol) &amp;&amp; M[newRow][newCol] == <span class="number">1</span>) &#123;</div><div class="line">                len++;</div><div class="line">                newRow += direction[<span class="number">0</span>];</div><div class="line">                newCol += direction[<span class="number">1</span>];</div><div class="line">            &#125;</div><div class="line">            maxLen = Math.max(maxLen, len);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxLen;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidPosition</span><span class="params">(<span class="keyword">int</span>[][] M, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> row &gt;= <span class="number">0</span> &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp;</div><div class="line">            row &lt; M.length &amp;&amp; col &lt; M[<span class="number">0</span>].length;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法二：类似于DP，记录下四个方向各自的最大长度。参考<a href="https://discuss.leetcode.com/topic/87389/simple-and-concise-java-solution-easy-to-understand-o-m-n-space" target="_blank" rel="external">这个</a>被lz<br>和<a href="https://leetcode.com/problems/n-queens-ii/descrciption/" target="_blank" rel="external">N皇后问题</a>很像。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">// O(N^2)时间，O(M+N)空间</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestLine</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</div><div class="line">        <span class="comment">// validation</span></div><div class="line">        <span class="keyword">if</span> (M == <span class="keyword">null</span> || M.length == <span class="number">0</span> || M[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> rows = M.length, cols = M[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span>[] bucketCol = <span class="keyword">new</span> <span class="keyword">int</span> [cols];</div><div class="line">        <span class="keyword">int</span>[] bucketDiag1 = <span class="keyword">new</span> <span class="keyword">int</span> [rows + cols];</div><div class="line">        <span class="keyword">int</span>[] bucketDiag2 = <span class="keyword">new</span> <span class="keyword">int</span> [rows + cols];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</div><div class="line">            <span class="keyword">int</span> row = <span class="number">0</span>;                <span class="comment">// 新行初始化为0</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (M[i][j] == <span class="number">1</span>) &#123;     <span class="comment">// 当前为1，对应更新bucket</span></div><div class="line">                    row++;</div><div class="line">                    bucketCol[j]++;</div><div class="line">                    bucketDiag1[j + i]++;</div><div class="line">                    bucketDiag2[j - i + M.length]++;</div><div class="line">                    longest = Math.max(longest, row);</div><div class="line">                    longest = Math.max(longest, bucketCol[j]);</div><div class="line">                    longest = Math.max(longest, bucketDiag1[j + i]);</div><div class="line">                    longest = Math.max(longest, bucketDiag2[j - i + M.length]);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    row = <span class="number">0</span>;</div><div class="line">                    bucketCol[j] = <span class="number">0</span>;</div><div class="line">                    bucketDiag1[j + i] = <span class="number">0</span>;</div><div class="line">                    bucketDiag2[j - i + M.length] = <span class="number">0</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> longest;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="567-permutation-in-string"><a href="#567-permutation-in-string" class="headerlink" title="567. permutation-in-string"></a><a href="https://leetcode.com/problems/permutation-in-string/description/" target="_blank" rel="external">567. permutation-in-string</a></h4><ul>
<li>给两个字符串，判断s1的permutation是否包含在s2中，例如<code>s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;</code>返回true，因为s2包含了<code>ba</code>。</li>
<li>其实这个s1的permutation并不用真的一个个求出来，在意的只是s1的每个字符及其出现次数，因此用一个map O(N)扫一波就好了。然后就对s2进行双指针 + producer/consumer操作，如果消耗完map中所有字符的时候恰好前后指针间距等于s1的长度，说明就是permutation的一种了，返回true。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (s1 == <span class="keyword">null</span> || s2 == <span class="keyword">null</span> || s1.length() == <span class="number">0</span> || s2.length() == <span class="number">0</span> ) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">char</span>[] s1Char = s1.toCharArray();</div><div class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> len1 = s1Char.length;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++) &#123;    <span class="comment">// 统计s1中每个字母出现个数，作为producer</span></div><div class="line">            map.put(s1Char[i], map.getOrDefault(s1Char[i], <span class="number">0</span>) + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">char</span>[] s2Char = s2.toCharArray();</div><div class="line">        <span class="keyword">int</span> count = map.size();</div><div class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (right &lt; s2Char.length) &#123;     <span class="comment">// 遍历s2作为consumer消耗字符，直到map中所有字符消耗完</span></div><div class="line">            <span class="keyword">if</span> (map.containsKey(s2Char[right])) &#123;</div><div class="line">                map.put(s2Char[right], map.get(s2Char[right]) - <span class="number">1</span>);</div><div class="line">                <span class="keyword">if</span> (map.get(s2Char[right]) == <span class="number">0</span>) &#123;</div><div class="line">                    count--;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;            <span class="comment">// 左指针补回来，直到map中出现available的字符</span></div><div class="line">                <span class="keyword">if</span> (right - left + <span class="number">1</span> == len1) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (map.containsKey(s2Char[left])) &#123;</div><div class="line">                    map.put(s2Char[left], map.get(s2Char[left]) + <span class="number">1</span>);</div><div class="line">                    <span class="keyword">if</span> (map.get(s2Char[left]) &gt; <span class="number">0</span>) &#123;</div><div class="line">                        count++;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                left++;</div><div class="line">            &#125;</div><div class="line">            right++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="598-range-addition-ii"><a href="#598-range-addition-ii" class="headerlink" title="598. range-addition-ii"></a><a href="https://leetcode.com/problems/range-addition-ii/description/" target="_blank" rel="external">598. range-addition-ii</a></h4><ul>
<li>给一个二维数组的规模m和n，初始值为0，再给一个ops二维数组，每个op表示前x行和前y列都加1.求最终最大值的个数。例如<code>m = 3, n = 3, operations = [[2,2],[3,3]]</code>，那么就是先给左上方<code>2*2</code>加1，再给<code>3*3</code>加1，最后就有4个最大值（2）。</li>
<li>直接找行和列的最小值，相乘即可。m和n甚至都没啥用。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">// 直接找最小的行和列数，相乘即得</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span>[][] ops)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (ops == <span class="keyword">null</span> || ops.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> m * n;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> rowMin = Integer.MAX_VALUE, colMin = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] op : ops) &#123;</div><div class="line">            rowMin = Math.min(op[<span class="number">0</span>], rowMin);</div><div class="line">            colMin = Math.min(op[<span class="number">1</span>], colMin);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> rowMin * colMin;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="600-non-negative-integers-without-consecutive-ones"><a href="#600-non-negative-integers-without-consecutive-ones" class="headerlink" title="600. non-negative-integers-without-consecutive-ones"></a><a href="https://leetcode.com/problems/non-negative-integers-without-consecutive-ones/description/" target="_blank" rel="external">600. non-negative-integers-without-consecutive-ones</a></h4><ul>
<li>给一个正数num，求[0, num]之间的bitString不含连续1的数字的个数。</li>
<li><p>方法一：DP。对于bitString有两种可能，以1结尾或以0结尾。为了不出现连续的1，对于0结尾的数字可以拼上0或1，而对于1结尾的数字就只能拼上0.<a href="https://www.geeksforgeeks.org/count-number-binary-strings-without-consecutive-1s/" target="_blank" rel="external">Geeks4Geeks</a>上面给的是bitString的长度，这里也可以用类似的方法。不过由于这里num的存在可能需要砍掉一部分结果，因此在最后需要多一步判断。如果num中出现了连续的<code>xx00xxx</code>（注意是从右往左遍历），而如果没有这个限制<code>xx10xxx, xx01xxx</code>等都可能算进去，因此需要减去前一个0到最前面的数字位数所保存的endWithOne的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">// 对于一个二进制数字，最后一位可能为1也可能为0.后者可以append数字0或1，而前者只能append数字0了。牵涉到DP了。</span></div><div class="line">    <span class="comment">// end0表示不含连续1的、bit长度为i + 1的、以0结尾的数字个数，end1表示不含连续1的、bit长度为i + 1的、以1结尾的数字的个数</span></div><div class="line">    <span class="comment">// 初始状态为end0[0] = 1, end1[0] = 1.</span></div><div class="line">    <span class="comment">// end0只在最后拼0，因此上一步来自0或1都可以；而end1只拼1，因此上一步只能来自0.</span></div><div class="line">    <span class="comment">// 状态转换为end0[i] = end0[i - 1] + end1[i - 1], end1[i] = end0[i - 1]</span></div><div class="line">    <span class="comment">// 但这是根据bitString长度来的，而题目给的是num，因此最后还需要过滤看看有没有多算</span></div><div class="line">    <span class="comment">// 如果在i, i+1处出现连续的0，说明i往前的部分就多算了，因此根据0～i-1的长度找endWithOne减掉即可。</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findIntegers</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(Integer.toBinaryString(num));</div><div class="line">        <span class="keyword">int</span> n = sb.length();</div><div class="line">        </div><div class="line">        <span class="keyword">int</span>[] endWithZero = <span class="keyword">new</span> <span class="keyword">int</span> [n];</div><div class="line">        <span class="keyword">int</span>[] endWithOne = <span class="keyword">new</span> <span class="keyword">int</span> [n];</div><div class="line">        endWithZero[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">        endWithOne[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</div><div class="line">            endWithZero[i] = endWithZero[i - <span class="number">1</span>] + endWithOne[i - <span class="number">1</span>];</div><div class="line">            endWithOne[i] = endWithZero[i - <span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> count = endWithZero[n - <span class="number">1</span>] + endWithOne[n - <span class="number">1</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (sb.charAt(i) == <span class="string">'1'</span> &amp;&amp; sb.charAt(i - <span class="number">1</span>) == <span class="string">'1'</span>) &#123;   <span class="comment">// x11xx说明已经是最大了，后面都不可能多算了</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sb.charAt(i) == <span class="string">'0'</span> &amp;&amp; sb.charAt(i - <span class="number">1</span>) == <span class="string">'0'</span>) &#123;    <span class="comment">// x00xx说明前一个0处不应该含有endWithOne</span></div><div class="line">                count -= endWithOne[n - <span class="number">1</span> - i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法二：constant space的DP。</p>
</li>
</ul>
<h4 id="604-design-compressed-string-iterator"><a href="#604-design-compressed-string-iterator" class="headerlink" title="604. design-compressed-string-iterator"></a><a href="https://leetcode.com/problems/design-compressed-string-iterator/description/" target="_blank" rel="external">604. design-compressed-string-iterator</a></h4><ul>
<li>给一个字符加数字组成的字符串，实现next、hasNext函数遍历这个字符串。例如<code>L20J3B8</code>这样。</li>
<li>一开始直接根据频数全部存入queue，后来发现如果某个数频数特别大，而实际用不到那么多项就很不划算。因此就自定义类来搞了。写出来是<a href="https://leetcode.com/submissions/detail/135742635/" target="_blank" rel="external">这样</a>.</li>
</ul>
<h4 id="605-can-place-flowers"><a href="#605-can-place-flowers" class="headerlink" title="605. can-place-flowers"></a><a href="https://leetcode.com/problems/can-place-flowers/description/" target="_blank" rel="external">605. can-place-flowers</a></h4><ul>
<li>给一个只含有0和1的数组，1表示该处被种了花，0表示可以种，同时相邻的位置不能同时种花。给一个花数n，判断能否种到所给的花池中。</li>
<li><p>方法一：想到了greedy的方法，每次判断0前后是否都为0，可以就直接设为1.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPlaceFlowers</span><span class="params">(<span class="keyword">int</span>[] flowerbed, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (flowerbed == <span class="keyword">null</span> || flowerbed.length == <span class="number">0</span> || n == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; flowerbed.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (flowerbed[i] == <span class="number">0</span></div><div class="line">                &amp;&amp; (i == flowerbed.length - <span class="number">1</span> || flowerbed[i + <span class="number">1</span>] != <span class="number">1</span>)     <span class="comment">// 后一个为0</span></div><div class="line">                &amp;&amp; (i == <span class="number">0</span> || flowerbed[i - <span class="number">1</span>] != <span class="number">1</span>)) &#123;                     <span class="comment">// 前一个为0</span></div><div class="line">                flowerbed[i] = <span class="number">1</span>;</div><div class="line">                <span class="keyword">if</span> (--n == <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法二：计算0的个数，碰到1就计算前面最多可以放多少0，同时重置计数。注意初始化count = 1，比如<code>0 0 1</code>在碰到1的时候需要保证slot为1，如果count初始化为0就无法得到了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPlaceFlowers</span><span class="params">(<span class="keyword">int</span>[] flowerbed, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (flowerbed == <span class="keyword">null</span> || flowerbed.length == <span class="number">0</span> || n == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">1</span>, slot = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; flowerbed.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (flowerbed[i] == <span class="number">0</span>) &#123;</div><div class="line">                count++;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                slot += (count - <span class="number">1</span>) / <span class="number">2</span>;</div><div class="line">                count = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        slot += count / <span class="number">2</span>;</div><div class="line">        <span class="keyword">return</span> slot &gt;= n;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="606-construct-string-from-binary-tree"><a href="#606-construct-string-from-binary-tree" class="headerlink" title="606. construct-string-from-binary-tree"></a><a href="https://leetcode.com/problems/construct-string-from-binary-tree/description/" target="_blank" rel="external">606. construct-string-from-binary-tree</a></h4><ul>
<li>给一个二叉树，encode成括号分割的字符串。</li>
<li>递归拼接。注意左子树和右子树为空时加不加括号需要加判断。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">tree2str</span><span class="params">(TreeNode t)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">        &#125;</div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">        sb.append(t.val);</div><div class="line">        String left = tree2str(t.left);</div><div class="line">        String right = tree2str(t.right);</div><div class="line">        <span class="keyword">if</span> (left.length() &gt; <span class="number">0</span> || right.length() &gt; <span class="number">0</span>) &#123;</div><div class="line">            sb.append(<span class="string">"("</span>);</div><div class="line">            sb.append(left);</div><div class="line">            sb.append(<span class="string">")"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (right.length() &gt; <span class="number">0</span>) &#123;</div><div class="line">            sb.append(<span class="string">"("</span>);</div><div class="line">            sb.append(right);</div><div class="line">            sb.append(<span class="string">")"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sb.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="609-find-duplicate-file-in-system"><a href="#609-find-duplicate-file-in-system" class="headerlink" title="609. find-duplicate-file-in-system"></a><a href="https://leetcode.com/problems/find-duplicate-file-in-system/description/" target="_blank" rel="external">609. find-duplicate-file-in-system</a></h4><ul>
<li>给一个字符串数组，每个字符串中表示某路径下的所有文件以及内容，求相同文件内容的文件路径并存入List。比较有意思的是follow-up，解答参考<a href="https://discuss.leetcode.com/topic/91430/c-clean-solution-answers-to-follow-up" target="_blank" rel="external">这里</a>：在真实的文件系统中你会选择BFS还是DFS?(BFS。虽然会消耗更多空间，但是可以利用locality提速)如果每个文件内容非常巨大怎么办？（不直接hash文件内容，而是首先根据文件大小判断是否是同一个文件，然后再取文件其中一部分进行hash）</li>
<li>直接以内容为key、路径&amp;文件名为value存入map。最坏时间复杂度是O(N^2 * k)，N是文件个数，k是文件大小。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findDuplicate(String[] paths) &#123;</div><div class="line">        List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">if</span> (paths == <span class="keyword">null</span> || paths.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> ans;</div><div class="line">        &#125;</div><div class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();    <span class="comment">// 以文件内容为key、路径+文件名为value</span></div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (String path : paths) &#123;</div><div class="line">            String[] arr = path.split(<span class="string">"\\s+"</span>);      <span class="comment">// 不可以直接用空格，要正则表达式!!!!!!</span></div><div class="line">            String dir = arr[<span class="number">0</span>];</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</div><div class="line">                <span class="keyword">int</span> start = arr[i].indexOf(<span class="string">"("</span>);</div><div class="line">                String file = arr[i].substring(<span class="number">0</span>, start);</div><div class="line">                String content = arr[i].substring(start, arr[i].length() - <span class="number">1</span>);</div><div class="line">                List&lt;String&gt; temp = map.get(content);</div><div class="line">                <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</div><div class="line">                    temp = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">                &#125;</div><div class="line">                temp.add(dir + <span class="string">"/"</span> + file);</div><div class="line">                map.put(content, temp);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (String content : map.keySet()) &#123;</div><div class="line">            List&lt;String&gt; temp = map.get(content);</div><div class="line">            <span class="keyword">if</span> (temp.size() &gt; <span class="number">1</span>) &#123;</div><div class="line">                ans.add(temp);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="611-valid-triangle-number"><a href="#611-valid-triangle-number" class="headerlink" title="611. valid-triangle-number"></a><a href="https://leetcode.com/problems/cvalid-triangle-number/description/" target="_blank" rel="external">611. valid-triangle-number</a></h4><ul>
<li>给一个int数组表示边长，问这些边可以组成多少个三角形。（这些边可能重复，但是算作不同的边）</li>
<li>三角形任意两边之和大于第三边，这个任意其实指的是起码较小的两边之和大于最大边。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">// 两边之和大于第三边，那么每次都取最小都两个边相加大于最大边即可</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">triangleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        Arrays.sort(nums);  <span class="comment">// 排序</span></div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">2</span>; i--) &#123;</div><div class="line">            <span class="keyword">int</span> left = <span class="number">0</span>, right = i - <span class="number">1</span>;    <span class="comment">// 双指针取比当前指针小的两条边</span></div><div class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</div><div class="line">                <span class="keyword">if</span> (nums[left] + nums[right] &gt; nums[i]) &#123;</div><div class="line">                    count += (right - left);    <span class="comment">// 相当于固定right取left开始的边</span></div><div class="line">                    right --;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    left ++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="632-smallest-range"><a href="#632-smallest-range" class="headerlink" title="632. smallest-range"></a><a href="https://leetcode.com/problems/smallest-range/description/" target="_blank" rel="external">632. smallest-range</a></h4><ul>
<li>给一个<code>List&lt;List&lt;Integer&gt;&gt;</code>，每行List内部是排好序的，求一个区间使其包括每一行的某个元素。例如<code>[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]</code>，返回<code>[20,24]</code>.</li>
<li>类似于merge k sorted list，自定义一个Node类存放值、所属的行数、所处的列数信息，每次从每个List中取值存入PriorityQueue，然后每次从pq中poll掉元素的下一个作为新的元素存入pq。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123; </div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        <span class="keyword">int</span> row;</div><div class="line">        <span class="keyword">int</span> index;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> row, <span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.val = val;</div><div class="line">            <span class="keyword">this</span>.row = row;</div><div class="line">            <span class="keyword">this</span>.index = index;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] smallestRange(List&lt;List&lt;Integer&gt;&gt; nums) &#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.size() == <span class="number">0</span> || nums.get(<span class="number">0</span>).size() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span> [] &#123;<span class="number">0</span>, Integer.MAX_VALUE&#125;;  <span class="comment">// warning: need to be max at first</span></div><div class="line">        <span class="keyword">int</span> k = nums.size();</div><div class="line">        PriorityQueue&lt;Node&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; a.val - b.val);</div><div class="line">        <span class="comment">// new PriorityQueue&lt;Node&gt;(new Comparator() &#123;</span></div><div class="line">        <span class="comment">// public int compare(Node a, Node b) &#123;</span></div><div class="line">        <span class="comment">//     return a.val - b.val;</span></div><div class="line">        <span class="comment">// &#125;</span></div><div class="line">        <span class="comment">// &#125;);</span></div><div class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</div><div class="line">            <span class="keyword">int</span> currVal = nums.get(i).get(<span class="number">0</span>);</div><div class="line">            max = Math.max(max, currVal);</div><div class="line">            pq.offer(<span class="keyword">new</span> Node(currVal, i, <span class="number">0</span>));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (pq.size() == nums.size()) &#123; <span class="comment">// 已经没有新的元素了加进来说明能跨所有行的间距已经遍历完成</span></div><div class="line">            Node node = pq.poll();</div><div class="line">            <span class="keyword">if</span> (max - node.val &lt; ans[<span class="number">1</span>] - ans[<span class="number">0</span>]) &#123;     <span class="comment">// 发现间距更小的window就更新</span></div><div class="line">                ans[<span class="number">1</span>] = max;</div><div class="line">                ans[<span class="number">0</span>] = node.val;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (node.index + <span class="number">1</span> &lt; nums.get(node.row).size()) &#123;</div><div class="line">                Node nextNode = <span class="keyword">new</span> Node(nums.get(node.row).get(node.index + <span class="number">1</span>), node.row, node.index + <span class="number">1</span>);</div><div class="line">                <span class="keyword">if</span> (nextNode.val &gt; max) &#123;</div><div class="line">                    max = nextNode.val;</div><div class="line">                &#125;</div><div class="line">                pq.offer(nextNode);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="637-average-of-levels-in-binary-tree"><a href="#637-average-of-levels-in-binary-tree" class="headerlink" title="637. average-of-levels-in-binary-tree"></a><a href="https://leetcode.com/problems/average-of-levels-in-binary-tree/description/" target="_blank" rel="external">637. average-of-levels-in-binary-tree</a></h4><ul>
<li>给一个二叉树，求每一层的平均数。</li>
<li>还是层级遍历的变形，主要是防止求平均值的时候越界，用了double，这样求平均值的时候也方便很多。写出来是<a href="https://leetcode.com/submissions/detail/136075057/" target="_blank" rel="external">这样</a>。</li>
</ul>
<h4 id="646-maximum-length-of-pair-chain"><a href="#646-maximum-length-of-pair-chain" class="headerlink" title="646. maximum-length-of-pair-chain"></a><a href="https://leetcode.com/problems/maximum-length-of-pair-chain/description/" target="_blank" rel="external">646. maximum-length-of-pair-chain</a></h4><ul>
<li>给一个pair的数组，每个pair可以作为chain的节点。节点<code>[c, d]</code>能够连到<code>[a, b]</code>后面的条件是<code>b &lt; c</code>。求最长的链长度。</li>
<li>DP。<code>len[i]</code>表示以pair[i]结尾的链的长度，那么在双重循环时，就需要找到pairs[j]使得<code>pairs[j][1] &lt; pairs[i][0]</code>。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLongestChain</span><span class="params">(<span class="keyword">int</span>[][] pairs)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (pairs == <span class="keyword">null</span> || pairs.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        Arrays.sort(pairs, (a, b) -&gt; &#123;</div><div class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">int</span>[] len = <span class="keyword">new</span> <span class="keyword">int</span> [pairs.length];     <span class="comment">// len[i]表示以pairs[i]结尾的链的长度</span></div><div class="line">        Arrays.fill(len, <span class="number">1</span>);</div><div class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pairs.length; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (pairs[i][<span class="number">0</span>] &gt; pairs[j][<span class="number">1</span>]) &#123;</div><div class="line">                    len[i] = Math.max(len[i], len[j] + <span class="number">1</span>);  <span class="comment">// 上一个节点为pairs[j]</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            maxLen = Math.max(maxLen, len[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxLen;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="647-palindromic-substrings"><a href="#647-palindromic-substrings" class="headerlink" title="647. palindromic-substrings"></a><a href="https://leetcode.com/problems/palindromic-substrings/description/" target="_blank" rel="external">647. palindromic-substrings</a></h4><ul>
<li>给一个字符串，求其中自对称的子串的个数。例如<code>aaa</code>就有6个，<code>aba</code>就有4个。</li>
<li>DP。<code>dp[i][j]</code>表示从第i个字符到第j个字符是否对称，当判断第<code>i</code>和第<code>j</code>个字符的时候，如果相等则需要用到<code>i + 1</code>到<code>j - 1</code>之间的结果（若也对称则当前这个也是对称的），因此需要从后往前递推更新DP数组才行。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">char</span>[] sChar = s.toCharArray();</div><div class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span> [sChar.length][sChar.length];  <span class="comment">// dp[i][j] means take substr from i to j</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = dp.length - <span class="number">1</span>; row &gt;= <span class="number">0</span>; row--) &#123;    <span class="comment">// 从最后一行开始往前</span></div><div class="line">            dp[row][row] = <span class="keyword">true</span>;    <span class="comment">// 最后一列设为true</span></div><div class="line">            count++;                <span class="comment">// 每个字符本身是自对称的</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = row + <span class="number">1</span>; col &lt; dp.length; col++) &#123;   <span class="comment">// 只更新对角线之后的元素</span></div><div class="line">                <span class="keyword">if</span> (sChar[col] == sChar[row]) &#123;</div><div class="line">                    dp[row][col] = row + <span class="number">1</span> &gt; col - <span class="number">1</span> || dp[row + <span class="number">1</span>][col - <span class="number">1</span>];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (dp[row][col]) &#123;</div><div class="line">                    count++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="652-find-duplicate-subtrees"><a href="#652-find-duplicate-subtrees" class="headerlink" title="652. find-duplicate-subtrees"></a><a href="https://leetcode.com/problems/find-duplicate-subtrees/description/" target="_blank" rel="external">652. find-duplicate-subtrees</a></h4><ul>
<li><p>给一个二叉树，返回一个包含所有duplicate的子树根节点的List。例如下面的树就有2-4和4两个duplicate的子树。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">    1</div><div class="line">   / \</div><div class="line">  2   3</div><div class="line"> /   / \</div><div class="line">4   2   4</div><div class="line">   /</div><div class="line">  4</div></pre></td></tr></table></figure>
</li>
<li><p>利用encoding tree的思路，对于每一个节点为root的树都进行一波类似前序遍历点操作，将遍历结果encode成字符串作为key、计数作为value存入map。一旦出现了两次就加入结果List。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">findDuplicateSubtrees</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        List&lt;TreeNode&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        check(root, map, ans);</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">check</span><span class="params">(TreeNode node, Map&lt;String, Integer&gt; map, List&lt;TreeNode&gt; ans)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 通过前序遍历拼接出pattern并存入map</span></div><div class="line">        String pattern = node.val + <span class="string">","</span> + check(node.left, map, ans) + <span class="string">","</span> + check(node.right, map, ans);</div><div class="line">        <span class="keyword">int</span> count = map.getOrDefault(pattern, <span class="number">0</span>) + <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (count == <span class="number">2</span>) &#123;       <span class="comment">// the second one</span></div><div class="line">            ans.add(node);</div><div class="line">        &#125;</div><div class="line">        map.put(pattern, count);</div><div class="line">        <span class="keyword">return</span> pattern;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="653-two-sum-iv-input-is-a-bst"><a href="#653-two-sum-iv-input-is-a-bst" class="headerlink" title="653. two-sum-iv-input-is-a-bst"></a><a href="https://leetcode.com/problems/two-sum-iv-input-is-a-bst/description/" target="_blank" rel="external">653. two-sum-iv-input-is-a-bst</a></h4><ul>
<li>给一个二叉搜索树和一个sum值，判断树中是否存在两个node之和等于sum。</li>
<li><p>朴素想法，对于每个可能的值进行O(logN)的搜索，因此总的时间复杂度就是O(NlogN)，而空间复杂度如果考虑递归栈的话就是O(TreeHeight)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findTarget</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> dfs(root, root, k);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(TreeNode node, TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> target = k - node.val;</div><div class="line">        <span class="keyword">if</span> (target != node.val &amp;&amp; search(root, target)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;    </div><div class="line">            <span class="keyword">return</span> dfs(node.left, root, k) || dfs(node.right, root, k);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (root.val == val) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; root.val) &#123;</div><div class="line">            <span class="keyword">return</span> search(root.left, val);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> search(root.right, val);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法二：用BST中序遍历转换成有序数组，再用双指针分别从头和尾往中间找。时间O(N)，空间O(N).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findTarget</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        inorder(root, list);</div><div class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = list.size() - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (left &lt; right) &#123;  <span class="comment">// 双指针查找有序数组中的pair</span></div><div class="line">            <span class="keyword">int</span> sum = list.get(left) + list.get(right);</div><div class="line">            <span class="keyword">if</span> (sum &lt; k) &#123;</div><div class="line">                left++;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; k) &#123;</div><div class="line">                right--;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        inorder(root.left, list);</div><div class="line">        list.add(root.val);</div><div class="line">        inorder(root.right, list);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="670-maximum-swap"><a href="#670-maximum-swap" class="headerlink" title="670. maximum-swap"></a><a href="https://leetcode.com/problems/maximum-swap/description/" target="_blank" rel="external">670. maximum-swap</a></h4><ul>
<li>给一个非负数，求至多将其中两个digit互换位置之后所能得到的最大数。例如<code>9987</code>就是本身，<code>9978</code>是<code>9987</code>，<code>958469</code>是<code>998465</code>.</li>
<li>暗中观察规律就是找其中一个小的数字并找在它右侧的最大数，交换。因此首先需要记录每个数字最后出现的位置，然后从原数字第一位开始遍历，从最大的数字开始比较，一旦找到比自己大且排在自己后面的数字就可以直接交换位置了。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumSwap</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">char</span>[] numStr = Integer.toString(num).toCharArray();</div><div class="line">        <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">10</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numStr.length; i++) &#123;</div><div class="line">            bucket[numStr[i] - <span class="string">'0'</span>] = i;    <span class="comment">// 每个数字最后出现的位置</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 找到最靠右的、比当前数字大的数字，交换位置即可</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numStr.length; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">9</span>; index &gt; numStr[i] - <span class="string">'0'</span>; index--) &#123;   <span class="comment">// 注意只跟比当前数字大的比位置</span></div><div class="line">                <span class="keyword">if</span> (bucket[index] &gt; i) &#123;    <span class="comment">// 在当前位置之后</span></div><div class="line">                    <span class="keyword">char</span> temp = numStr[bucket[index]];</div><div class="line">                    numStr[bucket[index]] = numStr[i];  </div><div class="line">                    numStr[i] = temp;</div><div class="line">                    <span class="keyword">return</span> Integer.valueOf(<span class="keyword">new</span> String(numStr));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> num;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="673-number-of-longest-increasing-subsequence"><a href="#673-number-of-longest-increasing-subsequence" class="headerlink" title="673. number-of-longest-increasing-subsequence"></a><a href="https://leetcode.com/problems/number-of-longest-increasing-subsequence/description/" target="_blank" rel="external">673. number-of-longest-increasing-subsequence</a></h4><ul>
<li>给一个数组，求其中最长递增的subsequence的个数。如<code>[1,3,5,4,7]</code>中有两个长度为4的subsequence。</li>
<li>DP。用一个len[k]数组记录以k结尾的字符处的最长长度，<code>count[k]</code>记录对应的计数。双重循环时，当<code>nums[i] &gt; nums[j]</code>，若<code>len[j] + 1 &gt; len[i]</code>则需要更新i处的长度，同时count也直接更新；若<code>len[j] + 1 == len[i]</code>，则说明刚好从j过来可以形成递增sequence，直接累加就行了（一开始以为是<a href="https://leetcode.com/problems/longest-increasing-subsequence/description/" target="_blank" rel="external">lc300求长度</a>，就用stack做了，然而stack这个greedy做法也是错误的，还是需要上DP。。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNumberOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] len = <span class="keyword">new</span> <span class="keyword">int</span> [nums.length];</div><div class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span> [nums.length];</div><div class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>, ans = <span class="number">0</span>;</div><div class="line">        Arrays.fill(len, <span class="number">1</span>);</div><div class="line">        Arrays.fill(count, <span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;        <span class="comment">// 保证递增关系</span></div><div class="line">                    <span class="keyword">int</span> tempLen = len[j] + <span class="number">1</span>;   <span class="comment">// 递增后的长度</span></div><div class="line">                    <span class="keyword">if</span> (tempLen &gt; len[i]) &#123;     </div><div class="line">                        len[i] = tempLen;</div><div class="line">                        count[i] = count[j];</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tempLen == len[i]) &#123;     <span class="comment">// 从j跳过来的递增</span></div><div class="line">                        count[i] += count[j];</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            maxLen = Math.max(len[i], maxLen);      <span class="comment">// 记录最大长度，后续用于对比并累计count</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (len[i] == maxLen) &#123;</div><div class="line">                ans += count[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="674-longest-continuous-increasing-subsequence"><a href="#674-longest-continuous-increasing-subsequence" class="headerlink" title="674. longest-continuous-increasing-subsequence"></a><a href="https://leetcode.com/problems/longest-continuous-increasing-subsequence/description/" target="_blank" rel="external">674. longest-continuous-increasing-subsequence</a></h4><ul>
<li>给一个数组，求其中最长递增的连续subarray的长度。如<code>[1,2,3,4,5,6,5,4,3,4,5]</code>就是6，<code>[2,2,2,2,2]</code>就是1.</li>
<li>贪心法，只有大于前面元素才更新，一旦小于就更新到总的里面。注意最后返回之前还要取一次max。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>, curr = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</div><div class="line">                curr++;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                ans = Math.max(ans, curr);</div><div class="line">                curr = <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> Math.max(ans, curr);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="676-implement-magic-dictionary"><a href="#676-implement-magic-dictionary" class="headerlink" title="676. implement-magic-dictionary"></a><a href="https://leetcode.com/problems/implement-magic-dictionary/description/" target="_blank" rel="external">676. implement-magic-dictionary</a></h4><ul>
<li>实现<code>buildDict</code>和<code>search</code>方法，search时判断能否通过「替换一个字符」的方式使得修改后的字符串包含在dict中，返回boolean。例如给<code>[&quot;hello&quot;, &quot;leetcode&quot;]</code>，搜索<code>hhllo</code>就返回true、搜索<code>hello</code>返回false。</li>
<li><p>方法一：dict就想到选择map，在build时对于每个字符串，将其中每个字符替换成特殊字符如<code>*</code>，将替换后的字符串作为key、被替换的字符作为value存入map。如果出现相同的key，则说明这个位置可以放任何字符（例如<code>hello, hallo</code>的第二位）；在搜索时也是对每个字符替换，然后看map中有没有，判断一下当前字符是否是value的字符（防止indentical）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MagicDictionary</span> </span>&#123;</div><div class="line">    <span class="comment">// 将每个单词的每个字符都替换成*之后，插入map，key是替换后的字符串，value是被替换掉的那个字符</span></div><div class="line">    <span class="comment">// 如果出现替换过后的key一样，则该位可以放任意字符，因为例如hello和hallo只有在第二位不同，如果替换后是h*llo可以任选一个，一定是true。</span></div><div class="line">    Map&lt;String, Character&gt; map = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">/** Initialize your data structure here. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MagicDictionary</span><span class="params">()</span> </span>&#123;</div><div class="line">        map = <span class="keyword">new</span> HashMap&lt;String, Character&gt;();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/** Build a dictionary through a list of words */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildDict</span><span class="params">(String[] dict)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (dict == <span class="keyword">null</span> || dict.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (String word : dict) &#123;</div><div class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder(word);</div><div class="line">            <span class="keyword">int</span> len = word.length();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">                sb.setCharAt(i, <span class="string">'*'</span>);</div><div class="line">                Character c = map.get(sb.toString());</div><div class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</div><div class="line">                    map.put(sb.toString(), word.charAt(i));</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    map.put(sb.toString(), <span class="string">'*'</span>);    <span class="comment">// 表示可以放任何字符</span></div><div class="line">                &#125;</div><div class="line">                sb.setCharAt(i, word.charAt(i));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (word == <span class="keyword">null</span> || word.length() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> len = word.length();</div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(word);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">            sb.setCharAt(i, <span class="string">'*'</span>);</div><div class="line">            Character c = map.get(sb.toString());</div><div class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; (c == <span class="string">'*'</span> || c != word.charAt(i))) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            sb.setCharAt(i, word.charAt(i));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法二：使用Trie。build的时候就正常地创建Trie，然后在search的时候逐个位置替换26个字符，每换一次就在Trie中搜索。Trie的效率感觉不高啊，感觉有square级别。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MagicDictionary</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</div><div class="line">        TrieNode[] children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</div><div class="line">        <span class="keyword">boolean</span> isWord;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    &#125;</div><div class="line">    TrieNode root;</div><div class="line">    <span class="comment">/** Initialize your data structure here. */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MagicDictionary</span><span class="params">()</span> </span>&#123;</div><div class="line">        root = <span class="keyword">new</span> TrieNode();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/** Build a dictionary through a list of words */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildDict</span><span class="params">(String[] dict)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (String s : dict) &#123;</div><div class="line">            TrieNode node = root;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</div><div class="line">                <span class="keyword">if</span> (node.children[c - <span class="string">'a'</span>] == <span class="keyword">null</span>) &#123;</div><div class="line">                    node.children[c - <span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</div><div class="line">                &#125;</div><div class="line">                node = node.children[c - <span class="string">'a'</span>];</div><div class="line">            &#125;</div><div class="line">            node.isWord = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</div><div class="line">        <span class="keyword">char</span>[] arr = word.toCharArray();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>; c++) &#123;</div><div class="line">                <span class="keyword">if</span> (arr[i] == c) &#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">char</span> org = arr[i];</div><div class="line">                arr[i] = c;</div><div class="line">                <span class="keyword">if</span> (checkTrie(<span class="keyword">new</span> String(arr), root)) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">                arr[i] = org;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkTrie</span><span class="params">(String s, TrieNode root)</span> </span>&#123;</div><div class="line">        TrieNode node = root;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</div><div class="line">            <span class="keyword">if</span> (node.children[c - <span class="string">'a'</span>] == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            node = node.children[c - <span class="string">'a'</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> node.isWord;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="680-valid-palindrome-ii"><a href="#680-valid-palindrome-ii" class="headerlink" title="680. valid-palindrome-ii"></a><a href="https://leetcode.com/problems/valid-palindrome-ii/description/" target="_blank" rel="external">680. valid-palindrome-ii</a></h4><ul>
<li>给一个字符串，判断能否通过“最多删掉一个字符”形成自对称字符串。例如<code>aba</code>本身就是，<code>abca</code>可以通过删掉b或c变成自对称。</li>
<li>直接前后指针往中间并拢，一旦发现不同的字符就把不同的两个字符分别遮住继续判断，如果还不行那就一定不能自对称了。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validPalindrome</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = s.length() - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</div><div class="line">            <span class="keyword">if</span> (s.charAt(left) != s.charAt(right)) &#123;    <span class="comment">// 发现对应位置不匹配，尝试遮掉其中一个继续判断</span></div><div class="line">                <span class="keyword">return</span> isPalin(s, left + <span class="number">1</span>, right) || isPalin(s, left, right - <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">            left++;</div><div class="line">            right--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalin</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</div><div class="line">            <span class="keyword">if</span> (s.charAt(left++) != s.charAt(right--)) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="684-redundant-connection"><a href="#684-redundant-connection" class="headerlink" title="684. redundant-connection"></a><a href="https://leetcode.com/problems/redundant-connection/description/" target="_blank" rel="external">684. redundant-connection</a></h4><ul>
<li>给一系列边组成<strong>无向图</strong>，其中恰好多了一个边使图无法形成树，求多出来的这个边即最后出现的这个边。例如<code>[[1,2], [2,3], [3,4], [1,4], [1,5]]</code>，返回<code>[1,4]</code>。</li>
<li>并查集，维护每个节点的祖先，首次出现时默认以自己为祖先，然后就判断edge中的两个节点祖先是否一样，一样就说明成环了，否则就把前者的祖先指向后者的祖先。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">// 并查集：维护一个Map，表示每个编号的点的祖先</span></div><div class="line">    <span class="comment">// 一旦找到两个点的祖先一样，就说明这个边就是让前面成环的，直接返回</span></div><div class="line">    <span class="comment">// 若祖先不同，则直接将前者的祖先归位后者祖先的后代，这样就把两个部分直接合并了，后面判断成环就可以直接判断</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findRedundantConnection(<span class="keyword">int</span>[][] edges) &#123;</div><div class="line">        <span class="keyword">if</span> (edges == <span class="keyword">null</span> || edges.length == <span class="number">0</span> || edges[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        Map&lt;Integer, Integer&gt; parentMap = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] edge: edges) &#123;</div><div class="line">            <span class="keyword">int</span> from = edge[<span class="number">0</span>];</div><div class="line">            <span class="keyword">int</span> to = edge[<span class="number">1</span>];</div><div class="line">            <span class="keyword">if</span> (!parentMap.containsKey(from)) &#123;</div><div class="line">                parentMap.put(from, from);      <span class="comment">// 刚开始设为本身</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (!parentMap.containsKey(to)) &#123;</div><div class="line">                parentMap.put(to, to);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">int</span> fromParent = findParent(parentMap, from);</div><div class="line">            <span class="keyword">int</span> toParent = findParent(parentMap, to);</div><div class="line">            <span class="keyword">if</span> (fromParent == toParent) &#123;       <span class="comment">// 二者的祖先是一样的说明成环了</span></div><div class="line">                <span class="keyword">return</span> edge;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                parentMap.put(fromParent, toParent);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">2</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findParent</span><span class="params">(Map&lt;Integer, Integer&gt; parentMap, <span class="keyword">int</span> node)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> parent = parentMap.get(node);</div><div class="line">        <span class="keyword">if</span> (parent != node) &#123;</div><div class="line">            parentMap.put(node, findParent(parentMap, parent));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> parentMap.get(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="685-redundant-connection-ii"><a href="#685-redundant-connection-ii" class="headerlink" title="685. redundant-connection-ii"></a><a href="https://leetcode.com/problems/redundant-connection-ii/description/" target="_blank" rel="external">685. redundant-connection-ii</a></h4><ul>
<li>给一系列边组成<strong>有向图</strong>，其中恰好多了一个边使图无法形成rooted tree，求多出来的这个边即最后出现的这个边。例如<code>[[2,1],[3,1],[4,2],[1,4]]</code>，返回<code>[2,1]</code>。</li>
<li>与684相比这里的边都是有向的了，有两种情况来判别边invalid：形成了环，或者一个节点同时有两个parent节点。做法分为两步：首先check看是否有节点有两个parent，有的话就设为candidate A和B，并把B设置为invalid（设一个节点为0即可）；然后进行union-find，如果此时树已经是valid的了，就直接返回candidate B（因为是后出现的）。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findRedundantDirectedConnection(<span class="keyword">int</span>[][] edges) &#123;</div><div class="line">        <span class="keyword">if</span> (edges == <span class="keyword">null</span> || edges.length == <span class="number">0</span> || edges[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] candidate1 = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">2</span>];</div><div class="line">        <span class="keyword">int</span>[] candidate2 = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">2</span>];     <span class="comment">// 后出现的</span></div><div class="line">        <span class="keyword">int</span>[] parent = <span class="keyword">new</span> <span class="keyword">int</span> [edges.length + <span class="number">1</span>];</div><div class="line">        </div><div class="line">        <span class="comment">// 先找有没有节点有两个parent</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (parent[edges[i][<span class="number">1</span>]] == <span class="number">0</span>) &#123;     <span class="comment">// 设置每个孩子节点的parent</span></div><div class="line">                parent[edges[i][<span class="number">1</span>]] = edges[i][<span class="number">0</span>];</div><div class="line">            &#125; <span class="keyword">else</span> &#123;            <span class="comment">// 发现有重复设置的情况</span></div><div class="line">                candidate2[<span class="number">0</span>] = edges[i][<span class="number">0</span>];</div><div class="line">                candidate2[<span class="number">1</span>] = edges[i][<span class="number">1</span>];</div><div class="line">                candidate1[<span class="number">0</span>] = parent[edges[i][<span class="number">1</span>]];    <span class="comment">// 原本存的parent是谁</span></div><div class="line">                candidate1[<span class="number">1</span>] = edges[i][<span class="number">1</span>];</div><div class="line">                edges[i][<span class="number">1</span>] = <span class="number">0</span>;        <span class="comment">// 这个孩子节点暂时设为无效的节点值，比如0</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 重新初始化parent，设为本身</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.length; i++) &#123;</div><div class="line">            parent[i] = i;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</div><div class="line">            <span class="keyword">if</span> (edge[<span class="number">1</span>] == <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">int</span> father = edge[<span class="number">0</span>], child = edge[<span class="number">1</span>];  <span class="comment">// 前-&gt;后</span></div><div class="line">            <span class="keyword">if</span> (root(parent, father) == child) &#123;      <span class="comment">// 判断两个节点是不是连到一起了，注意这里是直接判断是否以child作为parent，而不像上一题两个节点都要求parent</span></div><div class="line">                <span class="keyword">if</span> (candidate1[<span class="number">0</span>] == <span class="number">0</span>) &#123;      <span class="comment">// 没有多parent的情况</span></div><div class="line">                    <span class="keyword">return</span> edge;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">return</span> candidate1;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            parent[child] = father;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> candidate2;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">root</span><span class="params">(<span class="keyword">int</span>[] parent, <span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (parent[i] != i) &#123;</div><div class="line">            parent[i] = parent[parent[i]];</div><div class="line">            i = parent[i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> i;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="686-repeated-string-match"><a href="#686-repeated-string-match" class="headerlink" title="686. repeated-string-match"></a><a href="https://leetcode.com/problems/repeated-string-match/description/" target="_blank" rel="external">686. repeated-string-match</a></h4><ul>
<li>给两个字符串A和B，求A需要重复几次才能让B成为它的substring.</li>
<li><p>狗家实习的OA，自己想的方法。先看看起始字符都出现在哪些索引，统统入queue；然后先拼一波使得A的长度不小于B；然后从queue中取起始索引，比较看B是否包含其中；如果queue还没用完则还需要拼多一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">repeatedStringMatch</span><span class="params">(String A, String B)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (A == <span class="keyword">null</span> || B == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        String AOld = A;</div><div class="line">        Queue&lt;Integer&gt; startIndexQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        <span class="keyword">char</span>[] AChar = A.toCharArray(), BChar = B.toCharArray();</div><div class="line">        <span class="keyword">char</span> startChar = BChar[<span class="number">0</span>];</div><div class="line">        <span class="comment">// O(N) get start position</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; AChar.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (AChar[i] == startChar) &#123;</div><div class="line">                startIndexQueue.add(i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> repeatCount = <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (!startIndexQueue.isEmpty() &amp;&amp; A.length() - startIndexQueue.peek() &lt; BChar.length) &#123;</div><div class="line">            A += AOld;     <span class="comment">// append if not long enough            </span></div><div class="line">            repeatCount++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (!startIndexQueue.isEmpty() &amp;&amp; startIndexQueue.peek() + BChar.length &lt;= A.length()) &#123;</div><div class="line">            <span class="keyword">int</span> startIndex = startIndexQueue.poll();</div><div class="line">            <span class="keyword">if</span> (B.equals(A.substring(startIndex, startIndex + BChar.length))) &#123;</div><div class="line">                <span class="keyword">return</span> repeatCount;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// if there is still startIndex in queue, need to repeat and check more</span></div><div class="line">        <span class="keyword">if</span> (!startIndexQueue.isEmpty()) &#123;</div><div class="line">            A += AOld;</div><div class="line">            repeatCount++;</div><div class="line">            <span class="keyword">while</span> (!startIndexQueue.isEmpty()) &#123;</div><div class="line">                <span class="keyword">if</span> (B.equals(A.substring(startIndexQueue.peek(), startIndexQueue.peek() + BChar.length))) &#123;</div><div class="line">                    <span class="keyword">return</span> repeatCount;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    startIndexQueue.poll();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>或者直接用拼接的方式，一直拼接A直到超过B的长度，然后看是否包含。如果不包含还需要额外的一次拼接再看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">repeatedStringMatch</span><span class="params">(String A, String B)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">    <span class="keyword">while</span> (sb.length() &lt; B.length()) &#123;</div><div class="line">        sb.append(A);</div><div class="line">        count++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (sb.toString().contains(B)) <span class="keyword">return</span> count;</div><div class="line">    <span class="keyword">if</span> (sb.append(A).toString().contains(B)) <span class="keyword">return</span> ++count;</div><div class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="687-longest-univalue-path"><a href="#687-longest-univalue-path" class="headerlink" title="687. longest-univalue-path"></a><a href="https://leetcode.com/problems/longest-univalue-path/description/" target="_blank" rel="external">687. longest-univalue-path</a></h4><ul>
<li>给一个二叉树，求其中最长的连续边数使得经过的节点值都一样。不一定是完全笔直的路径。</li>
<li>对于左子树和右子树递归调用求最长路径（不取当前节点的情况），然后根据当前节点的值进行DFS（也就是取当前节点的情况）。最后取最大。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestUnivaluePath</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> child = Math.max(longestUnivaluePath(root.left), longestUnivaluePath(root.right));</div><div class="line">        <span class="keyword">return</span> Math.max(child, dfs(root.left, root.val) + dfs(root.right, root.val));</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode node, <span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span> || node.val != val) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(dfs(node.left, val), dfs(node.right, val)); <span class="comment">// two nodes forms one edge</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="689-maximum-sum-of-3-non-overlapping-subarrays"><a href="#689-maximum-sum-of-3-non-overlapping-subarrays" class="headerlink" title="689. maximum-sum-of-3-non-overlapping-subarrays"></a><a href="https://leetcode.com/problems/maximum-sum-of-3-non-overlapping-subarrays/description/" target="_blank" rel="external">689. maximum-sum-of-3-non-overlapping-subarrays</a></h4><ul>
<li>给一个正整数数组，找出三个互不重叠的、size为k的子数组，使得总和最大。返回的形式是每个subarray的起始索引。例如<code>[1,2,1,2,6,7,5,1], k=2</code>则返回<code>[0, 3, 5]</code>。</li>
<li>有唯一解吗？（可能有多个，只需返回最先出现索引）k本身会不会很大？（不会，不大于len/3）</li>
<li>首先是如何快速求某个区间内的和？如果数值都不大的话，可以通过累加把sum都给缓存下来，用的时候直接减一下就行了。然后是如何求subarray的结果？可以用二位dp数组，行表示划分成row个subarray，列表示从0到col处为止能得到的最大的总sum。此外还需要一个二维index数组记录第row个subarray对应的起始位置。从第一个subarray开始循环，固定求size为k的subarray使之和最大，其实就是贪心的思想，只要过程中求的每个subarray的和都最大那么最终的总和就是最大的。在循环过程中就可以不断求总和，为了防止重叠求和时必须求往前k个元素为end的dp结果。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSumOfThreeSubarrays(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</div><div class="line">        <span class="comment">// 动态规划</span></div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 缓存到i为止到所有项之和</span></div><div class="line">        <span class="keyword">int</span>[] sumArray = <span class="keyword">new</span> <span class="keyword">int</span> [nums.length];</div><div class="line">        sumArray[<span class="number">0</span>] = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</div><div class="line">            sumArray[i] = sumArray[i - <span class="number">1</span>] + nums[i];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// dp[i][j]表示求i个non-overlap sum的时候从0~j能得到的最大总sum</span></div><div class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">4</span>][nums.length];</div><div class="line">        <span class="comment">// index[i][j]表示求第i个non-overlap sum的时候的starting index</span></div><div class="line">        <span class="keyword">int</span>[][] index = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">4</span>][nums.length];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;   <span class="comment">// 从求第1个最大的k-size subarray开始直到第3个</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = k - <span class="number">1</span>; j &lt; nums.length; j++) &#123;</div><div class="line">                <span class="keyword">int</span> tempMax = j == k - <span class="number">1</span>? sumArray[j] :   <span class="comment">// 快速求区间内的和</span></div><div class="line">                    sumArray[j] - sumArray[j - k] + dp[i - <span class="number">1</span>][j - k];   <span class="comment">// 加上上一行前一个block为止的最大和</span></div><div class="line">                <span class="keyword">if</span> (j &gt; k - <span class="number">1</span>) &#123;        <span class="comment">// 先直接沿用同一行的前面的结果</span></div><div class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>];</div><div class="line">                    index[i][j] = index[i][j - <span class="number">1</span>];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; tempMax &gt; dp[i][j - <span class="number">1</span>]) &#123;  <span class="comment">// 若发现有更大的就更新当前最大和到dp</span></div><div class="line">                    dp[i][j] = tempMax;</div><div class="line">                    index[i][j] = j - k + <span class="number">1</span>;    <span class="comment">// 同时更新最大和出现的下标</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">3</span>];        </div><div class="line">        ans[<span class="number">2</span>] = index[<span class="number">3</span>][nums.length - <span class="number">1</span>];     <span class="comment">// 最后一行的最后一位就是第三个block的index</span></div><div class="line">        ans[<span class="number">1</span>] = index[<span class="number">2</span>][ans[<span class="number">2</span>] - <span class="number">1</span>];          <span class="comment">// 倒数第二行的index[3]之前的存的就是第二行的</span></div><div class="line">        ans[<span class="number">0</span>] = index[<span class="number">1</span>][ans[<span class="number">1</span>] - <span class="number">1</span>];          </div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="714-best-time-to-buy-and-sell-stock-with-transaction-fee"><a href="#714-best-time-to-buy-and-sell-stock-with-transaction-fee" class="headerlink" title="714. best-time-to-buy-and-sell-stock-with-transaction-fee"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/" target="_blank" rel="external">714. best-time-to-buy-and-sell-stock-with-transaction-fee</a></h4><ul>
<li>给一个数组表示股票价格，每次交易（买卖完成算一次）都会收取手续费。求最大收益。</li>
<li>（思路来自覃超说算法）DP。<code>profit[i][0]</code>表示第i天<strong>不持有</strong>股票手头的资金，<code>profit[i][1]</code>表示第i天<strong>持有</strong>股票手头的资金.初始化时第一天如果不持有股票则手头为0，若持有股票则需要消耗资金，因此是<code>-price[0]</code>。之后的状态转换为<code>profit[i][0] = profit[i - 1][0]（前一天也没有买入）和profit[i - 1][1] + prices[i]（前一天是持有的，今天卖出）的较大者</code>。类似地，<code>profit[i][1] = profit[i - 1][1]（前一天也持有）和profit[i - 1][0] - prices[i]（前一天没有，今天买入）的较大者</code>。最后返回最后一天不持有股票的profit即可。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[][] profit = <span class="keyword">new</span> <span class="keyword">int</span> [prices.length][<span class="number">2</span>];</div><div class="line">        profit[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">        profit[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; profit.length; i++) &#123;</div><div class="line">            profit[i][<span class="number">0</span>] = Math.max(profit[i - <span class="number">1</span>][<span class="number">0</span>], profit[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i] - fee);</div><div class="line">            profit[i][<span class="number">1</span>] = Math.max(profit[i - <span class="number">1</span>][<span class="number">1</span>], profit[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> profit[prices.length - <span class="number">1</span>][<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="719-find-k-th-smallest-pair-distance"><a href="#719-find-k-th-smallest-pair-distance" class="headerlink" title="719. find-k-th-smallest-pair-distance"></a><a href="https://leetcode.com/problems/find-k-th-smallest-pair-distance/description/" target="_blank" rel="external">719. find-k-th-smallest-pair-distance</a></h4><ul>
<li>给一个int数组，求每两个数之差中第k小的值。例如<code>[1,3,8,4,5,45]</code>，当k = 1，返回1，当k = 3，返回2.</li>
<li>先对所有元素从小到大排序，那么间距最小值为0、最大值为最右减最左。用二分查找的思想，假设mid为第k小的值，然后O(N^2)遍历求有多少对儿数之差小于mid；若对儿数小于k，说明猜的值太小了排太前了；大于k则说明猜太大了。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">smallestDistancePair</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        Arrays.sort(nums);</div><div class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums[nums.length - <span class="number">1</span>] - nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</div><div class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;   <span class="comment">// 猜一个距离</span></div><div class="line">            <span class="keyword">int</span> count = <span class="number">0</span>, left = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> right = <span class="number">1</span>; right &lt; nums.length; right++) &#123;</div><div class="line">                <span class="keyword">while</span> (nums[right] - nums[left] &gt; mid) &#123;</div><div class="line">                    left++;</div><div class="line">                &#125;</div><div class="line">                count += right - left;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (count &lt; k) &#123;        <span class="comment">// 说明猜的不够大</span></div><div class="line">                lo = mid + <span class="number">1</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                hi = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> lo;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="721-accounts-merge"><a href="#721-accounts-merge" class="headerlink" title="721. accounts-merge"></a><a href="https://leetcode.com/problems/accounts-merge/description/" target="_blank" rel="external">721. accounts-merge</a></h4><ul>
<li>给一堆字符串List，每个List中首先是名字，然后是这个人的各种邮箱。最后放回经过merge的姓名、邮箱List，并且要求将邮箱从小到大排序。</li>
<li><p>这种多对一的关系查找，特别适合用并查集。首先将每个邮箱的parent设为自己，然后将每个List靠后面的邮箱统一把parent设成第一个邮箱。然后利用TreeSet实现邮箱的排序，最后导出到List返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; accountsMerge(List&lt;List&lt;String&gt;&gt; accounts) &#123;</div><div class="line">        List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">if</span> (accounts == <span class="keyword">null</span> || accounts.size() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> ans;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 初始化并查集，并存放每个email的主人</span></div><div class="line">        Map&lt;String, String&gt; parent = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        Map&lt;String, String&gt; emailOwner = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (List&lt;String&gt; account : accounts) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; account.size(); i++) &#123;</div><div class="line">                parent.put(account.get(i), account.get(i));     <span class="comment">// 老大初始化为自己</span></div><div class="line">                emailOwner.put(account.get(i), account.get(<span class="number">0</span>));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 将同一个人的邮箱存入并查集map</span></div><div class="line">        <span class="keyword">for</span> (List&lt;String&gt; account : accounts) &#123;</div><div class="line">            String root = find(parent, account.get(<span class="number">1</span>));</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; account.size(); i++) &#123;</div><div class="line">                parent.put(find(parent, account.get(i)), root);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 将同属一个老大的email存入TreeSet以排序</span></div><div class="line">        Map&lt;String, Set&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (List&lt;String&gt; account : accounts) &#123;</div><div class="line">            String root = find(parent, account.get(<span class="number">1</span>));</div><div class="line">            <span class="keyword">if</span> (!map.containsKey(root)) &#123;</div><div class="line">                map.put(root, <span class="keyword">new</span> TreeSet&lt;String&gt;());</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; account.size(); i++) &#123;</div><div class="line">                map.get(root).add(account.get(i));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 最后导出到List中返回</span></div><div class="line">        <span class="keyword">for</span> (String email : map.keySet()) &#123;</div><div class="line">            String owner = emailOwner.get(email);</div><div class="line">            List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(map.get(email));</div><div class="line">            list.add(<span class="number">0</span>, owner);</div><div class="line">            ans.add(list);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">find</span><span class="params">(Map&lt;String, String&gt; parent, String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (!parent.get(s).equals(s)) &#123;</div><div class="line">            parent.put(s, parent.get(parent.get(s)));   <span class="comment">// 将当前的parent设为"parent的parent"</span></div><div class="line">            s = parent.get(s);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> s;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>其实更直白的看，这题就是个图论题，整理出图的联通部分。首先是构建graph，每个邮箱都是节点，用Set存每一行所给邮箱组成的subgraph，每个邮箱都用Set存放可达邻居（需要双向添加）。然后开始DFS或BFS搜索图，将每一行的第一个邮箱作为起点，把所有可达的邮箱都加进来，在这个过程中需要标记visited。之后如果再遇到visited的邮箱就说明已经在之前“可达”掉了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; accountsMerge(List&lt;List&lt;String&gt;&gt; accounts) &#123;</div><div class="line">        <span class="comment">// build the graph</span></div><div class="line">        Map&lt;String,Set&lt;String&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (List&lt;String&gt; ls : accounts) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ls.size();i ++) &#123;</div><div class="line">                <span class="keyword">if</span> (!graph.containsKey(ls.get(i))) graph.put(ls.get(i), <span class="keyword">new</span> HashSet&lt;String&gt;());</div><div class="line">                graph.get(ls.get(i)).add(ls.get(<span class="number">1</span>));</div><div class="line">                graph.get(ls.get(<span class="number">1</span>)).add(ls.get(i));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// traverse the graph, find out all the connected subgraph</span></div><div class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (List&lt;String&gt; ls : accounts) &#123;</div><div class="line">            <span class="keyword">if</span> (!visited.contains(ls.get(<span class="number">1</span>))) &#123;</div><div class="line">                List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">                bfs(graph, visited, ls.get(<span class="number">1</span>), ans); <span class="comment">// or dfs(graph,visited,ls.get(1),ans)</span></div><div class="line">                Collections.sort(ans);</div><div class="line">                ans.add(<span class="number">0</span>,ls.get(<span class="number">0</span>));</div><div class="line">                result.add(ans);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Map&lt;String, Set&lt;String&gt;&gt; graph, Set&lt;String&gt; visited, String s, List&lt;String&gt; ans)</span> </span>&#123;</div><div class="line">        ans.add(s);</div><div class="line">        visited.add(s);</div><div class="line">        <span class="keyword">for</span> (String str : graph.get(s)) &#123;</div><div class="line">            <span class="keyword">if</span> (!visited.contains(str)) &#123;</div><div class="line">                dfs(graph, visited, str, ans);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Map&lt;String, Set&lt;String&gt;&gt; graph, Set&lt;String&gt; visited, String s, List&lt;String&gt; ans)</span> </span>&#123;</div><div class="line">        Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        q.add(s);</div><div class="line">        visited.add(s);</div><div class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</div><div class="line">            String t = q.poll();</div><div class="line">            ans.add(t);</div><div class="line">            <span class="keyword">for</span> (String str : graph.get(t)) &#123;</div><div class="line">                <span class="keyword">if</span> (!visited.contains(str)) &#123;</div><div class="line">                    q.add(str);</div><div class="line">                    visited.add(str);</div><div class="line">                &#125; </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="726-number-of-atoms"><a href="#726-number-of-atoms" class="headerlink" title="726. number-of-atoms"></a><a href="https://leetcode.com/problems/number-of-atoms/description/" target="_blank" rel="external">726. number-of-atoms</a></h4><ul>
<li>给一个字符串表示化学物质，统计其中的元素及出现次数，按字典序输出。例如<code>H2(O(Mn)2)3</code>输出<code>H2Mn6O3</code>.</li>
<li>只有1个元素是输出1还是不输出？（不输出数字，只输出元素）</li>
<li>由于含有括号，联想运算符算式就知道要用Stack进行吞吐来处理括号嵌套的情况。如果是字母，就一直找到小写的为止作为元素名字，之后跟着的数字就是count，存入map。若出现左括号，则当前的这个map（保存了括号之前的元素及count）直接入栈，然后用新的map继续统计，一旦遇到右括号，说明当前部分结束(注意需要检查右括号之后还有没有数字)，则与栈顶弹出的map合并一下就好了。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">countOfAtoms</span><span class="params">(String formula)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (formula == <span class="keyword">null</span> || formula.length() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">        &#125;</div><div class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        Stack&lt;Map&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        <span class="keyword">char</span>[] fChar = formula.toCharArray();</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, fLen = fChar.length;</div><div class="line">        <span class="keyword">while</span> (i &lt; fLen) &#123;</div><div class="line">            <span class="keyword">if</span> (fChar[i] == <span class="string">'('</span>) &#123;  <span class="comment">// 将之前的map压栈</span></div><div class="line">                stack.push(map);    </div><div class="line">                map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">                i++;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fChar[i] == <span class="string">')'</span>) &#123;   <span class="comment">// 将当前的合并入之前的map</span></div><div class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">                i++;</div><div class="line">                <span class="comment">// 取括号后的数值</span></div><div class="line">                <span class="keyword">while</span> (i &lt; fLen &amp;&amp; Character.isDigit(fChar[i])) &#123;</div><div class="line">                    count = (<span class="number">10</span> * count) + fChar[i++] - <span class="string">'0'</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</div><div class="line">                    count = <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (!stack.isEmpty()) &#123;</div><div class="line">                    Map&lt;String, Integer&gt; prevMap = stack.pop();</div><div class="line">                    <span class="keyword">for</span> (String atom: map.keySet()) &#123;   <span class="comment">// 取当前map中的atom放入之前的</span></div><div class="line">                        prevMap.put(atom, prevMap.getOrDefault(atom, <span class="number">0</span>) + map.get(atom) * count);</div><div class="line">                    &#125;</div><div class="line">                    map = prevMap;  <span class="comment">// 用回原来的map</span></div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 以字母开头，直到非小写字母为一个原子</span></div><div class="line">                <span class="keyword">int</span> end = i + <span class="number">1</span>;</div><div class="line">                <span class="keyword">while</span> (end &lt; fLen &amp;&amp; Character.isLowerCase(fChar[end])) &#123;</div><div class="line">                    end++;</div><div class="line">                &#125;</div><div class="line">                String atom = formula.substring(i, end);</div><div class="line">                </div><div class="line">                <span class="comment">// 看看字母之后是否跟着数字</span></div><div class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">                <span class="keyword">while</span> (end &lt; fLen &amp;&amp; Character.isDigit(fChar[end])) &#123;</div><div class="line">                    count = <span class="number">10</span> * count + fChar[end++] - <span class="string">'0'</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</div><div class="line">                    count = <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                <span class="comment">// 更新原子数值 </span></div><div class="line">                map.put(atom, map.getOrDefault(atom, <span class="number">0</span>) + count);</div><div class="line">                i = end;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">        List&lt;String&gt; atoms = <span class="keyword">new</span> ArrayList&lt;&gt;(map.keySet());</div><div class="line">        Collections.sort(atoms);    <span class="comment">// 字母顺序</span></div><div class="line">        <span class="keyword">for</span> (String atom: atoms) &#123;</div><div class="line">            sb.append(atom);</div><div class="line">            <span class="keyword">if</span> (map.get(atom) &gt; <span class="number">1</span>) &#123;</div><div class="line">                sb.append(map.get(atom));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sb.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="727-minimum-window-subsequence"><a href="#727-minimum-window-subsequence" class="headerlink" title="727. minimum-window-subsequence"></a><a href="https://leetcode.com/problems/minimum-window-subsequence/description/" target="_blank" rel="external">727. minimum-window-subsequence</a></h4><ul>
<li>给一个source字符串和一个target字符串，求在source的最短子串使得包含target的所有字符（个数和出现顺序都必须一致）。</li>
<li>DP（感觉是野路子，不太好想）。。。纵向行为target，横向列为source，第一行全部初始化为<code>0,1,2....sLen</code>表示从第几位开始取，之后所有值初始化为-1表示无解。然后O(M*N)逐个字符遍历两个字符串，若匹配上了则从左上方取起始位置（看前一个字符的情况），若匹配不上则默认继续取source（直接取左侧的值）。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String S, String T)</span> </span>&#123;</div><div class="line">        <span class="comment">// 动态规划, 行为tLen + 1, 列为sLen + 1, dp[][]表示从dp[i][j]到j到这部分字符串是所求，</span></div><div class="line">        <span class="comment">// 即T[0, j)是S[0, i)的subsequence with substring S[dp[i][j], j).</span></div><div class="line">        <span class="comment">// 初始状态为</span></div><div class="line">        <span class="comment">// 状态转换为，若当前字符不匹配，则根据左侧（即S前一个字符）情况决定起始位置（保证最短）</span></div><div class="line">        <span class="comment">// 若匹配，则依赖于左上方的结果，即T前一个字符的起始位置。</span></div><div class="line">        <span class="keyword">if</span> (S == <span class="keyword">null</span> || T == <span class="keyword">null</span> || S.length() == <span class="number">0</span> || T.length() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">char</span>[] sChar = S.toCharArray();</div><div class="line">        <span class="keyword">char</span>[] tChar = T.toCharArray();</div><div class="line">        <span class="keyword">int</span> sLen = sChar.length, tLen = tChar.length;</div><div class="line">        <span class="keyword">int</span>[][] startFrom = <span class="keyword">new</span> <span class="keyword">int</span> [tLen + <span class="number">1</span>][sLen + <span class="number">1</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= tLen; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= sLen; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</div><div class="line">                    startFrom[i][j] = j;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    startFrom[i][j] = -<span class="number">1</span>;   <span class="comment">// -1表示无解</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tLen; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sLen; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (sChar[j - <span class="number">1</span>] == tChar[i - <span class="number">1</span>]) &#123;</div><div class="line">                    startFrom[i][j] = startFrom[i - <span class="number">1</span>][j - <span class="number">1</span>];</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    startFrom[i][j] = startFrom[i][j - <span class="number">1</span>];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = sLen, minLen = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sLen; j++) &#123;</div><div class="line">            System.out.print(startFrom[tLen][j] + <span class="string">" "</span>);</div><div class="line">            <span class="keyword">if</span> (startFrom[tLen][j] != -<span class="number">1</span>) &#123;</div><div class="line">                <span class="keyword">int</span> currLen = j - startFrom[tLen][j];</div><div class="line">                <span class="keyword">if</span> (currLen &lt; minLen) &#123;</div><div class="line">                    start = startFrom[tLen][j];</div><div class="line">                    end = j;</div><div class="line">                    minLen = currLen;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> minLen == Integer.MAX_VALUE? <span class="string">""</span> : S.substring(start, end);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="729-my-calendar-i"><a href="#729-my-calendar-i" class="headerlink" title="729. my-calendar-i"></a><a href="https://leetcode.com/problems/my-calendar-i/description/" target="_blank" rel="external">729. my-calendar-i</a></h4><ul>
<li>给若干开始时间+结束时间pair，实现book函数判断能否成功添加事件，不能有时间重叠。</li>
<li><p>方法一：暴力法，从头到尾遍历链表，无冲突就插入。效率O(N)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCalendar</span> </span>&#123;</div><div class="line">    <span class="comment">// 定义一个链表，每次遍历所有节点判断有没有重合，没有就插入到末尾</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> start;</div><div class="line">        <span class="keyword">int</span> end;</div><div class="line">        Node next;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.start = start;</div><div class="line">            <span class="keyword">this</span>.end = end;</div><div class="line">            next = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    Node head = <span class="keyword">null</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCalendar</span><span class="params">()</span> </span>&#123;</div><div class="line">        head = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">book</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</div><div class="line">            head = <span class="keyword">new</span> Node(start, end);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> checkAndAdd(<span class="keyword">new</span> Node(start, end));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// brute force: check with every existing intervals and insert at the end</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkAndAdd</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">        Node curr = head;</div><div class="line">        Node prev = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (node.end &gt; curr.start &amp;&amp; node.start &lt; curr.end) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                prev = curr;</div><div class="line">                curr = curr.next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        prev.next = node;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法二：利用TreeMap，对于每个[start, end]对，从TreeMap中找start的floor，取出它对应的end。一旦这个end大于start，就说明有重叠了。同理，也要从TreeMap中找start的ceiling，如果这个ceiling小于end，说明与后面有重叠。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCalendar</span> </span>&#123;</div><div class="line">    <span class="comment">// 维护start-end的TreeMap，每次尝试取输入的start的在TreeeMap中的下界和上界</span></div><div class="line">    <span class="comment">// 分别判断输入的start是否在最大的不大于start的floorStart对应的end之间，</span></div><div class="line">    <span class="comment">// 再判断最小的不小于start的ceilingStart会不会落在end之前</span></div><div class="line">    TreeMap&lt;Integer, Integer&gt; calendar;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCalendar</span><span class="params">()</span> </span>&#123;</div><div class="line">        calendar = <span class="keyword">new</span> TreeMap&lt;&gt;();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">book</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">        <span class="comment">// floorStart, start, floorStart'sEnd</span></div><div class="line">        Integer floorStart = calendar.floorKey(start);</div><div class="line">        <span class="keyword">if</span> (floorStart != <span class="keyword">null</span> &amp;&amp; calendar.get(floorStart) &gt; start) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// start, ceilingStart, end</span></div><div class="line">        Integer ceilingStart = calendar.ceilingKey(start);</div><div class="line">        <span class="keyword">if</span> (ceilingStart != <span class="keyword">null</span> &amp;&amp; ceilingStart &lt; end) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        calendar.put(start, end);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="731-my-calendar-ii"><a href="#731-my-calendar-ii" class="headerlink" title="731. my-calendar-ii"></a><a href="https://leetcode.com/problems/my-calendar-ii/description/" target="_blank" rel="external">731. my-calendar-ii</a></h4><ul>
<li>与729相比变成了不能出现triple的重叠就算是可以book。</li>
<li>注意不能简单地理解为一个interval同时与两个interval重叠，因为<code>[2,6]</code>和<code>[1,3]&amp;[5,7]</code>同时重叠，但没有形成triplet.</li>
<li>同样是维护TreeMap，对于每个新加入的interval，遍历已有的interval并把重叠的部分插入treemap。如果插入时发现有重叠，说明“重叠部分之间也有重叠”，这样就是triple了。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCalendarTwo</span> </span>&#123;</div><div class="line">    <span class="comment">// 原本一位和之前相比就只是多了一个map，这个存不了就尝试另一个map，都不行就说明triple了。</span></div><div class="line">    <span class="comment">// 但题目给的样例都不行，例如最后一个25~55，因为这个overlap分别和两个map里都interval重叠，但是没有形成triple；</span></div><div class="line">    <span class="comment">// 正解应该是用一个list维护所有的interval，然后用treemap只维护当前重叠的部分，如果后续又出现了和list里的重叠，</span></div><div class="line">    <span class="comment">// 就再去treemap中看看有没有第三次重叠。</span></div><div class="line">    <span class="comment">// 注意每次遍历都需要清空TreeMap，因为我在遍历List的时候只关心新加入的这个会不会和别的重叠。</span></div><div class="line">    List&lt;<span class="keyword">int</span>[]&gt; intervals;</div><div class="line">    TreeMap&lt;Integer, Integer&gt; overlap;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCalendarTwo</span><span class="params">()</span> </span>&#123;</div><div class="line">        intervals = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        overlap = <span class="keyword">new</span> TreeMap&lt;&gt;();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">book</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">        overlap.clear();</div><div class="line">        <span class="comment">// 遍历所有interval看看有没有重叠</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] interval: intervals) &#123;</div><div class="line">            <span class="keyword">if</span> (start &gt;= interval[<span class="number">0</span>] &amp;&amp; start &lt; interval[<span class="number">1</span>]) &#123;</div><div class="line">                <span class="comment">// interval:   ________</span></div><div class="line">                <span class="comment">// newInter:     _____...</span></div><div class="line">                <span class="keyword">if</span> (!addOverlap(start, Math.min(end, interval[<span class="number">1</span>]))) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end &gt; interval[<span class="number">0</span>] &amp;&amp; start &lt; interval[<span class="number">0</span>]) &#123;</div><div class="line">                <span class="comment">// interval:   ________</span></div><div class="line">                <span class="comment">// newInter:  ______...</span></div><div class="line">                <span class="keyword">if</span> (!addOverlap(interval[<span class="number">0</span>], Math.min(end, interval[<span class="number">1</span>]))) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        intervals.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;start, end&#125;);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addOverlap</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">        Integer floorStart = overlap.floorKey(start);</div><div class="line">        <span class="keyword">if</span> (floorStart != <span class="keyword">null</span> &amp;&amp; overlap.get(floorStart) &gt; start) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        Integer ceilingStart = overlap.ceilingKey(start);</div><div class="line">        <span class="keyword">if</span> (ceilingStart != <span class="keyword">null</span> &amp;&amp; ceilingStart &lt; end) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        overlap.put(start, end);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="734-sentence-similarity"><a href="#734-sentence-similarity" class="headerlink" title="734. sentence-similarity"></a><a href="https://leetcode.com/problems/sentence-similarity/" target="_blank" rel="external">734. sentence-similarity</a></h4><ul>
<li>给一堆同义词<code>[(&quot;restaurant&quot;, &quot;cafe&quot;), (&quot;ratings&quot;, &quot;reviews&quot;), ...]</code>，再给一些queries<code>[(&quot;restaurant ratings&quot;, &quot;cafe reviews&quot;), ...]</code>，要求返回每个query里的对应词是否都是synonym。同义词没有传递性。</li>
<li>直接把字符串作为key、对应的所有同义词的set作为value存入map，正反都放一次，比如<code>map.get(&quot;restaurant&quot;).add(&quot;cafe&quot;)), map.get(&quot;restaurant&quot;).add(&quot;cafe&quot;)</code>，这样在query的时候就可以直接调用了。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 维护一个总的map，每个单词作为key，对等的单词塞入它维护的Set中</span></div><div class="line"><span class="comment">// 有对称性所以需要正反都加</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">areSentencesSimilar</span><span class="params">(String[] words1, String[] words2, String[][] pairs)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (words1 == <span class="keyword">null</span> || words2 == <span class="keyword">null</span> || pairs == <span class="keyword">null</span></div><div class="line">        || words1.length != words2.length) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    Map&lt;String, Set&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pairs.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (!map.containsKey(pairs[i][<span class="number">0</span>])) &#123;</div><div class="line">            map.put(pairs[i][<span class="number">0</span>], <span class="keyword">new</span> HashSet&lt;&gt;());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!map.containsKey(pairs[i][<span class="number">1</span>])) &#123;</div><div class="line">            map.put(pairs[i][<span class="number">1</span>], <span class="keyword">new</span> HashSet&lt;&gt;());</div><div class="line">        &#125;</div><div class="line">        map.get(pairs[i][<span class="number">0</span>]).add(pairs[i][<span class="number">1</span>]);  <span class="comment">// 构建a-&gt;b</span></div><div class="line">        map.get(pairs[i][<span class="number">1</span>]).add(pairs[i][<span class="number">0</span>]);  <span class="comment">// 构建b-&gt;a</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words1.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (words1[i].equals(words2[i])) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (map.get(words1[i]) == <span class="keyword">null</span> || !map.get(words1[i]).contains(words2[i])) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="737-sentence-similarity-ii"><a href="#737-sentence-similarity-ii" class="headerlink" title="737. sentence-similarity-ii"></a><a href="https://leetcode.com/problems/sentence-similarity-ii/description/" target="_blank" rel="external">737. sentence-similarity-ii</a></h4><ul>
<li>给一堆同义词<code>[(&quot;restaurant&quot;, &quot;cafe&quot;), (&quot;ratings&quot;, &quot;reviews&quot;), ...]</code>，再给一些queries<code>[(&quot;restaurant ratings&quot;, &quot;cafe reviews&quot;), ...]</code>，要求返回每个query里的对应词是否都是synonym。注意这些同义词具有传递性，<code>a=b, b=c -&gt; a=c</code>。</li>
<li><p>方法一：图论题，每个词都是一个节点，对于每个节点维护一个Set，通过DFS遍历所有可达的节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 和前一个版本的区别是这个可以无限传递a=b=c=d...</span></div><div class="line"><span class="comment">// 还是map维护每个单词等价的单词，但匹配不上的话还得看它的set里所有单词对应的单词是否能匹配到</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">areSentencesSimilarTwo</span><span class="params">(String[] words1, String[] words2, String[][] pairs)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (words1 == <span class="keyword">null</span> || words2 == <span class="keyword">null</span> || pairs == <span class="keyword">null</span></div><div class="line">        || words1.length != words2.length) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 表示每个单词直接相连的同义词</span></div><div class="line">    Map&lt;String, Set&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pairs.length; i++) &#123;        <span class="comment">// O(N)</span></div><div class="line">        <span class="keyword">if</span> (!map.containsKey(pairs[i][<span class="number">0</span>])) &#123;</div><div class="line">            map.put(pairs[i][<span class="number">0</span>], <span class="keyword">new</span> HashSet&lt;&gt;());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!map.containsKey(pairs[i][<span class="number">1</span>])) &#123;</div><div class="line">            map.put(pairs[i][<span class="number">1</span>], <span class="keyword">new</span> HashSet&lt;&gt;());</div><div class="line">        &#125;</div><div class="line">        map.get(pairs[i][<span class="number">0</span>]).add(pairs[i][<span class="number">1</span>]);  <span class="comment">// 构建a-&gt;b</span></div><div class="line">        map.get(pairs[i][<span class="number">1</span>]).add(pairs[i][<span class="number">0</span>]);  <span class="comment">// 构建b-&gt;a</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words1.length; i++) &#123;       <span class="comment">// O(N*N)</span></div><div class="line">        <span class="keyword">if</span> (words1[i].equals(words2[i])) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!map.containsKey(words1[i])) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!dfs(words1[i], words2[i], map, <span class="keyword">new</span> HashSet&lt;String&gt;())) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(String start, String end, Map&lt;String, Set&lt;String&gt;&gt; map, Set&lt;String&gt; visited)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (map.get(start).contains(end)) &#123;     <span class="comment">// 终止条件：start连接着end</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    visited.add(start);</div><div class="line">    Set&lt;String&gt; neighbors = map.get(start);</div><div class="line">    <span class="keyword">if</span> (neighbors == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (String neighbor : neighbors) &#123;</div><div class="line">        <span class="keyword">if</span> (!visited.contains(neighbor) &amp;&amp; dfs(neighbor, end, map, visited)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法二：并查集，初始化时每个单词都是自己的root；然后根据同义词关系将前者的老大设为后者。判断句子是否同义时就找两个单词的老大是否相等即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 并查集。初始化时每个单词都是自己的root；然后根据同义词关系将前者的老大设为后者。</span></div><div class="line"><span class="comment">// 判断句子是否同义时就找两个单词的老大是否相等即可</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">areSentencesSimilarTwo</span><span class="params">(String[] words1, String[] words2, String[][] pairs)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (words1.length != words2.length) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="keyword">for</span> (String[] pair : pairs) &#123;     <span class="comment">// 开始时每个老大都是自己</span></div><div class="line">        map.put(pair[<span class="number">0</span>], pair[<span class="number">0</span>]);</div><div class="line">        map.put(pair[<span class="number">1</span>], pair[<span class="number">1</span>]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (String[] pair : pairs) &#123;</div><div class="line">        String par1 = findParent(pair[<span class="number">0</span>], map);</div><div class="line">        String par2 = findParent(pair[<span class="number">1</span>], map);</div><div class="line">        <span class="keyword">if</span> (!par1.equals(par2)) &#123;</div><div class="line">            map.put(par1, par2);    <span class="comment">// par1的老大设为par2</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words1.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (words1[i].equals(words2[i])) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!map.containsKey(words1[i]) || !map.containsKey(words2[i])) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        String par1 = findParent(words1[i], map);</div><div class="line">        String par2 = findParent(words2[i], map);</div><div class="line">        <span class="keyword">if</span> (!par1.equals(par2)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findParent</span><span class="params">(String str, Map&lt;String,String&gt; map)</span></span>&#123;</div><div class="line">        <span class="keyword">while</span> (!str.equals(map.get(str))) &#123; <span class="comment">// 追溯str的老大</span></div><div class="line">            str = map.get(str);              </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> str;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="739-daily-temperatures"><a href="#739-daily-temperatures" class="headerlink" title="739. daily-temperatures"></a><a href="https://leetcode.com/problems/daily-temperatures/description/" target="_blank" rel="external">739. daily-temperatures</a></h4><ul>
<li>给一个int数组表示气温，返回一个数组表示该日最短需要多少天才会有更温暖的日子。例如<code>[73, 74, 75, 71, 69, 72, 76, 73]</code>输出<code>[1, 1, 4, 2, 1, 1, 0, 0]</code>。</li>
<li>解法：维护一个Stack存放索引，每次读入新的温度时就和栈顶对应的温度比较，如果更高，就弹出并设置该索引处的天数。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] temperatures) &#123;</div><div class="line">        <span class="keyword">if</span> (temperatures == <span class="keyword">null</span> || temperatures.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] nextWarmer = <span class="keyword">new</span> <span class="keyword">int</span> [temperatures.length];</div><div class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temperatures.length; i++) &#123;</div><div class="line">            <span class="comment">// 比较当前温度和栈顶索引对应温度 </span></div><div class="line">            <span class="keyword">while</span> (!stack.isEmpty()</div><div class="line">                &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) &#123;</div><div class="line">                <span class="keyword">int</span> index = stack.pop();</div><div class="line">                nextWarmer[index] = i - index;</div><div class="line">            &#125;</div><div class="line">            stack.push(i);                  <span class="comment">// 栈剩下的都比当前大</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</div><div class="line">            nextWarmer[stack.pop()] = <span class="number">0</span>;    <span class="comment">// 其实Java数组原本就是0</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> nextWarmer;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="745-prefix-and-suffix-search"><a href="#745-prefix-and-suffix-search" class="headerlink" title="745. prefix-and-suffix-search"></a><a href="https://leetcode.com/problems/prefix-and-suffix-search/description/" target="_blank" rel="external">745. prefix-and-suffix-search</a></h4><ul>
<li>给一个字符串数组，之后给一些query，这些query含有前缀和后缀（0～10个字符），求符合前缀的单词的索引。</li>
<li>有多个答案怎么办？返回最后一个出现的。</li>
<li><p>方法一：encode的方式将每个单词所有可能的前缀后缀组合作为key存入map，索引作为value，这样在query的时候直接再encode一下就可以直接get了。初始化时间复杂度O(N <em> wordLen^2)，query时间复杂度O(1)，空间占用O(N </em> wordLen^2).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordFilter</span> </span>&#123;</div><div class="line">    Map&lt;String, Integer&gt; map;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WordFilter</span><span class="params">(String[] words)</span> </span>&#123; </div><div class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; words.length; index++) &#123;</div><div class="line">            <span class="keyword">int</span> wordLen = words[index].length();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span> &amp;&amp; i &lt;= wordLen; i++) &#123;</div><div class="line">                String front = words[index].substring(<span class="number">0</span>, i);</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">10</span> &amp;&amp; j &lt;= wordLen; j++) &#123;</div><div class="line">                    String back = words[index].substring(wordLen - j);  <span class="comment">// 组成"a...#p.."的key</span></div><div class="line">                    map.put(front + <span class="string">"#"</span> + back, index);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(String prefix, String suffix)</span> </span>&#123;</div><div class="line">        String key = prefix + <span class="string">"#"</span> + suffix;</div><div class="line">        <span class="keyword">return</span> map.containsKey(key)? map.get(key) : -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法二：拆分成两个map，一个专门维护前缀、一个专门维护后缀，value都是索引的List。在query的时候需要把两个List取出来，然后O(N)扫描看看有没有交点。初始化时间复杂度O(N <em> wordLen)，query时间复杂度O(N)，空间占用O(N </em> wordLen).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordFilter</span> </span>&#123;</div><div class="line">    Map&lt;String, List&lt;Integer&gt;&gt; mapPrefix;</div><div class="line">    Map&lt;String, List&lt;Integer&gt;&gt; mapSuffix;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WordFilter</span><span class="params">(String[] words)</span> </span>&#123; </div><div class="line">        mapPrefix = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        mapSuffix = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; words.length; index++) &#123;</div><div class="line">            <span class="keyword">int</span> wordLen = words[index].length();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span> &amp;&amp; i &lt;= wordLen; i++) &#123;</div><div class="line">                String front = words[index].substring(<span class="number">0</span>, i);</div><div class="line">                <span class="keyword">if</span> (!mapPrefix.containsKey(front)) &#123;</div><div class="line">                    mapPrefix.put(front, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</div><div class="line">                &#125;</div><div class="line">                mapPrefix.get(front).add(index);</div><div class="line">                </div><div class="line">                String back = words[index].substring(wordLen - i);</div><div class="line">                <span class="keyword">if</span> (!mapSuffix.containsKey(back)) &#123;</div><div class="line">                    mapSuffix.put(back, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</div><div class="line">                &#125;</div><div class="line">                mapSuffix.get(back).add(index);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(String prefix, String suffix)</span> </span>&#123;</div><div class="line">        List&lt;Integer&gt; listPrefix = mapPrefix.get(prefix);</div><div class="line">        List&lt;Integer&gt; listSuffix = mapSuffix.get(suffix);</div><div class="line">        <span class="keyword">if</span> (listPrefix == <span class="keyword">null</span> || listSuffix == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> i = listPrefix.size() - <span class="number">1</span>, j = listSuffix.size() - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;          <span class="comment">// 因为要返回最后一个，所以要从后往前找交点</span></div><div class="line">            <span class="keyword">if</span> (listPrefix.get(i) &gt; listSuffix.get(j)) &#123;</div><div class="line">                i--;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (listPrefix.get(i) &lt; listSuffix.get(j)) &#123;</div><div class="line">                j--;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> listPrefix.get(i);   <span class="comment">// 注意不能直接对Integer用==判断相等！</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法三：直接使用内建函数startsWith和endsWith。初始化时间复杂度O(1)，query时间复杂度O(N * wordLen)，空间占用O(1).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordFilter</span> </span>&#123;</div><div class="line">    String[] words;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WordFilter</span><span class="params">(String[] words)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.words = words;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(String prefix, String suffix)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = words.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">            <span class="keyword">if</span> (words[i].startsWith(prefix) &amp;&amp; words[i].endsWith(suffix)) &#123;</div><div class="line">                <span class="keyword">return</span> i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="748-shortest-completing-word"><a href="#748-shortest-completing-word" class="headerlink" title="748. shortest-completing-word"></a><a href="https://leetcode.com/problems/shortest-completing-word/description/" target="_blank" rel="external">748. shortest-completing-word</a></h4><ul>
<li>给一个licensePlate，再给一个words数组，求其中最短的字符串使得licensePlate出现过的字母都有。例如<code>licensePlate = &quot;1s3 PSt&quot;中只用关注S P S T, words = [&quot;step&quot;, &quot;steps&quot;, &quot;stripe&quot;, &quot;stepple&quot;]</code>，输出<code>steps</code>。</li>
<li>licensePlate有哪些字符、确定只关注字母？（-是的）字母大小写？（-忽略大小写）</li>
<li>解法：先统计licensePlate中字母出现次数，然后<code>O(N)</code>遍历字符串数组，对于每一个单词判断是否包含licensePlate的所有字母（<code>O(26)</code>），再找最短的返回。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">int</span> LETTER_NUM = <span class="number">26</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">shortestCompletingWord</span><span class="params">(String licensePlate, String[] words)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (licensePlate == <span class="keyword">null</span> || words == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 统计licensePlate里字母的出现次数</span></div><div class="line">        <span class="keyword">char</span>[] letterCount = <span class="keyword">new</span> <span class="keyword">char</span> [LETTER_NUM];</div><div class="line">        <span class="keyword">char</span>[] lChar = licensePlate.toLowerCase().toCharArray();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lChar.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (Character.isLetter(lChar[i])) &#123;</div><div class="line">                letterCount[lChar[i] - <span class="string">'a'</span>]++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 对于每个单词判断是否complete，然后找最短的</span></div><div class="line">        String ans = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">int</span> minLen = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">for</span> (String word: words) &#123;</div><div class="line">            <span class="keyword">if</span> (checkComplete(word, letterCount)) &#123;</div><div class="line">                <span class="keyword">if</span> (word.length() &lt; minLen) &#123;</div><div class="line">                    minLen = word.length();</div><div class="line">                    ans = word;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 统计当前单词的字母出现次数，然后再一波O（26）和licensePlate的字母Count比较</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkComplete</span><span class="params">(String word, <span class="keyword">char</span>[] letterCount)</span> </span>&#123;</div><div class="line">        <span class="keyword">char</span>[] wChar = word.toCharArray();</div><div class="line">        <span class="keyword">char</span>[] thisCount = <span class="keyword">new</span> <span class="keyword">char</span> [LETTER_NUM];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wChar.length; i++) &#123;</div><div class="line">            thisCount[wChar[i] - <span class="string">'a'</span>]++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LETTER_NUM; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (letterCount[i] &gt; <span class="number">0</span> &amp;&amp; thisCount[i] &lt; letterCount[i]) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="750-number-of-corner-rectangles"><a href="#750-number-of-corner-rectangles" class="headerlink" title="750. number-of-corner-rectangles"></a><a href="https://leetcode.com/problems/number-of-corner-rectangles/description/" target="_blank" rel="external">750. number-of-corner-rectangles</a></h4><ul>
<li>给一个只含有0和1的二维数组，求其中四个1所能组成矩形的个数。矩形的边必须横、竖两个方向。</li>
<li>扫描线的思路，取两个行，同时扫竖线，统计同时出现1的pair数作为竖线，然后把这些竖线组合一下即可。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">// 两行一起往右挪找是否有同时为1的，然后根据该平行线的pair数简单排列组合就可以了</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countCornerRectangles</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length - <span class="number">1</span>; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; grid.length; j++) &#123;</div><div class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; grid[<span class="number">0</span>].length; k++) &#123;</div><div class="line">                    <span class="keyword">if</span> (grid[i][k] == <span class="number">1</span> &amp;&amp; grid[j][k] == <span class="number">1</span>) &#123;   <span class="comment">// 两平行线同一列同为1</span></div><div class="line">                        count++;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                ans += count * (count - <span class="number">1</span>) / <span class="number">2</span>;     <span class="comment">// combination</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>└(^o^)┘</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatRewardImg.png" alt="BobbyLiujb WeChat Pay"/>
        <p>WeChat Pay</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipayRewardImg.png" alt="BobbyLiujb Alipay"/>
        <p>Alipay</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java/" rel="tag"># java</a>
          
            <a href="/tags/algorithm/" rel="tag"># algorithm</a>
          
            <a href="/tags/interview/" rel="tag"># interview</a>
          
            <a href="/tags/leetcode/" rel="tag"># leetcode</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/11/28/udacity/" rel="next" title="有代西滴">
                <i class="fa fa-chevron-left"></i> 有代西滴
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- Go to www.addthis.com/dashboard to customize your tools -->
<div class="addthis_inline_share_toolbox">
  <script type = "text/javascript" src = "//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-593135f4e114024c" async = "async" ></script>
</div>

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://ww4.sinaimg.cn/large/9b3a5c2fgw1faysh4xl7ij20bh0bhmy5.jpg"
               alt="BobbyLiujb" />
          <p class="site-author-name" itemprop="name">BobbyLiujb</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">29</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">categories</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">35</span>
                <span class="site-state-item-name">tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#403-frog-jump"><span class="nav-number">1.</span> <span class="nav-text">403. frog-jump</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#405-convert-a-number-to-hexadecimal"><span class="nav-number">2.</span> <span class="nav-text">405. convert-a-number-to-hexadecimal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#424-longest-repeating-character-replacement"><span class="nav-number">3.</span> <span class="nav-text">424. longest-repeating-character-replacement</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#437-path-sum-iii"><span class="nav-number">4.</span> <span class="nav-text">437. path-sum-iii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#438-find-all-anagrams-in-a-string"><span class="nav-number">5.</span> <span class="nav-text">438. find-all-anagrams-in-a-string</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#453-minimum-moves-to-equal-array-elements"><span class="nav-number">6.</span> <span class="nav-text">453. minimum-moves-to-equal-array-elements</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#460-Least-Frequently-Used-Cache"><span class="nav-number">7.</span> <span class="nav-text">460. Least Frequently Used Cache</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#480-sliding-window-median"><span class="nav-number">8.</span> <span class="nav-text">480. sliding-window-median</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#496-next-greater-element-i"><span class="nav-number">9.</span> <span class="nav-text">496. next-greater-element-i</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#503-next-greater-element-ii"><span class="nav-number">10.</span> <span class="nav-text">503. next-greater-element-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#515-find-largest-value-in-each-tree-row"><span class="nav-number">11.</span> <span class="nav-text">515. find-largest-value-in-each-tree-row</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#516-longest-palindromic-subsequence"><span class="nav-number">12.</span> <span class="nav-text">516. longest-palindromic-subsequence</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#529-minesweeper"><span class="nav-number">13.</span> <span class="nav-text">529. minesweeper</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#543-diameter-of-binary-tree"><span class="nav-number">14.</span> <span class="nav-text">543. diameter-of-binary-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#556-next-greater-element-iii"><span class="nav-number">15.</span> <span class="nav-text">556. next-greater-element-iii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#562-longest-line-of-consecutive-one-in-matrix"><span class="nav-number">16.</span> <span class="nav-text">562. longest-line-of-consecutive-one-in-matrix</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#567-permutation-in-string"><span class="nav-number">17.</span> <span class="nav-text">567. permutation-in-string</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#598-range-addition-ii"><span class="nav-number">18.</span> <span class="nav-text">598. range-addition-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#600-non-negative-integers-without-consecutive-ones"><span class="nav-number">19.</span> <span class="nav-text">600. non-negative-integers-without-consecutive-ones</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#604-design-compressed-string-iterator"><span class="nav-number">20.</span> <span class="nav-text">604. design-compressed-string-iterator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#605-can-place-flowers"><span class="nav-number">21.</span> <span class="nav-text">605. can-place-flowers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#606-construct-string-from-binary-tree"><span class="nav-number">22.</span> <span class="nav-text">606. construct-string-from-binary-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#609-find-duplicate-file-in-system"><span class="nav-number">23.</span> <span class="nav-text">609. find-duplicate-file-in-system</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#611-valid-triangle-number"><span class="nav-number">24.</span> <span class="nav-text">611. valid-triangle-number</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#632-smallest-range"><span class="nav-number">25.</span> <span class="nav-text">632. smallest-range</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#637-average-of-levels-in-binary-tree"><span class="nav-number">26.</span> <span class="nav-text">637. average-of-levels-in-binary-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#646-maximum-length-of-pair-chain"><span class="nav-number">27.</span> <span class="nav-text">646. maximum-length-of-pair-chain</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#647-palindromic-substrings"><span class="nav-number">28.</span> <span class="nav-text">647. palindromic-substrings</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#652-find-duplicate-subtrees"><span class="nav-number">29.</span> <span class="nav-text">652. find-duplicate-subtrees</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#653-two-sum-iv-input-is-a-bst"><span class="nav-number">30.</span> <span class="nav-text">653. two-sum-iv-input-is-a-bst</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#670-maximum-swap"><span class="nav-number">31.</span> <span class="nav-text">670. maximum-swap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#673-number-of-longest-increasing-subsequence"><span class="nav-number">32.</span> <span class="nav-text">673. number-of-longest-increasing-subsequence</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#674-longest-continuous-increasing-subsequence"><span class="nav-number">33.</span> <span class="nav-text">674. longest-continuous-increasing-subsequence</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#676-implement-magic-dictionary"><span class="nav-number">34.</span> <span class="nav-text">676. implement-magic-dictionary</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#680-valid-palindrome-ii"><span class="nav-number">35.</span> <span class="nav-text">680. valid-palindrome-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#684-redundant-connection"><span class="nav-number">36.</span> <span class="nav-text">684. redundant-connection</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#685-redundant-connection-ii"><span class="nav-number">37.</span> <span class="nav-text">685. redundant-connection-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#686-repeated-string-match"><span class="nav-number">38.</span> <span class="nav-text">686. repeated-string-match</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#687-longest-univalue-path"><span class="nav-number">39.</span> <span class="nav-text">687. longest-univalue-path</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#689-maximum-sum-of-3-non-overlapping-subarrays"><span class="nav-number">40.</span> <span class="nav-text">689. maximum-sum-of-3-non-overlapping-subarrays</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#714-best-time-to-buy-and-sell-stock-with-transaction-fee"><span class="nav-number">41.</span> <span class="nav-text">714. best-time-to-buy-and-sell-stock-with-transaction-fee</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#719-find-k-th-smallest-pair-distance"><span class="nav-number">42.</span> <span class="nav-text">719. find-k-th-smallest-pair-distance</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#721-accounts-merge"><span class="nav-number">43.</span> <span class="nav-text">721. accounts-merge</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#726-number-of-atoms"><span class="nav-number">44.</span> <span class="nav-text">726. number-of-atoms</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#727-minimum-window-subsequence"><span class="nav-number">45.</span> <span class="nav-text">727. minimum-window-subsequence</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#729-my-calendar-i"><span class="nav-number">46.</span> <span class="nav-text">729. my-calendar-i</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#731-my-calendar-ii"><span class="nav-number">47.</span> <span class="nav-text">731. my-calendar-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#734-sentence-similarity"><span class="nav-number">48.</span> <span class="nav-text">734. sentence-similarity</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#737-sentence-similarity-ii"><span class="nav-number">49.</span> <span class="nav-text">737. sentence-similarity-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#739-daily-temperatures"><span class="nav-number">50.</span> <span class="nav-text">739. daily-temperatures</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#745-prefix-and-suffix-search"><span class="nav-number">51.</span> <span class="nav-text">745. prefix-and-suffix-search</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#748-shortest-completing-word"><span class="nav-number">52.</span> <span class="nav-text">748. shortest-completing-word</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#750-number-of-corner-rectangles"><span class="nav-number">53.</span> <span class="nav-text">750. number-of-corner-rectangles</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 &mdash; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">BobbyLiujb</span>

  
</div>


  <div class="powered-by">
    Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
  </div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">
    Theme &mdash;
    <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
      NexT.Mist
    </a>
  </div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  

  

    
      <script id="dsq-count-scr" src="https://bobbyliujb.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://bobbyliujb.github.io/2018/01/05/java_leetcode5/';
          this.page.identifier = '2018/01/05/java_leetcode5/';
          this.page.title = 'Note for LeetCode in Java (401~800)';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://bobbyliujb.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  



	





  










  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("jT7i5auNazMHRONSPUHmcoko-gzGzoHsz", "dEWwuVre5Svmwvjw2DmcIbLy");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  

</body>
</html>
