<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"bobbyliujb.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"hide","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="刷题。祝我好运。">
<meta property="og:type" content="article">
<meta property="og:title" content="Note for LeetCode in Java (401~800)">
<meta property="og:url" content="https://bobbyliujb.github.io/2018/01/05/java_leetcode5/index.html">
<meta property="og:site_name" content="Bob&#39;s Blog">
<meta property="og:description" content="刷题。祝我好运。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2018-01-06T00:49:39.000Z">
<meta property="article:modified_time" content="2021-04-24T00:44:15.830Z">
<meta property="article:author" content="Bob">
<meta property="article:tag" content="java">
<meta property="article:tag" content="algorithm">
<meta property="article:tag" content="interview">
<meta property="article:tag" content="leetcode">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://bobbyliujb.github.io/2018/01/05/java_leetcode5/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://bobbyliujb.github.io/2018/01/05/java_leetcode5/","path":"2018/01/05/java_leetcode5/","title":"Note for LeetCode in Java (401~800)"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Note for LeetCode in Java (401~800) | Bob's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-118868735-1"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-118868735-1","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js" defer></script>








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Bob's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#402-remove-k-digits"><span class="nav-number">1.</span> <span class="nav-text">402. remove-k-digits</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#403-frog-jump"><span class="nav-number">2.</span> <span class="nav-text">403. frog-jump</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#404-sum-of-left-leaves"><span class="nav-number">3.</span> <span class="nav-text">404. sum-of-left-leaves</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#405-convert-a-number-to-hexadecimal"><span class="nav-number">4.</span> <span class="nav-text">405. convert-a-number-to-hexadecimal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#409-valid-word-abbreviation"><span class="nav-number">5.</span> <span class="nav-text">409. valid-word-abbreviation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#410-split-array-largest-sum"><span class="nav-number">6.</span> <span class="nav-text">410. split-array-largest-sum</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#412-FizzBuzz"><span class="nav-number">7.</span> <span class="nav-text">412. FizzBuzz</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#413-arithmetic-slices"><span class="nav-number">8.</span> <span class="nav-text">413. arithmetic-slices</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#414-third-maximum-number"><span class="nav-number">9.</span> <span class="nav-text">414. third-maximum-number</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#416-partition-equal-subset-sum"><span class="nav-number">10.</span> <span class="nav-text">416. partition-equal-subset-sum</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#417-pacific-atlantic-water-flow"><span class="nav-number">11.</span> <span class="nav-text">417. pacific-atlantic-water-flow</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#419-battleships-in-a-board"><span class="nav-number">12.</span> <span class="nav-text">419. battleships-in-a-board</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#424-longest-repeating-character-replacement"><span class="nav-number">13.</span> <span class="nav-text">424. longest-repeating-character-replacement</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#425-word-squares"><span class="nav-number">14.</span> <span class="nav-text">425. word-squares</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#426-convert-binary-search-tree-to-sorted-doubly-linked-list"><span class="nav-number">15.</span> <span class="nav-text">426. convert-binary-search-tree-to-sorted-doubly-linked-list</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#428-serialize-and-deserialize-n-ary-tree"><span class="nav-number">16.</span> <span class="nav-text">428. serialize-and-deserialize-n-ary-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#430-flatten-a-multilevel-doubly-linked-list"><span class="nav-number">17.</span> <span class="nav-text">430. flatten-a-multilevel-doubly-linked-list</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#432-encode-n-ary-tree-to-binary-tree"><span class="nav-number">18.</span> <span class="nav-text">432. encode-n-ary-tree-to-binary-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#435-non-overlapping-intervals"><span class="nav-number">19.</span> <span class="nav-text">435. non-overlapping-intervals</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#437-path-sum-iii"><span class="nav-number">20.</span> <span class="nav-text">437. path-sum-iii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#438-find-all-anagrams-in-a-string"><span class="nav-number">21.</span> <span class="nav-text">438. find-all-anagrams-in-a-string</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#439-ternary-expression-parser"><span class="nav-number">22.</span> <span class="nav-text">439. ternary-expression-parser</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#442-find-all-duplicates-in-an-array"><span class="nav-number">23.</span> <span class="nav-text">442. find-all-duplicates-in-an-array</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#443-string-compression"><span class="nav-number">24.</span> <span class="nav-text">443. string-compression</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#444-sequence-reconstruction"><span class="nav-number">25.</span> <span class="nav-text">444. sequence-reconstruction</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#445-add-two-numbers-ii"><span class="nav-number">26.</span> <span class="nav-text">445. add-two-numbers-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#448-find-all-numbers-disappeared-in-an-array"><span class="nav-number">27.</span> <span class="nav-text">448. find-all-numbers-disappeared-in-an-array</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#449-serialize-and-deserialize-bst"><span class="nav-number">28.</span> <span class="nav-text">449. serialize-and-deserialize-bst</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#450-delete-node-in-a-bst"><span class="nav-number">29.</span> <span class="nav-text">450. delete-node-in-a-bst</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#452-minimum-number-of-arrows-to-burst-balloons"><span class="nav-number">30.</span> <span class="nav-text">452. minimum-number-of-arrows-to-burst-balloons</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#453-minimum-moves-to-equal-array-elements"><span class="nav-number">31.</span> <span class="nav-text">453. minimum-moves-to-equal-array-elements</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#454-4sum-ii"><span class="nav-number">32.</span> <span class="nav-text">454. 4sum-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#456-132-pattern"><span class="nav-number">33.</span> <span class="nav-text">456. 132-pattern</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#457-circular-array-loop"><span class="nav-number">34.</span> <span class="nav-text">457. circular-array-loop</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#459-repeated-substring-pattern"><span class="nav-number">35.</span> <span class="nav-text">459. repeated-substring-pattern</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#460-Least-Frequently-Used-Cache"><span class="nav-number">36.</span> <span class="nav-text">460. Least Frequently Used Cache</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#461-hamming-distance"><span class="nav-number">37.</span> <span class="nav-text">461. hamming-distance</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#463-island-perimeter"><span class="nav-number">38.</span> <span class="nav-text">463. island-perimeter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#464-can-i-win"><span class="nav-number">39.</span> <span class="nav-text">464. can-i-win</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#468-validate-ip-address"><span class="nav-number">40.</span> <span class="nav-text">468. validate-ip-address</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#470-implement-rand10-using-rand7"><span class="nav-number">41.</span> <span class="nav-text">470. implement-rand10-using-rand7</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#471-encode-string-with-shortest-length"><span class="nav-number">42.</span> <span class="nav-text">471. encode-string-with-shortest-length</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#472-concatenated-words"><span class="nav-number">43.</span> <span class="nav-text">472. concatenated-words</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#475-heaters"><span class="nav-number">44.</span> <span class="nav-text">475. heaters</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#476-number-complement"><span class="nav-number">45.</span> <span class="nav-text">476. number-complement</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#477-total-hamming-distance"><span class="nav-number">46.</span> <span class="nav-text">477. total-hamming-distance</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#480-sliding-window-median"><span class="nav-number">47.</span> <span class="nav-text">480. sliding-window-median</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#482-license-key-formatting"><span class="nav-number">48.</span> <span class="nav-text">482. license-key-formatting</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#484-find-permutation"><span class="nav-number">49.</span> <span class="nav-text">484. find-permutation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#485-max-consecutive-ones"><span class="nav-number">50.</span> <span class="nav-text">485. max-consecutive-ones</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#486-predict-the-winner"><span class="nav-number">51.</span> <span class="nav-text">486. predict-the-winner</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#487-max-consecutive-ones-ii"><span class="nav-number">52.</span> <span class="nav-text">487. max-consecutive-ones-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#489-robot-room-cleaner"><span class="nav-number">53.</span> <span class="nav-text">489. robot-room-cleaner</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#490-the-maze"><span class="nav-number">54.</span> <span class="nav-text">490. the-maze</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#494-target-sum"><span class="nav-number">55.</span> <span class="nav-text">494. target-sum</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#495-teemo-attacking"><span class="nav-number">56.</span> <span class="nav-text">495. teemo-attacking</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#496-next-greater-element-i"><span class="nav-number">57.</span> <span class="nav-text">496. next-greater-element-i</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#498-diagonal-traverse"><span class="nav-number">58.</span> <span class="nav-text">498. diagonal-traverse</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#499-the-maze-iii"><span class="nav-number">59.</span> <span class="nav-text">499. the-maze-iii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#503-next-greater-element-ii"><span class="nav-number">60.</span> <span class="nav-text">503. next-greater-element-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#505-the-maze-ii"><span class="nav-number">61.</span> <span class="nav-text">505. the-maze-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#508-most-frequent-subtree-sum"><span class="nav-number">62.</span> <span class="nav-text">508. most-frequent-subtree-sum</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#509-fibonacci-number"><span class="nav-number">63.</span> <span class="nav-text">509. fibonacci-number</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#510-inorder-successor-in-bst-ii"><span class="nav-number">64.</span> <span class="nav-text">510. inorder-successor-in-bst-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#513-find-bottom-left-tree-value"><span class="nav-number">65.</span> <span class="nav-text">513. find-bottom-left-tree-value</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#515-find-largest-value-in-each-tree-row"><span class="nav-number">66.</span> <span class="nav-text">515. find-largest-value-in-each-tree-row</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#516-longest-palindromic-subsequence"><span class="nav-number">67.</span> <span class="nav-text">516. longest-palindromic-subsequence</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#518-coin-change-2"><span class="nav-number">68.</span> <span class="nav-text">518. coin-change-2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#523-continuous-subarray-sum"><span class="nav-number">69.</span> <span class="nav-text">523. continuous-subarray-sum</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#524-longest-word-in-dictionary-through-deleting"><span class="nav-number">70.</span> <span class="nav-text">524. longest-word-in-dictionary-through-deleting</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#525-contiguous-array"><span class="nav-number">71.</span> <span class="nav-text">525. contiguous-array</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#526-beautiful-arrangement"><span class="nav-number">72.</span> <span class="nav-text">526. beautiful-arrangement</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#528-random-pick-with-weight"><span class="nav-number">73.</span> <span class="nav-text">528. random-pick-with-weight</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#529-minesweeper"><span class="nav-number">74.</span> <span class="nav-text">529. minesweeper</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#530-minimum-absolute-difference-in-bst"><span class="nav-number">75.</span> <span class="nav-text">530. minimum-absolute-difference-in-bst</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#532-k-diff-pairs-in-an-array"><span class="nav-number">76.</span> <span class="nav-text">532. k-diff-pairs-in-an-array</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#535-encode-and-decode-tinyurl"><span class="nav-number">77.</span> <span class="nav-text">535. encode-and-decode-tinyurl</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#536-construct-binary-tree-from-string"><span class="nav-number">78.</span> <span class="nav-text">536. construct-binary-tree-from-string</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#538-convert-bst-to-greater-tree"><span class="nav-number">79.</span> <span class="nav-text">538. convert-bst-to-greater-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#539-minimum-time-difference"><span class="nav-number">80.</span> <span class="nav-text">539. minimum-time-difference</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#540-single-element-in-a-sorted-array"><span class="nav-number">81.</span> <span class="nav-text">540. single-element-in-a-sorted-array</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#543-diameter-of-binary-tree"><span class="nav-number">82.</span> <span class="nav-text">543. diameter-of-binary-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#544-output-contest-matches"><span class="nav-number">83.</span> <span class="nav-text">544. output-contest-matches</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#545-boundary-of-binary-tree"><span class="nav-number">84.</span> <span class="nav-text">545. boundary-of-binary-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#547-friend-circles"><span class="nav-number">85.</span> <span class="nav-text">547. friend-circles</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#548-split-array-with-equal-sum"><span class="nav-number">86.</span> <span class="nav-text">548. split-array-with-equal-sum</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#549-binary-tree-longest-consecutive-sequence-ii"><span class="nav-number">87.</span> <span class="nav-text">549. binary-tree-longest-consecutive-sequence-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#551-student-attendance-record-i"><span class="nav-number">88.</span> <span class="nav-text">551. student-attendance-record-i</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#554-brick-wall"><span class="nav-number">89.</span> <span class="nav-text">554. brick-wall</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#556-next-greater-element-iii"><span class="nav-number">90.</span> <span class="nav-text">556. next-greater-element-iii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#559-maximum-depth-of-n-ary-tree"><span class="nav-number">91.</span> <span class="nav-text">559. maximum-depth-of-n-ary-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#560-subarray-sum-equals-k"><span class="nav-number">92.</span> <span class="nav-text">560. subarray-sum-equals-k</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#562-longest-line-of-consecutive-one-in-matrix"><span class="nav-number">93.</span> <span class="nav-text">562. longest-line-of-consecutive-one-in-matrix</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#563-binary-tree-tilt"><span class="nav-number">94.</span> <span class="nav-text">563. binary-tree-tilt</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#565-array-nesting"><span class="nav-number">95.</span> <span class="nav-text">565. array-nesting</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#566-reshape-the-matrix"><span class="nav-number">96.</span> <span class="nav-text">566. reshape-the-matrix</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#567-permutation-in-string"><span class="nav-number">97.</span> <span class="nav-text">567. permutation-in-string</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#572-subtree-of-another-tree"><span class="nav-number">98.</span> <span class="nav-text">572. subtree-of-another-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#575-distribute-candies"><span class="nav-number">99.</span> <span class="nav-text">575. distribute-candies</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#581-shortest-unsorted-continuous-subarray"><span class="nav-number">100.</span> <span class="nav-text">581. shortest-unsorted-continuous-subarray</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#582-kill-process"><span class="nav-number">101.</span> <span class="nav-text">582. kill-process</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#594-longest-harmonious-subsequence"><span class="nav-number">102.</span> <span class="nav-text">594. longest-harmonious-subsequence</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#598-range-addition-ii"><span class="nav-number">103.</span> <span class="nav-text">598. range-addition-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#600-non-negative-integers-without-consecutive-ones"><span class="nav-number">104.</span> <span class="nav-text">600. non-negative-integers-without-consecutive-ones</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#604-design-compressed-string-iterator"><span class="nav-number">105.</span> <span class="nav-text">604. design-compressed-string-iterator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#605-can-place-flowers"><span class="nav-number">106.</span> <span class="nav-text">605. can-place-flowers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#606-construct-string-from-binary-tree"><span class="nav-number">107.</span> <span class="nav-text">606. construct-string-from-binary-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#609-find-duplicate-file-in-system"><span class="nav-number">108.</span> <span class="nav-text">609. find-duplicate-file-in-system</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#611-valid-triangle-number"><span class="nav-number">109.</span> <span class="nav-text">611. valid-triangle-number</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#616-add-bold-tag-in-string"><span class="nav-number">110.</span> <span class="nav-text">616. add-bold-tag-in-string</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#621-task-scheduler"><span class="nav-number">111.</span> <span class="nav-text">621. task-scheduler</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#622-design-circular-queue-https-leetcode-com-problems-design-circular-queue"><span class="nav-number">112.</span> <span class="nav-text">[622. design-circular-queue] (https:&#x2F;&#x2F;leetcode.com&#x2F;problems&#x2F;design-circular-queue&#x2F;)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#623-add-one-row-to-tree"><span class="nav-number">113.</span> <span class="nav-text">623. add-one-row-to-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#624-design-search-autocomplete-system"><span class="nav-number">114.</span> <span class="nav-text">624. design-search-autocomplete-system</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#628-maximum-product-of-three-numbers"><span class="nav-number">115.</span> <span class="nav-text">628. maximum-product-of-three-numbers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#631-design-excel-sum-formula"><span class="nav-number">116.</span> <span class="nav-text">631. design-excel-sum-formula</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#632-smallest-range"><span class="nav-number">117.</span> <span class="nav-text">632. smallest-range</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#633-sum-of-square-numbers"><span class="nav-number">118.</span> <span class="nav-text">633. sum-of-square-numbers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#636-exclusive-time-of-functions"><span class="nav-number">119.</span> <span class="nav-text">636. exclusive-time-of-functions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#637-average-of-levels-in-binary-tree"><span class="nav-number">120.</span> <span class="nav-text">637. average-of-levels-in-binary-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#638-shopping-offers"><span class="nav-number">121.</span> <span class="nav-text">638. shopping-offers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#646-maximum-length-of-pair-chain"><span class="nav-number">122.</span> <span class="nav-text">646. maximum-length-of-pair-chain</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#647-palindromic-substrings"><span class="nav-number">123.</span> <span class="nav-text">647. palindromic-substrings</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#648-replace-words"><span class="nav-number">124.</span> <span class="nav-text">648. replace-words</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#650-2-keys-keyboard"><span class="nav-number">125.</span> <span class="nav-text">650. 2-keys-keyboard</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#651-4-keys-keyboard"><span class="nav-number">126.</span> <span class="nav-text">651. 4-keys-keyboard</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#652-find-duplicate-subtrees"><span class="nav-number">127.</span> <span class="nav-text">652. find-duplicate-subtrees</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#653-two-sum-iv-input-is-a-bst"><span class="nav-number">128.</span> <span class="nav-text">653. two-sum-iv-input-is-a-bst</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#654-maximum-binary-tree"><span class="nav-number">129.</span> <span class="nav-text">654. maximum-binary-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#655-print-binary-tree"><span class="nav-number">130.</span> <span class="nav-text">655. print-binary-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#657-judge-route-circle"><span class="nav-number">131.</span> <span class="nav-text">657. judge-route-circle</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#658-find-k-closest-elements"><span class="nav-number">132.</span> <span class="nav-text">658. find-k-closest-elements</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#662-maximum-width-of-binary-tree"><span class="nav-number">133.</span> <span class="nav-text">662. maximum-width-of-binary-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#663-equal-tree-partition"><span class="nav-number">134.</span> <span class="nav-text">663. equal-tree-partition</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#665-non-decreasing-array"><span class="nav-number">135.</span> <span class="nav-text">665. non-decreasing-array</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#666-path-sum-iv"><span class="nav-number">136.</span> <span class="nav-text">666. path-sum-iv</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#669-trim-a-binary-search-tree"><span class="nav-number">137.</span> <span class="nav-text">669. trim-a-binary-search-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#670-maximum-swap"><span class="nav-number">138.</span> <span class="nav-text">670. maximum-swap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#671-second-minimum-node-in-a-binary-tree"><span class="nav-number">139.</span> <span class="nav-text">671. second-minimum-node-in-a-binary-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#673-number-of-longest-increasing-subsequence"><span class="nav-number">140.</span> <span class="nav-text">673. number-of-longest-increasing-subsequence</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#674-longest-continuous-increasing-subsequence"><span class="nav-number">141.</span> <span class="nav-text">674. longest-continuous-increasing-subsequence</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#676-implement-magic-dictionary"><span class="nav-number">142.</span> <span class="nav-text">676. implement-magic-dictionary</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#678-valid-parenthesis-string"><span class="nav-number">143.</span> <span class="nav-text">678. valid-parenthesis-string</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#680-valid-palindrome-ii"><span class="nav-number">144.</span> <span class="nav-text">680. valid-palindrome-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#681-next-closest-time"><span class="nav-number">145.</span> <span class="nav-text">681. next-closest-time</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#682-baseball-game"><span class="nav-number">146.</span> <span class="nav-text">682. baseball-game</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#683-k-empty-slots"><span class="nav-number">147.</span> <span class="nav-text">683. k-empty-slots</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#684-redundant-connection"><span class="nav-number">148.</span> <span class="nav-text">684. redundant-connection</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#685-redundant-connection-ii"><span class="nav-number">149.</span> <span class="nav-text">685. redundant-connection-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#686-repeated-string-match"><span class="nav-number">150.</span> <span class="nav-text">686. repeated-string-match</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#687-longest-univalue-path"><span class="nav-number">151.</span> <span class="nav-text">687. longest-univalue-path</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#688-knight-probability-in-chessboard"><span class="nav-number">152.</span> <span class="nav-text">688. knight-probability-in-chessboard</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#689-maximum-sum-of-3-non-overlapping-subarrays"><span class="nav-number">153.</span> <span class="nav-text">689. maximum-sum-of-3-non-overlapping-subarrays</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#690-employee-importance"><span class="nav-number">154.</span> <span class="nav-text">690. employee-importance</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#692-top-k-frequent-words"><span class="nav-number">155.</span> <span class="nav-text">692. top-k-frequent-words</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#694-number-of-distinct-islands"><span class="nav-number">156.</span> <span class="nav-text">694. number-of-distinct-islands</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#695-max-area-of-island"><span class="nav-number">157.</span> <span class="nav-text">695. max-area-of-island</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#696-count-binary-substrings"><span class="nav-number">158.</span> <span class="nav-text">696. count-binary-substrings</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#697-degree-of-an-array"><span class="nav-number">159.</span> <span class="nav-text">697. degree-of-an-array</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#698-partition-to-k-equal-sum-subsets"><span class="nav-number">160.</span> <span class="nav-text">698. partition-to-k-equal-sum-subsets</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#699-falling-squares"><span class="nav-number">161.</span> <span class="nav-text">699. falling-squares</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#700-search-in-a-binary-search-tree"><span class="nav-number">162.</span> <span class="nav-text">700. search-in-a-binary-search-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#701-insert-into-a-binary-search-tree"><span class="nav-number">163.</span> <span class="nav-text">701. insert-into-a-binary-search-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#703-kth-largest-element-in-a-stream"><span class="nav-number">164.</span> <span class="nav-text">703. kth-largest-element-in-a-stream</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#704-binary-search"><span class="nav-number">165.</span> <span class="nav-text">704. binary-search</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#706-design-hashmap"><span class="nav-number">166.</span> <span class="nav-text">706. design-hashmap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#708-insert-into-a-cyclic-sorted-list"><span class="nav-number">167.</span> <span class="nav-text">708. insert-into-a-cyclic-sorted-list</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#709-to-lower-case"><span class="nav-number">168.</span> <span class="nav-text">709. to-lower-case</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#711-number-of-distinct-islands-ii"><span class="nav-number">169.</span> <span class="nav-text">711. number-of-distinct-islands-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#712-minimum-ascii-delete-sum-for-two-strings"><span class="nav-number">170.</span> <span class="nav-text">712. minimum-ascii-delete-sum-for-two-strings</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#713-subarray-product-less-than-k"><span class="nav-number">171.</span> <span class="nav-text">713. subarray-product-less-than-k</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#714-best-time-to-buy-and-sell-stock-with-transaction-fee"><span class="nav-number">172.</span> <span class="nav-text">714. best-time-to-buy-and-sell-stock-with-transaction-fee</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#716-max-stack"><span class="nav-number">173.</span> <span class="nav-text">716. max-stack</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#717-1-bit-and-2-bit-characters"><span class="nav-number">174.</span> <span class="nav-text">717. 1-bit-and-2-bit-characters</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#718-maximum-length-of-repeated-subarray"><span class="nav-number">175.</span> <span class="nav-text">718. maximum-length-of-repeated-subarray</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#719-find-k-th-smallest-pair-distance"><span class="nav-number">176.</span> <span class="nav-text">719. find-k-th-smallest-pair-distance</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#720-longest-word-in-dictionary"><span class="nav-number">177.</span> <span class="nav-text">720. longest-word-in-dictionary</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#721-accounts-merge"><span class="nav-number">178.</span> <span class="nav-text">721. accounts-merge</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#722-remove-comments"><span class="nav-number">179.</span> <span class="nav-text">722. remove-comments</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#723-candy-crush"><span class="nav-number">180.</span> <span class="nav-text">723. candy-crush</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#724-find-pivot-index"><span class="nav-number">181.</span> <span class="nav-text">724. find-pivot-index</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#726-number-of-atoms"><span class="nav-number">182.</span> <span class="nav-text">726. number-of-atoms</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#727-minimum-window-subsequence"><span class="nav-number">183.</span> <span class="nav-text">727. minimum-window-subsequence</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#729-my-calendar-i"><span class="nav-number">184.</span> <span class="nav-text">729. my-calendar-i</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#731-my-calendar-ii"><span class="nav-number">185.</span> <span class="nav-text">731. my-calendar-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#733-flood-fill"><span class="nav-number">186.</span> <span class="nav-text">733. flood-fill</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#734-sentence-similarity"><span class="nav-number">187.</span> <span class="nav-text">734. sentence-similarity</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#735-asteroid-collision"><span class="nav-number">188.</span> <span class="nav-text">735. asteroid-collision</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#737-sentence-similarity-ii"><span class="nav-number">189.</span> <span class="nav-text">737. sentence-similarity-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#739-daily-temperatures"><span class="nav-number">190.</span> <span class="nav-text">739. daily-temperatures</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#740-delete-and-earn"><span class="nav-number">191.</span> <span class="nav-text">740. delete-and-earn</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#741-cherry-pickup"><span class="nav-number">192.</span> <span class="nav-text">741. cherry-pickup</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#742-closest-leaf-in-a-binary-tree"><span class="nav-number">193.</span> <span class="nav-text">742. closest-leaf-in-a-binary-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#743-network-delay-time"><span class="nav-number">194.</span> <span class="nav-text">743. network-delay-time</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#744-find-smallest-letter-greater-than-target"><span class="nav-number">195.</span> <span class="nav-text">744. find-smallest-letter-greater-than-target</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#745-prefix-and-suffix-search"><span class="nav-number">196.</span> <span class="nav-text">745. prefix-and-suffix-search</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#747-largest-number-at-least-twice-of-others"><span class="nav-number">197.</span> <span class="nav-text">747. largest-number-at-least-twice-of-others</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#748-shortest-completing-word"><span class="nav-number">198.</span> <span class="nav-text">748. shortest-completing-word</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#749-contain-virus"><span class="nav-number">199.</span> <span class="nav-text">749. contain-virus</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#750-number-of-corner-rectangles"><span class="nav-number">200.</span> <span class="nav-text">750. number-of-corner-rectangles</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#752-open-the-lock"><span class="nav-number">201.</span> <span class="nav-text">752. open-the-lock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#759-employee-free-time"><span class="nav-number">202.</span> <span class="nav-text">759. employee-free-time</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#760-find-anagram-mappings"><span class="nav-number">203.</span> <span class="nav-text">760. find-anagram-mappings</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#763-partition-labels"><span class="nav-number">204.</span> <span class="nav-text">763. partition-labels</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#764-largest-plus-sign"><span class="nav-number">205.</span> <span class="nav-text">764. largest-plus-sign</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#765-couples-holding-hands"><span class="nav-number">206.</span> <span class="nav-text">765. couples-holding-hands</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#767-reorganize-string"><span class="nav-number">207.</span> <span class="nav-text">767. reorganize-string</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#768-max-chunks-to-make-sorted-ii"><span class="nav-number">208.</span> <span class="nav-text">768. max-chunks-to-make-sorted-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#769-max-chunks-to-make-sorted"><span class="nav-number">209.</span> <span class="nav-text">769. max-chunks-to-make-sorted</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#771-jewels-and-stones"><span class="nav-number">210.</span> <span class="nav-text">771. jewels-and-stones</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#773-sliding-puzzle"><span class="nav-number">211.</span> <span class="nav-text">773. sliding-puzzle</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#775-global-and-local-inversions"><span class="nav-number">212.</span> <span class="nav-text">775. global-and-local-inversions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#776-split-bst"><span class="nav-number">213.</span> <span class="nav-text">776. split-bst</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#777-swap-adjacent-in-lr-string"><span class="nav-number">214.</span> <span class="nav-text">777. swap-adjacent-in-lr-string</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#778-swim-in-rising-water"><span class="nav-number">215.</span> <span class="nav-text">778. swim-in-rising-water</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#785-is-graph-bipartite"><span class="nav-number">216.</span> <span class="nav-text">785. is-graph-bipartite</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#787-cheapest-flights-within-k-stops"><span class="nav-number">217.</span> <span class="nav-text">787. cheapest-flights-within-k-stops</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#788-rotated-digits"><span class="nav-number">218.</span> <span class="nav-text">788. rotated-digits</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#791-custom-sort-string"><span class="nav-number">219.</span> <span class="nav-text">791. custom-sort-string</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#792-number-of-matching-subsequences"><span class="nav-number">220.</span> <span class="nav-text">792. number-of-matching-subsequences</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#794-valid-tic-tac-toe-state"><span class="nav-number">221.</span> <span class="nav-text">794. valid-tic-tac-toe-state</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#795-number-of-subarrays-with-bounded-maximum"><span class="nav-number">222.</span> <span class="nav-text">795. number-of-subarrays-with-bounded-maximum</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#796-rotate-string"><span class="nav-number">223.</span> <span class="nav-text">796. rotate-string</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Bob"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Bob</p>
  <div class="site-description" itemprop="description">I'm a Software Engineer!</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">50</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://bobbyliujb.github.io/2018/01/05/java_leetcode5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bob">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bob's Blog">
      <meta itemprop="description" content="I'm a Software Engineer!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Note for LeetCode in Java (401~800) | Bob's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Note for LeetCode in Java (401~800)
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-01-05 16:49:39" itemprop="dateCreated datePublished" datetime="2018-01-05T16:49:39-08:00">2018-01-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-04-23 17:44:15" itemprop="dateModified" datetime="2021-04-23T17:44:15-07:00">2021-04-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Tech/" itemprop="url" rel="index"><span itemprop="name">Tech</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2018/01/05/java_leetcode5/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/01/05/java_leetcode5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>刷题。祝我好运。</p>
<span id="more"></span>

<h4 id="402-remove-k-digits"><a href="#402-remove-k-digits" class="headerlink" title="402. remove-k-digits"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-k-digits/">402. remove-k-digits</a></h4><ul>
<li>给一个纯数字组成的字符串，给一个整数k，要求删除k个数字后得到的数尽可能地小。例如<code>112</code>删除2个后需要得到<code>1</code>。</li>
<li>找到规律，使用stack的思路+贪心法，每次将数字入栈，若当前数字比栈顶小，说明前面的数字应当删除，一直删除到栈顶数字不再比当前数字大，再入栈。最后保留下来的数字不一定删够了k个，需要twick索引只保留一部分栈里剩下的数字。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeKdigits</span><span class="params">(String num, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="literal">null</span> || num.length() == <span class="number">0</span> || k &gt;= num.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] numChars = num.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] newNumChars = <span class="keyword">new</span> <span class="title class_">char</span>[num.length()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numChars.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (index &gt; <span class="number">0</span> &amp;&amp; newNumChars[index - <span class="number">1</span>] &gt; numChars[i] &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                index--;</span><br><span class="line">                k--;    <span class="comment">// 持续删除直到栈顶数字足够小</span></span><br><span class="line">            &#125;</span><br><span class="line">            newNumChars[index++] = numChars[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; index &amp;&amp; newNumChars[start] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后剩下index个数字，只保留[start, index - start - k]的部分</span></span><br><span class="line">        <span class="keyword">return</span> start == index ? <span class="string">&quot;0&quot;</span> : <span class="keyword">new</span> <span class="title class_">String</span>(newNumChars, start, index - start - k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="403-frog-jump"><a href="#403-frog-jump" class="headerlink" title="403. frog-jump"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/frog-jump/description/">403. frog-jump</a></h4><ul>
<li>给一个数组表示石头所处的x坐标，青蛙每次只能跳上一次跳跃长度的-1,0,1三种可能，判断能否跳到最后一个石头。例如<code>[0,1,3,5,6,8,12,17]</code>是可以的，而<code>[0,1,2,3,4,8,9,11]</code>就不行。</li>
<li>相当于BFS，每个石头处维护一个set存放他可以跳的长度，然后每次都往后跳看看能否有新的石头，有就更新那个石头的可跳长度。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BFS，从开头出发，不断更新后续可达石头的新步数，若中途更新到了最后一个石头，就可达</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canCross</span><span class="params">(<span class="type">int</span>[] stones)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (stones == <span class="literal">null</span> || stones.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stones[<span class="number">0</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录每个坐标的石头所能跳的长度</span></span><br><span class="line">    Map&lt;Integer, Set&lt;Integer&gt;&gt; stone2step = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stones.length; i++) &#123;</span><br><span class="line">        stone2step.put(stones[i], <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    stone2step.get(<span class="number">0</span>).add(<span class="number">1</span>);   <span class="comment">// 第一步起码要能往后挪一步</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从第一个石头开始，往后更新每个石头的能跳步数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stones.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">currStone</span> <span class="operator">=</span> stones[i];</span><br><span class="line">        Set&lt;Integer&gt; steps = stone2step.get(currStone);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> step: steps) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newStone</span> <span class="operator">=</span> currStone + step;</span><br><span class="line">            <span class="keyword">if</span> (newStone == stones[stones.length - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Set&lt;Integer&gt; newStep = stone2step.get(newStone);</span><br><span class="line">            <span class="keyword">if</span> (newStep != <span class="literal">null</span>) &#123;   <span class="comment">// 表示有这个新石头的坐标</span></span><br><span class="line">                newStep.add(step + <span class="number">1</span>);</span><br><span class="line">                newStep.add(step);</span><br><span class="line">                <span class="keyword">if</span> (step - <span class="number">1</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    newStep.add(step - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="404-sum-of-left-leaves"><a href="#404-sum-of-left-leaves" class="headerlink" title="404. sum-of-left-leaves"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sum-of-left-leaves/description/">404. sum-of-left-leaves</a></h4><ul>
<li>给一个数，求所有左叶子的和。</li>
<li>递归求，只有是左孩子且是叶子才返回node.val。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sumOfLeftLeaves(root, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode node, <span class="type">boolean</span> isLeft)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> isLeft ? node.val : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sumOfLeftLeaves(node.left, <span class="literal">true</span>) + sumOfLeftLeaves(node.right, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="405-convert-a-number-to-hexadecimal"><a href="#405-convert-a-number-to-hexadecimal" class="headerlink" title="405. convert-a-number-to-hexadecimal"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/convert-a-number-to-hexadecimal/description/">405. convert-a-number-to-hexadecimal</a></h4><ul>
<li>将数字转换为十六进制字符串。</li>
<li>方法一：利用mask每次只取最后四个bit，然后直接map到字符拼接到hexStr的最前面，然后unsigned shift四位。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">private</span> <span class="type">char</span>[] map = &#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">private</span> <span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toHex</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">hexStr</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">        hexStr = map[(num &amp; mask)] + hexStr;</span><br><span class="line">        num = (num &gt;&gt;&gt; <span class="number">4</span>);  <span class="comment">// 不保留最高位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hexStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：更general的做法，可以推广到十进制转任意进制字符串。不过首先需要转成long并且过滤掉long前面填充的一堆符号位，然后取模得到的就是当前位的数值，直接map到字符；然后继续除。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">private</span> <span class="type">char</span>[] map = &#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toHex</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">longNum</span> <span class="operator">=</span> num &amp; <span class="number">0x00000000ffffffffL</span>;   <span class="comment">// 不能直接强制转换，不然会保留符号</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">hexStr</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (longNum != <span class="number">0</span>) &#123;</span><br><span class="line">        hexStr = map[(<span class="type">int</span>)(longNum % <span class="number">16</span>)] + hexStr;</span><br><span class="line">        longNum /= <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hexStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="409-valid-word-abbreviation"><a href="#409-valid-word-abbreviation" class="headerlink" title="409. valid-word-abbreviation"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-word-abbreviation/">409. valid-word-abbreviation</a></h4><ul>
<li>给两个字符串word和abbr，word只含有小写字母，abbr除小写字母外含有数字表示可以替换成多少个字母，判断abbr是否是word的简写。例如<code>word</code>可以简写成<code>w2d</code>。</li>
<li>注意corner case，例如<code>w4</code>就不是<code>word</code>的简写了，<code>01</code>也不是<code>a</code>的简写。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validWordAbbreviation</span><span class="params">(String word, String abbr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (word == <span class="literal">null</span> || word.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> word == abbr || (word != <span class="literal">null</span> &amp;&amp; word.equals(abbr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">indexWord</span> <span class="operator">=</span> <span class="number">0</span>, indexAbbr = <span class="number">0</span>, lenAbbr = abbr.length(), lenWord = word.length();</span><br><span class="line">    <span class="keyword">while</span> (indexAbbr &lt; lenAbbr &amp;&amp; indexWord &lt; lenWord) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> abbr.charAt(indexAbbr);</span><br><span class="line">        <span class="keyword">if</span> (Character.isLowerCase(c)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word.charAt(indexWord) != c) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            indexWord++;</span><br><span class="line">            indexAbbr++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (<span class="type">int</span>)(abbr.charAt(indexAbbr++) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span> (indexAbbr &lt; lenAbbr &amp;&amp; Character.isDigit(abbr.charAt(indexAbbr))) &#123;</span><br><span class="line">                num = <span class="number">10</span> * num + (abbr.charAt(indexAbbr++) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            indexWord += num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> indexAbbr == lenAbbr &amp;&amp; indexWord == lenWord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="410-split-array-largest-sum"><a href="#410-split-array-largest-sum" class="headerlink" title="410. split-array-largest-sum"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/split-array-largest-sum/description/">410. split-array-largest-sum</a></h4><ul>
<li>给一个只含有非负整数的int数组和一个subArray数目m，将这个数组分成m个连续subarray，求他们的最大值最小是多少。</li>
<li>方法一：在学c++时老师讲过，最大值最小化，经典二分查找问题。一波流求最大值和sum分别作为下界和上界，然后进行二分查找，mid作为targetSum，即如果每个subarray都不超过这个targetSum需要划分成多少个子数组，如果多了说明targetSum太小，需要往前收缩；注意需要尽量biase到尽可能小的targetSum，联想到求first occurance的二分查找。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">splitArray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最大值为下界、和为上界进行二分查找</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">            max = Math.max(max, num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> max - <span class="number">1</span>, end = sum + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (end - start &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">mid</span> <span class="operator">=</span> start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> getSubarrayCount(nums, mid);</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= m) &#123;   <span class="comment">// 当前的targetSum太大导致subarray个数过少</span></span><br><span class="line">                end = mid;      <span class="comment">// biase to front</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                start = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)end;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getSubarrayCount</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">long</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">tempSum</span> <span class="operator">=</span> sum + nums[i];</span><br><span class="line">            <span class="keyword">if</span> (tempSum &lt; targetSum) &#123;</span><br><span class="line">                sum = tempSum;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (tempSum == targetSum) &#123;</span><br><span class="line">                    sum = <span class="number">0</span>;        <span class="comment">// 恰好相等，则归零</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    sum = nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum != <span class="number">0</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：DP。。。</li>
</ul>
<h4 id="412-FizzBuzz"><a href="#412-FizzBuzz" class="headerlink" title="412. FizzBuzz"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/fizz-buzz/description/">412. FizzBuzz</a></h4><ul>
<li>根据是否为3、5的倍数输出指定的字符串。skip。</li>
</ul>
<h4 id="413-arithmetic-slices"><a href="#413-arithmetic-slices" class="headerlink" title="413. arithmetic-slices"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/arithmetic-slices/">413. arithmetic-slices</a></h4><ul>
<li>给一个int数组，求其中有多少段是等差数列。等差数列要求长度为3+。</li>
<li>DP。当前的长度只取决于以之前一个元素结尾的等差数列长度，如果不等差了则长度归零。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfArithmeticSlices</span><span class="params">(<span class="type">int</span>[] A)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || A.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">prevLen</span> <span class="operator">=</span> <span class="number">0</span>, retVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i - <span class="number">1</span>] - A[i - <span class="number">2</span>] == A[i] - A[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                prevLen++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prevLen = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            retVal += prevLen;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="414-third-maximum-number"><a href="#414-third-maximum-number" class="headerlink" title="414. third-maximum-number"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/third-maximum-number/">414. third-maximum-number</a></h4><ul>
<li>给一个数组，求其中第三大的数字。<code>[2, 2, 3, 1] -&gt; 1</code>.若第三大不存在（例如就两个数字）则返回最大的数字。<code>[1, 2] -&gt; 2</code>. 用pq搞定，pass。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">thirdMax</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">K</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set.add(num)) &#123;</span><br><span class="line">                pq.offer(num);</span><br><span class="line">                <span class="keyword">if</span> (pq.size() &gt; K) &#123;</span><br><span class="line">                    pq.poll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pq.size() == <span class="number">2</span>) &#123;</span><br><span class="line">            pq.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="416-partition-equal-subset-sum"><a href="#416-partition-equal-subset-sum" class="headerlink" title="416. partition-equal-subset-sum"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/partition-equal-subset-sum/description/">416. partition-equal-subset-sum</a></h4><ul>
<li>给一个只含有正数的int数组，判断是否可以划分成两个和相等的数组。</li>
<li>和698类似的暴力做法，直接遍历找所有可能的组合。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> IntStream.of(nums).sum();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">if</span> (nums[nums.length - <span class="number">1</span>] &gt; sum / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; canPartition(nums, <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length], sum / <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">boolean</span>[] visited, <span class="type">int</span> targetSum, <span class="type">int</span> currSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (currSum &gt; targetSum) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (currSum == targetSum) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                visited[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (canPartition(nums, visited, targetSum, currSum + nums[i])) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                visited[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>其实这题想考察的是DP。<code>dp[i][j]</code>表示<code>i</code>个数组成的和为<code>j</code>，期中这<code>i</code>个数不是全部都取。对于<code>dp[i][j]</code>来说如果不取第i个数（对应索引为<code>i - 1</code>），则直接来自<code>dp[i - 1][j]</code>；如果取了第i个数，则是从<code>dp[i - 1][j - nums[i - 1]]</code>转移过来。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> IntStream.of(nums).sum();</span><br><span class="line">        <span class="keyword">if</span> ((sum &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum /= <span class="number">2</span>;</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length + <span class="number">1</span>][sum + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= sum; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];   <span class="comment">// 假设不取nums[i - 1]到达当前位置</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= nums[i - <span class="number">1</span>]) &#123;    <span class="comment">// 防止数组越界</span></span><br><span class="line">                    dp[i][j] = dp[i][j] || dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]]; <span class="comment">// 这里只用了前一行，因此其实dp只用一维数组也够了</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length][sum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="417-pacific-atlantic-water-flow"><a href="#417-pacific-atlantic-water-flow" class="headerlink" title="417. pacific-atlantic-water-flow"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/pacific-atlantic-water-flow/">417. pacific-atlantic-water-flow</a></h4><ul>
<li>给一个int二维数组，左边和上边连接pacific，右边和下边连接atlantic。若当前元素大于相邻元素，则可达。求所有可以同时到达两个海洋的坐标。</li>
<li>从四条边进行DFS。与平时的区别在于visited数组，这里需要维护两种visited信息，一种是从pacific来，一种是从atlantic来，因此考虑用bit小技巧。注意DFS的visited可以放到进入后进行，而BFS需要在进入之前进行，防止重复放入queue。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PACIFIC_BIT</span> <span class="operator">=</span> <span class="number">1</span>, ATLANTIC_BIT = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>[] dir = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pacificAtlantic</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> matrix.length, cols = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] bits = <span class="keyword">new</span> <span class="title class_">int</span>[rows][cols];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; cols; col++) &#123;</span><br><span class="line">            dfs(matrix, bits, <span class="number">0</span>, col, PACIFIC_BIT);</span><br><span class="line">            dfs(matrix, bits, rows - <span class="number">1</span>, col, ATLANTIC_BIT);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>; row &lt; rows; row++) &#123;</span><br><span class="line">            dfs(matrix, bits, row, <span class="number">0</span>, PACIFIC_BIT);</span><br><span class="line">            dfs(matrix, bits, row, cols - <span class="number">1</span>, ATLANTIC_BIT);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>; row &lt; rows; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; cols; col++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((bits[row][col] &amp; PACIFIC_BIT) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    (bits[row][col] &amp; ATLANTIC_BIT) != <span class="number">0</span>) &#123;</span><br><span class="line">                    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                    list.add(row);</span><br><span class="line">                    list.add(col);</span><br><span class="line">                    ans.add(list);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span>[][] bits, <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> targetBit)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((bits[row][col] &amp; targetBit) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bits[row][col] |= targetBit;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> matrix.length, cols = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rowNew</span> <span class="operator">=</span> row + dir[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">colNew</span> <span class="operator">=</span> col + dir[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (rowNew &gt;= <span class="number">0</span> &amp;&amp; rowNew &lt; rows &amp;&amp;</span><br><span class="line">                colNew &gt;= <span class="number">0</span> &amp;&amp; colNew &lt; cols &amp;&amp;</span><br><span class="line">                matrix[row][col] &lt;= matrix[rowNew][colNew]) &#123;</span><br><span class="line">                dfs(matrix, bits, rowNew, colNew, targetBit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="419-battleships-in-a-board"><a href="#419-battleships-in-a-board" class="headerlink" title="419. battleships-in-a-board"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/battleships-in-a-board/description/">419. battleships-in-a-board</a></h4><ul>
<li>给一个二维char数组，其中含有<code>.</code>和<code>X</code>字符，<code>X</code>表示船，船只会横或者竖着放，船之间至少有一个<code>.</code>。求船的个数。</li>
<li>直接算「第一个」出现的<code>X</code>，即左边和上面都不是<code>X</code>的。</li>
</ul>
<h4 id="424-longest-repeating-character-replacement"><a href="#424-longest-repeating-character-replacement" class="headerlink" title="424. longest-repeating-character-replacement"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-repeating-character-replacement/description/">424. longest-repeating-character-replacement</a></h4><ul>
<li>给一个仅包含大写字母的字符串，再给一个k，表示假设可以有k次机会将其中的某些字母任意变成另一个字母，返回最长的相同字母的substring的长度。例如<code>ABAB</code>变2次，最长长度为4（<code>AAAA</code>）；<code>AAABAABB</code>变1次，为6.</li>
<li>这个替换是一一对应的吗？（不是，可以任意换成需要的字符。也就是可以多对一）</li>
<li>双指针 + producer&#x2F;consumer的方法，快指针先往后求各个字母的计数，同时更新一个出现最多的字母的频数maxCount。当前后两指针所夹字母数大于了maxCount + k，说明已经超过了可以替换的数目，此时就需要挪慢指针来consume计数。至于为什么不需要每次都保持最精确的maxCount，因为我们只关心最大的，当前最大的挪出窗口后，计数肯定是减掉的，那么后续再出现的时候，不会错误地产生更大的计数，最大值再大也大不过历史峰值。<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/63494/java-12-lines-o-n-sliding-window-solution-with-explanation/2">解释来自这里</a>.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">characterReplacement</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">26</span>];</span><br><span class="line">        <span class="type">char</span>[] sChar = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, maxCount = <span class="number">0</span>, maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>; end &lt; sChar.length; end++) &#123;  </span><br><span class="line">            maxCount = Math.max(maxCount, ++count[sChar[end] - <span class="string">&#x27;A&#x27;</span>]);   <span class="comment">// 更新最多的字母的频数</span></span><br><span class="line">            <span class="keyword">while</span> (end - start + <span class="number">1</span> &gt; k + maxCount) &#123;        <span class="comment">// 指针覆盖的字母过多</span></span><br><span class="line">                count[sChar[start] - <span class="string">&#x27;A&#x27;</span>]--;    <span class="comment">// 挪动慢指针，并consume掉计数</span></span><br><span class="line">                start++;</span><br><span class="line">                <span class="comment">// 注意并不需要重置maxCount，因为当前这样求出来的就是最大的，只有当新的字符超过了历史最大的maxCount才会有更长的长度需要更新</span></span><br><span class="line">            &#125;</span><br><span class="line">            maxLen = Math.max(maxLen, end - start + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="425-word-squares"><a href="#425-word-squares" class="headerlink" title="425. word-squares"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/word-squares/description/">425. word-squares</a></h4><ul>
<li>给一个wordList，将List中的String放入matrix中使得行、列的单词都来自于这个List。</li>
<li>Trie + DFS，对于每个Trie节点，除了正常的nexts数组、isWord布尔值，额外维护一个List<String>保存以「到达当前TrieNode路径」为prefix的所有word。固定一个word之后，下一个词的prefix可以通过纵向append得到，具体规律见<a target="_blank" rel="noopener" href="https://leetcode.com/problems/word-squares/discuss/91333/Explained.-My-Java-solution-using-Trie-126ms-1616">这个discussion</a>.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">        TrieNode[] nexts;</span><br><span class="line">        List&lt;String&gt; prefixWords;</span><br><span class="line">        <span class="type">boolean</span> isWord;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TrieNode</span><span class="params">()</span> &#123;</span><br><span class="line">            nexts = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line">            prefixWords = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            isWord = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">        TrieNode root;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">            root = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">            <span class="keyword">for</span> (String word : words) &#123; </span><br><span class="line">                <span class="type">TrieNode</span> <span class="variable">curr</span> <span class="operator">=</span> root;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                    <span class="keyword">if</span> (curr.nexts[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                        curr.nexts[index] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    curr.prefixWords.add(word);</span><br><span class="line">                    curr = curr.nexts[index];</span><br><span class="line">                &#125;</span><br><span class="line">                curr.isWord = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getByPrefix</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">            List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">TrieNode</span> <span class="variable">curr</span> <span class="operator">=</span> root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prefix.length(); i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> prefix.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (curr.nexts[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">                curr = curr.nexts[index];</span><br><span class="line">            &#125;</span><br><span class="line">            ans.addAll(curr.prefixWords);</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> len, Trie trie, List&lt;List&lt;String&gt;&gt; ans, List&lt;String&gt; curr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (curr.size() == len) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(curr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> curr.size();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">prefix</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (String s : curr) &#123;</span><br><span class="line">            prefix.append(s.charAt(index));</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; candidates = trie.getByPrefix(prefix.toString());</span><br><span class="line">        <span class="keyword">for</span> (String candidate : candidates) &#123;</span><br><span class="line">            curr.add(candidate);</span><br><span class="line">            dfs(len, trie, ans, curr);</span><br><span class="line">            curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">wordSquares</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (words == <span class="literal">null</span> || words.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> words[<span class="number">0</span>].length();</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trie</span>(words);</span><br><span class="line">        List&lt;String&gt; curr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            curr.add(word);</span><br><span class="line">            dfs(len, root, ans, curr);</span><br><span class="line">            curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="426-convert-binary-search-tree-to-sorted-doubly-linked-list"><a href="#426-convert-binary-search-tree-to-sorted-doubly-linked-list" class="headerlink" title="426. convert-binary-search-tree-to-sorted-doubly-linked-list"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/description/">426. convert-binary-search-tree-to-sorted-doubly-linked-list</a></h4><ul>
<li>给一个BST，将它转换成排好序的循环双向链表（头尾相接），返回头部。可以把左右孩子就看作是当前节点的前后链表节点，不需要额外搞ListNode类。</li>
<li>BST要维持顺序，那就是用中序遍历。利用全局变量prev来记录每一个子树的结尾节点，先build左子树，然后把当前节点拼到prev的后面，再去继续build右子树即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">treeToDoublyList</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();    <span class="comment">// 伪头部的next就是head</span></span><br><span class="line">    prev = dummy;   </span><br><span class="line">    buildDoublyList(root);</span><br><span class="line">    prev.right = dummy.right;</span><br><span class="line">    dummy.right.left = prev;</span><br><span class="line">    dummy.left = dummy.right = <span class="literal">null</span>;    <span class="comment">// 清理dummy</span></span><br><span class="line">    <span class="keyword">return</span> prev.right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行buildDoublyList后会将node下面的部分都形成双向链表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildDoublyList</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buildDoublyList(node.left); <span class="comment">// 先对左子树build一下，prev会指向最后一个节点</span></span><br><span class="line">    prev.right = node;          <span class="comment">// 将node拼进去</span></span><br><span class="line">    node.left = prev;</span><br><span class="line">    prev = node;                <span class="comment">// 左半部分+当前节点的结尾就是node</span></span><br><span class="line">    buildDoublyList(node.right);<span class="comment">// 继续build右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：分治法。先把左右子树的循环双向链表build好，再把当前节点塞到中间，同时把新的前后循环连接一下。注意在分别build的时候，需要把root本身设一个自循环，这样就可以重复使用connect方法了。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">treeToDoublyList</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">leftHead</span> <span class="operator">=</span> treeToDoublyList(root.left);</span><br><span class="line">    <span class="type">Node</span> <span class="variable">rightHead</span> <span class="operator">=</span> treeToDoublyList(root.right);</span><br><span class="line">    root.left = root;</span><br><span class="line">    root.right = root;</span><br><span class="line">    <span class="keyword">return</span> connect(connect(leftHead, root), rightHead);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node leftHead, Node rightHead)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (leftHead == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> rightHead;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rightHead == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> leftHead;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">leftTail</span> <span class="operator">=</span> leftHead.left;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">rightTail</span> <span class="operator">=</span> rightHead.left;</span><br><span class="line">    leftTail.right = rightHead;</span><br><span class="line">    rightHead.left = leftTail;</span><br><span class="line">    leftHead.left = rightTail;</span><br><span class="line">    rightTail.right = leftHead;</span><br><span class="line">    <span class="keyword">return</span> leftHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="428-serialize-and-deserialize-n-ary-tree"><a href="#428-serialize-and-deserialize-n-ary-tree" class="headerlink" title="428. serialize-and-deserialize-n-ary-tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/serialize-and-deserialize-n-ary-tree/">428. serialize-and-deserialize-n-ary-tree</a></h4><ul>
<li>对N叉树实现与string的互相转换。实现方式只有一个限制，就是必须是stateless，即不能用函数外面的全局变量。</li>
<li>对于这个话题很多讨论比较有意思。首先是如何将字符串拼接起来，事实上直接<code>+</code>从performance的角度来说是最快的，但消耗的内粗很大，因为需要复制很多次。若已经有一个list of strings，直接用join最快。如果是on-the-fly，那就用StringBuilder.</li>
<li>实现本身不难，因为实现很自由。例如直接存节点值和孩子节点数量，pre-order的方式递归拼入数组，用<code>,</code>连接。如果可以假设数字值域为<code>[0, 65535]</code>，则连<code>,</code>都不用，直接将数值转成unicode character即可，<code>(char) (value + &#39;0&#39;)</code>.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="type">String</span> <span class="variable">SPLITTER</span> <span class="operator">=</span> <span class="string">&quot;,&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        serialize(root, list);</span><br><span class="line">        <span class="keyword">return</span> String.join(SPLITTER, list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(Node node, List&lt;String&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            list.add(String.valueOf(node.val));</span><br><span class="line">            list.add(String.valueOf(node.children.size()));</span><br><span class="line">            <span class="keyword">for</span> (Node child : node.children) &#123;</span><br><span class="line">                serialize(child, list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="literal">null</span> || data.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] arr = data.split(SPLITTER);</span><br><span class="line">        Queue&lt;String&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(Arrays.asList(arr));</span><br><span class="line">        <span class="keyword">return</span> deserialize(q);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">deserialize</span><span class="params">(Queue&lt;String&gt; q)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        node.val = Integer.parseInt(q.poll());</span><br><span class="line">        node.children = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Node&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">childrenSize</span> <span class="operator">=</span> Integer.parseInt(q.poll());</span><br><span class="line">        <span class="keyword">while</span> (childrenSize-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node.children.add(deserialize(q));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="430-flatten-a-multilevel-doubly-linked-list"><a href="#430-flatten-a-multilevel-doubly-linked-list" class="headerlink" title="430. flatten-a-multilevel-doubly-linked-list"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list/">430. flatten-a-multilevel-doubly-linked-list</a></h4><ul>
<li>给一个nested的双向链表，将所有child节点都插入到父节点的后面。</li>
<li>方法一：递归，利用一个全局变量存放上一次flatten之后的最后一个节点，对于每一个节点都连到prev后面，然后flatten当前节点的子节点，然后再继续往后。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">flatten</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (prev != <span class="literal">null</span>) &#123;</span><br><span class="line">        prev.next = head;</span><br><span class="line">        head.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">    prev = head;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> head.next;</span><br><span class="line">    flatten(head.child);</span><br><span class="line">    head.child = <span class="literal">null</span>;</span><br><span class="line">    flatten(next);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：简单的遍历，当前节点有child时就到它的child那一层找到尾巴节点接到后面，然后继续遍历即可。但无法保证每个节点只遍历到一次。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">flatten</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curr.child != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">tail</span> <span class="operator">=</span> curr.child;     </span><br><span class="line">            <span class="keyword">while</span> (tail.next != <span class="literal">null</span>) &#123; <span class="comment">// 找到下一层的尾巴</span></span><br><span class="line">                tail = tail.next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail.next = curr.next;      <span class="comment">// 与下一个节点相连</span></span><br><span class="line">            <span class="keyword">if</span> (curr.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                curr.next.prev = tail;</span><br><span class="line">            &#125;</span><br><span class="line">            curr.next = curr.child;</span><br><span class="line">            curr.child.prev = curr;</span><br><span class="line">            curr.child = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr.next;       <span class="comment">// 继续遍历链表</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法三：用stack记录next节点和child节点（注意push的顺序，保证先处理child节点），每次从stack中取节点连接。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">flatten</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    stack.push(head);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">curr</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span>) &#123;</span><br><span class="line">            prev.next = curr;</span><br><span class="line">            curr.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curr.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(curr.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curr.child != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(curr.child);</span><br><span class="line">            curr.child = <span class="literal">null</span>;      </span><br><span class="line">        &#125;</span><br><span class="line">        prev = curr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="432-encode-n-ary-tree-to-binary-tree"><a href="#432-encode-n-ary-tree-to-binary-tree" class="headerlink" title="432. encode-n-ary-tree-to-binary-tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/encode-n-ary-tree-to-binary-tree/">432. encode-n-ary-tree-to-binary-tree</a></h4><ul>
<li>实现一个类，能够将N-ary树转换为二叉树、也能把二叉树转回N-ary。</li>
<li>对于N-ary的孩子放到左子树，对于同一级的节点则一直放到右子树。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line">    <span class="comment">// Encodes an n-ary tree to a binary tree.</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">encode</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">rootBT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(root.val);</span><br><span class="line">        <span class="keyword">if</span> (root.children == <span class="literal">null</span> || root.children.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> rootBT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">prevChildBT</span> <span class="operator">=</span> <span class="literal">null</span>, firstChildBT = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node child : root.children) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">childBT</span> <span class="operator">=</span> encode(child);</span><br><span class="line">            <span class="keyword">if</span> (prevChildBT != <span class="literal">null</span>) &#123;</span><br><span class="line">                prevChildBT.right = childBT;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (firstChildBT == <span class="literal">null</span>) &#123;</span><br><span class="line">                firstChildBT = childBT;</span><br><span class="line">            &#125;</span><br><span class="line">            prevChildBT = childBT;</span><br><span class="line">        &#125;</span><br><span class="line">        rootBT.left = firstChildBT;</span><br><span class="line">        <span class="keyword">return</span> rootBT;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// Decodes your binary tree to an n-ary tree.</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">decode</span><span class="params">(TreeNode rootBT)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (rootBT == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(rootBT.val, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">currBT</span> <span class="operator">=</span> rootBT.left;</span><br><span class="line">        <span class="keyword">while</span> (currBT != <span class="literal">null</span>) &#123;</span><br><span class="line">            root.children.add(decode(currBT));</span><br><span class="line">            currBT = currBT.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec = new Codec();</span></span><br><span class="line"><span class="comment">// codec.decode(codec.encode(root));</span></span><br></pre></td></tr></table></figure>

<h4 id="435-non-overlapping-intervals"><a href="#435-non-overlapping-intervals" class="headerlink" title="435. non-overlapping-intervals"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/non-overlapping-intervals">435. non-overlapping-intervals</a></h4><ul>
<li>给一个interval数组，求至少需要删除多少个interval才能让剩余的不重叠。相关的问题见56、252、253、452.</li>
<li>方法一：首先按照interval的起点从小到大排序，对于前后两个求overlap的部分，若有重叠，则无论如何至少得删掉一个，但是只保留重叠部分与后续比较。时间<code>O(NlogN)</code>.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals == <span class="literal">null</span> || intervals.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(intervals, (a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] currInterval = intervals[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span>[] overlap = getOverlap(currInterval, intervals[i]);</span><br><span class="line">            <span class="keyword">if</span> (overlap == <span class="literal">null</span>) &#123;</span><br><span class="line">                currInterval = intervals[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count++;</span><br><span class="line">                currInterval = overlap;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] getOverlap(<span class="type">int</span>[] interval1, <span class="type">int</span>[] interval2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (interval2[<span class="number">0</span>] &lt; interval1[<span class="number">1</span>] &amp;&amp; interval2[<span class="number">1</span>] &gt; interval1[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; Math.max(interval1[<span class="number">0</span>], interval2[<span class="number">0</span>]), Math.min(interval1[<span class="number">1</span>], interval2[<span class="number">1</span>])&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>转换思路，这题和求最多的non-overlapping interval个数一摸一样。统计最多的独立interval个数，首先根据interval的右界进行排序，然后取左界与当前的右界进行比较，如果左界大，说明是新的独立interval，直接计数++。最后返回总interval数减去独立interval数即可。时间<code>O(NlogN)</code>.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals == <span class="literal">null</span> || intervals.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(intervals, (a, b) -&gt; a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">nonOverlapCount</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">currEnd</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &gt;= currEnd) &#123;</span><br><span class="line">                currEnd = intervals[i][<span class="number">1</span>];</span><br><span class="line">                nonOverlapCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intervals.length - nonOverlapCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="437-path-sum-iii"><a href="#437-path-sum-iii" class="headerlink" title="437. path-sum-iii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/path-sum-iii/description/">437. path-sum-iii</a></h4><ul>
<li>给一个二叉树，给一个目标值sum，求有几条从上往下累加的路径之和等于sum。</li>
<li>递归DFS，每次深入之前都先减掉当前节点的值。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;    <span class="comment">// calculate path num starting from root</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(root, sum)   <span class="comment">// taking the given node</span></span><br><span class="line">            + pathSum(root.left, sum) + pathSum(root.right, sum); <span class="comment">// start from left/right child</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode node, <span class="type">int</span> target)</span> &#123;    <span class="comment">// dig to find path num taking current node</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (node.val == target? <span class="number">1</span> : <span class="number">0</span>) + dfs(node.left, target - node.val) + dfs(node.right, target - node.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>优化：显然上面最原始的方式会有许多重复性计算，所以考虑使用memo存放从各个可能的根到当前节点的各种sum出现的次数，这样看看”当前sum减去目标和”出现过多少次即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; sumCount = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        sumCount.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        dfs(root, <span class="number">0</span>, sum, sumCount);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> currSum, <span class="type">int</span> target, Map&lt;Integer, Integer&gt; sumCount)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        currSum += root.val;</span><br><span class="line">        count += sumCount.getOrDefault(currSum - target, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        sumCount.put(currSum, sumCount.getOrDefault(currSum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        dfs(root.left, currSum, target, sumCount);</span><br><span class="line">        dfs(root.right, currSum, target, sumCount);</span><br><span class="line">        </span><br><span class="line">        sumCount.put(currSum, sumCount.get(currSum) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="438-find-all-anagrams-in-a-string"><a href="#438-find-all-anagrams-in-a-string" class="headerlink" title="438. find-all-anagrams-in-a-string"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-all-anagrams-in-a-string/description/">438. find-all-anagrams-in-a-string</a></h4><ul>
<li>给一个字符串s和一个字符串p，求s中所有p的anagram子串的起始位置的List。</li>
<li>双指针 + producer&#x2F;consumer的方法，map中存放p中每个字符及其对应出现的次数，快指针负责consume直到没有可用的字符（只需要管map中有的字符），这时看看快慢指针所夹字符的个数是否等于p；之后就挪动慢指针provide补回字符。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// O(N)双指针。先一波流统计p中各个字符出现的频数，然后consume掉map中的字符直到没有available的</span></span><br><span class="line">    <span class="comment">// 此时判断左右指针之间长度是否等于目标的长度，然后挪动左指针重新往map中加回去，直到出现可选字符</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || p == <span class="literal">null</span> || s.length() == <span class="number">0</span> || p.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span>[] pChar = p.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">pLen</span> <span class="operator">=</span> pChar.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c: pChar) &#123;</span><br><span class="line">            map.put(c, map.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span>[] sChar = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> map.size();     <span class="comment">// 还有count个不同的字符可选</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; sChar.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(sChar[right])) &#123;</span><br><span class="line">                map.put(sChar[right], map.get(sChar[right]) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (map.get(sChar[right]) == <span class="number">0</span>) &#123;</span><br><span class="line">                    count--;    <span class="comment">// 可选字符少了一个</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (right - left + <span class="number">1</span> == pLen) &#123;</span><br><span class="line">                    ans.add(left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(sChar[left])) &#123;</span><br><span class="line">                    map.put(sChar[left], map.get(sChar[left]) + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (map.get(sChar[left]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        count++;    <span class="comment">// 恢复可选字符</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="439-ternary-expression-parser"><a href="#439-ternary-expression-parser" class="headerlink" title="439. ternary-expression-parser"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/ternary-expression-parser/description/">439. ternary-expression-parser</a></h4><ul>
<li>给一个三元运算的<code>? :</code>字符串，布尔表达式直接就是T或者F，其余的都是0-9的一位数字，求最终结果。例如<code>F?1:T?4:5</code>最后就是4.</li>
<li>方法一：Stack。想到了要用Stack，但是没有想出确切的方法。其实就是需要从后往前遍历，确定最终需要保留的是什么数字就好了，在stack中存放两个值以及问号，这样当下一个字符（准确说是前一个）出现时只需要判断栈顶是否是问号就知道当前字符是作为bool还是值。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">parseTernary</span><span class="params">(String expression)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (expression == <span class="literal">null</span> || expression.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;(); <span class="comment">// 存放数值和问号</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> expression.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;    <span class="comment">// 从末尾往前遍历</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">curr</span> <span class="operator">=</span> expression.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty() &amp;&amp; stack.peek() == <span class="string">&#x27;?&#x27;</span>) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="type">char</span> <span class="variable">first</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">char</span> <span class="variable">second</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (curr == <span class="string">&#x27;T&#x27;</span>) &#123;</span><br><span class="line">                    stack.push(first);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    stack.push(second);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curr != <span class="string">&#x27;:&#x27;</span>) &#123;</span><br><span class="line">                stack.push(curr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.peek() + <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：递归DFS。对于每一个问号都进行计数++，每个冒号进行计数–，这样当计数归0的时候就找到了与问号对应的冒号，然后根据T／F递归找前后其中一部分的结果就好。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">parseTernary</span><span class="params">(String expression)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (expression == <span class="literal">null</span> || expression.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> expression;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] exp = expression.toCharArray();</span><br><span class="line">        <span class="keyword">return</span> DFS(exp, <span class="number">0</span>, exp.length - <span class="number">1</span>) + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">DFS</span><span class="params">(<span class="type">char</span>[] c, <span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">            <span class="keyword">return</span> c[start];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>, i = start;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c[i] == <span class="string">&#x27;?&#x27;</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c[i] == <span class="string">&#x27;:&#x27;</span>) &#123;</span><br><span class="line">                count--;</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c[start] == <span class="string">&#x27;T&#x27;</span>? DFS(c, start + <span class="number">2</span>, i - <span class="number">1</span>) : DFS(c, i + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="442-find-all-duplicates-in-an-array"><a href="#442-find-all-duplicates-in-an-array" class="headerlink" title="442. find-all-duplicates-in-an-array"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-all-duplicates-in-an-array/">442. find-all-duplicates-in-an-array</a></h4><ul>
<li>给一个<code>size = n</code>的int数组，其中每个int都在<code>[1, n]</code>范围内。其中部分元素恰好出现了两次，剩余元素出现一次。求所有出现两次的元素，顺序无所谓。</li>
<li>暴力就是用Set，但如果要求不用额外空间且O(N)时间复杂度，就不行了。</li>
<li>充分利用<code>[1, n]</code>这个条件，每个int都可以作为index，那么就在index上面做文章，出现过的index就将元素标记一下，例如变为负数。这样在遍历数组过程中如果发现对应index已经是负数了，说明之前出现过。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Math.abs(nums[i]) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[index] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                ans.add(index + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[index] = -nums[index];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="443-string-compression"><a href="#443-string-compression" class="headerlink" title="443. string-compression"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/string-compression/description/">443. string-compression</a></h4><ul>
<li>给一个字符数组，统计字符出现的个数实现压缩。例如<code>a,a,a,a,a,b,c,c,c,c,c,c,c,c,c,c,c,c,c,c,c,c,c</code>就是<code>a,5,b,c,1,7</code>。要求in-place。</li>
<li>每次从头开始，以第一个为基准往后判断，直到不想等，再根据个数往里塞。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compress</span><span class="params">(<span class="type">char</span>[] chars)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (chars == <span class="literal">null</span> || chars.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; chars.length) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">curr</span> <span class="operator">=</span> chars[i++];     <span class="comment">// 以第一个字符为判断标准</span></span><br><span class="line">            chars[len++] = curr;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; chars.length &amp;&amp; curr == chars[i]) &#123;  <span class="comment">// 统计个数直到不匹配</span></span><br><span class="line">                i++;        </span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count != <span class="number">1</span>) &#123;           <span class="comment">// 超过一个才拼接上数字</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">char</span> c : Integer.toString(count).toCharArray()) &#123;</span><br><span class="line">                    chars[len++] = c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="444-sequence-reconstruction"><a href="#444-sequence-reconstruction" class="headerlink" title="444. sequence-reconstruction"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sequence-reconstruction/description/">444. sequence-reconstruction</a></h4><ul>
<li>给一个int数组org，再给一个List of list，这些list是某个original sequence的子序列，问根据这些子序列是否可以唯一地还原成一个完整的序列且正是org.</li>
<li>经典的拓扑排序。用<code>Map&lt;Integer, Set&lt;Integer&gt;&gt;</code>维护邻接关系，用<code>Map&lt;Integer&gt;</code>维护inDegrees关系</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sequenceReconstruction</span><span class="params">(<span class="type">int</span>[] org, List&lt;List&lt;Integer&gt;&gt; seqs)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (org == <span class="literal">null</span> || org.length == <span class="number">0</span> || seqs == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> org.length;</span><br><span class="line">        Map&lt;Integer, Integer&gt; inDegrees = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, Set&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; seq : seqs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seq.size() == <span class="number">1</span>) &#123;   <span class="comment">// 可能存在只有一个节点的seq</span></span><br><span class="line">                graph.putIfAbsent(seq.get(<span class="number">0</span>), <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line">                inDegrees.putIfAbsent(seq.get(<span class="number">0</span>), <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; seq.size();i++) &#123;   <span class="comment">// 依次取每条seq的节点形成graph</span></span><br><span class="line">                    graph.putIfAbsent(seq.get(i - <span class="number">1</span>), <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;());</span><br><span class="line">                    graph.putIfAbsent(seq.get(i), <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;());</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                        inDegrees.put(seq.get(i - <span class="number">1</span>), inDegrees.getOrDefault(seq.get(i - <span class="number">1</span>), <span class="number">0</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (graph.get(seq.get(i - <span class="number">1</span>)).add(seq.get(i))) &#123;</span><br><span class="line">                        inDegrees.put(seq.get(i), inDegrees.getOrDefault(seq.get(i), <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> key : inDegrees.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDegrees.get(key) == <span class="number">0</span>) &#123;</span><br><span class="line">                q.offer(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (q.size() == <span class="number">1</span>) &#123;     <span class="comment">// 必须保证每次只有一个入度为0的节点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="keyword">if</span> (startIndex != org[index]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (++index == n) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Set&lt;Integer&gt; neighbors = graph.get(startIndex);</span><br><span class="line">            <span class="keyword">if</span> (neighbors == <span class="literal">null</span>) &#123;    <span class="comment">// 没有后续节点可以判断</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> neighbor : neighbors) &#123;</span><br><span class="line">                inDegrees.put(neighbor, inDegrees.get(neighbor) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (inDegrees.get(neighbor) == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.offer(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index == n &amp;&amp; index == graph.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="445-add-two-numbers-ii"><a href="#445-add-two-numbers-ii" class="headerlink" title="445. add-two-numbers-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/add-two-numbers-ii/">445. add-two-numbers-ii</a></h4><ul>
<li>给两个链表的头节点，每个节点表示一个数位，将两个数字相加得到的链表.</li>
<li>方法一：stack，将节点统统存入之后，逐个pop相加。</li>
<li>方法二：先求得长度，然后根据长度差来加。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">null</span> || l2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1 == <span class="literal">null</span> ? l2 : l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> getLen(l1);</span><br><span class="line">    <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> getLen(l2);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> len1 &gt; len2 ? addTwoNumbers(l1, l2, len1 - len2) : addTwoNumbers(l2, l1, len2 - len1);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">hasCarry</span> <span class="operator">=</span> adjustCarry(head, next);</span><br><span class="line">    <span class="keyword">return</span> hasCarry ? head : next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2, <span class="type">int</span> offset)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">ret</span> <span class="operator">=</span> offset &gt; <span class="number">0</span> ? <span class="keyword">new</span> <span class="title class_">ListNode</span>(l1.val) : <span class="keyword">new</span> <span class="title class_">ListNode</span>(l1.val + l2.val);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> addTwoNumbers(l1.next, offset &gt; <span class="number">0</span> ? l2 : l2.next, offset &gt; <span class="number">0</span> ? offset - <span class="number">1</span> : offset);</span><br><span class="line">    adjustCarry(ret, next);</span><br><span class="line">    <span class="keyword">return</span> ret; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">adjustCarry</span><span class="params">(ListNode head, ListNode next)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">hasCarry</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (next != <span class="literal">null</span> &amp;&amp; next.val &gt; <span class="number">9</span>) &#123;</span><br><span class="line">        hasCarry = <span class="literal">true</span>;</span><br><span class="line">        next.val -= <span class="number">10</span>;</span><br><span class="line">        head.val += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next = next;</span><br><span class="line">    <span class="keyword">return</span> hasCarry;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getLen</span><span class="params">(ListNode node)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        len++;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="448-find-all-numbers-disappeared-in-an-array"><a href="#448-find-all-numbers-disappeared-in-an-array" class="headerlink" title="448. find-all-numbers-disappeared-in-an-array"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/">448. find-all-numbers-disappeared-in-an-array</a></h4><ul>
<li>给一个长度为N的int数组，其中的值都在<code>1~N</code>之间，每个值可能出现1或2次，求中落下的数字。例如<code>[4,3,2,7,8,2,3,1]</code>中，落下的数字是<code>[5, 6]</code>.</li>
<li>有点类似于swap求missing number，于是就想到用索引和value的关系来swap，最后和索引对应关系错误的就是missing的。但事实上不需要真的swap，而是可以在第一次遍历的时候，直接根据当前值跳到对应索引，然后将该处的值变为负数，这样就知道这个索引的值出现过了，第二次遍历直接将正值索引对应的数加入列表即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findDisappearedNumbers</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Math.abs(nums[i]) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[index] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                nums[index] = -nums[index];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; retVal = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                retVal.add(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="449-serialize-and-deserialize-bst"><a href="#449-serialize-and-deserialize-bst" class="headerlink" title="449. serialize-and-deserialize-bst"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/serialize-and-deserialize-bst/description/">449. serialize-and-deserialize-bst</a></h4><ul>
<li>给一个BST，实现序列化和反序列化，即和String互相转换。</li>
<li>如果只是一个普通的二叉树，直接暴力写preorder和StringBuilder拼接没问题。但对于BST这个条件要怎么用呢？root一定比所有左边节点大、比所有右边节点小，那么在反序列化的时候直接通过val找到属于左边那半部分subtree去build即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        preorder(root, sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(TreeNode root, StringBuilder sb)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(root.val);</span><br><span class="line">        sb.append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        preorder(root.left, sb);</span><br><span class="line">        preorder(root.right, sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="literal">null</span> || data.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] vals = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String val : vals) &#123;</span><br><span class="line">            q.offer(Integer.parseInt(val));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deserialize(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">deserialize</span><span class="params">(Queue&lt;Integer&gt; q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (q.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(q.poll());</span><br><span class="line">        Queue&lt;Integer&gt; smallerQueue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty() &amp;&amp; q.peek() &lt; root.val) &#123;</span><br><span class="line">            smallerQueue.offer(q.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = deserialize(smallerQueue);</span><br><span class="line">        root.right = deserialize(q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="450-delete-node-in-a-bst"><a href="#450-delete-node-in-a-bst" class="headerlink" title="450. delete-node-in-a-bst"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/delete-node-in-a-bst/description/">450. delete-node-in-a-bst</a></h4><ul>
<li>给一个BST和一个key，如果存在这个key就删除这个值，返回root（可能会更新）。</li>
<li>经典。首先是搜索这个key，然后就是删除节点。如果这个节点是叶子，直接返回null；如果是单边，返回非空child；如果是双边children，则需要取中序遍历的下一个节点来替换掉当前节点。一种做法是去右子树的最左节点的值放到当前节点，再把该最左节点删除。另一种是真正的替换</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; root.val) &#123;</span><br><span class="line">            root.left = deleteNode(root.left, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root.val) &#123;</span><br><span class="line">            root.right = deleteNode(root.right, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">minNode</span> <span class="operator">=</span> getMinNode(root.right);</span><br><span class="line">            <span class="comment">// 方法一：覆盖value</span></span><br><span class="line">            <span class="comment">// root.val = minNode.val;</span></span><br><span class="line">            <span class="comment">// root.right = deleteNode(root.right, minNode.val);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 方法二：真正的替换</span></span><br><span class="line">            minNode.right = deleteNode(root.right, minNode.val);</span><br><span class="line">            minNode.left = root.left;</span><br><span class="line">            root = minNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">getMinNode</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="452-minimum-number-of-arrows-to-burst-balloons"><a href="#452-minimum-number-of-arrows-to-burst-balloons" class="headerlink" title="452. minimum-number-of-arrows-to-burst-balloons"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/">452. minimum-number-of-arrows-to-burst-balloons</a></h4><ul>
<li>给一个二维int数组，每一项表示一个气球的跨度，求最少用几根针可以扎破所有气球，注意气球的边界也算有效扎破范围。例如<code>[[10,16], [2,8], [1,6], [7,12]]</code>就至少需要两根针。</li>
<li>贪心做法，既然针蹭到也算扎破，那就按照气球的右边界从小到大排序，然后从头开始遍历，一旦发现当前区间的左边界大于了之前的右边界，就说明前面需要用新的针来继续扎后面的了。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (points == <span class="literal">null</span> || points.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(points, (a, b) -&gt; a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">prevPos</span> <span class="operator">=</span> points[<span class="number">0</span>][<span class="number">1</span>], arrowCount = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (points[i][<span class="number">0</span>] &gt; prevPos) &#123;</span><br><span class="line">            prevPos = points[i][<span class="number">1</span>];</span><br><span class="line">            arrowCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrowCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>相似的题有<a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-intervals">56 Merge Intervals</a>, <a target="_blank" rel="noopener" href="https://leetcode.com/problems/non-overlapping-intervals">435 Non-overlapping Intervals</a>, <a target="_blank" rel="noopener" href="https://leetcode.com/problems/meeting-rooms/">252 Meeting Rooms</a>, <a target="_blank" rel="noopener" href="https://leetcode.com/problems/meeting-rooms-ii/">253 Meeting Rooms II</a>.</li>
</ul>
<h4 id="453-minimum-moves-to-equal-array-elements"><a href="#453-minimum-moves-to-equal-array-elements" class="headerlink" title="453. minimum-moves-to-equal-array-elements"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-moves-to-equal-array-elements/description/">453. minimum-moves-to-equal-array-elements</a></h4><ul>
<li>给一个int数组，返回move几次能够让每个元素相等。move指的是对某位置以外的所有元素加1.</li>
<li>这题其实是个math problem，<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/66737/it-is-a-math-question">推导在此</a>，假设所有数之和为sum，最小值为minNum，加了m次达到x，则有<code>sum + m * (n - 1) = x * n</code>以及<code>minNum + m = x</code>，代入抵消一下就得到<code>sum + mn - m = minNum * n + mn</code>，所求的m为<code>sum - minNum * n = SUM(num_i - minNum)</code>。直接根据公式来，先求一波最小值，然后累加即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minMoves</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            min = Math.min(min, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minMove</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: nums) &#123;</span><br><span class="line">            minMove += (num - min);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> minMove;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="454-4sum-ii"><a href="#454-4sum-ii" class="headerlink" title="454. 4sum-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/4sum-ii/description/">454. 4sum-ii</a></h4><ul>
<li>给四个数组，求其中有多少个组合使得<code>A[i] + B[j] + C[k] + D[l] = 0</code>.</li>
<li>Map统计A和B的所有和出现的次数，然后遍历C+D的组合，到map中找对应项。skip。</li>
</ul>
<h4 id="456-132-pattern"><a href="#456-132-pattern" class="headerlink" title="456. 132-pattern"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/132-pattern">456. 132-pattern</a></h4><ul>
<li>给一个int数组，判断其中是否有满足<code>i &lt; k &lt; j</code>且<code>A[i] &lt; A[j] &lt; A[k]</code>的形式，类似于<code>1, 3, 2</code>.</li>
<li>暴力的想法就是固定i和j，在中间找k。但事实上在中间找k这个操作可以利用stack优化。首先走一波存放minBefore，表示当前索引及之前的元素中的最小值。然后从后往前遍历原数组，如果出现了<code>minBefore &lt; num</code>，相当于固定<code>A[i]</code>和<code>A[k]</code>，从stack中找有没有落在范围内的值。如果持续弹出栈顶，直到比minBefore大，这时再看看是否小于num。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">find132pattern</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] minBefore = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        minBefore[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            minBefore[i] = Math.min(minBefore[i - <span class="number">1</span>], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; minBefore[j]) &#123;<span class="comment">// 固定(minBefore[j], nums[j])，找stack中有没有在之间的</span></span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() &lt;= minBefore[j]) &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!stack.isEmpty() &amp;&amp; stack.peek() &lt; nums[j]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;    <span class="comment">// 出现了minBefore[j] &lt; stack.peek() &lt; nums[j]</span></span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(nums[j]);<span class="comment">// 若到空了都没有，说明后面的都太小了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="457-circular-array-loop"><a href="#457-circular-array-loop" class="headerlink" title="457. circular-array-loop"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/circular-array-loop/description/">457. circular-array-loop</a></h4><ul>
<li>给一个int数组，从任意一点出发，跳动步数就是数组的值，判断是否存在一个单一方向的、含有多于一个element的loop。数组中不含0.尝试不实用额外空间。</li>
<li>如果可以使用extra space，可以直接用Set记录到过的index以及某个path的index。如果不用额外空间呢？联想LinkedList找loop用快慢指针，这里也是一样。slow每次往后一步、fast每次两步，若全程能保持同一个方向移动且slow和fast相遇，则有loop.注意这里需要filter掉self-loop的元素。为了标记是否访问过而不使用Set，可以利用条件「原数组不含有0元素」，将访问过的元素改成0。保证一个方向的loop则是通过每一步经过的元素是否符号相同来判定的，也就是相乘大于0.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">circularArrayLoop</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length, slow = i, fast = getNextIndex(i, nums[i], n);</span><br><span class="line">            <span class="keyword">while</span> (nums[fast] * nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[getNextIndex(fast, nums[fast], n)] * nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (slow == getNextIndex(slow, nums[slow], n)) &#123;    <span class="comment">// 排除只含有一个element的cycle</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                slow = getNextIndex(slow, nums[slow], n);   <span class="comment">// 慢快指针分别移动一步两步</span></span><br><span class="line">                fast = getNextIndex(fast, nums[fast], n);</span><br><span class="line">                fast = getNextIndex(fast, nums[fast], n);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i, val = nums[i];</span><br><span class="line">            <span class="keyword">while</span> (nums[j] * val &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextIndex</span> <span class="operator">=</span> getNextIndex(j, nums[j], n);</span><br><span class="line">                nums[j] = <span class="number">0</span>;</span><br><span class="line">                j = nextIndex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getNextIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> step, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextIndex</span> <span class="operator">=</span> index + step;</span><br><span class="line">        <span class="keyword">return</span> nextIndex &gt;= <span class="number">0</span> ? nextIndex % len : nextIndex % len + len; <span class="comment">// java的%求的是余数而不是真正的modulo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="459-repeated-substring-pattern"><a href="#459-repeated-substring-pattern" class="headerlink" title="459. repeated-substring-pattern"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/repeated-substring-pattern/">459. repeated-substring-pattern</a></h4><ul>
<li>给一个字符串，判断它是否能够通过子字符串自行重复拼接而成。</li>
<li>方法一：<code>O(N^2)</code>, 从小到达遍历各种子字符串长度，逐个判断是否能拼接成整个字符串。</li>
<li>方法二：<code>O(N)</code>使用KMP找字符串的common prefix和suffix的长度<code>l</code>，<code>n - l</code>表示非prefix或非suffix的部分，如果这个部分能够被总长度整除，就说明这个部分重复之后就能得到这个那个字符串。关于KMP，可以看<a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-happy-prefix/">1392. longest-happy-prefix</a>加深理解。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> dp[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s.charAt(i) != s.charAt(j)) &#123;</span><br><span class="line">                j = dp[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> dp[len - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> l &gt; <span class="number">0</span> &amp;&amp; len % (len - l) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="460-Least-Frequently-Used-Cache"><a href="#460-Least-Frequently-Used-Cache" class="headerlink" title="460. Least Frequently Used Cache"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/lfu-cache/description/">460. Least Frequently Used Cache</a></h4><ul>
<li>实现最近最频繁使用的有限容量缓存，到达容量上限时evict最不频繁使用的key，若频繁情况相同则evict掉最早插入的。</li>
<li>首先考虑如何实现根据频数来evict，这就需要一个<code>(freq -&gt; 元素)</code>的map来维护，由于频数持平时需要evict掉更久远的元素，因此这个map中就需要维护一个List，根据LRU使用doublelinkedlist可以在<code>O(1)</code>删除。当缓存满了，需要丢掉最小的freq中最早插入的元素，这个“最小的freq”只需要一个变量维护即可，而不需要保持整个freq都是有序的。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LFUCache</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> key, val, freq;</span><br><span class="line">        Node next, prev;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">            <span class="built_in">this</span>.freq = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DoubleLinkedList</span> &#123;</span><br><span class="line">        Node fakeHead, fakeTail;</span><br><span class="line">        <span class="type">int</span> size;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DoubleLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">            fakeHead = <span class="keyword">new</span> <span class="title class_">Node</span>(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">            fakeTail = <span class="keyword">new</span> <span class="title class_">Node</span>(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">            fakeHead.next = fakeTail;</span><br><span class="line">            fakeTail.prev = fakeHead;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">append</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">            node.next = fakeTail;</span><br><span class="line">            node.prev = fakeTail.prev;</span><br><span class="line">            fakeTail.prev.next = node;</span><br><span class="line">            fakeTail.prev = node;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">            node.prev.next = node.next;</span><br><span class="line">            node.next.prev = node.prev;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity, minFreq;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Node&gt; nodeMap;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, DoubleLinkedList&gt; freqMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LFUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        minFreq = <span class="number">0</span>;</span><br><span class="line">        nodeMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        freqMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!nodeMap.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nodeMap.get(key);</span><br><span class="line">        updateFreq(node);</span><br><span class="line">        <span class="keyword">return</span> node.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!nodeMap.containsKey(key)) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, value);</span><br><span class="line">            <span class="keyword">if</span> (nodeMap.size() == capacity) &#123;</span><br><span class="line">                <span class="type">DoubleLinkedList</span> <span class="variable">minFreqNodes</span> <span class="operator">=</span> freqMap.get(minFreq);</span><br><span class="line">                nodeMap.remove(minFreqNodes.fakeHead.next.key);</span><br><span class="line">                minFreqNodes.remove(minFreqNodes.fakeHead.next);</span><br><span class="line">                <span class="keyword">if</span> (minFreqNodes.size == <span class="number">0</span>) &#123;</span><br><span class="line">                    freqMap.remove(minFreq);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            nodeMap.put(node.key, node);</span><br><span class="line">            freqMap.putIfAbsent(node.freq, <span class="keyword">new</span> <span class="title class_">DoubleLinkedList</span>());</span><br><span class="line">            freqMap.get(node.freq).append(node);</span><br><span class="line">            minFreq = node.freq;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nodeMap.get(key);</span><br><span class="line">            node.val = value;</span><br><span class="line">            updateFreq(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateFreq</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="type">DoubleLinkedList</span> <span class="variable">oldList</span> <span class="operator">=</span> freqMap.get(node.freq);</span><br><span class="line">        oldList.remove(node);</span><br><span class="line">        <span class="keyword">if</span> (oldList.size == <span class="number">0</span>) &#123;</span><br><span class="line">            freqMap.remove(node.freq);</span><br><span class="line">            minFreq += (minFreq == node.freq ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        node.freq++;</span><br><span class="line">        freqMap.putIfAbsent(node.freq, <span class="keyword">new</span> <span class="title class_">DoubleLinkedList</span>());</span><br><span class="line">        <span class="type">DoubleLinkedList</span> <span class="variable">newList</span> <span class="operator">=</span> freqMap.get(node.freq);</span><br><span class="line">        newList.append(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="461-hamming-distance"><a href="#461-hamming-distance" class="headerlink" title="461. hamming-distance"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/hamming-distance/description/">461. hamming-distance</a></h4><ul>
<li>给两个int，求hamming distance. hamming distance指的是两个数不同的bit的个数，例如1001和0011就有两位不同。</li>
<li>异或之后看多少个bit。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingDistance</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> x ^ y;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; mask) != <span class="number">0</span>) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="463-island-perimeter"><a href="#463-island-perimeter" class="headerlink" title="463. island-perimeter"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/island-perimeter/description/">463. island-perimeter</a></h4><ul>
<li>给一个0&#x2F;1二维矩阵，求其中为1的island的周长。</li>
<li>方法一：BFS，每个1都先算它有四条边，然后根据邻接情况减掉不是边的即可��</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">islandPerimeter</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[grid.length][grid[<span class="number">0</span>].length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">perimeter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span> &amp;&amp; !visited[i][j]) &#123;</span><br><span class="line">                    perimeter += bfs(grid, i, j, visited);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> perimeter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] dirs = <span class="keyword">new</span> <span class="title class_">int</span>[][] &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">boolean</span>[][] visited)</span> &#123;</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;i, j&#125;);</span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">perimeter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span>[] curr = q.poll();</span><br><span class="line">            perimeter += <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] dir : dirs) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> curr[<span class="number">0</span>] + dir[<span class="number">0</span>], col = curr[<span class="number">1</span>] + dir[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (isIsland(grid, row, col)) &#123;</span><br><span class="line">                    perimeter--;</span><br><span class="line">                    <span class="keyword">if</span> (!visited[row][col]) &#123;</span><br><span class="line">                        q.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;row, col&#125;);</span><br><span class="line">                        visited[row][col] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> perimeter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isIsland</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= <span class="number">0</span> &amp;&amp; i &lt; grid.length</span><br><span class="line">            &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; grid[<span class="number">0</span>].length</span><br><span class="line">            &amp;&amp; grid[i][j] == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：找规律。对于每一个1的cell，看它的下方和右方neighbor是不是1，记录neighbor数，最后周长就是islands * 4 - neighbours * 2。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">islandPerimeter</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">islands</span> <span class="operator">=</span> <span class="number">0</span>, neighbours = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[i].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                islands++; <span class="comment">// count islands</span></span><br><span class="line">                <span class="keyword">if</span> (i &lt; grid.length - <span class="number">1</span> &amp;&amp; grid[i + <span class="number">1</span>][j] == <span class="number">1</span>) neighbours++; <span class="comment">// count down neighbours</span></span><br><span class="line">                <span class="keyword">if</span> (j &lt; grid[i].length - <span class="number">1</span> &amp;&amp; grid[i][j + <span class="number">1</span>] == <span class="number">1</span>) neighbours++; <span class="comment">// count right neighbours</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> islands * <span class="number">4</span> - neighbours * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="464-can-i-win"><a href="#464-can-i-win" class="headerlink" title="464. can-i-win"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/can-i-win/description/">464. can-i-win</a></h4><ul>
<li>给定一个最大可取的int，再给个目标值target，两个人轮流从<code>[1, int]</code>之间取值，用过的值就不能再用了，两个人取的值不断累加，恰好达到或超过target的人就赢了。问是否能稳赢。</li>
<li>经典的DFS递归。有两个状态需要维护，一个是可选的数字需要用map或者数组bucket存起来，一个是剩余的target。同样为了避免DFS重复计算，需要用一个map将中间结果存起来。如果不加memorize的话时间复杂度<code>O(N!)</code>，相当于从1到N每一步都有N, N-1, N-2…个选择。如果加了memorize，则提升到<code>O(2^N)</code>，相当于1到N每个数字都有取或不取两种状态，可以保证访问过的状态不会重复heo访问，那么就是<code>2^N</code>。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canIWin</span><span class="params">(<span class="type">int</span> maxChoosableInteger, <span class="type">int</span> desiredTotal)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (desiredTotal &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxTotal</span> <span class="operator">=</span> (<span class="number">1</span> + maxChoosableInteger) * maxChoosableInteger / <span class="number">2</span>; </span><br><span class="line">        <span class="keyword">if</span> (maxTotal &lt; desiredTotal) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> checkWin(desiredTotal, <span class="keyword">new</span> <span class="title class_">boolean</span> [maxChoosableInteger], <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Boolean&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkWin</span><span class="params">(<span class="type">int</span> total, <span class="type">boolean</span>[] bucket, Map&lt;String, Boolean&gt; map)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">state</span> <span class="operator">=</span> Arrays.toString(bucket);</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(state)) &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(state);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bucket.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!bucket[i]) &#123;</span><br><span class="line">                bucket[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &gt;= total || !checkWin(total - (i + <span class="number">1</span>), bucket, map)) &#123;     <span class="comment">// 超过或者对方必输，我就赢了</span></span><br><span class="line">                    map.put(state, <span class="literal">true</span>);</span><br><span class="line">                    bucket[i] = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                bucket[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(state, <span class="literal">false</span>);  <span class="comment">// 遍历了所有可能值都不行，必输</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="468-validate-ip-address"><a href="#468-validate-ip-address" class="headerlink" title="468. validate-ip-address"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/validate-ip-address/">468. validate-ip-address</a></h4><ul>
<li>给一个字符串，返回他属于的IP地址类型，若不属于IPv4或IPv6，返回Neither. IPv4的规定是有四个数字组成，用<code>.</code>分开。</li>
<li>很没意思的一题，就是split之后各种判断，需要考虑各种edge case，例如<code>-0</code>, <code>192.0.0.1.</code>。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NEITHER</span> <span class="operator">=</span> <span class="string">&quot;Neither&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">IPV6</span> <span class="operator">=</span> <span class="string">&quot;IPv6&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">IPV4</span> <span class="operator">=</span> <span class="string">&quot;IPv4&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">validIPAddress</span><span class="params">(String IP)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (IP == <span class="literal">null</span> || IP.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> NEITHER;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (validIPv4(IP)) &#123;</span><br><span class="line">            <span class="keyword">return</span> IPV4;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (validIPv6(IP)) &#123;</span><br><span class="line">            <span class="keyword">return</span> IPV6;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> NEITHER;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">validIPv4</span><span class="params">(String addr)</span> &#123;</span><br><span class="line">        String[] parts = addr.split(<span class="string">&quot;\\.&quot;</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (parts.length != <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String part : parts) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> Integer.valueOf(part);</span><br><span class="line">                <span class="keyword">if</span> (part.length() &gt; <span class="number">3</span> || value &lt; <span class="number">0</span> || value &gt; <span class="number">255</span></span><br><span class="line">                   || !String.valueOf(value).equals(part)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span>(NumberFormatException ex) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">validIPv6</span><span class="params">(String addr)</span> &#123;</span><br><span class="line">        String[] parts = addr.split(<span class="string">&quot;:&quot;</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (parts.length != <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String part : parts) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!part.matches(<span class="string">&quot;^[0-9a-fA-F]&#123;1,4&#125;$&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="470-implement-rand10-using-rand7"><a href="#470-implement-rand10-using-rand7" class="headerlink" title="470. implement-rand10-using-rand7"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/implement-rand10-using-rand7/">470. implement-rand10-using-rand7</a></h4><ul>
<li>利用rand7实现rand10，返回随机数1-10.</li>
<li>把它想像成掷骰子，用7面骰子模拟10面骰子，最直接的想法是投多次。例如投两次的话，总共有<code>7*7</code>种可能性，为了映射到<code>1～10</code>，最直接的办法就是取模。但是1<del>49直接取模并不是均匀分布的，因此可以直接将尾巴去掉，即只取到&#96;1</del>40&#96;，之所以可以这样是因为每个数字取到的概率都是一样的，我筛掉不取也一样。具体证明见<a target="_blank" rel="noopener" href="https://leetcode.com/problems/implement-rand10-using-rand7/discuss/150301/Three-line-Java-solution-the-idea-can-be-generalized-to-%22Implement-RandM()-Using-RandN()%22">这里</a>。</li>
<li>由此可以推广，大模拟小的情况下可以直接忽略较大值或取较小值的模，例如用6面骰子模拟2面骰子，可以只取1、2，或者取<code>(x % 2) + 1</code>. 小模拟大则需要找到超过大值的最小幂，例如用3面骰子模拟11面骰子，则可以掷3面骰子3次(<code>3*3*3 = 27</code>)，取<code>1~22</code>，最后取<code>x % 11 + 1</code>。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The rand7() API is already defined in the parent class SolBase.</span></span><br><span class="line"><span class="comment"> * public int rand7();</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a random integer in the range 1 to 7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> <span class="keyword">extends</span> <span class="title class_">SolBase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rand10</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">retVal</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line">        <span class="keyword">while</span> (retVal &gt;= <span class="number">40</span>) &#123;</span><br><span class="line">            retVal = <span class="number">7</span> * (rand7() - <span class="number">1</span>) + (rand7() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retVal % <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="471-encode-string-with-shortest-length"><a href="#471-encode-string-with-shortest-length" class="headerlink" title="471. encode-string-with-shortest-length"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/encode-string-with-shortest-length/">471. encode-string-with-shortest-length</a></h4><ul>
<li>给一个字符串，将它压缩成<code>k[part]</code>的形式，要求压缩后的长度比原来短（答案不唯一）。</li>
<li>DFS + memo，尝试将字符串拆分成一半、1&#x2F;3、1&#x2F;4以此类推的子串，如果发现了重复出现的pattern就可以压缩，同时也尝试将字符串劈成左右两部分分别压缩，最后最小长度的那个。时间复杂度应该是O(N^4)。其中查找最短的重复出现pattern可以用KMP算法，KMP求的是“最长共同prefix和suffix”，也就对应“最短的重复pattern”。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">encode</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> encode(s, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">encode</span><span class="params">(String s, Map&lt;String, String&gt; map)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(s)) &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">retVal</span> <span class="operator">=</span> s;</span><br><span class="line">        <span class="comment">// 从一半开始，尝试将字符串拆分成重复出现的部分</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> len / <span class="number">2</span>; k &lt; len; k++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">pattern</span> <span class="operator">=</span> s.substring(k);</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> countOccurance(s, pattern);</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">formatted</span> <span class="operator">=</span> count + <span class="string">&quot;[&quot;</span> + encode(pattern, map) + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">                <span class="keyword">if</span> (formatted.length() &lt; retVal.length()) &#123;</span><br><span class="line">                    retVal = formatted;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt; len; k++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">left</span> <span class="operator">=</span> s.substring(<span class="number">0</span>, k), right = s.substring(k);</span><br><span class="line">            <span class="type">String</span> <span class="variable">formatted</span> <span class="operator">=</span> encode(left, map) + encode(right, map);</span><br><span class="line">            <span class="keyword">if</span> (formatted.length() &lt; retVal.length()) &#123;</span><br><span class="line">                retVal = formatted;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(s, retVal);</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">countOccurance</span><span class="params">(String s, String pattern)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() % pattern.length() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i += pattern.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.substring(i).startsWith(pattern)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>DP也是类似的思路，<code>dp[i][j]</code>表示以i为起点、j为长度的子字符串的压缩结果，因此后面的结果需要依赖于前面所有更短的字符串的压缩结果，所以dp最外层循环根据的就是长度，然后内层循环尝试将字符串本身压缩、或者divide and conquer左右两部分的压缩结果。这里用到了KMP。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">encode</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        String[][] dp = <span class="keyword">new</span> <span class="title class_">String</span>[len + <span class="number">1</span>][len + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>; l &lt;= len; l++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i + l &lt;= len; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + l;</span><br><span class="line">                <span class="type">String</span> <span class="variable">substr</span> <span class="operator">=</span> s.substring(i, j);</span><br><span class="line">                dp[i][j] = substr;</span><br><span class="line">                <span class="keyword">if</span> (l &gt; <span class="number">4</span>) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">pattern</span> <span class="operator">=</span> getShortestPattern(substr);</span><br><span class="line">                    <span class="keyword">if</span> (pattern.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">formatted</span> <span class="operator">=</span> String.valueOf(substr.length() / pattern.length()) + <span class="string">&quot;[&quot;</span> + dp[i][i + pattern.length()] + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">                        <span class="keyword">if</span> (formatted.length() &lt; dp[i][j].length())&#123;</span><br><span class="line">                            dp[i][j] = formatted;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + <span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (dp[i][k].length() + dp[k][j].length() &lt; dp[i][j].length()) &#123;</span><br><span class="line">                            dp[i][j] = dp[i][k] + dp[k][j];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][len];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getShortestPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span>[] kmp = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> kmp[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s.charAt(j) != s.charAt(i)) &#123;</span><br><span class="line">                j = kmp[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(j) == s.charAt(i)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            kmp[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">prefixLen</span> <span class="operator">=</span> kmp[len - <span class="number">1</span>], patternLen = len - prefixLen;</span><br><span class="line">        <span class="keyword">return</span> prefixLen &gt; <span class="number">0</span> &amp;&amp; len % patternLen == <span class="number">0</span> ? s.substring(<span class="number">0</span>, patternLen) : <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="472-concatenated-words"><a href="#472-concatenated-words" class="headerlink" title="472. concatenated-words"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/concatenated-words/">472. concatenated-words</a></h4><ul>
<li>给一个字符串数组，求所有能通过其他字符串拼接而成的字符串。例如<code>[a, b, abb, bbab, c]</code>返回<code>[abb, bbab]</code>.</li>
<li>近似于暴力的做法：首先将数组按照长度进行排序，然后逐个判断是否能够通过更短的部分组成。这个判断的过程可以用到双指针+DP，利用双指针来取子字符串看看是否在先前出现过，如果出现过且子字符串往前部分也可以由别的部分组成，则到当前索引为止也是可以由其他组成的。假设字符串们平均长度为<code>L</code>，则判断部分<code>O(L*L)</code>;主函数对字符串进行排序为<code>O(NlogN)</code>，对每个字符串遍历调用判断，整体时间复杂度为<code>O(N*L*L)</code>。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findAllConcatenatedWordsInADict</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">        List&lt;String&gt; retVal = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (words == <span class="literal">null</span> || words.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> retVal;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(words, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> a.length() - b.length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Set&lt;String&gt; preWordSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="keyword">if</span> (canForm(word, preWordSet)) &#123;</span><br><span class="line">                retVal.add(word);</span><br><span class="line">            &#125;</span><br><span class="line">            preWordSet.add(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">canForm</span><span class="params">(String word, Set&lt;String&gt; preWordSet)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (preWordSet.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[word.length() + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">1</span>; right &lt;= word.length(); right++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; left &lt; right; left++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[left] &amp;&amp; preWordSet.contains(word.substring(left, right))) &#123;</span><br><span class="line">                    dp[right] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[word.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="475-heaters"><a href="#475-heaters" class="headerlink" title="475. heaters"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/heaters/">475. heaters</a></h4><ul>
<li>给两个数组，一个表示房屋的水平坐标（非负int）、另一个表示暖气的位置。求最小的暖气半径使得每个房子都能被覆盖。</li>
<li>greedy其实就需要找到每个房子距离最近的暖气的距离，取最大值即可保证当暖气为该距离时所有的房子都会被覆盖到。因此对两个数组分别排序后，固定房子坐标，然后取「与当前暖气的距离」跟「与后续暖气的距离」比较，若与当前暖气的距离更近就不需要用到后续暖气来覆盖了，否则就继续往后找暖气。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRadius</span><span class="params">(<span class="type">int</span>[] houses, <span class="type">int</span>[] heaters)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (houses == <span class="literal">null</span> || houses.length == <span class="number">0</span></span><br><span class="line">           || heaters == <span class="literal">null</span> || heaters.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(houses);</span><br><span class="line">        Arrays.sort(heaters);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> house : houses) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; heaters.length - <span class="number">1</span> &amp;&amp;</span><br><span class="line">                  Math.abs(heaters[i] - house) &gt;= Math.abs(heaters[i + <span class="number">1</span>] - house)) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, Math.abs(heaters[i] - house));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="476-number-complement"><a href="#476-number-complement" class="headerlink" title="476. number-complement"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/number-complement/">476. number-complement</a></h4><ul>
<li>给一个正整数，求它的所有bit flip之后的正整数。例如<code>5 = 101</code>，就对应<code>2 = 010</code>。 </li>
<li>可以构造一个全是1的数字，直接异或&#x2F;减去原数即可。<code>111 ^ 101 = 010</code></li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findComplement</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ones</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (ones &lt; num) &#123;</span><br><span class="line">            ones = (ones &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ones ^ num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="477-total-hamming-distance"><a href="#477-total-hamming-distance" class="headerlink" title="477. total-hamming-distance"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/total-hamming-distance/description/">477. total-hamming-distance</a></h4><ul>
<li>给一个int数组，求这些数两两之间的hamming distance之和。hamming distance指的是两个数不同的bit的个数，例如1001和0011就有两位不同。</li>
<li>直接用mask每一个bit地看有多少个数x该位为1，然后x乘一下(N - x)就得到该位不同的数的个数了。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalHammingDistance</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((nums[j] &amp; mask) != <span class="number">0</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += (count * (nums.length - count));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="480-sliding-window-median"><a href="#480-sliding-window-median" class="headerlink" title="480. sliding-window-median"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sliding-window-median/description/">480. sliding-window-median</a></h4><ul>
<li>给一个数组，给一个窗口size &#x3D; k，从前往后滑动窗口，求每一个范围的median。</li>
<li>用两个PriorityQueue分别维护大根堆（存的是较小的值）和小根堆（存的是较大的值），在往里存元素的时候先尝试往minHeap中存<strong>比堆顶大</strong>的值，不行就直接存入maxHeap。两个堆加起来存够k个元素之后，还需要根据两个堆的size进行调整，因为不一定刚好一半一半。匀完了之后，每次从两个堆中取最大、最小值，再根据size &#x3D; k决定中位数是直接取中间还是求平均。当窗口往后挪了之后，需要从两个堆的其中一个中删除，PriorityQueue的<code>offer, poll, remove</code>是<code>O(logN)</code>的，<code>contains</code>是<code>O(N)</code>的，<code>retreive peek</code>是<code>O(1)</code>的。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 和前面的slidingWindowMax单调队列有点像</span></span><br><span class="line">    <span class="comment">// 用一个单调队列可以求一个最大值/最小值，那么用两个单调队列维护大根堆和小根堆</span></span><br><span class="line">    <span class="comment">// 分别取一个元素出来，看看是否需要求平均</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span>[] medianSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">double</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(k, Collections.reverseOrder());</span><br><span class="line">        Queue&lt;Integer&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(k);</span><br><span class="line">        </span><br><span class="line">        <span class="type">double</span>[] ans = <span class="keyword">new</span> <span class="title class_">double</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (minHeap.contains(nums[i - k])) &#123;</span><br><span class="line">                    minHeap.remove(nums[i - k]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    maxHeap.remove(nums[i - k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (minHeap.size() &gt; <span class="number">0</span> &amp;&amp; nums[i] &gt; minHeap.peek()) &#123;</span><br><span class="line">                minHeap.add(nums[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxHeap.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            adjustHeaps(maxHeap, minHeap);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">                ans[i - (k - <span class="number">1</span>)] = getMedian(maxHeap, minHeap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="title function_">getMedian</span><span class="params">(Queue&lt;Integer&gt; minHeap, Queue&lt;Integer&gt; maxHeap)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minHeap.size() == maxHeap.size() ? </span><br><span class="line">            ((<span class="type">double</span>)minHeap.peek() + (<span class="type">double</span>)maxHeap.peek()) / <span class="number">2.0</span> : </span><br><span class="line">            minHeap.size() &gt; maxHeap.size() ? minHeap.peek() : maxHeap.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">adjustHeaps</span><span class="params">(Queue&lt;Integer&gt; maxHeap, Queue&lt;Integer&gt; minHeap)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (Math.abs(maxHeap.size() - minHeap.size()) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxHeap.size() &gt; minHeap.size()) &#123;</span><br><span class="line">                minHeap.add(maxHeap.poll());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxHeap.add(minHeap.poll());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="482-license-key-formatting"><a href="#482-license-key-formatting" class="headerlink" title="482. license-key-formatting"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/license-key-formatting/description/">482. license-key-formatting</a></h4><ul>
<li>给一个字符串，只含有数字和字母，再给一个K，将字符以K个为一组组成licenseKey。skip.</li>
</ul>
<h4 id="484-find-permutation"><a href="#484-find-permutation" class="headerlink" title="484. find-permutation"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-permutation/description/">484. find-permutation</a></h4><ul>
<li>给一个只有D和I的字符串，表示相邻两个数的大小关系下降和上升。求lexicographical最小的、符合这个升降关系的<code>1~n+1</code>的数组。</li>
<li>贪心做法，先一波升序填进去，然后再对应遍历字符串，对于D就一直往后找连续的D，将这一段reverse即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] findPermutation(String s) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length(), arr[] = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>]; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) arr[i] = i + <span class="number">1</span>; <span class="comment">// sorted</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>; h &lt; n; h++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(h) == <span class="string">&#x27;D&#x27;</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> h;</span><br><span class="line">            <span class="keyword">while</span> (h &lt; n &amp;&amp; s.charAt(h) == <span class="string">&#x27;D&#x27;</span>) h++;</span><br><span class="line">            reverse(arr, l, h); </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; h) &#123;</span><br><span class="line">        arr[l] ^= arr[h];   <span class="comment">// 酷炫的异或swap整数</span></span><br><span class="line">        arr[h] ^= arr[l];</span><br><span class="line">        arr[l] ^= arr[h];</span><br><span class="line">        l++; h--;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="485-max-consecutive-ones"><a href="#485-max-consecutive-ones" class="headerlink" title="485. max-consecutive-ones"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/max-consecutive-ones/description/">485. max-consecutive-ones</a></h4><ul>
<li>给一个只含有0和1的数组，求最多连续出现1的个数。</li>
<li>用一个lastIndex记录上一个出现的1的位置，然后不断往后遍历数组，如果是1就更新count、否则就把lastIndex更新过来。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxConsecutiveOnes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>, lastIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[lastIndex] == <span class="number">0</span>) &#123;</span><br><span class="line">                    lastIndex = i;</span><br><span class="line">                &#125;</span><br><span class="line">                max = Math.max(i - lastIndex + <span class="number">1</span>, max);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lastIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="486-predict-the-winner"><a href="#486-predict-the-winner" class="headerlink" title="486. predict-the-winner"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/predict-the-winner/description/">486. predict-the-winner</a></h4><ul>
<li>给一个int数组，两个玩家每次可以从两端任取一个数，轮流取完后比较取出数字之和，谁大谁赢（相等则player 1赢）。判断先选数字的player 1是否稳赢(两个玩家都会走最优)</li>
<li>DP。是否赢需要依赖之前选数字的状态，最终胜负并不在意具体的sum是多少，而是比较两个玩家的sum，因此<code>dp[i][j]</code>存储<code>nums[i...j]</code>中此时选择的玩家会比另一个玩家多多少分。相比上一步，当前玩家可以在两端分别选nums[i]或者nums[j]，每次会选让自己分更多的，即<code>Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]</code>（注意上一步存的是另一个玩家比自己多多少分，因此需要取负）.注意到dp每次只会用到左侧和下侧相邻的cell，<a target="_blank" rel="noopener" href="https://leetcode.com/problems/predict-the-winner/discuss/96828/JAVA-9-lines-DP-solution-easy-to-understand-with-improvement-to-O(N)-space-complexity.">可以优化成只用一维数组的dp</a>。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">PredictTheWinner</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>; len &lt; n; len++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - len; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + len;</span><br><span class="line">                dp[i][j] = Math.max(nums[i] - dp[i + <span class="number">1</span>][j], nums[j] - dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>] &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="487-max-consecutive-ones-ii"><a href="#487-max-consecutive-ones-ii" class="headerlink" title="487. max-consecutive-ones-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/max-consecutive-ones-ii/description/">487. max-consecutive-ones-ii</a></h4><ul>
<li>给一个只含有0和1的数组，至多可以将一个0 flip成1，求最长连续出现1的个数。</li>
<li>利用双指针维护一个至多含有一个0的window，当0过多就移动左指针直到恢复。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxConsecutiveOnes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>, zeroCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>; right &lt; nums.length; right++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[right] == <span class="number">0</span>) &#123;</span><br><span class="line">                zeroCount++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (zeroCount &gt; <span class="number">1</span>) &#123;   <span class="comment">// 将1改为k即可处理flip k个零的情况</span></span><br><span class="line">                <span class="keyword">if</span> (nums[left] == <span class="number">0</span>) &#123;</span><br><span class="line">                    zeroCount--;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>follow-up: 如果输入的数组无法全部存入内存？输入将以stream的形式传入，这样的话就不能直接存放整个数组，可以将零出现的index存入queue，当queue的size超过k的时候就说明window中零的个数过多，此时就将left移到<code>q.poll() + 1</code>即可。</li>
</ul>
<h4 id="489-robot-room-cleaner"><a href="#489-robot-room-cleaner" class="headerlink" title="489. robot-room-cleaner"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/robot-room-cleaner/">489. robot-room-cleaner</a></h4><ul>
<li>给一个Robot机器人类，这个机器人初始化在一个房间内面朝上，0表示障碍、1表示空地。这个机器人可以左转、右转、前进（若遇到障碍&#x2F;边界则返回false）、清扫。要求将这个房间完全清扫。</li>
<li>本质上就是考图的遍历，区别是只能用一个机器人通过DFS做。每次机器人进入一个cell的时候需要转到四个方向尝试前进，可以固定只向右转。四个方向都DFS完后会回到进入当前cell的方向，此时就需要回退到上一个cell，此时就需要实现一个掉头、前进、再掉头的步骤。时间复杂度为<code>O(1cells - 0cells)</code>，因为每个cell只会进入一次。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] dirs = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">(Robot robot, <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> dirIndex, Set&lt;String&gt; visited)</span> &#123;</span><br><span class="line">        robot.clean();</span><br><span class="line">        visited.add(row + <span class="string">&quot; &quot;</span> + col);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (dirIndex + i) % <span class="number">4</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rowNext</span> <span class="operator">=</span> row + dirs[index % <span class="number">4</span>][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">colNext</span> <span class="operator">=</span> col + dirs[index % <span class="number">4</span>][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (!visited.contains(rowNext + <span class="string">&quot; &quot;</span> + colNext) &amp;&amp; robot.move()) &#123;</span><br><span class="line">                clean(robot, rowNext, colNext, index, visited);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 回退到进入dfs前的状态</span></span><br><span class="line">                robot.turnRight();</span><br><span class="line">                robot.turnRight();</span><br><span class="line">                robot.move();</span><br><span class="line">                robot.turnRight();</span><br><span class="line">                robot.turnRight();</span><br><span class="line">            &#125;</span><br><span class="line">            robot.turnRight();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cleanRoom</span><span class="params">(Robot robot)</span> &#123;</span><br><span class="line">        clean(robot, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="490-the-maze"><a href="#490-the-maze" class="headerlink" title="490. the-maze"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/the-maze/description/">490. the-maze</a></h4><ul>
<li>给一个grid，0表示空地1表示障碍物，一颗球在里面滚动，只有碰到障碍物或者边缘才会停下，给起点和终点坐标判断能否到达。BFS. skip.</li>
</ul>
<h4 id="494-target-sum"><a href="#494-target-sum" class="headerlink" title="494. target-sum"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/target-sum/description/">494. target-sum</a></h4><ul>
<li>给一个只含有非负数的int数组和一个target，给这些int加正号或负号进行求和，求共有多少中加符号的方式使得sum等于target。其中所有数的sum不会超过1000，且数组长度不超过20.</li>
<li>注意到了限制“所有数的sum不会超过1000”，就联想到了木桶法。每个bucket[index]表示和为index有多少种方式，那么读入新的数x时将当前index的数加到[index+x]和[index-x]处即可。注意不可对原数组直接操作。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> S)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span> || Math.abs(S) &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] bucket = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">2001</span>];      <span class="comment">// 全部平移1000</span></span><br><span class="line">        <span class="type">int</span>[] bucketTemp = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">2001</span>];</span><br><span class="line">        bucket[<span class="number">1000</span>] = <span class="number">1</span>;                   <span class="comment">// sum = 0初始有一种情况，即空的输入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; bucket.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bucket[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                        bucketTemp[j - nums[i]] += bucket[j];   <span class="comment">// 以当前值为中心点往两边拓展</span></span><br><span class="line">                        bucketTemp[j + nums[i]] += bucket[j];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        bucketTemp[j] = bucket[j] * <span class="number">2</span>;          <span class="comment">// 当前值为0则直接翻倍（+0 / -0）</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    bucket[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; bucketTemp.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bucketTemp[j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    bucket[j] = bucketTemp[j];</span><br><span class="line">                    bucketTemp[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bucket[S + <span class="number">1000</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="495-teemo-attacking"><a href="#495-teemo-attacking" class="headerlink" title="495. teemo-attacking"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/teemo-attacking/">495. teemo-attacking</a></h4><ul>
<li>pass。</li>
</ul>
<h4 id="496-next-greater-element-i"><a href="#496-next-greater-element-i" class="headerlink" title="496. next-greater-element-i"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/next-greater-element-i/description/">496. next-greater-element-i</a></h4><ul>
<li>给两个int数组，都不含重复元素，求nums1中元素在nums2中的next greater.不存在则设为-1.</li>
<li>首先处理一波nums2，从前往后入栈，每次入栈之前需要判断是否小于栈顶，如果大于了栈顶，说明栈中元素的next greater就是当前元素，用一个map存起来（不含重复元素就可以这样搞），最后遍历nums1的时候直接从map中取就可以了。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElement(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1 == <span class="literal">null</span> || nums2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: nums2) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() &lt; num) &#123;</span><br><span class="line">                map.put(stack.pop(), num);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span> [nums1.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">            ans[i] = map.getOrDefault(nums1[i], -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="498-diagonal-traverse"><a href="#498-diagonal-traverse" class="headerlink" title="498. diagonal-traverse"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/diagonal-traverse">498. diagonal-traverse</a></h4><ul>
<li>给一个matrix，求蛇形遍历后得到的一维数组。</li>
<li>分情况讨论，向右上遍历的时候可能从上、右侧出去，向左下遍历的时候可能从左、下侧出去，对应调整index即可。pass。</li>
</ul>
<h4 id="499-the-maze-iii"><a href="#499-the-maze-iii" class="headerlink" title="499. the-maze-iii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/the-maze-iii/description/">499. the-maze-iii</a></h4><ul>
<li>给一个grid，0表示空地1表示障碍物，一颗球在里面滚动，只有碰到障碍物或者边缘才会停下，给起点和终点（和另两题的区别是这是一个洞，球滚到这里就会掉进去）坐标，求最短滚过的格子的路径（用u, d, l, r代替走过的上下左右），若有多个最短路径则取lexicographical更小的那个路径，若无法到达则返回<code>impossible</code>.</li>
<li>和前面第二题相比又需要存多一个path的信息，同时PriorityQueue的比较函数也需要更新当滚过的路程一样长时需要比较String。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Point</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Point&gt; &#123;</span><br><span class="line">        <span class="type">int</span> row, col, step;</span><br><span class="line">        String path;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> step, String path)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.row = row;</span><br><span class="line">            <span class="built_in">this</span>.col = col;</span><br><span class="line">            <span class="built_in">this</span>.step = step;</span><br><span class="line">            <span class="built_in">this</span>.path = path;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Point that)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.step == that.step ? <span class="built_in">this</span>.path.compareTo(that.path) : <span class="built_in">this</span>.step - that.step;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">IMP</span> <span class="operator">=</span> <span class="string">&quot;impossible&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findShortestWay</span><span class="params">(<span class="type">int</span>[][] maze, <span class="type">int</span>[] ball, <span class="type">int</span>[] hole)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (maze == <span class="literal">null</span> || maze.length == <span class="number">0</span> || maze[<span class="number">0</span>].length == <span class="number">0</span></span><br><span class="line">           || ball == <span class="literal">null</span> || ball.length != <span class="number">2</span></span><br><span class="line">           || hole == <span class="literal">null</span> || hole.length != <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> IMP;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> maze.length, cols = maze[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[rows][cols];</span><br><span class="line">        PriorityQueue&lt;Point&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        q.offer(<span class="keyword">new</span> <span class="title class_">Point</span>(ball[<span class="number">0</span>], ball[<span class="number">1</span>], <span class="number">0</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">Point</span> <span class="variable">curr</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="keyword">if</span> (curr.row == hole[<span class="number">0</span>] &amp;&amp; curr.col == hole[<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> curr.path;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[curr.row][curr.col] = <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="type">Point</span> <span class="variable">up</span> <span class="operator">=</span> getNext(curr, -<span class="number">1</span>, <span class="number">0</span>, maze, hole);</span><br><span class="line">            <span class="keyword">if</span> (!visited[up.row][up.col]) &#123;</span><br><span class="line">                up.path += <span class="string">&quot;u&quot;</span>;</span><br><span class="line">                q.offer(up);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="type">Point</span> <span class="variable">down</span> <span class="operator">=</span> getNext(curr, <span class="number">1</span>, <span class="number">0</span>, maze, hole);</span><br><span class="line">            <span class="keyword">if</span> (!visited[down.row][down.col]) &#123;</span><br><span class="line">                down.path += <span class="string">&quot;d&quot;</span>;</span><br><span class="line">                q.offer(down);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="type">Point</span> <span class="variable">left</span> <span class="operator">=</span> getNext(curr, <span class="number">0</span>, -<span class="number">1</span>, maze, hole);</span><br><span class="line">            <span class="keyword">if</span> (!visited[left.row][left.col]) &#123;</span><br><span class="line">                left.path += <span class="string">&quot;l&quot;</span>;</span><br><span class="line">                q.offer(left);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="type">Point</span> <span class="variable">right</span> <span class="operator">=</span> getNext(curr, <span class="number">0</span>, <span class="number">1</span>, maze, hole);</span><br><span class="line">            <span class="keyword">if</span> (!visited[right.row][right.col]) &#123;</span><br><span class="line">                right.path += <span class="string">&quot;r&quot;</span>;</span><br><span class="line">                q.offer(right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> IMP;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Point <span class="title function_">getNext</span><span class="params">(Point curr, <span class="type">int</span> rowShift, <span class="type">int</span> colShift, <span class="type">int</span>[][] maze, <span class="type">int</span>[] hole)</span> &#123;</span><br><span class="line">        <span class="type">Point</span> <span class="variable">next</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(curr.row, curr.col, curr.step, curr.path);</span><br><span class="line">        <span class="keyword">while</span> (next.row + rowShift &gt;= <span class="number">0</span> &amp;&amp; next.row + rowShift &lt; maze.length</span><br><span class="line">               &amp;&amp; next.col + colShift &gt;= <span class="number">0</span> &amp;&amp; next.col + colShift &lt; maze[<span class="number">0</span>].length</span><br><span class="line">               &amp;&amp; maze[next.row + rowShift][next.col + colShift] == <span class="number">0</span>) &#123;</span><br><span class="line">            next.row += rowShift;</span><br><span class="line">            next.col += colShift;</span><br><span class="line">            next.step++;</span><br><span class="line">            <span class="keyword">if</span> (next.row == hole[<span class="number">0</span>] &amp;&amp; next.col == hole[<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="503-next-greater-element-ii"><a href="#503-next-greater-element-ii" class="headerlink" title="503. next-greater-element-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems//description/">503. next-greater-element-ii</a></h4><ul>
<li>给一个circular数组，求每一个元素的下一个更大的元素的索引，如果不存在则设为-1。例如<code>[1,2,1]</code>返回<code>[2,-1,2]</code>。</li>
<li>这种circular性质的，容易想到直接拼接一段重复的元素到后方，转换成普通数组找后续更大值，时间O(N^2)。此外还能利用stack存放索引，首先从后往前把所有元素都丢进去，然后i还是从后往前遍历原数组并与栈顶索引对应的元素比较，直到小于栈顶时才将栈顶存入结果数组。此时还需要将当前索引push到栈中，因为循环的下一步是往前一个，所以需要将当前的元素存入stack作为最接近的next candidate.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElements(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span> [nums.length];</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;    <span class="comment">// 从后往前将元素入栈</span></span><br><span class="line">            stack.push(nums[i]);</span><br><span class="line">            ans[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;    <span class="comment">// 从后往前找greater</span></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[i] &gt;= stack.peek()) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                ans[i] = stack.peek();</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(nums[i]);  <span class="comment">// 因为下一个要遍历i - 1，所以就直接把i给入栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="505-the-maze-ii"><a href="#505-the-maze-ii" class="headerlink" title="505. the-maze-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/the-maze-ii/description/">505. the-maze-ii</a></h4><ul>
<li>给一个grid，0表示空地1表示障碍物，一颗球在里面滚动，只有碰到障碍物或者边缘才会停下，给起点和终点坐标，求最短滚过的格子数，若无法到达则返回-1.</li>
<li>仍然是BFS，只不过此时需要利用PriorityQueue代替传统BFS的Queue，这个PQ的比较函数是将从起点滚过距离最短的放在前面，这样率先到达终点的就一定是最短路径。</li>
</ul>
<h4 id="508-most-frequent-subtree-sum"><a href="#508-most-frequent-subtree-sum" class="headerlink" title="508. most-frequent-subtree-sum"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/most-frequent-subtree-sum/description/">508. most-frequent-subtree-sum</a></h4><ul>
<li>给一个二叉树，求所有subtree sum中出现最频繁的，tie则全都输出。</li>
<li>递归求sum过程中直接用map统计出现次数，最后导出来存入数组返回即可。skip。</li>
</ul>
<h4 id="509-fibonacci-number"><a href="#509-fibonacci-number" class="headerlink" title="509. fibonacci-number"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/fibonacci-number/">509. fibonacci-number</a></h4><ul>
<li>实现斐波那契数列。</li>
<li>递归&#x2F;memo递归&#x2F;双变量都可以。还有两个没有见过的方法，一是用矩阵Matrix Exponentiation，这样只需要<code>O(logN)</code>时间&amp;空间复杂度就可以了。二是用纯数学，用黄金比例可以<code>O(1)</code>实现。具体见<a target="_blank" rel="noopener" href="https://leetcode.com/problems/fibonacci-number/solution/">这里</a></li>
</ul>
<h4 id="510-inorder-successor-in-bst-ii"><a href="#510-inorder-successor-in-bst-ii" class="headerlink" title="510. inorder-successor-in-bst-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/inorder-successor-in-bst-ii/">510. inorder-successor-in-bst-ii</a></h4><ul>
<li>给一个BST中的节点（除了left, right, val还有parent），求在in-order遍历中它的下一个节点，即比他大的最小节点。</li>
<li>根据BST的定义，节点左子树全部比它小、右子树全部比它大。给定节点，如果它有右子树，则取右子树的最左节点即可。如果它没有右子树，说明在它上方某处，一直向上回溯，直到找到一个节点是parent的左子树，那么这个parent就是恰好比所有这堆左子树大的了。时间复杂度为<code>O(树高度)</code>，平均为<code>O(logN)</code>，最坏<code>O(N)</code>.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node left;</span></span><br><span class="line"><span class="comment">    public Node right;</span></span><br><span class="line"><span class="comment">    public Node parent;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">inorderSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (node.parent != <span class="literal">null</span> &amp;&amp; node == node.parent.right) &#123;</span><br><span class="line">                node = node.parent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node.parent;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">            <span class="keyword">while</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="513-find-bottom-left-tree-value"><a href="#513-find-bottom-left-tree-value" class="headerlink" title="513. find-bottom-left-tree-value"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-bottom-left-tree-value/description/">513. find-bottom-left-tree-value</a></h4><ul>
<li>给一个二叉树，求最下面一层最左边的节点。</li>
<li>方法一：Iterative，从右往左进行层级遍历，最后一个遍历到的节点就是最下层的最左节点。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            curr = q.poll();</span><br><span class="line">            <span class="keyword">if</span> (curr.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                q.offer(curr.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curr.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                q.offer(curr.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：Recursive, 正常地从左到右前序遍历，但是会track深度，第一个达到新的深度的节点就一定是最左边的。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>, h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        find(root, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">find</span><span class="params">(TreeNode root, <span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (h &lt; level) &#123;</span><br><span class="line">            ans = root.val;</span><br><span class="line">            h = level;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            find(root.left, level + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            find(root.right, level + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="515-find-largest-value-in-each-tree-row"><a href="#515-find-largest-value-in-each-tree-row" class="headerlink" title="515. find-largest-value-in-each-tree-row"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-largest-value-in-each-tree-row/description/">515. find-largest-value-in-each-tree-row</a></h4><ul>
<li>给一个树，返回它每一个level节点的最大值。</li>
<li>层级遍历嘛。DFS和BFS。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; levelMax;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">largestValues</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        levelMax = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfsLevelMax(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> levelMax;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfsLevelMax</span><span class="params">(TreeNode node, <span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        updateLevelMax(node.val, level);</span><br><span class="line">        dfsLevelMax(node.left, level + <span class="number">1</span>);</span><br><span class="line">        dfsLevelMax(node.right, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateLevelMax</span><span class="params">(<span class="type">int</span> val, <span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (levelMax.size() == level) &#123;</span><br><span class="line">            levelMax.add(val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            levelMax.set(level, Math.max(val, levelMax.get(level)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="516-longest-palindromic-subsequence"><a href="#516-longest-palindromic-subsequence" class="headerlink" title="516. longest-palindromic-subsequence"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-palindromic-subsequence/description/">516. longest-palindromic-subsequence</a></h4><ul>
<li>给一个字符串，求其中最长的自对称的subsequence（顺序与原字符串一样但不一定是连续的）的长度。例如<code>bbbab</code>最长为4（<code>bbbb</code>）。</li>
<li>DP。和647一样也是从后往前更新DP数组，<code>dp[i][j]</code>表示从i到j（inclusive）的最长长度。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span>[] sChar = s.toCharArray();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span> [sChar.length][sChar.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> sChar.length - <span class="number">1</span>; row &gt;= <span class="number">0</span>; row--) &#123;     <span class="comment">// 从最后一个字符往前更新</span></span><br><span class="line">            dp[row][row] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> row + <span class="number">1</span>; col &lt; sChar.length; col++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sChar[row] == sChar[col]) &#123;</span><br><span class="line">                    dp[row][col] = <span class="number">2</span> + dp[row + <span class="number">1</span>][col - <span class="number">1</span>];    <span class="comment">// 取中间夹的部分的最长长度加上头尾两个</span></span><br><span class="line">                    <span class="comment">// compare prev or adding curr palindrome. no worry about exceeding boundary</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 不取当前字符</span></span><br><span class="line">                    dp[row][col] = Math.max(dp[row][col - <span class="number">1</span>], dp[row + <span class="number">1</span>][col]);    <span class="comment">// keep at previous one</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][sChar.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="518-coin-change-2"><a href="#518-coin-change-2" class="headerlink" title="518. coin-change-2"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/coin-change-2/description/">518. coin-change-2</a></h4><ul>
<li>给一个数组表示有哪些面额的硬币，每个面额的硬币有无限多个可以任取。给定一个目标值，求总共有多少种组合方式。</li>
<li>DP。和前面的那个硬币题类似，这里dp[i]表示达到i这个值有多少组合方式。如果当前硬币的面额是x，则dp[i] &#x3D; dp[i] + dp[i - x].</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (amount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (coins == <span class="literal">null</span> || coins.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dp[amount]表示凑成amount有几种ways</span></span><br><span class="line">        <span class="comment">// 对于每个dp[i + coin] = dp[i + coin] + dp[i]</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span> [amount + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; coins.length; i++) &#123;    <span class="comment">// 固定coin值遍历所有可能值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; dp.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= coins[i]) &#123;</span><br><span class="line">                    dp[j] += dp[j - coins[i]];  <span class="comment">// 从j - coins[i]增加到j</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="523-continuous-subarray-sum"><a href="#523-continuous-subarray-sum" class="headerlink" title="523. continuous-subarray-sum"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/continuous-subarray-sum/description/">523. continuous-subarray-sum</a></h4><ul>
<li>给一个非负int数组和一个非负整数k，判断是否含有长度大于等于2的连续subarray whose sum是k的multiple。可以保证将原数组所有数加起来不会爆int。</li>
<li>方法一：暴力法，求膜的方式O(N^2)两重循环求sum。</li>
<li>方法二：求是否含有一部分使得sum是n*k，那么如果利用Map记录sum对应的索引，一路往后加x%k，当出现前面已经存在的sum的时候，说明这一路加的x刚好膜k得到0，即为k的倍数。注意需要特殊处理0，不可以膜0.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkSubarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录得到当前sum对应的索引</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; sum2Index = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        sum2Index.put(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (k != <span class="number">0</span>) &#123;</span><br><span class="line">                sum %= k;   <span class="comment">// 膜来处理倍数问题</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum2Index.containsKey(sum)) &#123;   <span class="comment">// 说明膜了一波等于0，中间可能有k的倍数</span></span><br><span class="line">                <span class="keyword">if</span> (i - sum2Index.get(sum) &gt; <span class="number">1</span>) &#123;   <span class="comment">// 注意需要长度大于等于2</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum2Index.put(sum, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="524-longest-word-in-dictionary-through-deleting"><a href="#524-longest-word-in-dictionary-through-deleting" class="headerlink" title="524. longest-word-in-dictionary-through-deleting"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/description/">524. longest-word-in-dictionary-through-deleting</a></h4><ul>
<li>给一个字符串s，给一个单词List，求将s中部分字母删除后能得到的最长的在List中的单词，若长度相等则取lexicographical更短的。</li>
<li>遍历List中的单词，与s比较看是否是subsequence。基本是暴力做法，只不过prune掉了一些情况，只有当candidate比之前的结果更长或者lexicographical order更前才会计算。还有一种做法是先对List进行排序，长度长的在前、字典序小的在前，然后再直接遍历List，第一个subsequence即为所求。</li>
</ul>
<h4 id="525-contiguous-array"><a href="#525-contiguous-array" class="headerlink" title="525. contiguous-array"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/contiguous-array/description/">525. contiguous-array</a></h4><ul>
<li>给一个只含0,1的int数组，求最长subarray的长度使得其中的0,1个数相等。</li>
<li>方法一：暴力破解，固定start和end依次看当前窗口的0,1个数。O(N^2)超时。</li>
<li>方法二：既然需要的是0,1相等的个数而不关心具体位置／顺序，也就是如果经过一波操作之后0和1的个数差回到原点，说明一波操作没有造成什么后果，也就是0，1个数相等。或者更近一步，将0先一波流替换成-1，这样只要sum为0就意味着相等，而且如果当前的sum在之前出现过，说明经过一波操作又回到原点，那么-1,1的个数也是相等的。因此想到用map记录sum出现的各个位置，只记录最早出现的位置，这样一旦后面出现了这个sum就可以求得最长长度了。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                nums[i] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; sum2Index = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        sum2Index.put(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>, maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (sum2Index.containsKey(sum)) &#123;</span><br><span class="line">                maxLen = Math.max(maxLen, i - sum2Index.get(sum));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum2Index.put(sum, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="526-beautiful-arrangement"><a href="#526-beautiful-arrangement" class="headerlink" title="526. beautiful-arrangement"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/beautiful-arrangement/">526. beautiful-arrangement</a></h4><ul>
<li>美丽安排指的是在数组中元素和下标之间有整除关系（谁除谁都行）。</li>
<li>DFS即可，每次尝试不同元素。时间复杂度<code>O(n!)</code>.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countArrangement</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span>[] used = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        dfs(<span class="number">1</span>, n, used);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> curr, <span class="type">int</span> n, <span class="type">boolean</span>[] used)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (curr &gt; n) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!used[i] &amp;&amp; (curr % i == <span class="number">0</span> || i % curr == <span class="number">0</span>)) &#123;</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line">                dfs(curr + <span class="number">1</span>, n, used);</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="528-random-pick-with-weight"><a href="#528-random-pick-with-weight" class="headerlink" title="528. random-pick-with-weight"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/random-pick-with-weight/">528. random-pick-with-weight</a></h4><ul>
<li>给一个只含有正整数的数组，表示该index所占的权重，实现一个随机生成器按照这个权重来取对应的索引。</li>
<li>利用一个累加数组，将所有权重累加起来。然后根据总和生成随机数，再利用二分查找看看这个数应该落在哪个权重和的区间内，就可以取对应的索引了。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Random r;</span><br><span class="line">    <span class="type">int</span>[] sums;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Solution</span><span class="params">(<span class="type">int</span>[] w)</span> &#123;</span><br><span class="line">        r = <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        sums = <span class="keyword">new</span> <span class="title class_">int</span>[w.length];</span><br><span class="line">        sums[<span class="number">0</span>] = w[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; w.length; i++) &#123;</span><br><span class="line">            sums[i] = sums[i - <span class="number">1</span>] + w[i];   <span class="comment">// 累加数组</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pickIndex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> r.nextInt(sums[sums.length - <span class="number">1</span>]) + <span class="number">1</span>;  <span class="comment">// 在1～最终累加和之间取随机数</span></span><br><span class="line">        <span class="keyword">return</span> binarySearchInsertPos(sums, target);         <span class="comment">// 找随机数所处的区间</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">binarySearchInsertPos</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> -<span class="number">1</span>, right = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (right - left &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution obj = new Solution(w);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.pickIndex();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="529-minesweeper"><a href="#529-minesweeper" class="headerlink" title="529. minesweeper"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minesweeper/description/">529. minesweeper</a></h4><ul>
<li>点击一个位置，根据是否有雷更新棋盘。如果是雷，直接改成叉叉并返回；如果没有点开并且周围八个相邻格子有雷，则改成雷的数目并返回；如果周围都没有雷，就扩散到相邻格子继续更新。</li>
<li>方法一：根据描述本身就蕴含了递归，所以自然想到DFS。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span>[][] updateBoard(<span class="type">char</span>[][] board, <span class="type">int</span>[] click) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="literal">null</span> || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span></span><br><span class="line">           || click == <span class="literal">null</span> || click.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">char</span> [<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rowCount</span> <span class="operator">=</span> board.length, colCount = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> click[<span class="number">0</span>], col = click[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (board[row][col] == <span class="string">&#x27;B&#x27;</span>) &#123;   <span class="comment">// 已经点开了就直接返回</span></span><br><span class="line">            <span class="keyword">return</span> board;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (board[row][col] == <span class="string">&#x27;M&#x27;</span>) &#123;   <span class="comment">// 是雷就gg</span></span><br><span class="line">            board[row][col] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;              <span class="comment">// 计算雷的个数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> -<span class="number">1</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tempRow</span> <span class="operator">=</span> row + i;</span><br><span class="line">                <span class="keyword">if</span> (tempRow &lt; <span class="number">0</span> || tempRow &gt;= rowCount) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> -<span class="number">1</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">tempCol</span> <span class="operator">=</span> col + j;</span><br><span class="line">                    <span class="keyword">if</span> (tempCol &lt; <span class="number">0</span> || tempCol &gt;= colCount) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (board[tempRow][tempCol] == <span class="string">&#x27;M&#x27;</span>) &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                board[row][col] = (<span class="type">char</span>)(<span class="string">&#x27;0&#x27;</span> + count);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                board[row][col] = <span class="string">&#x27;B&#x27;</span>;      <span class="comment">// 改为已经reveal，并扩散到周围unreveal的邻居</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> -<span class="number">1</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">tempRow</span> <span class="operator">=</span> row + i;</span><br><span class="line">                    <span class="keyword">if</span> (tempRow &lt; <span class="number">0</span> || tempRow &gt;= rowCount) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> -<span class="number">1</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">tempCol</span> <span class="operator">=</span> col + j;</span><br><span class="line">                        <span class="keyword">if</span> (tempCol &lt; <span class="number">0</span> || tempCol &gt;= colCount) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (board[tempRow][tempCol] == <span class="string">&#x27;E&#x27;</span>) &#123;   <span class="comment">// DFS the unrevealed</span></span><br><span class="line">                            updateBoard(board, <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;tempRow, tempCol&#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> board;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：BFS，Queue中存放点击之后扩散的点（如果有的话），一直扩散直到Queue为空。但是和DFS需要区别的是，由于BFS会将相邻的所有E的格子都入队，很可能会出现重复，所以就直接在更新时就赋值为B，防止重复入队。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span>[][] updateBoard(<span class="type">char</span>[][] board, <span class="type">int</span>[] click) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="literal">null</span> || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span></span><br><span class="line">           || click == <span class="literal">null</span> || click.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">char</span> [<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">rowCount</span> <span class="operator">=</span> board.length, colCount = board[<span class="number">0</span>].length;</span><br><span class="line">        q.add(click);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span>[] curr = q.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> curr[<span class="number">0</span>], col = curr[<span class="number">1</span>];   <span class="comment">// 和DFS相比少了判断为B的步骤</span></span><br><span class="line">            <span class="keyword">if</span> (board[row][col] == <span class="string">&#x27;M&#x27;</span>) &#123;</span><br><span class="line">                board[row][col] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> -<span class="number">1</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">tempRow</span> <span class="operator">=</span> row + i;</span><br><span class="line">                    <span class="keyword">if</span> (tempRow &lt; <span class="number">0</span> || tempRow &gt;= rowCount) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> -<span class="number">1</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">tempCol</span> <span class="operator">=</span> col + j;</span><br><span class="line">                        <span class="keyword">if</span> (tempCol &lt; <span class="number">0</span> || tempCol &gt;= colCount) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (board[tempRow][tempCol] == <span class="string">&#x27;M&#x27;</span>) &#123;</span><br><span class="line">                            count++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    board[row][col] = (<span class="type">char</span>)(<span class="string">&#x27;0&#x27;</span> + count);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    board[row][col] = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> -<span class="number">1</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">tempRow</span> <span class="operator">=</span> row + i;</span><br><span class="line">                        <span class="keyword">if</span> (tempRow &lt; <span class="number">0</span> || tempRow &gt;= rowCount) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> -<span class="number">1</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">tempCol</span> <span class="operator">=</span> col + j;</span><br><span class="line">                            <span class="keyword">if</span> (tempCol &lt; <span class="number">0</span> || tempCol &gt;= colCount) &#123;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (board[tempRow][tempCol] == <span class="string">&#x27;E&#x27;</span>) &#123;   <span class="comment">// BFS the unrevealed</span></span><br><span class="line">                                q.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;tempRow, tempCol&#125;);</span><br><span class="line">                                board[tempRow][tempCol] = <span class="string">&#x27;B&#x27;</span>;  <span class="comment">// IMPORTANT!!!</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> board;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="530-minimum-absolute-difference-in-bst"><a href="#530-minimum-absolute-difference-in-bst" class="headerlink" title="530. minimum-absolute-difference-in-bst"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-absolute-difference-in-bst/">530. minimum-absolute-difference-in-bst</a></h4><ul>
<li>给一个BST，求任意两个节点之差的绝对值的最小值。</li>
<li>BST的重要特性就是中序遍历能得到有序序列，而最小的差一定是相邻的两个节点。因此可以中序遍历的时候利用prev减一减。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">TreeNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">minDiff</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        getMinimumDifference(root.left);</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span>) &#123;</span><br><span class="line">            minDiff = Math.min(minDiff, root.val - prev.val);</span><br><span class="line">        &#125;</span><br><span class="line">        prev = root;</span><br><span class="line">        getMinimumDifference(root.right);</span><br><span class="line">        <span class="keyword">return</span> minDiff;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="532-k-diff-pairs-in-an-array"><a href="#532-k-diff-pairs-in-an-array" class="headerlink" title="532. k-diff-pairs-in-an-array"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/k-diff-pairs-in-an-array/">532. k-diff-pairs-in-an-array</a></h4><ul>
<li>给一个int数组，找其中unique对儿使得两个数的差的绝对值等于k，求对儿数。</li>
<li>方法一：用map来count每个数字出现的次数，如果是新出现的数字且map中有对应的另一半就累加。注意用map是因为要处理<code>k = 0</code>的情况。</li>
<li>方法二：排序后双指针，如果发现gap较大说明需要挪动左指针、gap过小则需要挪动右指针。需要注意处理左指针连续相同值的情况，这就需要连续挪动直到前后值不相等。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findPairs</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span> || k &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; nums.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (right &lt;= left || nums[right] - nums[left] &lt; k) &#123;    <span class="comment">// 有可能左指针skip了很多相同的值</span></span><br><span class="line">                right++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((left &gt; <span class="number">0</span> &amp;&amp; nums[left] == nums[left - <span class="number">1</span>]) ||</span><br><span class="line">                      nums[right] - nums[left] &gt; k) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left++;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="535-encode-and-decode-tinyurl"><a href="#535-encode-and-decode-tinyurl" class="headerlink" title="535. encode-and-decode-tinyurl"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/encode-and-decode-tinyurl/description/">535. encode-and-decode-tinyurl</a></h4><ul>
<li>实现一个含有encode和decode方法的类，能够转码和解码tinyURL。</li>
<li>这种映射关系必定需要Map，关键是如何建立这种从长到短的映射？利用随机数随机从一长串字符串中取字符，取够6个即形成了短码。如果这个短码已经存在，就需要再来一次生成新的短码，直到出现新的。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HOST</span> <span class="operator">=</span> <span class="string">&quot;http://tinyurl.com/&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CHAR</span> <span class="operator">=</span> <span class="string">&quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LIMIT</span> <span class="operator">=</span> CHAR.length();</span><br><span class="line">    </span><br><span class="line">    Map&lt;String, String&gt; url2tiny = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Map&lt;String, String&gt; tiny2url = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Encodes a URL to a shortened URL.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">encode</span><span class="params">(String longUrl)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (url2tiny.containsKey(longUrl)) &#123;</span><br><span class="line">            <span class="keyword">return</span> HOST + url2tiny.get(longUrl);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * LIMIT);</span><br><span class="line">                sb.append(CHAR.charAt(index));</span><br><span class="line">            &#125;</span><br><span class="line">            ret = sb.toString();</span><br><span class="line">        &#125; <span class="keyword">while</span> (tiny2url.containsKey(ret));</span><br><span class="line">        </span><br><span class="line">        url2tiny.put(longUrl, ret);</span><br><span class="line">        tiny2url.put(ret, longUrl);</span><br><span class="line">        <span class="keyword">return</span> HOST + ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes a shortened URL to its original URL.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">decode</span><span class="params">(String shortUrl)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tiny2url.get(shortUrl.replace(HOST, <span class="string">&quot;&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec = new Codec();</span></span><br><span class="line"><span class="comment">// codec.decode(codec.encode(url));</span></span><br></pre></td></tr></table></figure>

<h4 id="536-construct-binary-tree-from-string"><a href="#536-construct-binary-tree-from-string" class="headerlink" title="536. construct-binary-tree-from-string"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-binary-tree-from-string/">536. construct-binary-tree-from-string</a></h4><ul>
<li>给一个由数字、<code>-</code>、括号组成的字符串，将它还原成一个二叉树，注意空树由<code>&quot;&quot;</code>表示而不是<code>()</code>。一开始完全无法理解<code>-</code>是干啥的，原来只是用来表示负数，囧。</li>
<li>方法一：看到这种括号嵌套就想到利用stack，到<code>(</code>直接忽略，碰到数字或者<code>-</code>则将这个value提取出来后，再看看栈顶节点是否已经有left&#x2F;right，对应添加上去后再入栈，这样就可以保证后续的孩子节点能够继续连到当前节点，碰到<code>)</code>则说明栈顶节点已经处理完毕，直接弹出即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">str2tree</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; s.length() &amp;&amp; </span><br><span class="line">                    (Character.isDigit(s.charAt(i)) || s.charAt(i) == <span class="string">&#x27;-&#x27;</span>)) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.valueOf(s.substring(start, i)));</span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stack.peek().left == <span class="literal">null</span>) &#123;</span><br><span class="line">                    stack.peek().left = curr;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    stack.peek().right = curr;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(curr);</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：更自然的是想到递归，但是这样就不是one-pass的，因为每次需要根据括号的情况找到后续节点对应的字符串，需要不断地count括号，比如<a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-binary-tree-from-string/discuss/100357/Verbose-Java-Solution-Recursion">这个</a>。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">str2tree</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.length() &amp;&amp; (Character.isDigit(s.charAt(i)) || s.charAt(i) == <span class="string">&#x27;-&#x27;</span>)) &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.valueOf(s.substring(<span class="number">0</span>, i++)));   <span class="comment">// 挪到下一个位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>, start = i;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.length() &amp;&amp; count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时i指向字符末尾或者(</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; i - <span class="number">1</span>) &#123;   <span class="comment">// 取start到i-1部分作为前半部分</span></span><br><span class="line">        root.left = str2tree(s.substring(start, i - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i + <span class="number">1</span> &lt; s.length() - <span class="number">1</span>) &#123;  <span class="comment">// 取(的后一个字符到)之前的字符</span></span><br><span class="line">        root.right = str2tree(s.substring(i + <span class="number">1</span>, s.length() - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="538-convert-bst-to-greater-tree"><a href="#538-convert-bst-to-greater-tree" class="headerlink" title="538. convert-bst-to-greater-tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/convert-bst-to-greater-tree/">538. convert-bst-to-greater-tree</a></h4><ul>
<li>给一个BST，将每个节点的值加上BST中所有比他大的节点值，返回修改之后的greater树。</li>
<li>既然是BST，那么在中序遍历的时候就可以得到从小到大的序列了，因此使用一个全局的running sum<strong>从右往左</strong>求和即可滚雪球似的得到比当前节点大的所有值之和了。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">convertBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            convertBST(root.right);</span><br><span class="line">            sum += root.val;</span><br><span class="line">            root.val = sum;</span><br><span class="line">            convertBST(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果不能用全局变量，就考虑传入一个参数作为running sum。对于每一个节点，比他大的节点可以出现在右孩子，或者他的祖先（如果他本身是左孩子的话）。由于没有prev链接，因此在递归时需要直接传入他的祖先中比他大的值之和。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">convertBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> dfs(root.right, val);   <span class="comment">// 对于右孩子来说，比它大的就是val，返回的就是所有比当前节点大的值之和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> dfs(root.left, root.val + right); <span class="comment">// 对于左孩子来说，比它大的除了上一步的right还有当前节点</span></span><br><span class="line">        root.val = root.val + right; </span><br><span class="line">        <span class="keyword">return</span> left;    <span class="comment">// 返回的left包括了以当前节点为根的所有节点之和</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="539-minimum-time-difference"><a href="#539-minimum-time-difference" class="headerlink" title="539. minimum-time-difference"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-time-difference/">539. minimum-time-difference</a></h4><ul>
<li>给一个表示时间的字符串数组，包含的字符串都是合法的<code>00:00 ~ 23:59</code>时间，求最小的两个时间之分钟差。注意<code>23:59 + 1 = 00:00</code>，因此之差一分钟。</li>
<li>将全部都转为分钟，排个序之后相邻两个做对比.</li>
</ul>
<h4 id="540-single-element-in-a-sorted-array"><a href="#540-single-element-in-a-sorted-array" class="headerlink" title="540. single-element-in-a-sorted-array"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/single-element-in-a-sorted-array/description/">540. single-element-in-a-sorted-array</a></h4><ul>
<li>给一个排好序的数组，每个数字都出现了两次except其中一个，求这个毒瘤。要求时间复杂度O(logN)，空间(1).</li>
<li>二分查找，利用pair的特性，以偶数index与下一个元素为判断依据，若元素相等说明毒瘤出现在后半部分，若不想等说明出现在前面。edge case需要考虑单独元素出现在数组首位和末尾的情况。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNonDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (mid % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                mid--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">                left = mid + <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="543-diameter-of-binary-tree"><a href="#543-diameter-of-binary-tree" class="headerlink" title="543. diameter-of-binary-tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/diameter-of-binary-tree/description/">543. diameter-of-binary-tree</a></h4><ul>
<li>Zillow面试题刻骨铭心。给一个二叉树，求其中任意两个节点的path距离中最长长度。例如下面的树就有<code>4-2-1-3</code>和<code>5-2-1-3</code>两个最长路径，都是3.</li>
<li>对于当前节点有取和不取两种情况（但），取根则等于左深度加右深度，不取则在往下求深度的时候就可以顺便用一个全局变量去更新，时间复杂度就为O(N)了。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        getMaxDepth(root);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMaxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> getMaxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> getMaxDepth(root.right);</span><br><span class="line">        </span><br><span class="line">        max = Math.max(max, left + right);  <span class="comment">// 取根的情况</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;   <span class="comment">// 求深度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="544-output-contest-matches"><a href="#544-output-contest-matches" class="headerlink" title="544. output-contest-matches"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/output-contest-matches/">544. output-contest-matches</a></h4><ul>
<li>给一个整数n表示有多少支队伍，返回这些队伍的对决情况。例如n &#x3D; 4时，返回<code>((1,4),(2,3))</code>.</li>
<li>有点类似动态规划，n个格子存放当前的对阵情况，队伍减半后再继续套。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findContestMatch</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] bucket = <span class="keyword">new</span> <span class="title class_">String</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            bucket[i] = String.valueOf(i + <span class="number">1</span>);  <span class="comment">// 初始化每个队伍</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i * <span class="number">2</span> &lt; n; i++) &#123;</span><br><span class="line">                bucket[i] = <span class="string">&quot;(&quot;</span> + bucket[i] + <span class="string">&quot;,&quot;</span> + bucket[n - i - <span class="number">1</span>] + <span class="string">&quot;)&quot;</span>;    <span class="comment">// 前后对应着取对阵情况</span></span><br><span class="line">            &#125;</span><br><span class="line">            n /= <span class="number">2</span>;         <span class="comment">// 对半折后继续取</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bucket[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="545-boundary-of-binary-tree"><a href="#545-boundary-of-binary-tree" class="headerlink" title="545. boundary-of-binary-tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/boundary-of-binary-tree/description/">545. boundary-of-binary-tree</a></h4><ul>
<li>给一个二叉树，求它从左到下方到右的所有boundary的元素。</li>
<li>方法一：根据定义来写，则是老老实实先把所有左边界找出来、再把叶子节点找出来、再把右边界节点找出来。需要注意的是在遍历左边界时遵循preorder，当所有的左侧叶子节点都遍历完了再重新潜入一次找所有最下方节点（叶子节点），找完所有叶子结点之后再开始遍历右边界节点，遵循postorder.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; nodes;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">boundaryOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nodes;</span><br><span class="line">        &#125;</span><br><span class="line">        nodes.add(root.val);</span><br><span class="line">        traverseLeftBoundary(root.left);</span><br><span class="line">        traverseLeaves(root.left);</span><br><span class="line">        traverseLeaves(root.right);</span><br><span class="line">        traverseRightBoundary(root.right);</span><br><span class="line">        <span class="keyword">return</span> nodes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverseLeftBoundary</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> || root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nodes.add(root.val);</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            traverseLeftBoundary(root.left);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            traverseLeftBoundary(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverseRightBoundary</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> || root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            traverseRightBoundary(root.right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            traverseRightBoundary(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        nodes.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverseLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            nodes.add(root.val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            traverseLeaves(root.left);</span><br><span class="line">            traverseLeaves(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：如何one-pass只遍历一次呢？在潜入的时候其实就已经知道节点的身份了：若当前节点是左边界，潜入左child时肯定还是左边界；右边界亦然。若当前节点是左边界，潜入右child时，若左child是null，则当前继续是左边界，也就是一个AND的关系。若当前节点是右边界，潜入左child时，若右child为null，则继续时右边界。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">boundaryOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(root.val);</span><br><span class="line">        dfs(root.left, <span class="literal">true</span>, <span class="literal">false</span>, ans);</span><br><span class="line">        dfs(root.right, <span class="literal">false</span>, <span class="literal">true</span>, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">boolean</span> isLeft, <span class="type">boolean</span> isRight, List&lt;Integer&gt; ans)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isLeft) &#123;</span><br><span class="line">            ans.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left, isLeft, isRight &amp;&amp; root.right == <span class="literal">null</span>, ans);</span><br><span class="line">        <span class="keyword">if</span> (!isLeft &amp;&amp; !isRight &amp;&amp; root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            ans.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right, isLeft &amp;&amp; root.left == <span class="literal">null</span>, isRight, ans);</span><br><span class="line">        <span class="keyword">if</span> (isRight) &#123;</span><br><span class="line">            ans.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="547-friend-circles"><a href="#547-friend-circles" class="headerlink" title="547. friend-circles"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/friend-circles/">547. friend-circles</a></h4><ul>
<li>给一个只含有0&#x2F;1的二维矩阵，1表示row和col互为好友，求总共有多少个独立的朋友圈子。</li>
<li>经典的并查集。需要讨论的是时间复杂度。root数组相当于保存了N-ary的树，利用size可以保证每次union的时候都尽量保持树balance（size小的往大的merge），所以每次union相当于从最深处走到根，最大深度也就是log(N)，所以时间复杂度是<code>log(N)</code>.TODO【并查集的复杂度分析】</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span>[] root;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span>[] size;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line">            count = N;</span><br><span class="line">            root = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">            size = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">                root[i] = i;    <span class="comment">// 根是它本身</span></span><br><span class="line">                size[i] = <span class="number">1</span>;    <span class="comment">// 只有本身一个节点y9\h    z</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (root[i] != i) &#123;</span><br><span class="line">                root[i] = root[root[i]];</span><br><span class="line">                i = root[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootI</span> <span class="operator">=</span> find(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootJ</span> <span class="operator">=</span> find(j);</span><br><span class="line">            <span class="keyword">if</span> (rootI == rootJ) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (size[rootI] &lt; size[rootJ]) &#123;  <span class="comment">// 小的往大的合并</span></span><br><span class="line">                    root[rootI] = root[rootJ];</span><br><span class="line">                    size[rootJ] += size[rootI];   <span class="comment">// 大的就含有所有小的节点了</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    root[rootJ] = root[rootI];</span><br><span class="line">                    size[rootI] += size[rootJ];</span><br><span class="line">                &#125;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findCircleNum</span><span class="params">(<span class="type">int</span>[][] M)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (M == <span class="literal">null</span> || M.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> M.length;</span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (M[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    uf.union(i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uf.getCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="548-split-array-with-equal-sum"><a href="#548-split-array-with-equal-sum" class="headerlink" title="548. split-array-with-equal-sum"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/split-array-with-equal-sum/description/">548. split-array-with-equal-sum</a></h4><ul>
<li>给一个int数组，判断是否存在三个分割点i, j, k使得被这三个点分割出来的四个部分（不包含分割点）的sum相等。</li>
<li>方法一：类似于4sum，利用Set存储在之前出现过的相等的sum，然后固定中间点j，遍历可能的i，将前面两部分相等的sum存入set，然后遍历后半部分k，若也存在两部分相等的和且set中存在，则说明确实可以分成四个相等的部分。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">splitArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt; <span class="number">7</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] sum = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        sum[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">3</span>; j + <span class="number">3</span> &lt; nums.length; j++) &#123;</span><br><span class="line">            Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i + <span class="number">1</span> &lt; j; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sumBeforeI</span> <span class="operator">=</span> sum[i - <span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">sumItoJ</span> <span class="operator">=</span> sum[j - <span class="number">1</span>] - sum[i];</span><br><span class="line">                <span class="keyword">if</span> (sumBeforeI == sumItoJ) &#123;</span><br><span class="line">                    set.add(sumBeforeI);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> j + <span class="number">1</span>; k + <span class="number">1</span> &lt; nums.length; k++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sumJtoK</span> <span class="operator">=</span> sum[k - <span class="number">1</span>] - sum[j];</span><br><span class="line">                <span class="type">int</span> <span class="variable">sumAfterK</span> <span class="operator">=</span> sum[nums.length - <span class="number">1</span>] - sum[k];</span><br><span class="line">                <span class="keyword">if</span> (sumJtoK == sumAfterK &amp;&amp; set.contains(sumJtoK)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>DFS也可破。枚举所有可能的part sum，然后dfs到后续部分判断是否可以根据这个part sum恰好得到四个部分。注意为了避免无效DFS，需要ignore连续出现的0。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">splitArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt; <span class="number">7</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> IntStream.of(nums).sum();</span><br><span class="line">        <span class="keyword">return</span> dfs(nums, <span class="number">0</span>, <span class="number">0</span>, sum, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> target, <span class="type">int</span> sumRemain, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (depth == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target == sumRemain)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">currSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start + <span class="number">1</span>; i + <span class="number">5</span> - (<span class="number">2</span> * depth) &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">1</span> &amp;&amp; nums[i - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; nums[i] == <span class="number">0</span>) &#123;       <span class="comment">// 忽略连续出现的0</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            currSum += nums[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> ((depth == <span class="number">0</span> || currSum == target)</span><br><span class="line">                &amp;&amp; dfs(nums, i + <span class="number">1</span>, currSum, sumRemain - currSum - nums[i], depth + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="549-binary-tree-longest-consecutive-sequence-ii"><a href="#549-binary-tree-longest-consecutive-sequence-ii" class="headerlink" title="549. binary-tree-longest-consecutive-sequence-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-longest-consecutive-sequence-ii/description/">549. binary-tree-longest-consecutive-sequence-ii</a></h4><ul>
<li>给一个二叉树，求其中路径最长的连续increasing或decreasing的长度，这个路径不一定是parent-child的，怎么上下左右都行，只要是连续即可。</li>
<li>不论怎么弯折，对于每一个节点来说其实就是看和孩子能否形成increase和decrease，可以则加一下就是一个弯折的路径了。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        helper(root);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] helper(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] left = helper(root.left), right = helper(root.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">inc</span> <span class="operator">=</span> <span class="number">1</span>, dec = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.left.val == root.val + <span class="number">1</span>) &#123;   <span class="comment">// 确认是否能和孩子形成升序/降序列</span></span><br><span class="line">                inc = left[<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (root.left.val == root.val - <span class="number">1</span>) &#123;</span><br><span class="line">                dec = left[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.right.val == root.val + <span class="number">1</span>) &#123;</span><br><span class="line">                inc = Math.max(inc, right[<span class="number">0</span>] + <span class="number">1</span>);  <span class="comment">// 取左右中最大的</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (root.right.val == root.val - <span class="number">1</span>) &#123;</span><br><span class="line">                dec = Math.max(dec, right[<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(inc + dec - <span class="number">1</span>, max);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;inc, dec&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="551-student-attendance-record-i"><a href="#551-student-attendance-record-i" class="headerlink" title="551. student-attendance-record-i"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/student-attendance-record-i/submissions/">551. student-attendance-record-i</a></h4><ul>
<li>给一个字符串，若连续出现2次以上<code>L</code>、总共出现1次以上<code>A</code>则返回false。pass.</li>
</ul>
<h4 id="554-brick-wall"><a href="#554-brick-wall" class="headerlink" title="554. brick-wall"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/brick-wall/description/">554. brick-wall</a></h4><ul>
<li>给一个二维List表示每一行每一块砖各自的长度。求纵向切下来最少穿过的墙的个数。</li>
<li>最少的穿过的个数也就是求穿过最多缝隙的个数，也就事给定一个结束长度，最多的那个即为所求。用Map记录每一行的累加的结尾长度，不断更新最多的那个长度，最后wall的行数减去count即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">leastBricks</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; wall)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (wall == <span class="literal">null</span> || wall.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; list : wall) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                len += list.get(i);</span><br><span class="line">                map.put(len, map.getOrDefault(len, <span class="number">0</span>) + <span class="number">1</span>); <span class="comment">// 求对应长度结尾的墙有多少</span></span><br><span class="line">                count = Math.max(count, map.get(len));      <span class="comment">// 更新以len结尾的最多的</span></span><br><span class="line">                <span class="keyword">if</span> (count == wall.size()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> wall.size() - count;     <span class="comment">// 减一下就是穿过墙最少的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="556-next-greater-element-iii"><a href="#556-next-greater-element-iii" class="headerlink" title="556. next-greater-element-iii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/next-greater-element-iii/description/">556. next-greater-element-iii</a></h4><ul>
<li>给一个32bit的正整数，求十进制中相同数字组成的下一个更大值。例如<code>12</code>的下一个就是<code>21</code>，<code>1342</code>则是<code>1423</code>。</li>
<li>若已经是最大的可能值？（返回-1）</li>
<li>对输入的数字从后往前遍历，找到连续的两个数字使得前面的（<code>i - 1</code>）小于后面的（<code>i</code>），然后再从<code>i + 1</code>开始往后找最小的大于<code>i - 1</code>的数字，互换他俩，最后从i开始往后从小到大排个序即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextGreaterElement</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(n);</span><br><span class="line">        <span class="type">char</span>[] sChar = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sChar.length - <span class="number">1</span>;   <span class="comment">// 从后往前</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sChar[i - <span class="number">1</span>] &lt; sChar[i]) &#123;      <span class="comment">// 找到第一个连续的顺序对</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;       <span class="comment">// 到最后都没找到</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>, minIndex = i;</span><br><span class="line">        <span class="type">char</span> <span class="variable">first</span> <span class="operator">=</span> sChar[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (j &lt; sChar.length) &#123;      <span class="comment">// 从i + 1开始从前往后不断更新最小的大于i - 1的元素</span></span><br><span class="line">            <span class="keyword">if</span> (sChar[j] &lt;= sChar[minIndex] &amp;&amp; sChar[j] &gt; first) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        sChar[i - <span class="number">1</span>] = sChar[minIndex];     <span class="comment">// 交换该ceiling值和i - 1</span></span><br><span class="line">        sChar[minIndex] = first;</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(sChar, i, sChar.length);    <span class="comment">// 从i开始拍个序</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> Long.valueOf(<span class="keyword">new</span> <span class="title class_">String</span>(sChar));</span><br><span class="line">        <span class="keyword">return</span> ans &gt; Integer.MAX_VALUE? -<span class="number">1</span>: (<span class="type">int</span>)ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="559-maximum-depth-of-n-ary-tree"><a href="#559-maximum-depth-of-n-ary-tree" class="headerlink" title="559. maximum-depth-of-n-ary-tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-depth-of-n-ary-tree/">559. maximum-depth-of-n-ary-tree</a></h4><ul>
<li>给一个多叉树，求最深的深度。DFS&#x2F;BSF均可，pass。</li>
</ul>
<h4 id="560-subarray-sum-equals-k"><a href="#560-subarray-sum-equals-k" class="headerlink" title="560. subarray-sum-equals-k"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/subarray-sum-equals-k/description/">560. subarray-sum-equals-k</a></h4><ul>
<li>给一个int数组和一个k，问有多少连续的subarray之和等于k。这些int都在<code>[-1000, 1000]</code>，数组长度最多20000。</li>
<li>一开始想用双指针，但有正有负，更新条件不好搞。正解是使用Map，在计算sum的时候顺便看看之前是否出现过sum - k。这其实和path sum III 很像，都是利用prefix sum.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(sum - k)) &#123;     <span class="comment">// 看之前是否已经出现了</span></span><br><span class="line">                count += map.get(sum - k);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(sum, map.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="562-longest-line-of-consecutive-one-in-matrix"><a href="#562-longest-line-of-consecutive-one-in-matrix" class="headerlink" title="562. longest-line-of-consecutive-one-in-matrix"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-line-of-consecutive-one-in-matrix/description/">562. longest-line-of-consecutive-one-in-matrix</a></h4><ul>
<li>给一个只含有0和1的二维数组，求横、竖、两个斜对角的连续出现1的最长长度。</li>
<li>方法一：O(N^2)从每个点出发往四个方向分别遍历，求最长长度。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// O(N^3)：矩阵遍历每个点是N^2，对每个点在扫四个方向是4N</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestLine</span><span class="params">(<span class="type">int</span>[][] M)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (M == <span class="literal">null</span> || M.length == <span class="number">0</span> || M[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">longest</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; M.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; M[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (M[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    longest = Math.max(longest, getLongest(M, i, j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右、下、右下、左下</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="type">int</span>[][] directions = <span class="keyword">new</span> <span class="title class_">int</span>[][] &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, -<span class="number">1</span>&#125;&#125;; </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getLongest</span><span class="params">(<span class="type">int</span>[][] M, <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] direction: directions) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newRow</span> <span class="operator">=</span> row + direction[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">newCol</span> <span class="operator">=</span> col + direction[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 持续在一个方向上继续走</span></span><br><span class="line">            <span class="keyword">while</span> (isValidPosition(M, newRow, newCol) &amp;&amp; M[newRow][newCol] == <span class="number">1</span>) &#123;</span><br><span class="line">                len++;</span><br><span class="line">                newRow += direction[<span class="number">0</span>];</span><br><span class="line">                newCol += direction[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            maxLen = Math.max(maxLen, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValidPosition</span><span class="params">(<span class="type">int</span>[][] M, <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> row &gt;= <span class="number">0</span> &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">            row &lt; M.length &amp;&amp; col &lt; M[<span class="number">0</span>].length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：类似于DP，记录下四个方向各自的最大长度。参考<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/87389/simple-and-concise-java-solution-easy-to-understand-o-m-n-space">这个</a>被lz<br> 和<a target="_blank" rel="noopener" href="https://leetcode.com/problems/n-queens-ii/descrciption/">N皇后问题</a>很像。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// O(N^2)时间，O(M+N)空间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestLine</span><span class="params">(<span class="type">int</span>[][] M)</span> &#123;</span><br><span class="line">        <span class="comment">// validation</span></span><br><span class="line">        <span class="keyword">if</span> (M == <span class="literal">null</span> || M.length == <span class="number">0</span> || M[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> M.length, cols = M[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">longest</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] bucketCol = <span class="keyword">new</span> <span class="title class_">int</span> [cols];</span><br><span class="line">        <span class="type">int</span>[] bucketDiag1 = <span class="keyword">new</span> <span class="title class_">int</span> [rows + cols];</span><br><span class="line">        <span class="type">int</span>[] bucketDiag2 = <span class="keyword">new</span> <span class="title class_">int</span> [rows + cols];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>;                <span class="comment">// 新行初始化为0</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (M[i][j] == <span class="number">1</span>) &#123;     <span class="comment">// 当前为1，对应更新bucket</span></span><br><span class="line">                    row++;</span><br><span class="line">                    bucketCol[j]++;</span><br><span class="line">                    bucketDiag1[j + i]++;</span><br><span class="line">                    bucketDiag2[j - i + M.length]++;</span><br><span class="line">                    longest = Math.max(longest, row);</span><br><span class="line">                    longest = Math.max(longest, bucketCol[j]);</span><br><span class="line">                    longest = Math.max(longest, bucketDiag1[j + i]);</span><br><span class="line">                    longest = Math.max(longest, bucketDiag2[j - i + M.length]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    row = <span class="number">0</span>;</span><br><span class="line">                    bucketCol[j] = <span class="number">0</span>;</span><br><span class="line">                    bucketDiag1[j + i] = <span class="number">0</span>;</span><br><span class="line">                    bucketDiag2[j - i + M.length] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="563-binary-tree-tilt"><a href="#563-binary-tree-tilt" class="headerlink" title="563. binary-tree-tilt"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-tilt/">563. binary-tree-tilt</a></h4><ul>
<li>给一个二叉树，求每一个节点的左右子树和的差的绝对值之和。</li>
<li>直接后序遍历求sum搞定。pass。</li>
</ul>
<h4 id="565-array-nesting"><a href="#565-array-nesting" class="headerlink" title="565. array-nesting"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/array-nesting/">565. array-nesting</a></h4><ul>
<li>给一个长度为N的int数组，其中元素为<code>0 ~ N-1</code>。从<code>nums[i]</code>开始往后跳，<code>nums[nums[i]]</code>持续跳直到回到原处。求所有这些自循环链接中的最长长度。</li>
<li>方法一：利用visited数组，模拟跳动。</li>
<li>方法二：不需要额外数组，利用<code>0 ~ N-1</code>这个条件直接用一些trick来重复使用input array. 常见手段包括：<ul>
<li>Negating: 既然都是正数，不妨用负数表示visited。</li>
<li>Modulo: 加上n来表示visited，最后<code>% N</code>即可得到原值。</li>
<li>Sorting: 将<code>nums[i]</code>放到<code>i</code>处，但这里就不适用了。</li>
</ul>
</li>
</ul>
<h4 id="566-reshape-the-matrix"><a href="#566-reshape-the-matrix" class="headerlink" title="566. reshape-the-matrix"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reshape-the-matrix/">566. reshape-the-matrix</a></h4><ul>
<li>给一个二维数组，返回reshape之后的。pass.</li>
</ul>
<h4 id="567-permutation-in-string"><a href="#567-permutation-in-string" class="headerlink" title="567. permutation-in-string"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/permutation-in-string/description/">567. permutation-in-string</a></h4><ul>
<li>给两个字符串，判断s1的permutation是否包含在s2中，例如<code>s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;</code>返回true，因为s2包含了<code>ba</code>。</li>
<li>其实这个s1的permutation并不用真的一个个求出来，在意的只是s1的每个字符及其出现次数，因此用一个map O(N)扫一波就好了。然后就对s2进行双指针 + producer&#x2F;consumer操作，如果消耗完map中所有字符的时候恰好前后指针间距等于s1的长度，说明就是permutation的一种了，返回true。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkInclusion</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1 == <span class="literal">null</span> || s2 == <span class="literal">null</span> || s1.length() == <span class="number">0</span> || s2.length() == <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] s1Char = s1.toCharArray();</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> s1Char.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len1; i++) &#123;    <span class="comment">// 统计s1中每个字母出现个数，作为producer</span></span><br><span class="line">            map.put(s1Char[i], map.getOrDefault(s1Char[i], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span>[] s2Char = s2.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> map.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; s2Char.length) &#123;     <span class="comment">// 遍历s2作为consumer消耗字符，直到map中所有字符消耗完</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(s2Char[right])) &#123;</span><br><span class="line">                map.put(s2Char[right], map.get(s2Char[right]) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (map.get(s2Char[right]) == <span class="number">0</span>) &#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;            <span class="comment">// 左指针补回来，直到map中出现available的字符</span></span><br><span class="line">                <span class="keyword">if</span> (right - left + <span class="number">1</span> == len1) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(s2Char[left])) &#123;</span><br><span class="line">                    map.put(s2Char[left], map.get(s2Char[left]) + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (map.get(s2Char[left]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="572-subtree-of-another-tree"><a href="#572-subtree-of-another-tree" class="headerlink" title="572. subtree-of-another-tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/subtree-of-another-tree/description/">572. subtree-of-another-tree</a></h4><ul>
<li>给两棵树，判断后者是不是前者的子树。子树指的是还有一个任意节点为根的子树，结构、数值完全一样。</li>
<li>递归搞定。先判断两个树是否相同，若相同直接就是子树了。若不同则需要到左右子树进行递归，判断t是否是左／右的子树。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> &amp;&amp; t == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || t == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSame(s, t) ? <span class="literal">true</span> : isSubtree(s.left, t) || isSubtree(s.right, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSame</span><span class="params">(TreeNode s, TreeNode t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> &amp;&amp; t == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || t == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.val == t.val ? isSame(s.left, t.left) &amp;&amp; isSame(s.right, t.right) : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="575-distribute-candies"><a href="#575-distribute-candies" class="headerlink" title="575. distribute-candies"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/distribute-candies/description/">575. distribute-candies</a></h4><ul>
<li>给一个数组表示糖果的id，其中可能有重复，且糖果数量一定是偶数。要求将其分成两部分，问如果想尝最多的不同的糖果，有多少种。例如<code>[3,2,2,1,3,1]</code>就有三种，<code>[7,3,1,4,3,7,4,3,7]</code>就有四种。要求时间复杂度最差<code>O(N*lgN)</code>，空间复杂度O(N)。</li>
<li>先排序，然后双指针一个从前往后，一个从后往前。left指针负责将糖果存入set，right则是调取后方的糖果往前替换，当left发现当前糖果吃过了，就从right那里swap过来继续判断，直到出现新的糖果或者穷尽。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxCandy</span><span class="params">(<span class="type">int</span>[] candies)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (candies == <span class="literal">null</span> || candies.length == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Arrays.sort(candies);</span><br><span class="line">		Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">		<span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> candies.length / <span class="number">2</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = candies.length - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (left &lt; half) &#123;</span><br><span class="line">			<span class="keyword">while</span> (set.contains(candies[left]) &amp;&amp; right &gt;= half) &#123;</span><br><span class="line">				swap(candies, left, right--);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (right &lt; half) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				set.add(candies[left++]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		set.add(candies[left]);</span><br><span class="line">		<span class="keyword">return</span> set.size();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="581-shortest-unsorted-continuous-subarray"><a href="#581-shortest-unsorted-continuous-subarray" class="headerlink" title="581. shortest-unsorted-continuous-subarray"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/shortest-unsorted-continuous-subarray/description/">581. shortest-unsorted-continuous-subarray</a></h4><ul>
<li>给一个部分部分有序的数组，求将其中哪一部分排序之后整个数组就都有序了，求最短的区间的长度。</li>
<li>首先从左往右逆序对，然后从右往左找逆序对。这样就有了一个大致区间，但是还需要找区间内的min和max，分别往前和往后遍历看看是否真的完全符合，否则还需要扩展区间。例如<code>[1,3,6,4,8,2,7,10]</code>在前两步之后找到得失<code>[6,4]</code>和<code>[8,2]</code>实际上前面的3和后面的1都需要加入进来。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findUnsortedSubarray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找第一个逆序对</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; nums.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[left - <span class="number">1</span>] &gt; nums[left]) &#123;</span><br><span class="line">                left--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left == nums.length) &#123;  <span class="comment">// 说明已经有序了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[right - <span class="number">1</span>] &gt; nums[right]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找[left, right]之间的最小、最大</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE, max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt;= right; i++) &#123;</span><br><span class="line">            min = Math.min(min, nums[i]);</span><br><span class="line">            max = Math.max(max, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前面的必须小于min，后面的必须大于max，否则扩散</span></span><br><span class="line">        <span class="keyword">while</span> (left &gt; <span class="number">0</span> &amp;&amp; nums[left - <span class="number">1</span>] &gt; min) &#123;</span><br><span class="line">            left--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (right + <span class="number">1</span> &lt; nums.length &amp;&amp; nums[right + <span class="number">1</span>] &lt; max) &#123;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right - left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="582-kill-process"><a href="#582-kill-process" class="headerlink" title="582. kill-process"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/kill-process/">582. kill-process</a></h4><ul>
<li>给两个pid的int list，分别表示进程id和parent进程id。给一个id，从它出发找出所有后续pid，返回所有被杀掉的进程id。</li>
<li>直接map表示<code>pid -&gt; list of child id</code>，然后递归&#x2F;迭代找后续pid即可。pass.</li>
</ul>
<h4 id="594-longest-harmonious-subsequence"><a href="#594-longest-harmonious-subsequence" class="headerlink" title="594. longest-harmonious-subsequence"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-harmonious-subsequence/description/">594. longest-harmonious-subsequence</a></h4><ul>
<li>给一个int数组，求其中最大和最小值恰好为1的非连续子序列。</li>
<li>用Map存每个值出现的次数，然后遍历Map取key相差1都存在的进行更新。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLHS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(num + <span class="number">1</span>)) &#123;</span><br><span class="line">                max = Math.max(max, map.get(num) + map.get(num + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="598-range-addition-ii"><a href="#598-range-addition-ii" class="headerlink" title="598. range-addition-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/range-addition-ii/description/">598. range-addition-ii</a></h4><ul>
<li>给一个二维数组的规模m和n，初始值为0，再给一个ops二维数组，每个op表示前x行和前y列都加1.求最终最大值的个数。例如<code>m = 3, n = 3, operations = [[2,2],[3,3]]</code>，那么就是先给左上方<code>2*2</code>加1，再给<code>3*3</code>加1，最后就有4个最大值（2）。</li>
<li>直接找行和列的最小值，相乘即可。m和n甚至都没啥用。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 直接找最小的行和列数，相乘即得</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxCount</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span>[][] ops)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ops == <span class="literal">null</span> || ops.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> m * n;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">rowMin</span> <span class="operator">=</span> Integer.MAX_VALUE, colMin = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] op : ops) &#123;</span><br><span class="line">            rowMin = Math.min(op[<span class="number">0</span>], rowMin);</span><br><span class="line">            colMin = Math.min(op[<span class="number">1</span>], colMin);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rowMin * colMin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="600-non-negative-integers-without-consecutive-ones"><a href="#600-non-negative-integers-without-consecutive-ones" class="headerlink" title="600. non-negative-integers-without-consecutive-ones"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/non-negative-integers-without-consecutive-ones/description/">600. non-negative-integers-without-consecutive-ones</a></h4><ul>
<li>给一个正数num，求[0, num]之间的bitString不含连续1的数字的个数。</li>
<li>方法一：DP。对于bitString有两种可能，以1结尾或以0结尾。为了不出现连续的1，对于0结尾的数字可以拼上0或1，而对于1结尾的数字就只能拼上0.<a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/count-number-binary-strings-without-consecutive-1s/">Geeks4Geeks</a>上面给的是bitString的长度，这里也可以用类似的方法。不过由于这里num的存在可能需要砍掉一部分结果，因此在最后需要多一步判断。如果num中出现了连续的<code>xx00xxx</code>（注意是从右往左遍历），而如果没有这个限制<code>xx10xxx, xx01xxx</code>等都可能算进去，因此需要减去前一个0到最前面的数字位数所保存的endWithOne的值。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 对于一个二进制数字，最后一位可能为1也可能为0.后者可以append数字0或1，而前者只能append数字0了。牵涉到DP了。</span></span><br><span class="line">    <span class="comment">// end0表示不含连续1的、bit长度为i + 1的、以0结尾的数字个数，end1表示不含连续1的、bit长度为i + 1的、以1结尾的数字的个数</span></span><br><span class="line">    <span class="comment">// 初始状态为end0[0] = 1, end1[0] = 1.</span></span><br><span class="line">    <span class="comment">// end0只在最后拼0，因此上一步来自0或1都可以；而end1只拼1，因此上一步只能来自0.</span></span><br><span class="line">    <span class="comment">// 状态转换为end0[i] = end0[i - 1] + end1[i - 1], end1[i] = end0[i - 1]</span></span><br><span class="line">    <span class="comment">// 但这是根据bitString长度来的，而题目给的是num，因此最后还需要过滤看看有没有多算</span></span><br><span class="line">    <span class="comment">// 如果在i, i+1处出现连续的0，说明i往前的部分就多算了，因此根据0～i-1的长度找endWithOne减掉即可。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findIntegers</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(Integer.toBinaryString(num));</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sb.length();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] endWithZero = <span class="keyword">new</span> <span class="title class_">int</span> [n];</span><br><span class="line">        <span class="type">int</span>[] endWithOne = <span class="keyword">new</span> <span class="title class_">int</span> [n];</span><br><span class="line">        endWithZero[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        endWithOne[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            endWithZero[i] = endWithZero[i - <span class="number">1</span>] + endWithOne[i - <span class="number">1</span>];</span><br><span class="line">            endWithOne[i] = endWithZero[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> endWithZero[n - <span class="number">1</span>] + endWithOne[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sb.charAt(i) == <span class="string">&#x27;1&#x27;</span> &amp;&amp; sb.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;1&#x27;</span>) &#123;   <span class="comment">// x11xx说明已经是最大了，后面都不可能多算了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sb.charAt(i) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; sb.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;0&#x27;</span>) &#123;    <span class="comment">// x00xx说明前一个0处不应该含有endWithOne</span></span><br><span class="line">                count -= endWithOne[n - <span class="number">1</span> - i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：constant space的DP。</li>
</ul>
<h4 id="604-design-compressed-string-iterator"><a href="#604-design-compressed-string-iterator" class="headerlink" title="604. design-compressed-string-iterator"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/design-compressed-string-iterator/description/">604. design-compressed-string-iterator</a></h4><ul>
<li>给一个字符加数字组成的字符串，实现next、hasNext函数遍历这个字符串。例如<code>L20J3B8</code>这样。</li>
<li>一开始直接根据频数全部存入queue，后来发现如果某个数频数特别大，而实际用不到那么多项就很不划算。因此就自定义类来搞了。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/135742635/">这样</a>.</li>
</ul>
<h4 id="605-can-place-flowers"><a href="#605-can-place-flowers" class="headerlink" title="605. can-place-flowers"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/can-place-flowers/description/">605. can-place-flowers</a></h4><ul>
<li>给一个只含有0和1的数组，1表示该处被种了花，0表示可以种，同时相邻的位置不能同时种花。给一个花数n，判断能否种到所给的花池中。</li>
<li>方法一：想到了greedy的方法，每次判断0前后是否都为0，可以就直接设为1.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPlaceFlowers</span><span class="params">(<span class="type">int</span>[] flowerbed, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flowerbed == <span class="literal">null</span> || flowerbed.length == <span class="number">0</span> || n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; flowerbed.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flowerbed[i] == <span class="number">0</span></span><br><span class="line">                &amp;&amp; (i == flowerbed.length - <span class="number">1</span> || flowerbed[i + <span class="number">1</span>] != <span class="number">1</span>)     <span class="comment">// 后一个为0</span></span><br><span class="line">                &amp;&amp; (i == <span class="number">0</span> || flowerbed[i - <span class="number">1</span>] != <span class="number">1</span>)) &#123;                     <span class="comment">// 前一个为0</span></span><br><span class="line">                flowerbed[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (--n == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：计算0的个数，碰到1就计算前面最多可以放多少0，同时重置计数。注意初始化count &#x3D; 1，比如<code>0 0 1</code>在碰到1的时候需要保证slot为1，如果count初始化为0就无法得到了。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPlaceFlowers</span><span class="params">(<span class="type">int</span>[] flowerbed, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flowerbed == <span class="literal">null</span> || flowerbed.length == <span class="number">0</span> || n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>, slot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; flowerbed.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flowerbed[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                slot += (count - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        slot += count / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> slot &gt;= n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="606-construct-string-from-binary-tree"><a href="#606-construct-string-from-binary-tree" class="headerlink" title="606. construct-string-from-binary-tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-string-from-binary-tree/description/">606. construct-string-from-binary-tree</a></h4><ul>
<li>给一个二叉树，encode成括号分割的字符串。</li>
<li>递归拼接。注意左子树和右子树为空时加不加括号需要加判断。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">tree2str</span><span class="params">(TreeNode t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(t.val);</span><br><span class="line">        <span class="type">String</span> <span class="variable">left</span> <span class="operator">=</span> tree2str(t.left);</span><br><span class="line">        <span class="type">String</span> <span class="variable">right</span> <span class="operator">=</span> tree2str(t.right);</span><br><span class="line">        <span class="keyword">if</span> (left.length() &gt; <span class="number">0</span> || right.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            sb.append(left);</span><br><span class="line">            sb.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            sb.append(right);</span><br><span class="line">            sb.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="609-find-duplicate-file-in-system"><a href="#609-find-duplicate-file-in-system" class="headerlink" title="609. find-duplicate-file-in-system"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-duplicate-file-in-system/description/">609. find-duplicate-file-in-system</a></h4><ul>
<li>给一个字符串数组，每个字符串中表示某路径下的所有文件以及内容，求相同文件内容的文件路径并存入List。比较有意思的是follow-up，解答参考<a target="_blank" rel="noopener" href="https://discuss.leetcode.com/topic/91430/c-clean-solution-answers-to-follow-up">这里</a>：在真实的文件系统中你会选择BFS还是DFS?(BFS。虽然会消耗更多空间，但是可以利用locality提速)如果每个文件内容非常巨大怎么办？（不直接hash文件内容，而是首先根据文件大小判断是否是同一个文件，然后再取文件其中一部分进行hash）</li>
<li>直接以内容为key、路径&amp;文件名为value存入map。最坏时间复杂度是O(N^2 * k)，N是文件个数，k是文件大小。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">findDuplicate</span><span class="params">(String[] paths)</span> &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (paths == <span class="literal">null</span> || paths.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();    <span class="comment">// 以文件内容为key、路径+文件名为value</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (String path : paths) &#123;</span><br><span class="line">            String[] arr = path.split(<span class="string">&quot;\\s+&quot;</span>);      <span class="comment">// 不可以直接用空格，要正则表达式!!!!!!</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">dir</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> arr[i].indexOf(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">file</span> <span class="operator">=</span> arr[i].substring(<span class="number">0</span>, start);</span><br><span class="line">                <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> arr[i].substring(start, arr[i].length() - <span class="number">1</span>);</span><br><span class="line">                List&lt;String&gt; temp = map.get(content);</span><br><span class="line">                <span class="keyword">if</span> (temp == <span class="literal">null</span>) &#123;</span><br><span class="line">                    temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                temp.add(dir + <span class="string">&quot;/&quot;</span> + file);</span><br><span class="line">                map.put(content, temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (String content : map.keySet()) &#123;</span><br><span class="line">            List&lt;String&gt; temp = map.get(content);</span><br><span class="line">            <span class="keyword">if</span> (temp.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                ans.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="611-valid-triangle-number"><a href="#611-valid-triangle-number" class="headerlink" title="611. valid-triangle-number"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/cvalid-triangle-number/description/">611. valid-triangle-number</a></h4><ul>
<li>给一个int数组表示边长，问这些边可以组成多少个三角形。（这些边可能重复，但是算作不同的边）</li>
<li>三角形任意两边之和大于第三边，这个任意其实指的是起码较小的两边之和大于最大边。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 两边之和大于第三边，那么每次都取最小都两个边相加大于最大边即可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">triangleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);  <span class="comment">// 排序</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt;= <span class="number">2</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = i - <span class="number">1</span>;    <span class="comment">// 双指针取比当前指针小的两条边</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] + nums[right] &gt; nums[i]) &#123;</span><br><span class="line">                    count += (right - left);    <span class="comment">// 相当于固定right取left开始的边</span></span><br><span class="line">                    right --;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="616-add-bold-tag-in-string"><a href="#616-add-bold-tag-in-string" class="headerlink" title="616. add-bold-tag-in-string"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/add-bold-tag-in-string/">616. add-bold-tag-in-string</a></h4><ul>
<li>给一个字符串s和一个字符串数组dict，若dict中的词在s中出现则需要加粗，例如<code>abc</code>加粗成<code>&lt;b&gt;abc&lt;/b&gt;</code>。</li>
<li>方法一：近似于暴力的做法，s逐位往后挪，对于每一个dict中的词都取出来用startsWith判断，用一个boolean数组标记是否加粗。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addBoldTag</span><span class="params">(String s, String[] dict)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span></span><br><span class="line">           || dict == <span class="literal">null</span> || dict.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span>[] isBold = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, end = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String word : dict) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.startsWith(word, i)) &#123;</span><br><span class="line">                    end = Math.max(end, i + word.length());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; end) &#123;</span><br><span class="line">                isBold[i] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; isBold.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isBold[i]) &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;&lt;b&gt;&quot;</span>).append(s.charAt(i++));</span><br><span class="line">                <span class="keyword">while</span> (i &lt; isBold.length &amp;&amp; isBold[i]) &#123;</span><br><span class="line">                    sb.append(s.charAt(i++));</span><br><span class="line">                &#125;</span><br><span class="line">                sb.append(<span class="string">&quot;&lt;/b&gt;&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(s.charAt(i++));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：直接使用indexOf将所有词出现的位置标出来，同样用一个boolean数组标记。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addBoldTag</span><span class="params">(String s, String[] dict)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span></span><br><span class="line">           || dict == <span class="literal">null</span> || dict.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span>[] isBold = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length()];</span><br><span class="line">        <span class="keyword">for</span> (String word : dict) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> s.indexOf(word);</span><br><span class="line">            <span class="keyword">while</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                fill(isBold, index, index + word.length());</span><br><span class="line">                index = s.indexOf(word, index + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; isBold.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isBold[i]) &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;&lt;b&gt;&quot;</span>).append(s.charAt(i++));</span><br><span class="line">                <span class="keyword">while</span> (i &lt; isBold.length &amp;&amp; isBold[i]) &#123;</span><br><span class="line">                    sb.append(s.charAt(i++));</span><br><span class="line">                &#125;</span><br><span class="line">                sb.append(<span class="string">&quot;&lt;/b&gt;&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(s.charAt(i++));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fill</span><span class="params">(<span class="type">boolean</span>[] isBold, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            isBold[start++] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：首先将所有dict中出现的位置找出来，用Interval表示，然后就<a target="_blank" rel="noopener" href="https://leetcode.com/problems/add-bold-tag-in-string/discuss/104263/Java-solution-Same-as-Merge-Interval.">转化成了merge intervals的问题</a>。</li>
</ul>
<h4 id="621-task-scheduler"><a href="#621-task-scheduler" class="headerlink" title="621. task-scheduler"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/task-scheduler/description/">621. task-scheduler</a></h4><ul>
<li>给一个char数组，每个char表示一个task的名字；然后给一个interval表示相同的task必须经过这么多时间之后才能再次执行。求执行完所有任务所需要的时间。</li>
<li>greedy可解，即以所给的interval作为周期，每次按频数从多到少地放task，如果周期没有用完而后续还有任务则需要把idle的时间也加进去。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">        <span class="type">char</span> name;</span><br><span class="line">        <span class="type">int</span> freq;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Task</span><span class="params">(<span class="type">char</span> name, <span class="type">int</span> freq)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.freq = freq;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">leastInterval</span><span class="params">(<span class="type">char</span>[] tasks, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tasks == <span class="literal">null</span> || tasks.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 统计每个任务的频数</span></span><br><span class="line">        Map&lt;Character, Task&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : tasks) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(c)) &#123;</span><br><span class="line">                map.put(c, <span class="keyword">new</span> <span class="title class_">Task</span>(c, <span class="number">1</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">Task</span> <span class="variable">t</span> <span class="operator">=</span> map.get(c);</span><br><span class="line">                t.freq++;</span><br><span class="line">                map.put(c, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据频数维护优先队列</span></span><br><span class="line">        PriorityQueue&lt;Task&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> b.freq == a.freq? a.name - b.name : b.freq - a.freq;     <span class="comment">// freq大的在前</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (Character c : map.keySet()) &#123;</span><br><span class="line">            q.add(map.get(c));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 以n+1为周期，从pq中根据freq从高到低取task</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">totalTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            List&lt;Task&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">period</span> <span class="operator">=</span> n + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (period &gt; <span class="number">0</span> &amp;&amp; !q.isEmpty()) &#123;</span><br><span class="line">                <span class="type">Task</span> <span class="variable">t</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                t.freq--;</span><br><span class="line">                temp.add(t);</span><br><span class="line">                period--;</span><br><span class="line">                totalTime++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Task t : temp) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t.freq &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    q.add(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!q.isEmpty()) &#123;         <span class="comment">// 后面还有task，确实需要隔多这么多时间</span></span><br><span class="line">                totalTime += period;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="622-design-circular-queue-https-leetcode-com-problems-design-circular-queue"><a href="#622-design-circular-queue-https-leetcode-com-problems-design-circular-queue" class="headerlink" title="[622. design-circular-queue] (https://leetcode.com/problems/design-circular-queue/)"></a>[622. design-circular-queue] (<a target="_blank" rel="noopener" href="https://leetcode.com/problems/design-circular-queue/">https://leetcode.com/problems/design-circular-queue/</a>)</h4><ul>
<li>设计并实现一个循环队列，给定初始长度为k，根据操作（enqueue&#x2F;dequeue）成功与否返回boolean.</li>
<li>其实不难，只是需要想清楚逻辑。将数组想像成无限长的，利用头尾两个index和len，每次enqueueu挪动尾指针（初始为-1）、dequeue挪动头指针。</li>
</ul>
<h4 id="623-add-one-row-to-tree"><a href="#623-add-one-row-to-tree" class="headerlink" title="623. add-one-row-to-tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/add-one-row-to-tree/">623. add-one-row-to-tree</a></h4><ul>
<li>给一个二叉树，root深度为1，给一个value和深度d，在d处插入值为value的节点，继承原先的左、右子树。返回插入完成后的root。</li>
<li>有三种方法。一是直接BFS层级遍历，在<code>d - 1</code>层停下来插入。二是DFS并利用currDepth来跟踪当前节点的深度从而决定是否插入。三是无需额外递归函数的DFS，通过直接修改传入的<code>d</code>值来决定是否到达了需要插入的层数，并巧妙利用d &#x3D; 1或0来决定插入左边还是右边。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">addOneRow</span><span class="params">(TreeNode root, <span class="type">int</span> v, <span class="type">int</span> d)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (d &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(v);</span><br><span class="line">            <span class="keyword">if</span> (d == <span class="number">0</span>) &#123;</span><br><span class="line">                newNode.right = root;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newNode.left = root;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = addOneRow(root.left, v, d - <span class="number">1</span>);</span><br><span class="line">        root.right = addOneRow(root.right, v, d == <span class="number">2</span> ? <span class="number">0</span> : d - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="624-design-search-autocomplete-system"><a href="#624-design-search-autocomplete-system" class="headerlink" title="624. design-search-autocomplete-system"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/design-search-autocomplete-system/">624. design-search-autocomplete-system</a></h4><ul>
<li>实现一个搜索框按照历史搜索频数排序的自动推荐搜索词条系统。初始化时会提供一串历史搜索词条和对应频数，每次用户输入一个字符就需要看历史中是否出现过以此为开头的，按照出现频数返回前三个词条。当用户输入<code>#</code>时表示输入结束，将当前的输入词条补充到频数统计中。输入的只有小写字母和空格。</li>
<li>方法一：传统的bucket + Map方法。根据第一个字母划分成26个buckets，首先将最开始给出的词条存入对应bucket的map中。用户没输入一个字符就到对应的bucket中取map，看看是否有key是以当前输入的字符串开头的，将所有符合的词条排序返回。初始化时间复杂度为<code>O(k*l + 26)</code>，其中k为词条平均长度、总共有l个不同的词条，这里主要是消耗在对各个词条字符串计算哈希值。input时间复杂度为<code>O(s + mlogm)</code>，其中s为bucket中取出map的规模、m符合以当前输入开头的key的个数，需要排序。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AutocompleteSystem</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        String str;</span><br><span class="line">        <span class="type">int</span> count;</span><br><span class="line">        Node(String str, <span class="type">int</span> count) &#123;</span><br><span class="line">            <span class="built_in">this</span>.str = str;</span><br><span class="line">            <span class="built_in">this</span>.count = count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringBuilder sb;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt;[] bucket;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LIMIT</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AutocompleteSystem</span><span class="params">(String[] sentences, <span class="type">int</span>[] times)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sentences == <span class="literal">null</span> || times == <span class="literal">null</span> ||</span><br><span class="line">           sentences.length == <span class="number">0</span> || times.length == <span class="number">0</span> ||</span><br><span class="line">           sentences.length != times.length) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sb = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        bucket = <span class="keyword">new</span> <span class="title class_">HashMap</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bucket.length; i++) &#123;</span><br><span class="line">            bucket[i] = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sentences.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> sentences[i].charAt(<span class="number">0</span>) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            bucket[index].put(sentences[i], times[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">input</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">        List&lt;String&gt; retVal = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">query</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> query.charAt(<span class="number">0</span>) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            bucket[index].put(query, bucket[index].getOrDefault(query, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            sb.setLength(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            List&lt;Node&gt; nodeList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            sb.append(c);</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> sb.charAt(<span class="number">0</span>) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span> (String key : bucket[index].keySet()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (key.startsWith(sb.toString())) &#123;</span><br><span class="line">                    nodeList.add(<span class="keyword">new</span> <span class="title class_">Node</span>(key, bucket[index].get(key)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Collections.sort(nodeList, (a, b) -&gt; a.count == b.count ? a.str.compareTo(b.str) : b.count - a.count);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Math.min(LIMIT, nodeList.size()); i++) &#123;</span><br><span class="line">                retVal.add(nodeList.get(i).str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：既然都是小写字母+空格，完全可以用Trie来实现搜索。对于每个Trie节点存放后续节点数组，共27个（a-z加上空格）。与一般Trie搜索不同的是，只要在traverse过程中碰到节点的count不为0，那么经过路径所拼接成的string就是一个合法的词条了，需要加到返回的list中。假设l个词条、平均长度为k，初始化时间复杂度为<code>O(k*l)</code>；input时假设当前已输入的长度为p、trie有效后续节点为q，时间复杂度为<code>O(p + q + mlogm)</code>.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AutocompleteSystem</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        String str;</span><br><span class="line">        <span class="type">int</span> count;</span><br><span class="line">        Node(String str, <span class="type">int</span> count) &#123;</span><br><span class="line">            <span class="built_in">this</span>.str = str;</span><br><span class="line">            <span class="built_in">this</span>.count = count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Trie[] branches = <span class="keyword">new</span> <span class="title class_">Trie</span>[<span class="number">27</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c == <span class="string">&#x27; &#x27;</span> ? <span class="number">26</span> : c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Trie t, String s, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> getIndex(s.charAt(i));</span><br><span class="line">            <span class="keyword">if</span> (t.branches[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                t.branches[index] = <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            t = t.branches[index];</span><br><span class="line">        &#125;</span><br><span class="line">        t.count += count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> List&lt;Node&gt; <span class="title function_">search</span><span class="params">(Trie t, String s)</span> &#123;</span><br><span class="line">        List&lt;Node&gt; nodeList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> getIndex(s.charAt(i));</span><br><span class="line">            <span class="keyword">if</span> (t.branches[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> nodeList;</span><br><span class="line">            &#125;</span><br><span class="line">            t = t.branches[index];</span><br><span class="line">        &#125;</span><br><span class="line">        collectCount(s, t, nodeList);</span><br><span class="line">        <span class="keyword">return</span> nodeList;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">collectCount</span><span class="params">(String s, Trie t, List&lt;Node&gt; nodeList)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (t.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            nodeList.add(<span class="keyword">new</span> <span class="title class_">Node</span>(s, t.count));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; c++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> getIndex(c);</span><br><span class="line">            <span class="keyword">if</span> (t.branches[index] != <span class="literal">null</span>) &#123;</span><br><span class="line">                collectCount(s + c, t.branches[index], nodeList);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t.branches[<span class="number">26</span>] != <span class="literal">null</span>) &#123;</span><br><span class="line">            collectCount(s + <span class="string">&#x27; &#x27;</span>, t.branches[<span class="number">26</span>], nodeList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringBuilder sb;</span><br><span class="line">    <span class="keyword">private</span> Trie root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LIMIT</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AutocompleteSystem</span><span class="params">(String[] sentences, <span class="type">int</span>[] times)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sentences == <span class="literal">null</span> || times == <span class="literal">null</span> ||</span><br><span class="line">           sentences.length == <span class="number">0</span> || times.length == <span class="number">0</span> ||</span><br><span class="line">           sentences.length != times.length) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">        sb = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sentences.length; i++) &#123;</span><br><span class="line">            insert(root, sentences[i], times[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">input</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">        List&lt;String&gt; retVal = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">            insert(root, sb.toString(), <span class="number">1</span>);</span><br><span class="line">            sb.setLength(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sb.append(c);</span><br><span class="line">            List&lt;Node&gt; nodeList = search(root, sb.toString());</span><br><span class="line">            Collections.sort(nodeList, (a, b) -&gt; a.count == b.count ? a.str.compareTo(b.str) : b.count - a.count);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Math.min(<span class="number">3</span>, nodeList.size()); i++) &#123;</span><br><span class="line">                retVal.add(nodeList.get(i).str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="628-maximum-product-of-three-numbers"><a href="#628-maximum-product-of-three-numbers" class="headerlink" title="628. maximum-product-of-three-numbers"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-product-of-three-numbers/description/">628. maximum-product-of-three-numbers</a></h4><ul>
<li>给一个int数组，求其中任意三个数的最大乘积（不用考虑越界问题）。</li>
<li>naive的想法是排序后取三个max，但实际上只需要用到三个max<strong>以及两个可能为负数的min</strong>。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumProduct</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max1</span> <span class="operator">=</span> Integer.MIN_VALUE, max2 = Integer.MIN_VALUE, max3 = Integer.MIN_VALUE, </span><br><span class="line">            min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &lt;= min1) &#123;</span><br><span class="line">                min2 = min1;</span><br><span class="line">                min1 = num;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt;= min2) &#123;</span><br><span class="line">                min2 = num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= max1) &#123;</span><br><span class="line">                max3 = max2;</span><br><span class="line">                max2 = max1;</span><br><span class="line">                max1 = num;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt;= max2) &#123;</span><br><span class="line">                max3 = max2;</span><br><span class="line">                max2 = num;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt;= max3) &#123;</span><br><span class="line">                max3 = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(max1 * max2 * max3, max1 * min1 * min2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="631-design-excel-sum-formula"><a href="#631-design-excel-sum-formula" class="headerlink" title="631. design-excel-sum-formula"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/design-excel-sum-formula/">631. design-excel-sum-formula</a></h4><ul>
<li>实现一个excel类，能够set、get、sum，单元格如果修改了对应的sum也要更新。</li>
<li>根据需求确定实现方式。假如是read heavy，那就需要让get最快，牺牲set和sum的时间。将单元格之间的关系想像成subscribe的关系，单元格永远保持在最新状态，set时更新所有包含它的sum所处的单元格，同时取消旧的sum subscription；sum的时候就是subscribe到对应的单元格中。subscribe关系通过两个map实现。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Excel</span> &#123;</span><br><span class="line">    Map&lt;String, Map&lt;String, Integer&gt;&gt; subscriberMap;</span><br><span class="line">    Map&lt;String, Set&lt;String&gt;&gt; subscribeeMap;</span><br><span class="line">    <span class="type">int</span>[][] boards;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Excel</span><span class="params">(<span class="type">int</span> H, <span class="type">char</span> W)</span> &#123;</span><br><span class="line">        boards = <span class="keyword">new</span> <span class="title class_">int</span>[H][W - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>];</span><br><span class="line">        subscriberMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        subscribeeMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> r, <span class="type">char</span> c, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] coordinate = decode(c + <span class="string">&quot;&quot;</span> + r);</span><br><span class="line">        set(coordinate[<span class="number">0</span>], coordinate[<span class="number">1</span>], v);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">encode</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> encode(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;row, col&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">encode</span><span class="params">(<span class="type">int</span>[] coordinate)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">char</span>)(coordinate[<span class="number">1</span>] + <span class="string">&#x27;A&#x27;</span>) + <span class="string">&quot;&quot;</span> + (coordinate[<span class="number">0</span>] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] decode(String str) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">targetCol</span> <span class="operator">=</span> str.charAt(<span class="number">0</span>) - <span class="string">&#x27;A&#x27;</span>, targetRow = Integer.valueOf(str.substring(<span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;targetRow, targetCol&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">        set(row, col, v, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> v, <span class="type">boolean</span> rawSet)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> encode(row, col);</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldVal</span> <span class="operator">=</span> boards[row][col], delta = v - oldVal;</span><br><span class="line">        <span class="keyword">if</span> (subscribeeMap.containsKey(key) &amp;&amp; rawSet) &#123;   <span class="comment">// 不再接收其他cell的更新</span></span><br><span class="line">            <span class="keyword">for</span> (String upstream : subscribeeMap.get(key)) &#123;</span><br><span class="line">                subscriberMap.get(upstream).remove(key);</span><br><span class="line">            &#125;</span><br><span class="line">            subscribeeMap.remove(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (subscriberMap.containsKey(key)) &#123;   <span class="comment">// 推送到其他cell</span></span><br><span class="line">            Map&lt;String, Integer&gt; cellCount = subscriberMap.get(key);</span><br><span class="line">            <span class="keyword">for</span> (String str : cellCount.keySet()) &#123;</span><br><span class="line">                <span class="type">int</span>[] coordinate = decode(str);</span><br><span class="line">                <span class="type">int</span> <span class="variable">subVal</span> <span class="operator">=</span> boards[coordinate[<span class="number">0</span>]][coordinate[<span class="number">1</span>]] + (cellCount.get(str) * delta);</span><br><span class="line">                set(coordinate[<span class="number">0</span>], coordinate[<span class="number">1</span>], subVal, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        boards[row][col] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> r, <span class="type">char</span> c)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> r - <span class="number">1</span>, col = c - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> boards[row][col];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> r, <span class="type">char</span> c, String[] strs)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> r - <span class="number">1</span>, col = c - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">currKey</span> <span class="operator">=</span> encode(row, col);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.indexOf(<span class="string">&quot;:&quot;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">                String[] splitted = str.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">colMin</span> <span class="operator">=</span> splitted[<span class="number">0</span>].charAt(<span class="number">0</span>) - <span class="string">&#x27;A&#x27;</span>, colMax = splitted[<span class="number">1</span>].charAt(<span class="number">0</span>) - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">rowMin</span> <span class="operator">=</span> Integer.valueOf(splitted[<span class="number">0</span>].substring(<span class="number">1</span>)) - <span class="number">1</span>, rowMax = Integer.valueOf(splitted[<span class="number">1</span>].substring(<span class="number">1</span>)) - <span class="number">1</span>; </span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">targetRow</span> <span class="operator">=</span> rowMin; targetRow &lt;= rowMax; targetRow++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">targetCol</span> <span class="operator">=</span> colMin; targetCol &lt;= colMax; targetCol++) &#123;</span><br><span class="line">                        sum += boards[targetRow][targetCol];</span><br><span class="line">                        <span class="type">String</span> <span class="variable">targetKey</span> <span class="operator">=</span> encode(targetRow, targetCol);</span><br><span class="line">                        subscriberMap.putIfAbsent(targetKey, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;());</span><br><span class="line">                        subscriberMap.get(targetKey).put(currKey, subscriberMap.get(targetKey).getOrDefault(currKey, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                        subscribeeMap.putIfAbsent(currKey, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line">                        subscribeeMap.get(currKey).add(targetKey);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">targetCol</span> <span class="operator">=</span> str.charAt(<span class="number">0</span>) - <span class="string">&#x27;A&#x27;</span>, targetRow = Integer.valueOf(str.substring(<span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line">                sum += boards[targetRow][targetCol];</span><br><span class="line">                <span class="type">String</span> <span class="variable">targetKey</span> <span class="operator">=</span> encode(targetRow, targetCol);</span><br><span class="line">                subscriberMap.putIfAbsent(targetKey, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;());</span><br><span class="line">                subscriberMap.get(targetKey).put(currKey, subscriberMap.get(targetKey).getOrDefault(currKey, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                subscribeeMap.putIfAbsent(currKey, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line">                subscribeeMap.get(currKey).add(targetKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        set(row, col, sum, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Excel object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Excel obj = new Excel(H, W);</span></span><br><span class="line"><span class="comment"> * obj.set(r,c,v);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.get(r,c);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.sum(r,c,strs);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>假如是set heavy，那么可以set的时候直接保存值，sum的时候保存需要sum的单元格，get的时候再从各个单元格中取值相加。</li>
</ul>
<h4 id="632-smallest-range"><a href="#632-smallest-range" class="headerlink" title="632. smallest-range"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/smallest-range/description/">632. smallest-range</a></h4><ul>
<li>给一个<code>List&lt;List&lt;Integer&gt;&gt;</code>，每行List内部是排好序的，求一个区间使其包括每一行的某个元素。例如<code>[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]</code>，返回<code>[20,24]</code>.</li>
<li>类似于merge k sorted list，自定义一个Node类存放值、所属的行数、所处的列数信息，每次从每个List中取值存入PriorityQueue，然后每次从pq中poll掉元素的下一个作为新的元素存入pq。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123; </span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        <span class="type">int</span> row;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> val, <span class="type">int</span> row, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">            <span class="built_in">this</span>.row = row;</span><br><span class="line">            <span class="built_in">this</span>.index = index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] smallestRange(List&lt;List&lt;Integer&gt;&gt; nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.size() == <span class="number">0</span> || nums.get(<span class="number">0</span>).size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span> [] &#123;<span class="number">0</span>, Integer.MAX_VALUE&#125;;  <span class="comment">// warning: need to be max at first</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> nums.size();</span><br><span class="line">        PriorityQueue&lt;Node&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a.val - b.val);</span><br><span class="line">        <span class="comment">// new PriorityQueue&lt;Node&gt;(new Comparator() &#123;</span></span><br><span class="line">        <span class="comment">// public int compare(Node a, Node b) &#123;</span></span><br><span class="line">        <span class="comment">//     return a.val - b.val;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// &#125;);</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">currVal</span> <span class="operator">=</span> nums.get(i).get(<span class="number">0</span>);</span><br><span class="line">            max = Math.max(max, currVal);</span><br><span class="line">            pq.offer(<span class="keyword">new</span> <span class="title class_">Node</span>(currVal, i, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (pq.size() == nums.size()) &#123; <span class="comment">// 已经没有新的元素了加进来说明能跨所有行的间距已经遍历完成</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">            <span class="keyword">if</span> (max - node.val &lt; ans[<span class="number">1</span>] - ans[<span class="number">0</span>]) &#123;     <span class="comment">// 发现间距更小的window就更新</span></span><br><span class="line">                ans[<span class="number">1</span>] = max;</span><br><span class="line">                ans[<span class="number">0</span>] = node.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.index + <span class="number">1</span> &lt; nums.get(node.row).size()) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">nextNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(nums.get(node.row).get(node.index + <span class="number">1</span>), node.row, node.index + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (nextNode.val &gt; max) &#123;</span><br><span class="line">                    max = nextNode.val;</span><br><span class="line">                &#125;</span><br><span class="line">                pq.offer(nextNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="633-sum-of-square-numbers"><a href="#633-sum-of-square-numbers" class="headerlink" title="633. sum-of-square-numbers"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sum-of-square-numbers/description/">633. sum-of-square-numbers</a></h4><ul>
<li>给一个非负数，判断它是否是两个整数的平方和。</li>
<li>方法一：类似two sum，把每个整数的平方和存入set，判断set中是否有target - curr即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">judgeSquareSum</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (c &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sqrtC</span> <span class="operator">=</span> (<span class="type">int</span>) Math.sqrt(c);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= sqrtC; i++) &#123;</span><br><span class="line">            set.add(i * i);</span><br><span class="line">            <span class="keyword">if</span> (set.contains(c - i * i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：双指针，同时从0和sqrt(num)出发往中间逼近，若平方和大了则左移右指针、若小了则右移左指针。但</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">judgeSquareSum</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = (<span class="type">int</span>) Math.sqrt(c);</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curr</span> <span class="operator">=</span> left * left + right * right;</span><br><span class="line">        <span class="keyword">if</span> (curr &gt; c) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curr &lt; c) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="636-exclusive-time-of-functions"><a href="#636-exclusive-time-of-functions" class="headerlink" title="636. exclusive-time-of-functions"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/exclusive-time-of-functions/description/">636. exclusive-time-of-functions</a></h4><ul>
<li>给一个log数组，每个log包含<code>function_id:start_or_end:timestamp</code>形式的字符串，求每个function执行时间长度。注意这些function的执行可能嵌套、也可能递归调用。</li>
<li>经典的Stack题，需要用Stack记录function_id，这样在后续log来的时候，如果是start，说明栈顶函数暂停执行了，需要先把它的时间存起来（当前时间戳减去之前的时间戳）；如果是end，说明栈顶函数彻底执行完了，此时的时间计算需要加上end的这个时间戳。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] exclusiveTime(<span class="type">int</span> n, List&lt;String&gt; logs) &#123;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span> [n];</span><br><span class="line">        <span class="keyword">if</span> (logs == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="number">0</span>;           <span class="comment">// 记录上一次log的时间戳</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; logs.size(); i++) &#123;</span><br><span class="line">            String[] log = logs.get(i).split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (log[<span class="number">1</span>].equals(<span class="string">&quot;start&quot;</span>)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">curr</span> <span class="operator">=</span> Integer.valueOf(log[<span class="number">2</span>]);</span><br><span class="line">                <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                    ans[stack.peek()] += (curr - prev); </span><br><span class="line">                &#125;</span><br><span class="line">                prev = curr;</span><br><span class="line">                stack.push(Integer.valueOf(log[<span class="number">0</span>]));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">curr</span> <span class="operator">=</span> Integer.valueOf(log[<span class="number">2</span>]);</span><br><span class="line">                ans[stack.pop()] += (curr - prev + <span class="number">1</span>);  <span class="comment">// end包含当前这个时间点，因此要加1</span></span><br><span class="line">                prev = curr + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="637-average-of-levels-in-binary-tree"><a href="#637-average-of-levels-in-binary-tree" class="headerlink" title="637. average-of-levels-in-binary-tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/average-of-levels-in-binary-tree/description/">637. average-of-levels-in-binary-tree</a></h4><ul>
<li>给一个二叉树，求每一层的平均数。</li>
<li>还是层级遍历的变形，主要是防止求平均值的时候越界，用了double，这样求平均值的时候也方便很多。写出来是<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/136075057/">这样</a>。</li>
</ul>
<h4 id="638-shopping-offers"><a href="#638-shopping-offers" class="headerlink" title="638. shopping-offers"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/shopping-offers/">638. shopping-offers</a></h4><ul>
<li>给一个list表示商品单价，然后给一些购买组合，最后给一个target，求组成target所需的最小开销。</li>
<li>DFS+memo。对于每一个优惠组合都进行尝试，如果有商品数小于target，则可以取当前开销后继续DFS，否则说明当前组合超过需要的了，直接break。在暴力尝试所有购买组合的过程中，target可能会被反复访问到，所以用一个map表示target对应的最小开销即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shoppingOffers</span><span class="params">(List&lt;Integer&gt; price, List&lt;List&lt;Integer&gt;&gt; special, List&lt;Integer&gt; needs)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (price == <span class="literal">null</span> || special == <span class="literal">null</span> || needs == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;List&lt;Integer&gt;, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> dfs(price, special, needs, map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(List&lt;Integer&gt; price, List&lt;List&lt;Integer&gt;&gt; special, List&lt;Integer&gt; needs, Map&lt;List&lt;Integer&gt;, Integer&gt; map)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(needs)) &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(needs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, min = buySingle(price, needs);</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; bundle : special) &#123;</span><br><span class="line">            List&lt;Integer&gt; currNeeds = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(needs);</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; currNeeds.size(); i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> currNeeds.get(i) - bundle.get(i);</span><br><span class="line">                <span class="keyword">if</span> (diff &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                currNeeds.set(i, diff);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == needs.size()) &#123;</span><br><span class="line">                min = Math.min(min, bundle.get(i) + dfs(price, special, currNeeds, map));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(needs, min);</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">buySingle</span><span class="params">(List&lt;Integer&gt; price, List&lt;Integer&gt; needs)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; price.size(); i++) &#123;</span><br><span class="line">            sum += price.get(i) * needs.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="646-maximum-length-of-pair-chain"><a href="#646-maximum-length-of-pair-chain" class="headerlink" title="646. maximum-length-of-pair-chain"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-length-of-pair-chain/description/">646. maximum-length-of-pair-chain</a></h4><ul>
<li>给一个pair的数组，每个pair可以作为chain的节点。节点<code>[c, d]</code>能够连到<code>[a, b]</code>后面的条件是<code>b &lt; c</code>。求最长的链长度。</li>
<li>DP。<code>len[i]</code>表示以pair[i]结尾的链的长度，那么在双重循环时，就需要找到pairs[j]使得<code>pairs[j][1] &lt; pairs[i][0]</code>。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLongestChain</span><span class="params">(<span class="type">int</span>[][] pairs)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pairs == <span class="literal">null</span> || pairs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(pairs, (a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span>[] len = <span class="keyword">new</span> <span class="title class_">int</span> [pairs.length];     <span class="comment">// len[i]表示以pairs[i]结尾的链的长度</span></span><br><span class="line">        Arrays.fill(len, <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; pairs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pairs[i][<span class="number">0</span>] &gt; pairs[j][<span class="number">1</span>]) &#123;</span><br><span class="line">                    len[i] = Math.max(len[i], len[j] + <span class="number">1</span>);  <span class="comment">// 上一个节点为pairs[j]</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxLen = Math.max(maxLen, len[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="647-palindromic-substrings"><a href="#647-palindromic-substrings" class="headerlink" title="647. palindromic-substrings"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/palindromic-substrings/description/">647. palindromic-substrings</a></h4><ul>
<li>给一个字符串，求其中自对称的子串的个数。例如<code>aaa</code>就有6个，<code>aba</code>就有4个。</li>
<li>DP。<code>dp[i][j]</code>表示从第i个字符到第j个字符是否对称，当判断第<code>i</code>和第<code>j</code>个字符的时候，如果相等则需要用到<code>i + 1</code>到<code>j - 1</code>之间的结果（若也对称则当前这个也是对称的），因此需要从后往前递推更新DP数组才行。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span>[] sChar = s.toCharArray();</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span> [sChar.length][sChar.length];  <span class="comment">// dp[i][j] means take substr from i to j</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> dp.length - <span class="number">1</span>; row &gt;= <span class="number">0</span>; row--) &#123;    <span class="comment">// 从最后一行开始往前</span></span><br><span class="line">            dp[row][row] = <span class="literal">true</span>;    <span class="comment">// 最后一列设为true</span></span><br><span class="line">            count++;                <span class="comment">// 每个字符本身是自对称的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> row + <span class="number">1</span>; col &lt; dp.length; col++) &#123;   <span class="comment">// 只更新对角线之后的元素</span></span><br><span class="line">                <span class="keyword">if</span> (sChar[col] == sChar[row]) &#123;</span><br><span class="line">                    dp[row][col] = row + <span class="number">1</span> &gt; col - <span class="number">1</span> || dp[row + <span class="number">1</span>][col - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[row][col]) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="648-replace-words"><a href="#648-replace-words" class="headerlink" title="648. replace-words"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/replace-words/description/">648. replace-words</a></h4><ul>
<li>给一个List的dict表示词根，然后给一个sentence String，将其中以词根开头的单词替换成词根，返回修改后的String。</li>
<li>方法一：直接用Set存放这些词根，然后split之后暴力取每一个单词，再逐一取字符append判断是否在Set中，有就替换过去。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceWords</span><span class="params">(List&lt;String&gt; dict, String sentence)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (dict == <span class="literal">null</span> || dict.size() == <span class="number">0</span> || sentence == <span class="literal">null</span> || sentence.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sentence;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">minLen</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (String str : dict) &#123;</span><br><span class="line">            set.add(str);</span><br><span class="line">            minLen = Math.min(str.length(), minLen);</span><br><span class="line">        &#125;</span><br><span class="line">        String[] words = sentence.split(<span class="string">&quot;\\s+&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">wordLen</span> <span class="operator">=</span> words[i].length();</span><br><span class="line">            <span class="keyword">if</span> (wordLen &lt; minLen) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(words[i].substring(<span class="number">0</span>, minLen));</span><br><span class="line">            <span class="keyword">if</span> (set.contains(temp.toString())) &#123;</span><br><span class="line">                words[i] = temp.toString();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> minLen; j &lt; wordLen; j++) &#123;</span><br><span class="line">                temp.append(words[i].charAt(j));</span><br><span class="line">                <span class="keyword">if</span> (set.contains(temp.toString())) &#123;</span><br><span class="line">                    words[i] = temp.toString();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            sb.append(word);</span><br><span class="line">            sb.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.setLength(sb.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：使用Trie，将dict中的所有词根都存入Trie，然后还是取出来判断这些word是否有前缀出现在Trie中。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> isWord;</span><br><span class="line">        TrieNode[] next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TrieNode</span><span class="params">()</span> &#123;</span><br><span class="line">            next = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line">            Arrays.fill(next, <span class="literal">null</span>);</span><br><span class="line">            isWord = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceWords</span><span class="params">(List&lt;String&gt; dict, String sentence)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (dict == <span class="literal">null</span> || dict.size() == <span class="number">0</span> || sentence == <span class="literal">null</span> || sentence.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sentence;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">root</span> <span class="operator">=</span> buildTrie(dict);</span><br><span class="line">        String[] words = sentence.split(<span class="string">&quot;\\s+&quot;</span>);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> getPrefix(root, words[i]);</span><br><span class="line">            ans.append(prefix == <span class="literal">null</span> ? words[i] : prefix);</span><br><span class="line">            ans.append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.setLength(ans.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> TrieNode <span class="title function_">buildTrie</span><span class="params">(List&lt;String&gt; dict)</span> &#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">        <span class="keyword">for</span> (String str : dict) &#123;</span><br><span class="line">            insert(root, str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(TrieNode root, String word)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.next[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">null</span>) &#123;</span><br><span class="line">                root.next[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            root = root.next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        root.isWord = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return the prefix in trie if exist, or null if not.</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getPrefix</span><span class="params">(TrieNode root, String word)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.next[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(c);</span><br><span class="line">            <span class="keyword">if</span> (root.next[c - <span class="string">&#x27;a&#x27;</span>].isWord) &#123;</span><br><span class="line">                <span class="keyword">return</span> sb.toString();</span><br><span class="line">            &#125;</span><br><span class="line">            root = root.next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.isWord ? word : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="650-2-keys-keyboard"><a href="#650-2-keys-keyboard" class="headerlink" title="650. 2-keys-keyboard"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/2-keys-keyboard/">650. 2-keys-keyboard</a></h4><ul>
<li>假设有一个2键键盘，分别为全选屏幕上的字符复制、粘贴。开始时屏幕上有一个字符A，求输出n个A最少需要按几次键盘。</li>
<li>朴素DP：最后按下的键一定是粘贴，不知道的是在前方何时按下复制，因此需要暴力遍历。<code>dp[n]</code>表示产生n个A所需的最小按键次数，最开始屏幕上就有一个A，因此<code>dp[1] = 0</code>. 对于<code>dp[k]</code>，假设在<code>dp[i]</code>处按下了复制键复制了屏幕上的<code>i</code>个A，之后粘贴<code>(k - i)/i</code>次，加上按下的一次复制，总共为<code>k / i</code>次。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSteps</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">2</span>; k &lt;= n; k++) &#123;</span><br><span class="line">            dp[k] = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k % i == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[k] = Math.min(dp[k], dp[i] + k / i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：较为specific的方法。假设分为<code>[cpp][cpppp][cp]</code>组，每组的按键次数为l1, l2, l3，则最后得到的总数<code>N = l1 * l2 * l3</code>，因此问题转换为求N的所有素数factors，而且这个按键次数一定是最少的，因为<code>pq &gt;= p + q</code>.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSteps</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">retVal</span> <span class="operator">=</span> <span class="number">0</span>, divisor = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (n % divisor == <span class="number">0</span>) &#123;</span><br><span class="line">                retVal += divisor;</span><br><span class="line">                n /= divisor;</span><br><span class="line">            &#125;</span><br><span class="line">            divisor++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="651-4-keys-keyboard"><a href="#651-4-keys-keyboard" class="headerlink" title="651. 4-keys-keyboard"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/4-keys-keyboard/">651. 4-keys-keyboard</a></h4><ul>
<li>假设有一个4键键盘，分别为输入A、全选、复制、粘贴。求一共按N次的情况下最多能够输出多少A。</li>
<li>DP。</li>
</ul>
<h4 id="652-find-duplicate-subtrees"><a href="#652-find-duplicate-subtrees" class="headerlink" title="652. find-duplicate-subtrees"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-duplicate-subtrees/description/">652. find-duplicate-subtrees</a></h4><ul>
<li>给一个二叉树，返回一个包含所有duplicate的子树根节点的List。例如下面的树就有2-4和4两个duplicate的子树。</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> /   / \</span><br><span class="line">4   2   4</span><br><span class="line">   /</span><br><span class="line">  4</span><br></pre></td></tr></table></figure>
<ul>
<li>利用encoding tree的思路，对于每一个节点为root的树都进行一波类似前序遍历点操作，将遍历结果encode成字符串作为key、计数作为value存入map。一旦出现了两次就加入结果List。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">findDuplicateSubtrees</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;TreeNode&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        check(root, map, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">check</span><span class="params">(TreeNode node, Map&lt;String, Integer&gt; map, List&lt;TreeNode&gt; ans)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过前序遍历拼接出pattern并存入map</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">pattern</span> <span class="operator">=</span> node.val + <span class="string">&quot;,&quot;</span> + check(node.left, map, ans) + <span class="string">&quot;,&quot;</span> + check(node.right, map, ans);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> map.getOrDefault(pattern, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">2</span>) &#123;       <span class="comment">// the second one</span></span><br><span class="line">            ans.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(pattern, count);</span><br><span class="line">        <span class="keyword">return</span> pattern;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="653-two-sum-iv-input-is-a-bst"><a href="#653-two-sum-iv-input-is-a-bst" class="headerlink" title="653. two-sum-iv-input-is-a-bst"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/two-sum-iv-input-is-a-bst/description/">653. two-sum-iv-input-is-a-bst</a></h4><ul>
<li>给一个二叉搜索树和一个sum值，判断树中是否存在两个node之和等于sum。</li>
<li>朴素想法，对于每个可能的值进行O(logN)的搜索，因此总的时间复杂度就是O(NlogN)，而空间复杂度如果考虑递归栈的话就是O(TreeHeight)。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findTarget</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root, root, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(TreeNode node, TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> k - node.val;</span><br><span class="line">        <span class="keyword">if</span> (target != node.val &amp;&amp; search(root, target)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">            <span class="keyword">return</span> dfs(node.left, root, k) || dfs(node.right, root, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val == val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; root.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> search(root.left, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> search(root.right, val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：用BST中序遍历转换成有序数组，再用双指针分别从头和尾往中间找。时间O(N)，空间O(N).</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findTarget</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        inorder(root, list);</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = list.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;  <span class="comment">// 双指针查找有序数组中的pair</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> list.get(left) + list.get(right);</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; k) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; k) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.left, list);</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        inorder(root.right, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="654-maximum-binary-tree"><a href="#654-maximum-binary-tree" class="headerlink" title="654. maximum-binary-tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-binary-tree/">654. maximum-binary-tree</a></h4><ul>
<li>给一个不重复的int数组表示的二叉树节点value，最大值作为root，左侧子数组对应root左子树，右侧子数组对应root右子树，重新建树并返回root节点。</li>
<li>方法一：直接递归解决，但是时间复杂度最坏情况是O(N^2)。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> constructMaximumBinaryTree(nums, <span class="number">0</span>, nums.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxIndex</span> <span class="operator">=</span> start;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start + <span class="number">1</span>; i &lt; end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[maxIndex]) &#123;</span><br><span class="line">            maxIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[maxIndex]);</span><br><span class="line">    root.left = constructMaximumBinaryTree(nums, start, maxIndex);</span><br><span class="line">    root.right = constructMaximumBinaryTree(nums, maxIndex + <span class="number">1</span>, end);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：利用Stack可以达到O(N)时间复杂度，关键是发现规律，即「当前节点的左孩子一定是在左侧大于它的最远节点右侧的小于当前val的最左节点，同理右孩子一定是在右边较大节点左侧的小于当前节点值的最右节点」。在Stack中需要栈底到栈顶是从大到小的，一旦新的节点更大，就要不断pop，同时将此时pop出来的节点作为新节点的左节点，这样就能实现第一个要求。第二个要求则是在插入的时候，将栈顶的右孩子暂时指向新节点，同时将新节点入栈，之后如果有比新节点更大但没有前一个节点大的节点加入，则又回指向该节点了。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[i]);</span><br><span class="line">        <span class="comment">// 将左边小于当前节点的值作为当前节点的左孩子</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek().val &lt; curr.val) &#123;</span><br><span class="line">            curr.left = stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到左边第一个大于当前节点的值，当前节点作为它的右孩子</span></span><br><span class="line">        <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            stack.peek().right = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(curr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;  <span class="comment">// 栈顶是root</span></span><br><span class="line">        root = stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="655-print-binary-tree"><a href="#655-print-binary-tree" class="headerlink" title="655. print-binary-tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/print-binary-tree/">655. print-binary-tree</a></h4><ul>
<li>给一个二叉树，将每一层每个节点的值打印成字符串List，若为null则打印成空字符串。</li>
<li>方法一：递归。首先需要知道树的高度H才能确定每一层需要打印多少字符串。将List全部初始化为<code>&quot;&quot;</code>后，对每一层List的终点进行赋值，然后递归到下一层对左右子节点继续赋值。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">printTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; retVal = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            retVal.add(Arrays.asList(<span class="string">&quot;&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span> retVal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> getHeight(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">cols</span> <span class="operator">=</span> (<span class="type">int</span>)Math.pow(<span class="number">2</span>, rows) - <span class="number">1</span>;</span><br><span class="line">        List&lt;String&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cols; i++) &#123;</span><br><span class="line">            temp.add(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            retVal.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(temp));</span><br><span class="line">        &#125;</span><br><span class="line">        populate(root, retVal, <span class="number">0</span>, rows, <span class="number">0</span>, cols - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">populate</span><span class="params">(TreeNode curr, List&lt;List&lt;String&gt;&gt; retVal, <span class="type">int</span> row, <span class="type">int</span> rows, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (curr == <span class="literal">null</span> || row == rows) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">        retVal.get(row).set(mid, Integer.toString(curr.val));</span><br><span class="line">        populate(curr.left, retVal, row + <span class="number">1</span>, rows, left, mid - <span class="number">1</span>);</span><br><span class="line">        populate(curr.right, retVal, row + <span class="number">1</span>, rows, mid + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(getHeight(root.left), getHeight(root.right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：在populate中不递归调用，二是使用Queue进行BFS，对于每一层也是取中点进行赋值，然后将当前节点的左右孩子入队。</li>
</ul>
<h4 id="657-judge-route-circle"><a href="#657-judge-route-circle" class="headerlink" title="657. judge-route-circle"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/judge-route-circle/description/">657. judge-route-circle</a></h4><ul>
<li>给一个字符串表示一个移动的seq，判断最终是否回到远点。skip.</li>
</ul>
<h4 id="658-find-k-closest-elements"><a href="#658-find-k-closest-elements" class="headerlink" title="658. find-k-closest-elements"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-k-closest-elements/description/">658. find-k-closest-elements</a></h4><ul>
<li>在一个排好序的数组中��找距离x最近的k个元素，若有tie则尽量取更小的值。</li>
<li>二分查找找到x所在位置&#x2F;若x存在则应该处在的index，然后取它左边的元素作为left、本身作为right，双指针前后取即可。为了提高insert效率，使用linkedlist的addfirst。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findClosestElements</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> binarySearch(arr, x);</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> pos - <span class="number">1</span>, right = pos;</span><br><span class="line">        <span class="keyword">while</span> (ans.size() &lt; k &amp;&amp; left &gt;= <span class="number">0</span> &amp;&amp; right &lt; arr.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x - arr[left] &lt;= arr[right] - x) &#123;  <span class="comment">// delta相等时尽量取小的</span></span><br><span class="line">                ans.addFirst(arr[left--]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.add(arr[right++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (ans.size() &lt; k &amp;&amp; left &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            ans.addFirst(arr[left--]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (ans.size() &lt; k &amp;&amp; right &lt; arr.length) &#123;</span><br><span class="line">            ans.add(arr[right++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> -<span class="number">1</span>, right = arr.length;</span><br><span class="line">        <span class="keyword">while</span> (right - left &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (target &lt;= arr[mid]) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="662-maximum-width-of-binary-tree"><a href="#662-maximum-width-of-binary-tree" class="headerlink" title="662. maximum-width-of-binary-tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-width-of-binary-tree/description/">662. maximum-width-of-binary-tree</a></h4><ul>
<li>给一个二叉树，求最大宽度，即最左节点和最右节点之间的间隔。</li>
<li>在dfs过程中记录最左节点的id（类似于数组存储二叉树的形式），然后在遍历过程中根据level和当前id求间隔。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">widthOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; leftMostIds = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> dfs(root, <span class="number">1</span>, <span class="number">0</span>, leftMostIds);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode node, <span class="type">int</span> nodeId, <span class="type">int</span> level, List&lt;Integer&gt; leftMostIds)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (level &gt;= leftMostIds.size()) &#123;  <span class="comment">// 每一个level最左的node id</span></span><br><span class="line">            leftMostIds.add(nodeId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(nodeId - leftMostIds.get(level) + <span class="number">1</span>, </span><br><span class="line">                        Math.max(dfs(node.left, <span class="number">2</span> * nodeId, level + <span class="number">1</span>, leftMostIds), </span><br><span class="line">                                dfs(node.right, <span class="number">2</span> * nodeId + <span class="number">1</span>, level + <span class="number">1</span>, leftMostIds)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="663-equal-tree-partition"><a href="#663-equal-tree-partition" class="headerlink" title="663. equal-tree-partition"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/equal-tree-partition/">663. equal-tree-partition</a></h4><ul>
<li>给一个二叉树，判断是否可能通过移除一个edge使得两个拆分出来的树的节点sum相等。</li>
<li>方法一：使用Set存放所有可能的sum，然后在根部直接<code>/ 2</code>看看在Set中是否存在。时间、空间都是<code>O(N)</code>.</li>
<li>方法二：首先一波流求总的sum，然后在递归逐个节点求sum，看看总sum减去当前sum是否就是当前sum。需要注意edge case<code>[0, -1, 1]</code>，只要当前节点不是root即可。这样时间也是<code>O(N)</code>，空间为<code>O(Height)</code>。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">found</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> TreeNode allRoot;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkEqualTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">allSum</span> <span class="operator">=</span> getSum(root);</span><br><span class="line">        allRoot = root;</span><br><span class="line">        dfs(root, allSum);</span><br><span class="line">        <span class="keyword">return</span> found;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getSum(root.left) + getSum(root.right) + root.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> allSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> || found) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">currSum</span> <span class="operator">=</span> root.val + dfs(root.left, allSum) + dfs(root.right, allSum);</span><br><span class="line">        <span class="keyword">if</span> (root != allRoot &amp;&amp; allSum - currSum == currSum) &#123;</span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法三：直接修改节点值，存放每个子树的sum。逐层判断即可，也需要排除root。</li>
</ul>
<h4 id="665-non-decreasing-array"><a href="#665-non-decreasing-array" class="headerlink" title="665. non-decreasing-array"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/non-decreasing-array">665. non-decreasing-array</a></h4><ul>
<li>给一个int数组，问能否只修改其中一个元素使得整个数组non-decending.</li>
<li>greedy。对于当前元素与之前一位的比较，如果之前一位更大，就需要考虑是将当前元素拔高还是将之前元素降低。如果要保证后续尽量少操作，应当尽量把之前元素降低，但是还需要考虑再之前一个元素：如果再之前一个元素比当前元素大，即形成<code>3,4,2</code>的局面，则为了保证操作数最少，只能将当前元素拔高；否则就是类似与<code>3,6,4</code>的局面，将<code>6</code>降低即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkPossibility</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length &amp;&amp; count &lt;= <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i - <span class="number">1</span>] &gt; nums[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i - <span class="number">2</span> &lt; <span class="number">0</span> || nums[i - <span class="number">2</span>] &lt;= nums[i]) &#123;</span><br><span class="line">                    nums[i - <span class="number">1</span>] = nums[i];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    nums[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count &lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="666-path-sum-iv"><a href="#666-path-sum-iv" class="headerlink" title="666. path-sum-iv"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/path-sum-iv/">666. path-sum-iv</a></h4><ul>
<li>给一个int数组，每个数字都有三个digit，表示一个二叉树中的<code>深度、从左到右第几个、值</code>。求这个树的所有root到leaf的path sum.</li>
<li>不用构造树，可以直接根据层数、索引来确定后续的节点是什么，和普通的遍历一样进行DFS就可以了。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> sum;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            map.put(num / <span class="number">10</span>, num % <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(nums[<span class="number">0</span>] / <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> currSum)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> root / <span class="number">10</span>, index = root % <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftIndex</span> <span class="operator">=</span> index * <span class="number">2</span> - <span class="number">1</span>, rightIndex = index * <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftKey</span> <span class="operator">=</span> (level + <span class="number">1</span>) * <span class="number">10</span> + leftIndex, rightKey = (level + <span class="number">1</span>) * <span class="number">10</span> + rightIndex;</span><br><span class="line">        </span><br><span class="line">        currSum += map.get(root);</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(leftKey) &amp;&amp; !map.containsKey(rightKey)) &#123;</span><br><span class="line">            sum += currSum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(leftKey)) &#123;</span><br><span class="line">            dfs(leftKey, currSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(rightKey)) &#123;</span><br><span class="line">            dfs(rightKey, currSum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="669-trim-a-binary-search-tree"><a href="#669-trim-a-binary-search-tree" class="headerlink" title="669. trim-a-binary-search-tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/trim-a-binary-search-tree/description/">669. trim-a-binary-search-tree</a></h4><ul>
<li>给一个BST和一个值域[L, R]，只保留BST中属于该值域的节点。递归搞定，skip。</li>
</ul>
<h4 id="670-maximum-swap"><a href="#670-maximum-swap" class="headerlink" title="670. maximum-swap"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-swap/description/">670. maximum-swap</a></h4><ul>
<li>给一个非负数，求至多将其中两个digit互换位置之后所能得到的最大数。例如<code>9987</code>就是本身，<code>9978</code>是<code>9987</code>，<code>958469</code>是<code>998465</code>.</li>
<li>暗中观察规律就是找其中一个小的数字并找在它右侧的最大数，交换。因此首先需要记录每个数字最后出现的位置，然后从原数字第一位开始遍历，从最大的数字开始比较，一旦找到比自己大且排在自己后面的数字就可以直接交换位置了。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumSwap</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] numStr = Integer.toString(num).toCharArray();</span><br><span class="line">        <span class="type">int</span>[] bucket = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numStr.length; i++) &#123;</span><br><span class="line">            bucket[numStr[i] - <span class="string">&#x27;0&#x27;</span>] = i;    <span class="comment">// 每个数字最后出现的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找到最靠右的、比当前数字大的数字，交换位置即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numStr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">9</span>; index &gt; numStr[i] - <span class="string">&#x27;0&#x27;</span>; index--) &#123;   <span class="comment">// 注意只跟比当前数字大的比位置</span></span><br><span class="line">                <span class="keyword">if</span> (bucket[index] &gt; i) &#123;    <span class="comment">// 在当前位置之后</span></span><br><span class="line">                    <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> numStr[bucket[index]];</span><br><span class="line">                    numStr[bucket[index]] = numStr[i];  </span><br><span class="line">                    numStr[i] = temp;</span><br><span class="line">                    <span class="keyword">return</span> Integer.valueOf(<span class="keyword">new</span> <span class="title class_">String</span>(numStr));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="671-second-minimum-node-in-a-binary-tree"><a href="#671-second-minimum-node-in-a-binary-tree" class="headerlink" title="671. second-minimum-node-in-a-binary-tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/description/">671. second-minimum-node-in-a-binary-tree</a></h4><ul>
<li>给一个特殊的二叉树，每一个节点只有0或2个children，且值是两个子节点的较小值。求树中第二小的值，若没有，返回-1.</li>
<li>既然找的是比最小值大的最小的值，就用递归的方法在左右两边分别找比最小值的大的最小值，然后比较一下即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findSecondMinimumValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> || root.left == <span class="literal">null</span> || root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftLeastGreater</span> <span class="operator">=</span> getLeastGreater(root.left, root.val);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightLeastGreater</span> <span class="operator">=</span> getLeastGreater(root.right, root.val);</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Math.min(leftLeastGreater, rightLeastGreater);</span><br><span class="line">        <span class="keyword">if</span> (leftLeastGreater &gt; root.val &amp;&amp; rightLeastGreater &gt; root.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftLeastGreater == root.val ? (rightLeastGreater == root.val ? -<span class="number">1</span> : rightLeastGreater) : leftLeastGreater;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getLeastGreater</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftLeastGreater</span> <span class="operator">=</span> getLeastGreater(root.left, val);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightLeastGreater</span> <span class="operator">=</span> getLeastGreater(root.right, val);</span><br><span class="line">        <span class="keyword">if</span> (leftLeastGreater &gt; val &amp;&amp; rightLeastGreater &gt; val) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.min(leftLeastGreater, rightLeastGreater);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (leftLeastGreater &gt; val) &#123;</span><br><span class="line">            <span class="keyword">return</span> leftLeastGreater;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> rightLeastGreater;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="673-number-of-longest-increasing-subsequence"><a href="#673-number-of-longest-increasing-subsequence" class="headerlink" title="673. number-of-longest-increasing-subsequence"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/number-of-longest-increasing-subsequence/description/">673. number-of-longest-increasing-subsequence</a></h4><ul>
<li>给一个数组，求其中最长递增的subsequence的个数。如<code>[1,3,5,4,7]</code>中有两个长度为4的subsequence。</li>
<li>DP。用一个len[k]数组记录以k结尾的字符处的最长长度，<code>count[k]</code>记录对应的计数。双重循环时，当<code>nums[i] &gt; nums[j]</code>，若<code>len[j] + 1 &gt; len[i]</code>则需要更新i处的长度，同时count也直接更新；若<code>len[j] + 1 == len[i]</code>，则说明刚好从j过来可以形成递增sequence，直接累加就行了（一开始以为是<a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-increasing-subsequence/description/">lc300求长度</a>，就用stack做了，然而stack这个greedy做法也是错误的，还是需要上DP。。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findNumberOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] len = <span class="keyword">new</span> <span class="title class_">int</span> [nums.length];</span><br><span class="line">        <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span> [nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        Arrays.fill(len, <span class="number">1</span>);</span><br><span class="line">        Arrays.fill(count, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;        <span class="comment">// 保证递增关系</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">tempLen</span> <span class="operator">=</span> len[j] + <span class="number">1</span>;   <span class="comment">// 递增后的长度</span></span><br><span class="line">                    <span class="keyword">if</span> (tempLen &gt; len[i]) &#123;     </span><br><span class="line">                        len[i] = tempLen;</span><br><span class="line">                        count[i] = count[j];</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tempLen == len[i]) &#123;     <span class="comment">// 从j跳过来的递增</span></span><br><span class="line">                        count[i] += count[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxLen = Math.max(len[i], maxLen);      <span class="comment">// 记录最大长度，后续用于对比并累计count</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (len[i] == maxLen) &#123;</span><br><span class="line">                ans += count[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="674-longest-continuous-increasing-subsequence"><a href="#674-longest-continuous-increasing-subsequence" class="headerlink" title="674. longest-continuous-increasing-subsequence"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-continuous-increasing-subsequence/description/">674. longest-continuous-increasing-subsequence</a></h4><ul>
<li>给一个数组，求其中最长递增的连续subarray的长度。如<code>[1,2,3,4,5,6,5,4,3,4,5]</code>就是6，<code>[2,2,2,2,2]</code>就是1.</li>
<li>贪心法，只有大于前面元素才更新，一旦小于就更新到总的里面。注意最后返回之前还要取一次max。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLengthOfLCIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>, curr = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                curr++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = Math.max(ans, curr);</span><br><span class="line">                curr = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(ans, curr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="676-implement-magic-dictionary"><a href="#676-implement-magic-dictionary" class="headerlink" title="676. implement-magic-dictionary"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/implement-magic-dictionary/description/">676. implement-magic-dictionary</a></h4><ul>
<li>实现<code>buildDict</code>和<code>search</code>方法，search时判断能否通过「替换一个字符」的方式使得修改后的字符串包含在dict中，返回boolean。例如给<code>[&quot;hello&quot;, &quot;leetcode&quot;]</code>，搜索<code>hhllo</code>就返回true、搜索<code>hello</code>返回false。</li>
<li>方法一：dict就想到选择map，在build时对于每个字符串，将其中每个字符替换成特殊字符如<code>*</code>，将替换后的字符串作为key、被替换的字符作为value存入map。如果出现相同的key，则说明这个位置可以放任何字符（例如<code>hello, hallo</code>的第二位）；在搜索时也是对每个字符替换，然后看map中有没有，判断一下当前字符是否是value的字符（防止indentical）。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MagicDictionary</span> &#123;</span><br><span class="line">    <span class="comment">// 将每个单词的每个字符都替换成*之后，插入map，key是替换后的字符串，value是被替换掉的那个字符</span></span><br><span class="line">    <span class="comment">// 如果出现替换过后的key一样，则该位可以放任意字符，因为例如hello和hallo只有在第二位不同，如果替换后是h*llo可以任选一个，一定是true。</span></span><br><span class="line">    Map&lt;String, Character&gt; map = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MagicDictionary</span><span class="params">()</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Character&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Build a dictionary through a list of words */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildDict</span><span class="params">(String[] dict)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (dict == <span class="literal">null</span> || dict.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String word : dict) &#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(word);</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> word.length();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                sb.setCharAt(i, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">                <span class="type">Character</span> <span class="variable">c</span> <span class="operator">=</span> map.get(sb.toString());</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                    map.put(sb.toString(), word.charAt(i));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    map.put(sb.toString(), <span class="string">&#x27;*&#x27;</span>);    <span class="comment">// 表示可以放任何字符</span></span><br><span class="line">                &#125;</span><br><span class="line">                sb.setCharAt(i, word.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (word == <span class="literal">null</span> || word.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> word.length();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(word);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            sb.setCharAt(i, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">            <span class="type">Character</span> <span class="variable">c</span> <span class="operator">=</span> map.get(sb.toString());</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="literal">null</span> &amp;&amp; (c == <span class="string">&#x27;*&#x27;</span> || c != word.charAt(i))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.setCharAt(i, word.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：使用Trie。build的时候就正常地创建Trie，然后在search的时候逐个位置替换26个字符，每换一次就在Trie中搜索。Trie的效率感觉不高啊，感觉有square级别。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MagicDictionary</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">        TrieNode[] children = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">boolean</span> isWord;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TrieNode</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    TrieNode root;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MagicDictionary</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Build a dictionary through a list of words */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildDict</span><span class="params">(String[] dict)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String s : dict) &#123;</span><br><span class="line">            <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.children[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">null</span>) &#123;</span><br><span class="line">                    node.children[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.children[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            node.isWord = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] arr = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; c++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] == c) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">char</span> <span class="variable">org</span> <span class="operator">=</span> arr[i];</span><br><span class="line">                arr[i] = c;</span><br><span class="line">                <span class="keyword">if</span> (checkTrie(<span class="keyword">new</span> <span class="title class_">String</span>(arr), root)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                arr[i] = org;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkTrie</span><span class="params">(String s, TrieNode root)</span> &#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.children[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.isWord;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="678-valid-parenthesis-string"><a href="#678-valid-parenthesis-string" class="headerlink" title="678. valid-parenthesis-string"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-parenthesis-string/">678. valid-parenthesis-string</a></h4><ul>
<li>给一个只含有<code>(</code>, <code>*</code>, <code>)</code>的字符串，其中<code>*</code>可以是任何一种括号，或者为空，判断字符串是否合法。</li>
<li>方法一：与传统的valid parenthesis相比就是多了一个<code>*</code>，那就把它分别带入左右和空三种情况递归判断即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkValidString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> check(s.toCharArray(), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">char</span>[] charArray, <span class="type">int</span> start, <span class="type">int</span> leftCount)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (leftCount &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; charArray.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (charArray[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            leftCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (charArray[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftCount == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            leftCount--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> check(charArray, i + <span class="number">1</span>, leftCount + <span class="number">1</span>)</span><br><span class="line">                || check(charArray, i + <span class="number">1</span>, leftCount - <span class="number">1</span>)</span><br><span class="line">                || check(charArray, i + <span class="number">1</span>, leftCount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> leftCount == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：延续stack的做法，左括号和星号<strong>的index</strong>入栈，每次遇到右括号先把左括号的stack弹出。最后比较左括号的星号栈的索引大小即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkValidString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Integer&gt; leftIds = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; starIds = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            leftIds.push(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            starIds.push(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftIds.isEmpty() &amp;&amp; starIds.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!leftIds.isEmpty()) &#123;</span><br><span class="line">                leftIds.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                starIds.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!leftIds.isEmpty() &amp;&amp; !starIds.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (starIds.pop() &lt; leftIds.pop()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> leftIds.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法三：从左到右扫一遍，分别统计左括号和星号，优先匹配左括号，当左括号不够时再调用右括号；但是这样一波无法判断<code>(*()</code>这样的情况，因为星号始终是当成左的。因此需要再从右往左走一波，把星号当成有括号。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkValidString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, leftStar = <span class="number">0</span>, right = <span class="number">0</span>, rightStar = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            leftStar++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                left--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (leftStar &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                leftStar--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            right++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            rightStar++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (right &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rightStar &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                rightStar--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="680-valid-palindrome-ii"><a href="#680-valid-palindrome-ii" class="headerlink" title="680. valid-palindrome-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-palindrome-ii/description/">680. valid-palindrome-ii</a></h4><ul>
<li>给一个字符串，判断能否通过“最多删掉一个字符”形成自对称字符串。例如<code>aba</code>本身就是，<code>abca</code>可以通过删掉b或c变成自对称。</li>
<li>直接前后指针往中间并拢，一旦发现不同的字符就把不同的两个字符分别遮住继续判断，如果还不行那就一定不能自对称了。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(left) != s.charAt(right)) &#123;    <span class="comment">// 发现对应位置不匹配，尝试遮掉其中一个继续判断</span></span><br><span class="line">                <span class="keyword">return</span> isPalin(s, left + <span class="number">1</span>, right) || isPalin(s, left, right - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPalin</span><span class="params">(String s, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(left++) != s.charAt(right--)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="681-next-closest-time"><a href="#681-next-closest-time" class="headerlink" title="681. next-closest-time"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/next-closest-time/description/">681. next-closest-time</a></h4><ul>
<li>给一个字符串表示时间，求由这些数组组成的、下一个最近的时间（数字可无限使用）。</li>
<li>greedy方法，从末尾开始替换，如果有恰好比他大的数字，替换之后直接就返回了。否则就替换成这些数字中最小的数字。注意每一个位置的限制都不同，例如第二位就需要根据第一位是否为2来决定最大值是3还是9.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">nextClosestTime</span><span class="params">(String time)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (time == <span class="literal">null</span> || time.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] digits = getDigits(time.split(<span class="string">&quot;:&quot;</span>));</span><br><span class="line">        <span class="type">char</span>[] digitsOrigin = Arrays.copyOf(digits, digits.length);</span><br><span class="line">        <span class="type">char</span>[] ans = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line">        ans[<span class="number">0</span>] = digitsOrigin[<span class="number">0</span>];</span><br><span class="line">        ans[<span class="number">1</span>] = digitsOrigin[<span class="number">1</span>];</span><br><span class="line">        ans[<span class="number">2</span>] = <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line">        ans[<span class="number">3</span>] = digitsOrigin[<span class="number">2</span>];</span><br><span class="line">        ans[<span class="number">4</span>] = digitsOrigin[<span class="number">3</span>];</span><br><span class="line">        Arrays.sort(digits);</span><br><span class="line">        </span><br><span class="line">        ans[<span class="number">4</span>] = getNextGreater(digitsOrigin[<span class="number">3</span>], <span class="string">&#x27;9&#x27;</span>, digits);</span><br><span class="line">        <span class="keyword">if</span> (ans[<span class="number">4</span>] &gt; digitsOrigin[<span class="number">3</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(ans);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ans[<span class="number">3</span>] = getNextGreater(digitsOrigin[<span class="number">2</span>], <span class="string">&#x27;5&#x27;</span>, digits);</span><br><span class="line">        <span class="keyword">if</span> (ans[<span class="number">3</span>] &gt; digitsOrigin[<span class="number">2</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(ans);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ans[<span class="number">1</span>] = getNextGreater(digitsOrigin[<span class="number">1</span>], digitsOrigin[<span class="number">0</span>] == <span class="string">&#x27;2&#x27;</span> ? <span class="string">&#x27;3&#x27;</span> : <span class="string">&#x27;9&#x27;</span>, digits);</span><br><span class="line">        <span class="keyword">if</span> (ans[<span class="number">1</span>] &gt; digitsOrigin[<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(ans);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ans[<span class="number">0</span>] = getNextGreater(digitsOrigin[<span class="number">0</span>], <span class="string">&#x27;2&#x27;</span>, digits);</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span>[] getDigits(String[] timeSplitted) &#123;</span><br><span class="line">        <span class="type">char</span>[] digits = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">4</span>];</span><br><span class="line">        digits[<span class="number">0</span>] = (<span class="type">char</span>)(<span class="string">&#x27;0&#x27;</span> + Integer.parseInt(timeSplitted[<span class="number">0</span>]) / <span class="number">10</span>);</span><br><span class="line">        digits[<span class="number">1</span>] = (<span class="type">char</span>)(<span class="string">&#x27;0&#x27;</span> + Integer.parseInt(timeSplitted[<span class="number">0</span>]) % <span class="number">10</span>);</span><br><span class="line">        digits[<span class="number">2</span>] = (<span class="type">char</span>)(<span class="string">&#x27;0&#x27;</span> + Integer.parseInt(timeSplitted[<span class="number">1</span>]) / <span class="number">10</span>);</span><br><span class="line">        digits[<span class="number">3</span>] = (<span class="type">char</span>)(<span class="string">&#x27;0&#x27;</span> + Integer.parseInt(timeSplitted[<span class="number">1</span>]) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> <span class="title function_">getNextGreater</span><span class="params">(<span class="type">char</span> curr, <span class="type">char</span> limit, <span class="type">char</span>[] digits)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> Arrays.binarySearch(digits, curr) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (pos &lt; <span class="number">4</span> &amp;&amp; digits[pos] &lt;= limit &amp;&amp; digits[pos] == curr) &#123;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pos &lt; <span class="number">4</span> &amp;&amp; digits[pos] &lt;= limit ? digits[pos] : digits[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="682-baseball-game"><a href="#682-baseball-game" class="headerlink" title="682. baseball-game"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/baseball-game/description/">682. baseball-game</a></h4><ul>
<li>定义一个积分规则，没有什么好说的，用List即可。</li>
</ul>
<h4 id="683-k-empty-slots"><a href="#683-k-empty-slots" class="headerlink" title="683. k-empty-slots"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/k-empty-slots/description/">683. k-empty-slots</a></h4><ul>
<li>给一个flowers数组表示第<code>i + 1</code>天，开花的索引是<code>flowers[i]</code>。再给一个k，问是否存在某一天使得存在连续k个花未开且左右两边都已经开放，返回这个天数，若不存在则返回-1。</li>
<li>方法一：维护一个days数组表示该index的花在第<code>days[index]</code>天开。需要求得一个子序列<code>left, left+1, left+2, ..., left+k, right</code>使得days[left]和days[right]开放时间比中间任何一个都要早。从左往右遍历days数组，一旦发现中间某天开花时间早于left或者right就说明这个子序列中断了，更新left为i即可。时间空间都是O(N).<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kEmptySlots</span><span class="params">(<span class="type">int</span>[] flowers, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flowers == <span class="literal">null</span> || flowers.length &lt;= k) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] days = <span class="keyword">new</span> <span class="title class_">int</span>[flowers.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; flowers.length; i++) &#123;</span><br><span class="line">            days[flowers[i] - <span class="number">1</span>] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = k + <span class="number">1</span>, ans = Integer.MAX_VALUE;   <span class="comment">// 从左开始往右遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; days.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (days[i] &lt; days[left] || days[i] &lt;= days[right]) &#123;  <span class="comment">// 若其中某个i开花时刻早于左或者右侧window，就以该处为新的起点</span></span><br><span class="line">                <span class="keyword">if</span> (i == right) &#123;   <span class="comment">// 若遍历到right都没有问题，就是一个新的ans</span></span><br><span class="line">                    ans = Math.min(ans, Math.max(days[left], days[right]));</span><br><span class="line">                &#125;</span><br><span class="line">                left = i;</span><br><span class="line">                right = i + k + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == Integer.MAX_VALUE ? -<span class="number">1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>方法二：利用TreeSet存储flowers，随着天数增加，利用TreeSet的lower找小于该索引处的最大值、利用higher找大于该索引的最小值，这样求出来就能碰到完美等于k的子序列了。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kEmptySlots</span><span class="params">(<span class="type">int</span>[] flowers, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flowers == <span class="literal">null</span> || flowers.length &lt;= k) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeSet&lt;Integer&gt; bloomIndex = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> <span class="number">0</span>; day &lt; flowers.length; day++) &#123;</span><br><span class="line">            bloomIndex.add(flowers[day]);</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">left</span> <span class="operator">=</span> bloomIndex.lower(flowers[day]);</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">right</span> <span class="operator">=</span> bloomIndex.higher(flowers[day]);</span><br><span class="line">            <span class="keyword">if</span> ((left != <span class="literal">null</span> &amp;&amp; flowers[day] - left == k + <span class="number">1</span>)</span><br><span class="line">            || (right != <span class="literal">null</span> &amp;&amp; right - flowers[day] == k + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> day + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="684-redundant-connection"><a href="#684-redundant-connection" class="headerlink" title="684. redundant-connection"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/redundant-connection/description/">684. redundant-connection</a></h4><ul>
<li>给一系列边组成<strong>无向图</strong>，其中恰好多了一个边使图无法形成树，求多出来的这个边即最后出现的这个边。例如<code>[[1,2], [2,3], [3,4], [1,4], [1,5]]</code>，返回<code>[1,4]</code>。</li>
<li>并查集，维护每个节点的祖先，首次出现时默认以自己为祖先，然后就判断edge中的两个节点祖先是否一样，一样就说明成环了，否则就把前者的祖先指向后者的祖先。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 并查集：维护一个Map，表示每个编号的点的祖先</span></span><br><span class="line">    <span class="comment">// 一旦找到两个点的祖先一样，就说明这个边就是让前面成环的，直接返回</span></span><br><span class="line">    <span class="comment">// 若祖先不同，则直接将前者的祖先归位后者祖先的后代，这样就把两个部分直接合并了，后面判断成环就可以直接判断</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findRedundantConnection(<span class="type">int</span>[][] edges) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edges == <span class="literal">null</span> || edges.length == <span class="number">0</span> || edges[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; parentMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edge: edges) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> edge[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> edge[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (!parentMap.containsKey(from)) &#123;</span><br><span class="line">                parentMap.put(from, from);      <span class="comment">// 刚开始设为本身</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!parentMap.containsKey(to)) &#123;</span><br><span class="line">                parentMap.put(to, to);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">fromParent</span> <span class="operator">=</span> findParent(parentMap, from);</span><br><span class="line">            <span class="type">int</span> <span class="variable">toParent</span> <span class="operator">=</span> findParent(parentMap, to);</span><br><span class="line">            <span class="keyword">if</span> (fromParent == toParent) &#123;       <span class="comment">// 二者的祖先是一样的说明成环了</span></span><br><span class="line">                <span class="keyword">return</span> edge;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parentMap.put(fromParent, toParent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findParent</span><span class="params">(Map&lt;Integer, Integer&gt; parentMap, <span class="type">int</span> node)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> parentMap.get(node);</span><br><span class="line">        <span class="keyword">if</span> (parent != node) &#123;</span><br><span class="line">            parentMap.put(node, findParent(parentMap, parent));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parentMap.get(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="685-redundant-connection-ii"><a href="#685-redundant-connection-ii" class="headerlink" title="685. redundant-connection-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/redundant-connection-ii/description/">685. redundant-connection-ii</a></h4><ul>
<li>给一系列边组成<strong>有向图</strong>，其中恰好多了一个边使图无法形成rooted tree，求多出来的这个边即最后出现的这个边。例如<code>[[2,1],[3,1],[4,2],[1,4]]</code>，返回<code>[2,1]</code>。</li>
<li>与684相比这里的边都是有向的了，有两种情况来判别边invalid：形成了环，或者一个节点同时有两个parent节点。做法分为两步：首先check看是否有节点有两个parent，有的话就设为candidate A和B，并把B设置为invalid（设一个节点为0即可）；然后进行union-find，如果此时树已经是valid的了，就直接返回candidate B（因为是后出现的）。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findRedundantDirectedConnection(<span class="type">int</span>[][] edges) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edges == <span class="literal">null</span> || edges.length == <span class="number">0</span> || edges[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] candidate1 = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span>[] candidate2 = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">2</span>];     <span class="comment">// 后出现的</span></span><br><span class="line">        <span class="type">int</span>[] parent = <span class="keyword">new</span> <span class="title class_">int</span> [edges.length + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先找有没有节点有两个parent</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; edges.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent[edges[i][<span class="number">1</span>]] == <span class="number">0</span>) &#123;     <span class="comment">// 设置每个孩子节点的parent</span></span><br><span class="line">                parent[edges[i][<span class="number">1</span>]] = edges[i][<span class="number">0</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;            <span class="comment">// 发现有重复设置的情况</span></span><br><span class="line">                candidate2[<span class="number">0</span>] = edges[i][<span class="number">0</span>];</span><br><span class="line">                candidate2[<span class="number">1</span>] = edges[i][<span class="number">1</span>];</span><br><span class="line">                candidate1[<span class="number">0</span>] = parent[edges[i][<span class="number">1</span>]];    <span class="comment">// 原本存的parent是谁</span></span><br><span class="line">                candidate1[<span class="number">1</span>] = edges[i][<span class="number">1</span>];</span><br><span class="line">                edges[i][<span class="number">1</span>] = <span class="number">0</span>;        <span class="comment">// 这个孩子节点暂时设为无效的节点值，比如0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 重新初始化parent，设为本身</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; edges.length; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edge[<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">father</span> <span class="operator">=</span> edge[<span class="number">0</span>], child = edge[<span class="number">1</span>];  <span class="comment">// 前-&gt;后</span></span><br><span class="line">            <span class="keyword">if</span> (root(parent, father) == child) &#123;      <span class="comment">// 判断两个节点是不是连到一起了，注意这里是直接判断是否以child作为parent，而不像上一题两个节点都要求parent</span></span><br><span class="line">                <span class="keyword">if</span> (candidate1[<span class="number">0</span>] == <span class="number">0</span>) &#123;      <span class="comment">// 没有多parent的情况</span></span><br><span class="line">                    <span class="keyword">return</span> edge;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> candidate1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            parent[child] = father;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidate2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">root</span><span class="params">(<span class="type">int</span>[] parent, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (parent[i] != i) &#123;</span><br><span class="line">            parent[i] = parent[parent[i]];</span><br><span class="line">            i = parent[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="686-repeated-string-match"><a href="#686-repeated-string-match" class="headerlink" title="686. repeated-string-match"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/repeated-string-match/description/">686. repeated-string-match</a></h4><ul>
<li>给两个字符串A和B，求A需要重复几次才能让B成为它的substring.</li>
<li>狗家实习的OA，自己想的方法。先看看起始字符都出现在哪些索引，统统入queue；然后先拼一波使得A的长度不小于B；然后从queue中取起始索引，比较看B是否包含其中；如果queue还没用完则还需要拼多一次。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">repeatedStringMatch</span><span class="params">(String A, String B)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || B == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">AOld</span> <span class="operator">=</span> A;</span><br><span class="line">        Queue&lt;Integer&gt; startIndexQueue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span>[] AChar = A.toCharArray(), BChar = B.toCharArray();</span><br><span class="line">        <span class="type">char</span> <span class="variable">startChar</span> <span class="operator">=</span> BChar[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// O(N) get start position</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; AChar.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (AChar[i] == startChar) &#123;</span><br><span class="line">                startIndexQueue.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">repeatCount</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!startIndexQueue.isEmpty() &amp;&amp; A.length() - startIndexQueue.peek() &lt; BChar.length) &#123;</span><br><span class="line">            A += AOld;     <span class="comment">// append if not long enough            </span></span><br><span class="line">            repeatCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!startIndexQueue.isEmpty() &amp;&amp; startIndexQueue.peek() + BChar.length &lt;= A.length()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> startIndexQueue.poll();</span><br><span class="line">            <span class="keyword">if</span> (B.equals(A.substring(startIndex, startIndex + BChar.length))) &#123;</span><br><span class="line">                <span class="keyword">return</span> repeatCount;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if there is still startIndex in queue, need to repeat and check more</span></span><br><span class="line">        <span class="keyword">if</span> (!startIndexQueue.isEmpty()) &#123;</span><br><span class="line">            A += AOld;</span><br><span class="line">            repeatCount++;</span><br><span class="line">            <span class="keyword">while</span> (!startIndexQueue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (B.equals(A.substring(startIndexQueue.peek(), startIndexQueue.peek() + BChar.length))) &#123;</span><br><span class="line">                    <span class="keyword">return</span> repeatCount;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    startIndexQueue.poll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>或者直接用拼接的方式，一直拼接A直到超过B的长度，然后看是否包含。如果不包含还需要额外的一次拼接再看。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">repeatedStringMatch</span><span class="params">(String A, String B)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">while</span> (sb.length() &lt; B.length()) &#123;</span><br><span class="line">        sb.append(A);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sb.toString().contains(B)) <span class="keyword">return</span> count;</span><br><span class="line">    <span class="keyword">if</span> (sb.append(A).toString().contains(B)) <span class="keyword">return</span> ++count;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="687-longest-univalue-path"><a href="#687-longest-univalue-path" class="headerlink" title="687. longest-univalue-path"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-univalue-path/description/">687. longest-univalue-path</a></h4><ul>
<li>给一个二叉树，求其中最长的连续边数使得经过的节点值都一样。不一定是完全笔直的路径。</li>
<li>对于左子树和右子树递归调用求最长路径（不取当前节点的情况），然后根据当前节点的值进行DFS（也就是取当前节点的情况）。最后取最大。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestUnivaluePath</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> Math.max(longestUnivaluePath(root.left), longestUnivaluePath(root.right));</span><br><span class="line">        <span class="keyword">return</span> Math.max(child, dfs(root.left, root.val) + dfs(root.right, root.val));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode node, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span> || node.val != val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(dfs(node.left, val), dfs(node.right, val)); <span class="comment">// two nodes forms one edge</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>但是上面的这个方法存在大量重复访问节点，时间复杂度O(N^2)。因此考虑和之前diameter题一样，使用全局变量求最大path，同时在dfs每步直接将两侧中较大深度返回给上一层。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestUnivaluePath</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root, root.val);</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode node, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> dfs(node.left, node.val);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> dfs(node.right, node.val);</span><br><span class="line">        maxLen = Math.max(maxLen, left + right);    <span class="comment">// 取当前node为转折点</span></span><br><span class="line">        <span class="keyword">return</span> node.val == val ? Math.max(left, right) + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="688-knight-probability-in-chessboard"><a href="#688-knight-probability-in-chessboard" class="headerlink" title="688. knight-probability-in-chessboard"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/knight-probability-in-chessboard/">688. knight-probability-in-chessboard</a></h4><ul>
<li>给一个整数N表示是<code>N*N</code>的棋盘，其中一个knight&#x2F;马在坐标(r, c)，问走K步后它还在棋盘有效范围内的概率是多少。</li>
<li>概率就是走到棋盘上的情况数&#x2F;总的情况数即<code>8^K</code>种走法。当前位置取决于上一步的位置，但是我们并不知道上一步有多少种走法，因此想到bottom-up的DP方法，即假设当前是走完K步之后的位置，可以从之前的哪些位置走过来呢，倒推上一步的走法，然后再继续倒推。注意只有上一步是在有效棋盘内才能update。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="type">int</span>[][] moves = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, -<span class="number">2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;-<span class="number">1</span>, -<span class="number">2</span>&#125;, &#123;-<span class="number">2</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">2</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">knightProbability</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> K, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isValid(r, c, N)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span>[][] dp = <span class="keyword">new</span> <span class="title class_">double</span>[N][N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">double</span>[] row : dp) &#123;</span><br><span class="line">            Arrays.fill(row, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; K; k++) &#123;</span><br><span class="line">            <span class="type">double</span>[][] dpFrom = <span class="keyword">new</span> <span class="title class_">double</span>[N][N];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span>[] move : moves) &#123;  <span class="comment">// 倒推：从i, j跳到当前位置的</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> i + move[<span class="number">0</span>];</span><br><span class="line">                        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> j + move[<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span> (isValid(row, col, N)) &#123; <span class="comment">// 需要得到跳过来的那个位置的情况数</span></span><br><span class="line">                            dpFrom[i][j] = dp[row][col] + dpFrom[i][j];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp = dpFrom;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[r][c] / Math.pow(<span class="number">8</span>, K);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c, <span class="type">int</span> N)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> r &gt;= <span class="number">0</span> &amp;&amp; r &lt; N &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="689-maximum-sum-of-3-non-overlapping-subarrays"><a href="#689-maximum-sum-of-3-non-overlapping-subarrays" class="headerlink" title="689. maximum-sum-of-3-non-overlapping-subarrays"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-sum-of-3-non-overlapping-subarrays/description/">689. maximum-sum-of-3-non-overlapping-subarrays</a></h4><ul>
<li>给一个正整数数组，找出三个互不重叠的、size为k的子数组，使得总和最大。返回的形式是每个subarray的起始索引。例如<code>[1,2,1,2,6,7,5,1], k=2</code>则返回<code>[0, 3, 5]</code>。</li>
<li>有唯一解吗？（可能有多个，只需返回最先出现索引）k本身会不会很大？（不会，不大于len&#x2F;3）</li>
<li>首先是如何快速求某个区间内的和？如果数值都不大的话，可以通过累加把sum都给缓存下来，用的时候直接减一下就行了。然后是如何求subarray的结果？可以用二位dp数组，行表示划分成row个subarray，列表示从0到col处为止能得到的最大的总sum。此外还需要一个二维index数组记录第row个subarray对应的起始位置。从第一个subarray开始循环，固定求size为k的subarray使之和最大，其实就是贪心的思想，只要过程中求的每个subarray的和都最大那么最终的总和就是最大的。在循环过程中就可以不断求总和，为了防止重叠求和时必须求往前k个元素为end的dp结果。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSumOfThreeSubarrays(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 动态规划</span></span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 缓存到i为止到所有项之和</span></span><br><span class="line">        <span class="type">int</span>[] sumArray = <span class="keyword">new</span> <span class="title class_">int</span> [nums.length];</span><br><span class="line">        sumArray[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sumArray[i] = sumArray[i - <span class="number">1</span>] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// dp[i][j]表示求i个non-overlap sum的时候从0~j能得到的最大总sum</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">4</span>][nums.length];</span><br><span class="line">        <span class="comment">// index[i][j]表示求第i个non-overlap sum的时候的starting index</span></span><br><span class="line">        <span class="type">int</span>[][] index = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">4</span>][nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;   <span class="comment">// 从求第1个最大的k-size subarray开始直到第3个</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> k - <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tempMax</span> <span class="operator">=</span> j == k - <span class="number">1</span>? sumArray[j] :   <span class="comment">// 快速求区间内的和</span></span><br><span class="line">                    sumArray[j] - sumArray[j - k] + dp[i - <span class="number">1</span>][j - k];   <span class="comment">// 加上上一行前一个block为止的最大和</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt; k - <span class="number">1</span>) &#123;        <span class="comment">// 先直接沿用同一行的前面的结果</span></span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">                    index[i][j] = index[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; tempMax &gt; dp[i][j - <span class="number">1</span>]) &#123;  <span class="comment">// 若发现有更大的就更新当前最大和到dp</span></span><br><span class="line">                    dp[i][j] = tempMax;</span><br><span class="line">                    index[i][j] = j - k + <span class="number">1</span>;    <span class="comment">// 同时更新最大和出现的下标</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">3</span>];        </span><br><span class="line">        ans[<span class="number">2</span>] = index[<span class="number">3</span>][nums.length - <span class="number">1</span>];     <span class="comment">// 最后一行的最后一位就是第三个block的index</span></span><br><span class="line">        ans[<span class="number">1</span>] = index[<span class="number">2</span>][ans[<span class="number">2</span>] - <span class="number">1</span>];          <span class="comment">// 倒数第二行的index[3]之前的存的就是第二行的</span></span><br><span class="line">        ans[<span class="number">0</span>] = index[<span class="number">1</span>][ans[<span class="number">1</span>] - <span class="number">1</span>];          </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="690-employee-importance"><a href="#690-employee-importance" class="headerlink" title="690. employee-importance"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/employee-importance/description/">690. employee-importance</a></h4><ul>
<li>给一个List of Employee，包含id、importance、下属List等属性。给定id，求这个id对应员工及其所有下属（不一定是直接下属）的imp之和。</li>
<li>DFS。用一个Map先存储id-Employee的键值对，然后可以给定一个id快速访问到该Employee的信息，然后DFS递归搞定。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Employee info</span></span><br><span class="line"><span class="comment">class Employee &#123;</span></span><br><span class="line"><span class="comment">    // It&#x27;s the unique id of each node;</span></span><br><span class="line"><span class="comment">    // unique id of this employee</span></span><br><span class="line"><span class="comment">    public int id;</span></span><br><span class="line"><span class="comment">    // the importance value of this employee</span></span><br><span class="line"><span class="comment">    public int importance;</span></span><br><span class="line"><span class="comment">    // the id of direct subordinates</span></span><br><span class="line"><span class="comment">    public List&lt;Integer&gt; subordinates;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getImportance</span><span class="params">(List&lt;Employee&gt; employees, <span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (employees == <span class="literal">null</span> || employees.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Employee&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Employee e : employees) &#123;</span><br><span class="line">            map.put(e.id, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getImp(map, id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getImp</span><span class="params">(Map&lt;Integer, Employee&gt; map, <span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(id)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> map.get(id);</span><br><span class="line">        <span class="type">int</span> <span class="variable">imp</span> <span class="operator">=</span> e.importance;</span><br><span class="line">        <span class="keyword">for</span> (Integer i : e.subordinates) &#123;</span><br><span class="line">            imp += getImp(map, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> imp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="692-top-k-frequent-words"><a href="#692-top-k-frequent-words" class="headerlink" title="692. top-k-frequent-words"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/top-k-frequent-words/description/">692. top-k-frequent-words</a></h4><ul>
<li>给一个String数组，求出现频率top k的字符串。</li>
<li>跟<a target="_blank" rel="noopener" href="https://leetcode.com/problems/top-k-frequent-elements/description/">347</a>类似。先用Map存每个单词出现的频数，再自定义根据频数minHeap存这些Map.Entry，然后每次都check堆的规模，一旦大于k就直接把最小的poll出来，这样就保证在minHeap中的一定是top k.最后就直接逆序插入结果List。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">topKFrequent</span><span class="params">(String[] words, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (words == <span class="literal">null</span> || words.length == <span class="number">0</span> || k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 统计每个单词出现的频数</span></span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(word)) &#123;</span><br><span class="line">                map.put(word, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(word, map.get(word) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将entry按照频数从小到大插入PQ，若规模&gt;k则直接poll掉最小的</span></span><br><span class="line">        PriorityQueue&lt;Map.Entry&lt;String, Integer&gt;&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> a.getValue() != b.getValue()? </span><br><span class="line">                a.getValue() - b.getValue() : b.getKey().compareTo(a.getKey());</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; e : map.entrySet()) &#123;</span><br><span class="line">            pq.offer(e);</span><br><span class="line">            <span class="keyword">if</span> (pq.size() &gt; k) &#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取PQ元素，逆序插入结果</span></span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            ans.add(<span class="number">0</span>, pq.poll().getKey());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>follow-up：如果给定的输入不是一个完整的数组，而是一个stream，即每次都只能取得一个单词，然后立即返回top k，如何改进？</li>
<li>关键在于无法在最开始就获得完整的频数统计Map，在插入minHeap的时候就无法知道后续的Entry需不需要覆盖PQ中的值。因此需要一个额外的Map记录具体哪些Entry目前被存放在minHeap中；当新的单词出现，就先更新map中的项，然后再看看它是否在PQ中，在则需要更新（我只能想到把k个元素全抖出来再加进去），不在则跟minHeap的peek比较决定是否需要替换。这样时间是O(N)的统计频数、O(logN)的插入minHeap、O(KlogK)的更新(?)和最后O(K)的倒入List。</li>
</ul>
<h4 id="694-number-of-distinct-islands"><a href="#694-number-of-distinct-islands" class="headerlink" title="694. number-of-distinct-islands"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/number-of-distinct-islands/description/">694. number-of-distinct-islands</a></h4><ul>
<li>给一个grid，其中含有0和1，求所有distinct的连续1的团簇的个数，distinct指的是通过位移无法完全匹配的连续的1的区域。</li>
<li>与统计number of island的区别在于这里的island需要通过某种方式辨别该形状是否出现过，联想到encode方法，利用上下左右标记走过的路程。对于DFS，需要额外标出回溯的字母。对于BFS，也需要在结束当前节点的邻接点enqueue后加上标记符。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>[][] directions = <span class="keyword">new</span> <span class="title class_">int</span>[][] &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span>[] directionsChar = <span class="keyword">new</span> <span class="title class_">char</span>[] &#123;<span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;r&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDistinctIslands</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rowTotal</span> <span class="operator">=</span> grid.length, colTotal = grid[<span class="number">0</span>].length;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rowTotal; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; colTotal; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                    <span class="comment">// dfs(grid, i, j, sb, &#x27;o&#x27;);</span></span><br><span class="line">                    bfs(grid, i, j, sb);</span><br><span class="line">                    set.add(sb.toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> set.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> row, <span class="type">int</span> col, StringBuilder sb)</span> &#123;</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.offer(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;row, col&#125;);</span><br><span class="line">        grid[row][col] = <span class="number">0</span>;     <span class="comment">// BFS在加入queue的时候就要将grid标记为已访问了</span></span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span>[] curr = q.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; directions.length; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">rowNeighbor</span> <span class="operator">=</span> curr[<span class="number">0</span>] + directions[i][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">colNeighbor</span> <span class="operator">=</span> curr[<span class="number">1</span>] + directions[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (validatePos(grid, rowNeighbor, colNeighbor)) &#123;</span><br><span class="line">                    grid[rowNeighbor][colNeighbor] = <span class="number">0</span>;</span><br><span class="line">                    q.offer(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;rowNeighbor, colNeighbor&#125;);</span><br><span class="line">                    sb.append(directionsChar[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(<span class="string">&#x27;,&#x27;</span>); <span class="comment">// 表示将当前的所有neighbor都enqueue了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> row, <span class="type">int</span> col, StringBuilder sb, <span class="type">char</span> dir)</span> &#123;</span><br><span class="line">        grid[row][col] = <span class="number">0</span>;</span><br><span class="line">        sb.append(dir);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; directions.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rowNeighbor</span> <span class="operator">=</span> row + directions[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">colNeighbor</span> <span class="operator">=</span> col + directions[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (validatePos(grid, rowNeighbor, colNeighbor)) &#123;</span><br><span class="line">                dfs(grid, rowNeighbor, colNeighbor, sb, directionsChar[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(<span class="string">&#x27;b&#x27;</span>);     <span class="comment">// Trick!!! DFS回溯的时候需要标出来，不然无法区分是否回溯之后的位移</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">validatePos</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> row &gt;= <span class="number">0</span> &amp;&amp; row &lt; grid.length &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; grid[<span class="number">0</span>].length &amp;&amp; grid[row][col] == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="695-max-area-of-island"><a href="#695-max-area-of-island" class="headerlink" title="695. max-area-of-island"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/max-area-of-island/description/">695. max-area-of-island</a></h4><ul>
<li>给一个grid，表示水和小岛，求最大的岛的面积。DFS搞定，skip。</li>
</ul>
<h4 id="696-count-binary-substrings"><a href="#696-count-binary-substrings" class="headerlink" title="696. count-binary-substrings"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/count-binary-substrings/description/">696. count-binary-substrings</a></h4><ul>
<li>给一个只含有0和1的字符串，求其中有多少个子字符串使得0和1分别连续出现且个数相等，例如<code>01</code>, <code>1100</code>就满足要求。</li>
<li>从头到尾遍历，然后双指针扩散判断。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countBinarySubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">1</span>, ans = <span class="number">0</span>;       <span class="comment">// 同时比较相邻两个字符</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(left) != s.charAt(right)) &#123;    <span class="comment">// 往左和右分别扩展</span></span><br><span class="line">                <span class="type">char</span> <span class="variable">charLeft</span> <span class="operator">=</span> s.charAt(left), charRight = s.charAt(right);</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left - <span class="number">1</span>, j = right + <span class="number">1</span>, count = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i) == charLeft &amp;&amp; </span><br><span class="line">                       j &lt; s.length() &amp;&amp; s.charAt(j) == charRight) &#123;</span><br><span class="line">                    i--;</span><br><span class="line">                    j++;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                ans += count;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="697-degree-of-an-array"><a href="#697-degree-of-an-array" class="headerlink" title="697. degree-of-an-array"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/degree-of-an-array/">697. degree-of-an-array</a></h4><ul>
<li>给一个int数组，degree为其中元素出现的最大频数。求和原数组degree相同的最小subarray长度。</li>
<li>对每个元素计数，同时记录第一个出现的index，出现新degree直接就是当前索引到第一个出现索引的距离。pass。</li>
</ul>
<h4 id="698-partition-to-k-equal-sum-subsets"><a href="#698-partition-to-k-equal-sum-subsets" class="headerlink" title="698. partition-to-k-equal-sum-subsets"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/partition-to-k-equal-sum-subsets/description/">698. partition-to-k-equal-sum-subsets</a></h4><ul>
<li>给一个只含有(0, 10000)的int数组和一个k，判断是否可以将该数组划分为k个相等sum的partition。</li>
<li>似乎是个NP-hard的问题。只能用暴力办法，DFS+标记数组，每次累加过后进入下一层看看是否达到了targetSum，达到了就清空继续往后找新的一组subset.最后如果只剩下一组了，直接返回true，因为此时其他k - 1个组都已经达到targetSum了，当前的<code>sum = k * targetSum - (k - 1) * targetSum = targetSum</code>.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartitionKSubsets</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span> || k &gt; nums.length || k &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> IntStream.of(nums).sum();  <span class="comment">// Java8的stream!</span></span><br><span class="line">        <span class="keyword">if</span> (sum % k != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">targetSum</span> <span class="operator">=</span> sum / k;</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        <span class="keyword">return</span> checkPartition(nums, visited, <span class="number">0</span>, targetSum, <span class="number">0</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkPartition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">boolean</span>[] visited, <span class="type">int</span> startIndex, <span class="type">int</span> targetSum, <span class="type">int</span> currSum, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;    <span class="comment">// 提前break</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (currSum == targetSum) &#123;</span><br><span class="line">            <span class="keyword">return</span> checkPartition(nums, visited, <span class="number">0</span>, targetSum, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                visited[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (checkPartition(nums, visited, i + <span class="number">1</span>, targetSum, currSum + nums[i], k)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                visited[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：更快的做法是先对数组排序，然后存k个bucket，每个bucket从后往前取元素不断累加.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartitionKSubsets</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span> || k &gt; nums.length || k &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum % k != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">targetSum</span> <span class="operator">=</span> sum / k;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> checkPartition(nums, targetSum, <span class="keyword">new</span> <span class="title class_">int</span>[k], nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkPartition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> targetSum, <span class="type">int</span>[] buckets, <span class="type">int</span> numsIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (numsIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> bucket : buckets) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bucket != targetSum) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (buckets[i] + nums[numsIndex] &lt;= targetSum) &#123;</span><br><span class="line">                buckets[i] += nums[numsIndex];</span><br><span class="line">                <span class="keyword">if</span> (checkPartition(nums, targetSum, buckets, numsIndex - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                buckets[i] -= nums[numsIndex];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>follow-up: 如果去掉正数的限制，允许出现负数和0？</li>
<li>上面的方法只考虑了直接累积叠加，无法解决负数问题。因此需要引入一个elementCount来统计当前这一波存入了多少element，当达到targetSum的时候需要判断当前这一波是否真的存入了元素。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartitionKSubsets</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span> || k &gt; nums.length || k &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> IntStream.of(nums).sum();</span><br><span class="line">        <span class="keyword">if</span> (sum % k != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">targetSum</span> <span class="operator">=</span> sum / k;</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        <span class="keyword">return</span> checkPartition(nums, visited, <span class="number">0</span>, targetSum, <span class="number">0</span>, k, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkPartition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">boolean</span>[] visited, <span class="type">int</span> startIndex, <span class="type">int</span> targetSum, <span class="type">int</span> currSum, <span class="type">int</span> k, <span class="type">int</span> elementCount)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;      <span class="comment">// 必须算完才行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (currSum == targetSum &amp;&amp; elementCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> checkPartition(nums, visited, <span class="number">0</span>, targetSum, <span class="number">0</span>, k - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                visited[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (checkPartition(nums, visited, i + <span class="number">1</span>, targetSum, currSum + nums[i], k, elementCount + <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                visited[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="699-falling-squares"><a href="#699-falling-squares" class="headerlink" title="699. falling-squares"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/falling-squares/description/">699. falling-squares</a></h4><ul>
<li>给一个二维数组，每一行表示一个方块的起始坐标和边长。方块按照数组的顺序下落，方块底部可以粘在下面的方块上，无限堆叠，求一个List表示当前已下落的所有方块中的最大高度。</li>
<li>方法一：naive的O(N^2)暴力遍历法。对于每个方块都往前遍历所有的方块求当前方块的高度，然后和List的前一个元素比较，获取最大高度。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Square</span> &#123;</span><br><span class="line">        <span class="type">int</span> left, right, height;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Square</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.left = left;</span><br><span class="line">            <span class="built_in">this</span>.right = right;</span><br><span class="line">            <span class="built_in">this</span>.height = height;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">fallingSquares</span><span class="params">(<span class="type">int</span>[][] positions)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (positions == <span class="literal">null</span> || positions.length == <span class="number">0</span> || positions[<span class="number">0</span>].length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        Square[] squares = <span class="keyword">new</span> <span class="title class_">Square</span>[positions.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; positions.length; i++) &#123;</span><br><span class="line">            squares[i] = <span class="keyword">new</span> <span class="title class_">Square</span>(positions[i][<span class="number">0</span>], positions[i][<span class="number">0</span>] + positions[i][<span class="number">1</span>], positions[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">currHeight</span> <span class="operator">=</span> getHeight(squares, i);</span><br><span class="line">            squares[i].height = currHeight;</span><br><span class="line">            ans.add(Math.max(i &gt; <span class="number">0</span> ? ans.get(i - <span class="number">1</span>) : <span class="number">0</span>, currHeight));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(Square[] squares, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxHeight</span> <span class="operator">=</span> squares[i].height;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (squares[i].left &gt;= squares[j].right || squares[i].right &lt;= squares[j].left) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            maxHeight = Math.max(maxHeight, squares[i].height + squares[j].height);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxHeight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：TreeMap</li>
<li>方法三：Segment Tree</li>
</ul>
<h4 id="700-search-in-a-binary-search-tree"><a href="#700-search-in-a-binary-search-tree" class="headerlink" title="700. search-in-a-binary-search-tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/search-in-a-binary-search-tree/">700. search-in-a-binary-search-tree</a></h4><ul>
<li>给一个BST和val，返回对应节点。pass.</li>
</ul>
<h4 id="701-insert-into-a-binary-search-tree"><a href="#701-insert-into-a-binary-search-tree" class="headerlink" title="701. insert-into-a-binary-search-tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/insert-into-a-binary-search-tree/">701. insert-into-a-binary-search-tree</a></h4><ul>
<li>给一个BST和一个val，将val插入BST，返回插入后的BST。</li>
<li>方法一：递归。val与当前节点比较，小就深入左子树、大就深入右子树。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (val &lt; root.val) &#123;</span><br><span class="line">            root.left = insertIntoBST(root.left, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root.right = insertIntoBST(root.right, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：迭代。思路类似，根据大小决定潜入左还是右子树。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val &lt; curr.val) &#123;</span><br><span class="line">                <span class="keyword">if</span> (curr.left == <span class="literal">null</span>) &#123;</span><br><span class="line">                    curr.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">                    <span class="keyword">return</span> root;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    curr = curr.left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (curr.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                    curr.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">                    <span class="keyword">return</span> root;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    curr = curr.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="703-kth-largest-element-in-a-stream"><a href="#703-kth-largest-element-in-a-stream" class="headerlink" title="703. kth-largest-element-in-a-stream"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/kth-largest-element-in-a-stream/description/">703. kth-largest-element-in-a-stream</a></h4><ul>
<li>实现一个能handle stream of int的类，调用add时能返回第k大的数。</li>
<li>和求top k element一个道理，PriorityQueue搞定。skip.</li>
</ul>
<h4 id="704-binary-search"><a href="#704-binary-search" class="headerlink" title="704. binary-search"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-search/">704. binary-search</a></h4><ul>
<li>实现二分查找，直接套了<a href="https://bobbyliujb.github.io/2017/09/04/cheatsheet/">模版</a>。</li>
</ul>
<h4 id="706-design-hashmap"><a href="#706-design-hashmap" class="headerlink" title="706. design-hashmap"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/design-hashmap/">706. design-hashmap</a></h4><ul>
<li>实现一个HashMap。</li>
<li>基本上就是考察CS基础了。最直接的想法就是用bucket，输入的key范围是多少就用多少空间。如果没有那么多空间，那就要考虑缩小空间并处理collision. 这里可以使用<code>ListNode chaining</code>解决。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyHashMap</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> key, val;</span><br><span class="line">        Node next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node[] bucket;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyHashMap</span><span class="params">()</span> &#123;</span><br><span class="line">        bucket = <span class="keyword">new</span> <span class="title class_">Node</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** value will always be non-negative. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> key % size;</span><br><span class="line">        <span class="keyword">if</span> (bucket[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">            bucket[index] = <span class="keyword">new</span> <span class="title class_">Node</span>(key, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> bucket[index];</span><br><span class="line">            <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            prev.next = head;</span><br><span class="line">            <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (head.key == key) &#123;</span><br><span class="line">                    head.val = value;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = head;</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev.next = <span class="keyword">new</span> <span class="title class_">Node</span>(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> key % size;</span><br><span class="line">        <span class="keyword">if</span> (bucket[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> bucket[index];</span><br><span class="line">            <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (head.key == key) &#123;</span><br><span class="line">                    <span class="keyword">return</span> head.val;</span><br><span class="line">                &#125;</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the mapping of the specified value key if this map contains a mapping for the key */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> key % size;</span><br><span class="line">        <span class="keyword">if</span> (bucket[index] != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> bucket[index];</span><br><span class="line">            <span class="keyword">if</span> (head.key == key) &#123;</span><br><span class="line">                bucket[index] = head.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> head;</span><br><span class="line">                head = head.next;</span><br><span class="line">                <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (head.key == key) &#123;</span><br><span class="line">                        prev.next = head.next;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    prev = head;</span><br><span class="line">                    head = head.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyHashMap object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyHashMap obj = new MyHashMap();</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.remove(key);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="708-insert-into-a-cyclic-sorted-list"><a href="#708-insert-into-a-cyclic-sorted-list" class="headerlink" title="708. insert-into-a-cyclic-sorted-list"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/insert-into-a-cyclic-sorted-list/">708. insert-into-a-cyclic-sorted-list</a></h4><ul>
<li>给一个环状链表的任意一个节点，这个链表是从小到大有序的，插入一个新节点，返回原本给的那个节点。若一开始为null，则返回新插入的节点。</li>
<li>方法一：各种条件判断，边缘情况讨论，各种if，没有成功。</li>
<li>方法二：先走一波找到最大的节点，即给的节点开始往后走，一旦当前节点比后续节点大了就说明拐点到了。暂时将最大节点与后续节点断开，后续节点就是最小节点，在它之前插入一个dummy节点，以方便插入，然后从dummy开始往后一个个看，一旦当前节点不比要插入的节点小了，就是插入位置了，或者一直到最后都没找到插入点，就插在末尾。最后再把最大节点接回最小节点即可，注意需要判断最大节点有没有变化，即看看之前的那个「最大节点」后面是否为null。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">insert</span><span class="params">(Node head, <span class="type">int</span> insertVal)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(insertVal, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            head = newNode;</span><br><span class="line">            head.next = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. 找到最大的节点，变成单向链表</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (curr.next != head &amp;&amp; curr.val &lt;= curr.next.val) &#123;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 将最大节点断开，从dummy开始往后找插入点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">maxNode</span> <span class="operator">=</span> curr, dummy = <span class="keyword">new</span> <span class="title class_">Node</span>(Integer.MIN_VALUE, curr.next);</span><br><span class="line">        maxNode.next = <span class="literal">null</span>;    <span class="comment">// 最大之后就是最小的了，断开</span></span><br><span class="line">        curr = dummy;           <span class="comment">// dummy之后就是最小节点</span></span><br><span class="line">        <span class="keyword">while</span> (curr.next != <span class="literal">null</span> &amp;&amp; curr.next.val &lt; insertVal) &#123;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        newNode.next = curr.next;</span><br><span class="line">        curr.next = newNode;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newMax</span> <span class="operator">=</span> maxNode.next == <span class="literal">null</span> ? maxNode : maxNode.next;</span><br><span class="line">        newMax.next = dummy.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="709-to-lower-case"><a href="#709-to-lower-case" class="headerlink" title="709. to-lower-case"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/to-lower-case/">709. to-lower-case</a></h4><ul>
<li>实现转化成小写的函数。pass。</li>
</ul>
<h4 id="711-number-of-distinct-islands-ii"><a href="#711-number-of-distinct-islands-ii" class="headerlink" title="711. number-of-distinct-islands-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/number-of-distinct-islands-ii/description/">711. number-of-distinct-islands-ii</a></h4><ul>
<li>给一个二维grid表示小岛，求其中形状distinct的小岛数量。这些形状可以任意平移、轴对称、翻转。</li>
<li>暴力方法，遍历完一个小岛的时候就将所有的轴对称、翻转形式统统列出来，然后根据某个统一标准取一个root form来代表所有这些形状，这里就直接使用encode之后字典序最小的作为key。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="type">int</span>[][] directions = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="type">int</span>[][] transitions = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDistinctIslands2</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rowTotal</span> <span class="operator">=</span> grid.length, colTotal = grid[<span class="number">0</span>].length;</span><br><span class="line">        Set&lt;String&gt; islandSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rowTotal; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; colTotal; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    List&lt;<span class="type">int</span>[]&gt; island = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                    dfs(grid, i, j, island);</span><br><span class="line">                    islandSet.add(getRootShape(island));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> islandSet.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> row, <span class="type">int</span> col, List&lt;<span class="type">int</span>[]&gt; island)</span> &#123;</span><br><span class="line">        island.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;row, col&#125;);</span><br><span class="line">        grid[row][col] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] direction : directions) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rowNeighbor</span> <span class="operator">=</span> row + direction[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">colNeighbor</span> <span class="operator">=</span> col + direction[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (validatePos(grid, rowNeighbor, colNeighbor)) &#123;</span><br><span class="line">                dfs(grid, rowNeighbor, colNeighbor, island);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">validatePos</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> row &gt;= <span class="number">0</span> &amp;&amp; row &lt; grid.length &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; grid[<span class="number">0</span>].length &amp;&amp; grid[row][col] == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getRootShape</span><span class="params">(List&lt;<span class="type">int</span>[]&gt; island)</span> &#123;</span><br><span class="line">        List&lt;String&gt; shapes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 对于shape中的一个点，总共有八种形式</span></span><br><span class="line">        <span class="comment">// (x, y), (x, -y), (-x, y), (-x, -y)</span></span><br><span class="line">        <span class="comment">// (y, x), (-y, x), (y, -x), (-y, -x)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] transition : transitions) &#123;</span><br><span class="line">            List&lt;<span class="type">int</span>[]&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            List&lt;<span class="type">int</span>[]&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] point : island) &#123;</span><br><span class="line">                list1.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;point[<span class="number">0</span>] * transition[<span class="number">0</span>], point[<span class="number">1</span>] * transition[<span class="number">1</span>]&#125;);</span><br><span class="line">                list2.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;point[<span class="number">1</span>] * transition[<span class="number">1</span>], point[<span class="number">0</span>] * transition[<span class="number">0</span>]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            shapes.add(getKey(list1));  <span class="comment">// 获取每个方向上的root encode形式</span></span><br><span class="line">            shapes.add(getKey(list2));</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(shapes);       <span class="comment">// 用最小的代表所有这些shape</span></span><br><span class="line">        <span class="keyword">return</span> shapes.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getKey</span><span class="params">(List&lt;<span class="type">int</span>[]&gt; points)</span> &#123;</span><br><span class="line">        Collections.sort(points, (a, b) -&gt; a[<span class="number">0</span>] != b[<span class="number">0</span>] ? a[<span class="number">0</span>] - b[<span class="number">0</span>] : a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> points.get(<span class="number">0</span>)[<span class="number">0</span>], col = points.get(<span class="number">0</span>)[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] point : points) &#123;</span><br><span class="line">            <span class="comment">// 注意是与最小的那个点的delta作为坐标，即相对坐标</span></span><br><span class="line">            sb.append(point[<span class="number">0</span>] - row).append(<span class="string">&#x27;,&#x27;</span>).append(point[<span class="number">1</span>] - col).append(<span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="712-minimum-ascii-delete-sum-for-two-strings"><a href="#712-minimum-ascii-delete-sum-for-two-strings" class="headerlink" title="712. minimum-ascii-delete-sum-for-two-strings"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/">712. minimum-ascii-delete-sum-for-two-strings</a></h4><ul>
<li>给两个字符串，需要删除适当的字符使得他们相等，求最小的所有被删除字符的ascii之和。</li>
<li>每个字符是否保留都是独立的决策，因此考虑DP。<code>dp[i][j]</code>表示<code>s1[i]</code>到末尾、<code>s2[j]</code>到末尾的需要被删字符的最小ascii之和。如果其中一个字符串为空，显然ascii之和就是非空字符串各个字符从后往前累加，最后<code>dp[0][0]</code>即为所求。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumDeleteSum</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1 == <span class="literal">null</span> || s2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s1.length() + <span class="number">1</span>][s2.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s1.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            dp[i][s2.length()] = dp[i + <span class="number">1</span>][s2.length()] + s1.codePointAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> s2.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            dp[s1.length()][j] = dp[s1.length()][j + <span class="number">1</span>] + s2.codePointAt(j);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s1.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> s2.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s1.charAt(i) == s2.charAt(j)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j + <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i + <span class="number">1</span>][j] + s1.codePointAt(i), dp[i][j + <span class="number">1</span>] + s2.codePointAt(j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="713-subarray-product-less-than-k"><a href="#713-subarray-product-less-than-k" class="headerlink" title="713. subarray-product-less-than-k"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/subarray-product-less-than-k/">713. subarray-product-less-than-k</a></h4><ul>
<li>给一个正整数数组，和一个k，求有多少个子数组的积小于k。</li>
<li>滑动窗口，一旦发现当前积大于k就挪动左指针，直到小于。此时左右指针中间的即为valid的子数组。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSubarrayProductLessThanK</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span> || k &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, product = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; nums.length; right++) &#123;</span><br><span class="line">            product *= nums[right];</span><br><span class="line">            <span class="keyword">while</span> (product &gt;= k) &#123;</span><br><span class="line">                product /= nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">            ans += right - left + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="714-best-time-to-buy-and-sell-stock-with-transaction-fee"><a href="#714-best-time-to-buy-and-sell-stock-with-transaction-fee" class="headerlink" title="714. best-time-to-buy-and-sell-stock-with-transaction-fee"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/">714. best-time-to-buy-and-sell-stock-with-transaction-fee</a></h4><ul>
<li>给一个数组表示股票价格，每次交易（买卖完成算一次）都会收取手续费。求最大收益。</li>
<li>（思路来自覃超说算法）DP。<code>profit[i][0]</code>表示第i天<strong>不持有</strong>股票手头的资金，<code>profit[i][1]</code>表示第i天<strong>持有</strong>股票手头的资金.初始化时第一天如果不持有股票则手头为0，若持有股票则需要消耗资金，因此是<code>-price[0]</code>。之后的状态转换为<code>profit[i][0] = profit[i - 1][0]（前一天也没有买入）和profit[i - 1][1] + prices[i]（前一天是持有的，今天卖出）的较大者</code>。类似地，<code>profit[i][1] = profit[i - 1][1]（前一天也持有）和profit[i - 1][0] - prices[i]（前一天没有，今天买入）的较大者</code>。最后返回最后一天不持有股票的profit即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices, <span class="type">int</span> fee)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="literal">null</span> || prices.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] profit = <span class="keyword">new</span> <span class="title class_">int</span> [prices.length][<span class="number">2</span>];</span><br><span class="line">        profit[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        profit[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; profit.length; i++) &#123;</span><br><span class="line">            profit[i][<span class="number">0</span>] = Math.max(profit[i - <span class="number">1</span>][<span class="number">0</span>], profit[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i] - fee);</span><br><span class="line">            profit[i][<span class="number">1</span>] = Math.max(profit[i - <span class="number">1</span>][<span class="number">1</span>], profit[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit[prices.length - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="716-max-stack"><a href="#716-max-stack" class="headerlink" title="716. max-stack"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/max-stack/">716. max-stack</a></h4><ul>
<li>实现一个maxStack类，支持普通栈的pop, top，还有peekMax, popMax操作。</li>
<li>方法一：maxStack经典做法就是双栈，一个作为普通stack，一个记录以对应元素为栈顶时的最大元素。tricky的时popMax时需要暂时将普通栈的元素转存到另一个栈中，直到找到当前max元素，pop掉之后，再push回去，这样时间复杂度为<code>O(N)</code>，其中N为操作数。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MaxStack</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack, maxStack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MaxStack</span><span class="params">()</span> &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        maxStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stack.add(x);</span><br><span class="line">        maxStack.add(maxStack.isEmpty() ? x : Math.max(x, maxStack.peek()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        maxStack.pop();</span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peekMax</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> maxStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">popMax</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">currMax</span> <span class="operator">=</span> <span class="built_in">this</span>.peekMax();</span><br><span class="line">        Stack&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (stack.peek() != currMax) &#123;</span><br><span class="line">            temp.add(<span class="built_in">this</span>.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.pop();</span><br><span class="line">        <span class="keyword">while</span> (!temp.isEmpty()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.push(temp.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currMax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：如果希望提升peekMax的速度到logN（其他O(1)的操作可以降速），就需要思考如何提升删除元素的速度了。在LRU中我们学习过double linked list可以在给定node时O(1)删除元素，因此可以用来作为stack本体。至于max，就可以考虑tree结构来维护最大堆value -&gt; node，由于stack中可以重复出现元素，对于每一个value需要维护一个node的list，在list后面的就是后插入的，也就是需要先行挪出的。这样所有操作的时间复杂度都是<code>O(logN)</code>（因为涉及treeMap的查询）</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MaxStack</span> &#123;</span><br><span class="line">    </span><br><span class="line">    DoubleLinkedList doubleLinkedList;</span><br><span class="line">    TreeMap&lt;Integer, LinkedList&lt;Node&gt;&gt; treeMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MaxStack</span><span class="params">()</span> &#123;</span><br><span class="line">        doubleLinkedList = <span class="keyword">new</span> <span class="title class_">DoubleLinkedList</span>();</span><br><span class="line">        treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(Collections.reverseOrder());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        treeMap.putIfAbsent(x, <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Node&gt;());</span><br><span class="line">        treeMap.get(x).offer(doubleLinkedList.insert(x));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> doubleLinkedList.pop();</span><br><span class="line">        treeMap.get(val).pollLast();</span><br><span class="line">        <span class="keyword">if</span> (treeMap.get(val).size() == <span class="number">0</span>) &#123;</span><br><span class="line">            treeMap.remove(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> doubleLinkedList.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peekMax</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> treeMap.firstKey();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">popMax</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">maxNode</span> <span class="operator">=</span> treeMap.firstEntry().getValue().pollLast();</span><br><span class="line">        <span class="keyword">if</span> (treeMap.get(maxNode.val).size() == <span class="number">0</span>) &#123;</span><br><span class="line">            treeMap.remove(maxNode.val);</span><br><span class="line">        &#125;</span><br><span class="line">        doubleLinkedList.delete(maxNode);</span><br><span class="line">        <span class="keyword">return</span> maxNode.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    Node prev, next;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        prev = next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubleLinkedList</span> &#123;</span><br><span class="line">    Node head, tail;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DoubleLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">insert</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(val);</span><br><span class="line">        node.prev = tail.prev;</span><br><span class="line">        node.next = tail;</span><br><span class="line">        tail.prev.next = node;</span><br><span class="line">        tail.prev = node;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">delete</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> delete(tail.prev).val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tail.prev.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="717-1-bit-and-2-bit-characters"><a href="#717-1-bit-and-2-bit-characters" class="headerlink" title="717. 1-bit-and-2-bit-characters"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/1-bit-and-2-bit-characters/">717. 1-bit-and-2-bit-characters</a></h4><ul>
<li>给一个只含有0、1的int数组，读取时只可以读成<code>0</code>或<code>11</code>或<code>10</code>。判断最后一个数字是否必须是1-bit.</li>
<li>贪心即可。每次向后挪动，碰到0挪动1位、碰到1挪动2位，最后看看停留的索引即可。pass。</li>
</ul>
<h4 id="718-maximum-length-of-repeated-subarray"><a href="#718-maximum-length-of-repeated-subarray" class="headerlink" title="718. maximum-length-of-repeated-subarray"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-length-of-repeated-subarray/">718. maximum-length-of-repeated-subarray</a></h4><ul>
<li>给两个int数组，求其中相同的subarray的最大长度。</li>
<li>DP，<code>dp[i][j]</code>表示<code>A[0, i)</code>和<code>B[0, j)</code>的相同subarray的最大长度。如果两个元素相同，则以当前元素结尾的子数组长度取决于以前一个元素结尾的长度。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLength</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span>[] B)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || B == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[A.length + <span class="number">1</span>][B.length + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">retVal</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= A.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= B.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i - <span class="number">1</span>] == B[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                retVal = Math.max(retVal, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="719-find-k-th-smallest-pair-distance"><a href="#719-find-k-th-smallest-pair-distance" class="headerlink" title="719. find-k-th-smallest-pair-distance"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-k-th-smallest-pair-distance/description/">719. find-k-th-smallest-pair-distance</a></h4><ul>
<li>给一个int数组，求每两个数之差中第k小的值。例如<code>[1,3,8,4,5,45]</code>，当k &#x3D; 1，返回1，当k &#x3D; 3，返回2.</li>
<li>先对所有元素从小到大排序，那么间距最小值为0、最大值为最右减最左。用二分查找的思想，假设mid为第k小的值，然后O(N^2)遍历求有多少对儿数之差小于mid；若对儿数小于k，说明猜的值太小了排太前了；大于k则说明猜太大了。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">smallestDistancePair</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">0</span>, hi = nums[nums.length - <span class="number">1</span>] - nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo + (hi - lo) / <span class="number">2</span>;   <span class="comment">// 猜一个距离</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">1</span>; right &lt; nums.length; right++) &#123;</span><br><span class="line">                <span class="keyword">while</span> (nums[right] - nums[left] &gt; mid) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                count += right - left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count &lt; k) &#123;        <span class="comment">// 说明猜的不够大</span></span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hi = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="720-longest-word-in-dictionary"><a href="#720-longest-word-in-dictionary" class="headerlink" title="720. longest-word-in-dictionary"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-word-in-dictionary/description/">720. longest-word-in-dictionary</a></h4><ul>
<li>给一个string数组，只含有小写字母，这些word可能形成链式如<code>a, ap, app, appl, apple</code>，求能形成链式的最长的单词，若有多个则取lexicographical最小的。</li>
<li>用sort + Set的方式比较trivial。还有<a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-word-in-dictionary/discuss/109113/Java-Solution-with-Trie-+-BFS">一种Trie + DFS&#x2F;BFS的</a>更考察基本功，构建trie之后从root节点开始尝试从后往前遍历邻接点并更新最长word，这样就可以保证是lexicograpchical最小的了。</li>
</ul>
<h4 id="721-accounts-merge"><a href="#721-accounts-merge" class="headerlink" title="721. accounts-merge"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/accounts-merge/description/">721. accounts-merge</a></h4><ul>
<li>给一堆字符串List，每个List中首先是名字，然后是这个人的各种邮箱。最后放回经过merge的姓名、邮箱List，并且要求将邮箱从小到大排序。</li>
<li>这种多对一的关系查找，特别适合用并查集。首先将每个邮箱的parent设为自己，然后将每个List靠后面的邮箱统一把parent设成第一个邮箱。然后利用TreeSet实现邮箱的排序，最后导出到List返回。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">accountsMerge</span><span class="params">(List&lt;List&lt;String&gt;&gt; accounts)</span> &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (accounts == <span class="literal">null</span> || accounts.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化并查集，并存放每个email的主人</span></span><br><span class="line">        Map&lt;String, String&gt; parent = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;String, String&gt; emailOwner = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; account : accounts) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; account.size(); i++) &#123;</span><br><span class="line">                parent.put(account.get(i), account.get(i));     <span class="comment">// 老大初始化为自己</span></span><br><span class="line">                emailOwner.put(account.get(i), account.get(<span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将同一个人的邮箱存入并查集map</span></span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; account : accounts) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">root</span> <span class="operator">=</span> find(parent, account.get(<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; account.size(); i++) &#123;</span><br><span class="line">                parent.put(find(parent, account.get(i)), root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将同属一个老大的email存入TreeSet以排序</span></span><br><span class="line">        Map&lt;String, Set&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; account : accounts) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">root</span> <span class="operator">=</span> find(parent, account.get(<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(root)) &#123;</span><br><span class="line">                map.put(root, <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;String&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; account.size(); i++) &#123;</span><br><span class="line">                map.get(root).add(account.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 最后导出到List中返回</span></span><br><span class="line">        <span class="keyword">for</span> (String email : map.keySet()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">owner</span> <span class="operator">=</span> emailOwner.get(email);</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(map.get(email));</span><br><span class="line">            list.add(<span class="number">0</span>, owner);</span><br><span class="line">            ans.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">find</span><span class="params">(Map&lt;String, String&gt; parent, String s)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!parent.get(s).equals(s)) &#123;</span><br><span class="line">            parent.put(s, parent.get(parent.get(s)));   <span class="comment">// 将当前的parent设为&quot;parent的parent&quot;</span></span><br><span class="line">            s = parent.get(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>其实更直白的看，这题就是个图论题，整理出图的联通部分。首先是构建graph，每个邮箱都是节点，用Set存每一行所给邮箱组成的subgraph，每个邮箱都用Set存放可达邻居（需要双向添加）。然后开始DFS或BFS搜索图，将每一行的第一个邮箱作为起点，把所有可达的邮箱都加进来，在这个过程中需要标记visited。之后如果再遇到visited的邮箱就说明已经在之前“可达”掉了。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">accountsMerge</span><span class="params">(List&lt;List&lt;String&gt;&gt; accounts)</span> &#123;</span><br><span class="line">        <span class="comment">// build the graph</span></span><br><span class="line">        Map&lt;String,Set&lt;String&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; ls : accounts) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; ls.size();i ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!graph.containsKey(ls.get(i))) graph.put(ls.get(i), <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;());</span><br><span class="line">                graph.get(ls.get(i)).add(ls.get(<span class="number">1</span>));</span><br><span class="line">                graph.get(ls.get(<span class="number">1</span>)).add(ls.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// traverse the graph, find out all the connected subgraph</span></span><br><span class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; ls : accounts) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited.contains(ls.get(<span class="number">1</span>))) &#123;</span><br><span class="line">                List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                bfs(graph, visited, ls.get(<span class="number">1</span>), ans); <span class="comment">// or dfs(graph,visited,ls.get(1),ans)</span></span><br><span class="line">                Collections.sort(ans);</span><br><span class="line">                ans.add(<span class="number">0</span>,ls.get(<span class="number">0</span>));</span><br><span class="line">                result.add(ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Map&lt;String, Set&lt;String&gt;&gt; graph, Set&lt;String&gt; visited, String s, List&lt;String&gt; ans)</span> &#123;</span><br><span class="line">        ans.add(s);</span><br><span class="line">        visited.add(s);</span><br><span class="line">        <span class="keyword">for</span> (String str : graph.get(s)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited.contains(str)) &#123;</span><br><span class="line">                dfs(graph, visited, str, ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(Map&lt;String, Set&lt;String&gt;&gt; graph, Set&lt;String&gt; visited, String s, List&lt;String&gt; ans)</span> &#123;</span><br><span class="line">        Queue&lt;String&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.add(s);</span><br><span class="line">        visited.add(s);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">t</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            ans.add(t);</span><br><span class="line">            <span class="keyword">for</span> (String str : graph.get(t)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited.contains(str)) &#123;</span><br><span class="line">                    q.add(str);</span><br><span class="line">                    visited.add(str);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="722-remove-comments"><a href="#722-remove-comments" class="headerlink" title="722. remove-comments"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-comments/description/">722. remove-comments</a></h4><ul>
<li>给一个string数组，每一个string代表一行C++代码，要求将其中的comment清除。可以保证这些comment不会存在于字符串中。</li>
<li>没什么意思。用一个inComment布尔值存放当前是否在注释块中。遍历每行代码的时候若仍在注释块中则关注<code>*/</code>；正常状态下则先关注是否是<code>//</code>，这样后续就不用继续append了，否则关注<code>/*</code>。</li>
</ul>
<h4 id="723-candy-crush"><a href="#723-candy-crush" class="headerlink" title="723. candy-crush"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/candy-crush/">723. candy-crush</a></h4><ul>
<li>模拟candy crush小游戏，给一个初始的board。若水平或者垂直方向连续三个相同的int，则需要消掉并将上面的数字往下填充，最顶上如果掉下了则补充0表示空。</li>
<li>其实主要就是模拟这个过程。如果监测到水平&#x2F;垂直连续三个相同绝对值的int，则将这三个标记为负。最终再从下往上将负的值用更上面的正值覆盖。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] candyCrush(<span class="type">int</span>[][] board) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="literal">null</span> || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> board;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rowCount</span> <span class="operator">=</span> board.length, colCount = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">shouldCrush</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (shouldCrush) &#123;</span><br><span class="line">            shouldCrush = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rowCount; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; colCount; j++) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> Math.abs(board[i][j]);</span><br><span class="line">                    <span class="keyword">if</span> (val == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (j + <span class="number">2</span> &lt; colCount &amp;&amp;</span><br><span class="line">                        Math.abs(board[i][j + <span class="number">1</span>]) == val &amp;&amp;</span><br><span class="line">                        Math.abs(board[i][j + <span class="number">2</span>]) == val) &#123;</span><br><span class="line">                        shouldCrush = <span class="literal">true</span>;</span><br><span class="line">                        board[i][j] = -val;</span><br><span class="line">                        board[i][j + <span class="number">1</span>] = -val;</span><br><span class="line">                        board[i][j + <span class="number">2</span>] = -val;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (i + <span class="number">2</span> &lt; rowCount &amp;&amp;</span><br><span class="line">                        Math.abs(board[i + <span class="number">1</span>][j]) == val &amp;&amp;</span><br><span class="line">                        Math.abs(board[i + <span class="number">2</span>][j]) == val) &#123;</span><br><span class="line">                        shouldCrush = <span class="literal">true</span>;</span><br><span class="line">                        board[i][j] = -val;</span><br><span class="line">                        board[i + <span class="number">1</span>][j] = -val;</span><br><span class="line">                        board[i + <span class="number">2</span>][j] = -val;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (shouldCrush) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; colCount; j++) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">lowerIndex</span> <span class="operator">=</span> rowCount - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lowerIndex; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (board[i][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            board[lowerIndex--][j] = board[i][j];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (lowerIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        board[lowerIndex--][j] = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> board;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="724-find-pivot-index"><a href="#724-find-pivot-index" class="headerlink" title="724. find-pivot-index"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-pivot-index/description/">724. find-pivot-index</a></h4><ul>
<li>给一个int数组，求其中一个index使得左侧数字之和与右侧数字之和相等。zillow面试原题，维护leftSum和rightSum即可。</li>
</ul>
<h4 id="726-number-of-atoms"><a href="#726-number-of-atoms" class="headerlink" title="726. number-of-atoms"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/number-of-atoms/description/">726. number-of-atoms</a></h4><ul>
<li>给一个字符串表示化学物质，统计其中的元素及出现次数，按字典序输出。例如<code>H2(O(Mn)2)3</code>输出<code>H2Mn6O3</code>.</li>
<li>只有1个元素是输出1还是不输出？（不输出数字，只输出元素）</li>
<li>由于含有括号，联想运算符算式就知道要用Stack进行吞吐来处理括号嵌套的情况。如果是字母，就一直找到小写的为止作为元素名字，之后跟着的数字就是count，存入map。若出现左括号，则当前的这个map（保存了括号之前的元素及count）直接入栈，然后用新的map继续统计，一旦遇到右括号，说明当前部分结束(注意需要检查右括号之后还有没有数字)，则与栈顶弹出的map合并一下就好了。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">countOfAtoms</span><span class="params">(String formula)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (formula == <span class="literal">null</span> || formula.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;Map&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span>[] fChar = formula.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, fLen = fChar.length;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; fLen) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fChar[i] == <span class="string">&#x27;(&#x27;</span>) &#123;  <span class="comment">// 将之前的map压栈</span></span><br><span class="line">                stack.push(map);    </span><br><span class="line">                map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fChar[i] == <span class="string">&#x27;)&#x27;</span>) &#123;   <span class="comment">// 将当前的合并入之前的map</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="comment">// 取括号后的数值</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; fLen &amp;&amp; Character.isDigit(fChar[i])) &#123;</span><br><span class="line">                    count = (<span class="number">10</span> * count) + fChar[i++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                    count = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                    Map&lt;String, Integer&gt; prevMap = stack.pop();</span><br><span class="line">                    <span class="keyword">for</span> (String atom: map.keySet()) &#123;   <span class="comment">// 取当前map中的atom放入之前的</span></span><br><span class="line">                        prevMap.put(atom, prevMap.getOrDefault(atom, <span class="number">0</span>) + map.get(atom) * count);</span><br><span class="line">                    &#125;</span><br><span class="line">                    map = prevMap;  <span class="comment">// 用回原来的map</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 以字母开头，直到非小写字母为一个原子</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (end &lt; fLen &amp;&amp; Character.isLowerCase(fChar[end])) &#123;</span><br><span class="line">                    end++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">String</span> <span class="variable">atom</span> <span class="operator">=</span> formula.substring(i, end);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 看看字母之后是否跟着数字</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (end &lt; fLen &amp;&amp; Character.isDigit(fChar[end])) &#123;</span><br><span class="line">                    count = <span class="number">10</span> * count + fChar[end++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                    count = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 更新原子数值 </span></span><br><span class="line">                map.put(atom, map.getOrDefault(atom, <span class="number">0</span>) + count);</span><br><span class="line">                i = end;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        List&lt;String&gt; atoms = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(map.keySet());</span><br><span class="line">        Collections.sort(atoms);    <span class="comment">// 字母顺序</span></span><br><span class="line">        <span class="keyword">for</span> (String atom: atoms) &#123;</span><br><span class="line">            sb.append(atom);</span><br><span class="line">            <span class="keyword">if</span> (map.get(atom) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                sb.append(map.get(atom));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="727-minimum-window-subsequence"><a href="#727-minimum-window-subsequence" class="headerlink" title="727. minimum-window-subsequence"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-window-subsequence/description/">727. minimum-window-subsequence</a></h4><ul>
<li>给一个source字符串和一个target字符串，求在source的最短子串使得包含target的所有字符（个数和出现顺序都必须一致）。</li>
<li>DP（感觉是野路子，不太好想）。。。纵向行为target，横向列为source，第一行全部初始化为<code>0,1,2....sLen</code>表示从第几位开始取，之后所有值初始化为-1表示无解。然后O(M*N)逐个字符遍历两个字符串，若匹配上了则从左上方取起始位置（看前一个字符的情况），若匹配不上则默认继续取source（直接取左侧的值）。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String S, String T)</span> &#123;</span><br><span class="line">        <span class="comment">// 动态规划, 行为tLen + 1, 列为sLen + 1, dp[][]表示从dp[i][j]到j到这部分字符串是所求，</span></span><br><span class="line">        <span class="comment">// 即T[0, j)是S[0, i)的subsequence with substring S[dp[i][j], j).</span></span><br><span class="line">        <span class="comment">// 初始状态为</span></span><br><span class="line">        <span class="comment">// 状态转换为，若当前字符不匹配，则根据左侧（即S前一个字符）情况决定起始位置（保证最短）</span></span><br><span class="line">        <span class="comment">// 若匹配，则依赖于左上方的结果，即T前一个字符的起始位置。</span></span><br><span class="line">        <span class="keyword">if</span> (S == <span class="literal">null</span> || T == <span class="literal">null</span> || S.length() == <span class="number">0</span> || T.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] sChar = S.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] tChar = T.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sLen</span> <span class="operator">=</span> sChar.length, tLen = tChar.length;</span><br><span class="line">        <span class="type">int</span>[][] startFrom = <span class="keyword">new</span> <span class="title class_">int</span> [tLen + <span class="number">1</span>][sLen + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= tLen; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= sLen; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    startFrom[i][j] = j;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    startFrom[i][j] = -<span class="number">1</span>;   <span class="comment">// -1表示无解</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= tLen; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= sLen; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sChar[j - <span class="number">1</span>] == tChar[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    startFrom[i][j] = startFrom[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    startFrom[i][j] = startFrom[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, end = sLen, minLen = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= sLen; j++) &#123;</span><br><span class="line">            System.out.print(startFrom[tLen][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (startFrom[tLen][j] != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">currLen</span> <span class="operator">=</span> j - startFrom[tLen][j];</span><br><span class="line">                <span class="keyword">if</span> (currLen &lt; minLen) &#123;</span><br><span class="line">                    start = startFrom[tLen][j];</span><br><span class="line">                    end = j;</span><br><span class="line">                    minLen = currLen;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minLen == Integer.MAX_VALUE? <span class="string">&quot;&quot;</span> : S.substring(start, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="729-my-calendar-i"><a href="#729-my-calendar-i" class="headerlink" title="729. my-calendar-i"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/my-calendar-i/description/">729. my-calendar-i</a></h4><ul>
<li>给若干开始时间+结束时间pair，实现book函数判断能否成功添加事件，不能有时间重叠。</li>
<li>方法一：暴力法，从头到尾遍历链表，无冲突就插入。效率O(N)。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCalendar</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个链表，每次遍历所有节点判断有没有重合，没有就插入到末尾</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> start;</span><br><span class="line">        <span class="type">int</span> end;</span><br><span class="line">        Node next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.start = start;</span><br><span class="line">            <span class="built_in">this</span>.end = end;</span><br><span class="line">            next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCalendar</span><span class="params">()</span> &#123;</span><br><span class="line">        head = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">book</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            head = <span class="keyword">new</span> <span class="title class_">Node</span>(start, end);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> checkAndAdd(<span class="keyword">new</span> <span class="title class_">Node</span>(start, end));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// brute force: check with every existing intervals and insert at the end</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkAndAdd</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.end &gt; curr.start &amp;&amp; node.start &lt; curr.end) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev = curr;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        prev.next = node;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：利用TreeMap，对于每个[start, end]对，从TreeMap中找start的floor，取出它对应的end。一旦这个end大于start，就说明有重叠了。同理，也要从TreeMap中找start的ceiling，如果这个ceiling小于end，说明与后面有重叠。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCalendar</span> &#123;</span><br><span class="line">    <span class="comment">// 维护start-end的TreeMap，每次尝试取输入的start的在TreeeMap中的下界和上界</span></span><br><span class="line">    <span class="comment">// 分别判断输入的start是否在最大的不大于start的floorStart对应的end之间，</span></span><br><span class="line">    <span class="comment">// 再判断最小的不小于start的ceilingStart会不会落在end之前</span></span><br><span class="line">    TreeMap&lt;Integer, Integer&gt; calendar;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCalendar</span><span class="params">()</span> &#123;</span><br><span class="line">        calendar = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">book</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="comment">// floorStart, start, floorStart&#x27;sEnd</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">floorStart</span> <span class="operator">=</span> calendar.floorKey(start);</span><br><span class="line">        <span class="keyword">if</span> (floorStart != <span class="literal">null</span> &amp;&amp; calendar.get(floorStart) &gt; start) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// start, ceilingStart, end</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">ceilingStart</span> <span class="operator">=</span> calendar.ceilingKey(start);</span><br><span class="line">        <span class="keyword">if</span> (ceilingStart != <span class="literal">null</span> &amp;&amp; ceilingStart &lt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        calendar.put(start, end);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="731-my-calendar-ii"><a href="#731-my-calendar-ii" class="headerlink" title="731. my-calendar-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/my-calendar-ii/description/">731. my-calendar-ii</a></h4><ul>
<li>与729相比变成了不能出现triple的重叠就算是可以book。</li>
<li>注意不能简单地理解为一个interval同时与两个interval重叠，因为<code>[2,6]</code>和<code>[1,3]&amp;[5,7]</code>同时重叠，但没有形成triplet.</li>
<li>同样是维护TreeMap，对于每个新加入的interval，遍历已有的interval并把重叠的部分插入treemap。如果插入时发现有重叠，说明“重叠部分之间也有重叠”，这样就是triple了。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCalendarTwo</span> &#123;</span><br><span class="line">    <span class="comment">// 原本一位和之前相比就只是多了一个map，这个存不了就尝试另一个map，都不行就说明triple了。</span></span><br><span class="line">    <span class="comment">// 但题目给的样例都不行，例如最后一个25~55，因为这个overlap分别和两个map里都interval重叠，但是没有形成triple；</span></span><br><span class="line">    <span class="comment">// 正解应该是用一个list维护所有的interval，然后用treemap只维护当前重叠的部分，如果后续又出现了和list里的重叠，</span></span><br><span class="line">    <span class="comment">// 就再去treemap中看看有没有第三次重叠。</span></span><br><span class="line">    <span class="comment">// 注意每次遍历都需要清空TreeMap，因为我在遍历List的时候只关心新加入的这个会不会和别的重叠。</span></span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; intervals;</span><br><span class="line">    TreeMap&lt;Integer, Integer&gt; overlap;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCalendarTwo</span><span class="params">()</span> &#123;</span><br><span class="line">        intervals = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        overlap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">book</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        overlap.clear();</span><br><span class="line">        <span class="comment">// 遍历所有interval看看有没有重叠</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] interval: intervals) &#123;</span><br><span class="line">            <span class="keyword">if</span> (start &gt;= interval[<span class="number">0</span>] &amp;&amp; start &lt; interval[<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// interval:   ________</span></span><br><span class="line">                <span class="comment">// newInter:     _____...</span></span><br><span class="line">                <span class="keyword">if</span> (!addOverlap(start, Math.min(end, interval[<span class="number">1</span>]))) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end &gt; interval[<span class="number">0</span>] &amp;&amp; start &lt; interval[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="comment">// interval:   ________</span></span><br><span class="line">                <span class="comment">// newInter:  ______...</span></span><br><span class="line">                <span class="keyword">if</span> (!addOverlap(interval[<span class="number">0</span>], Math.min(end, interval[<span class="number">1</span>]))) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        intervals.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;start, end&#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addOverlap</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">floorStart</span> <span class="operator">=</span> overlap.floorKey(start);</span><br><span class="line">        <span class="keyword">if</span> (floorStart != <span class="literal">null</span> &amp;&amp; overlap.get(floorStart) &gt; start) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">ceilingStart</span> <span class="operator">=</span> overlap.ceilingKey(start);</span><br><span class="line">        <span class="keyword">if</span> (ceilingStart != <span class="literal">null</span> &amp;&amp; ceilingStart &lt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        overlap.put(start, end);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="733-flood-fill"><a href="#733-flood-fill" class="headerlink" title="733. flood-fill"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/flood-fill/description/">733. flood-fill</a></h4><ul>
<li>给一个二维int数组，其中包含0-65535的值。给定坐标i，j，和一个newColor，将该cell周围和它值相等的cell都赋值为newColor.</li>
<li>DFS，直接赋值。需要注意如果原色和newColor相等就直接返回了，否则会stack overflow。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] floodFill(<span class="type">int</span>[][] image, <span class="type">int</span> sr, <span class="type">int</span> sc, <span class="type">int</span> newColor) &#123;</span><br><span class="line">        <span class="keyword">if</span> (image == <span class="literal">null</span> || image.length == <span class="number">0</span> || image[<span class="number">0</span>].length == <span class="number">0</span> || image[sr][sc] == newColor) &#123; <span class="comment">// warning!!</span></span><br><span class="line">            <span class="keyword">return</span> image;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(image, sr, sc, image[sr][sc], newColor);</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">(<span class="type">int</span>[][] image, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i &lt; <span class="number">0</span> || i &gt;= image.length || j &lt; <span class="number">0</span> || j &gt;= image[<span class="number">0</span>].length ? -<span class="number">1</span> : image[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] image, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> oldColor, <span class="type">int</span> newColor)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (getValue(image, i, j) != oldColor) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        image[i][j] = newColor;</span><br><span class="line">        dfs(image, i - <span class="number">1</span>, j, oldColor, newColor);</span><br><span class="line">        dfs(image, i + <span class="number">1</span>, j, oldColor, newColor);</span><br><span class="line">        dfs(image, i, j - <span class="number">1</span>, oldColor, newColor);</span><br><span class="line">        dfs(image, i, j + <span class="number">1</span>, oldColor, newColor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="734-sentence-similarity"><a href="#734-sentence-similarity" class="headerlink" title="734. sentence-similarity"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sentence-similarity/">734. sentence-similarity</a></h4><ul>
<li>给一堆同义词<code>[(&quot;restaurant&quot;, &quot;cafe&quot;), (&quot;ratings&quot;, &quot;reviews&quot;), ...]</code>，再给一些queries<code>[(&quot;restaurant ratings&quot;, &quot;cafe reviews&quot;), ...]</code>，要求返回每个query里的对应词是否都是synonym。同义词没有传递性。</li>
<li>直接把字符串作为key、对应的所有同义词的set作为value存入map，正反都放一次，比如<code>map.get(&quot;restaurant&quot;).add(&quot;cafe&quot;)), map.get(&quot;restaurant&quot;).add(&quot;cafe&quot;)</code>，这样在query的时候就可以直接调用了。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 维护一个总的map，每个单词作为key，对等的单词塞入它维护的Set中</span></span><br><span class="line"><span class="comment">// 有对称性所以需要正反都加</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">areSentencesSimilar</span><span class="params">(String[] words1, String[] words2, String[][] pairs)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (words1 == <span class="literal">null</span> || words2 == <span class="literal">null</span> || pairs == <span class="literal">null</span></span><br><span class="line">        || words1.length != words2.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Map&lt;String, Set&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pairs.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(pairs[i][<span class="number">0</span>])) &#123;</span><br><span class="line">            map.put(pairs[i][<span class="number">0</span>], <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(pairs[i][<span class="number">1</span>])) &#123;</span><br><span class="line">            map.put(pairs[i][<span class="number">1</span>], <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        map.get(pairs[i][<span class="number">0</span>]).add(pairs[i][<span class="number">1</span>]);  <span class="comment">// 构建a-&gt;b</span></span><br><span class="line">        map.get(pairs[i][<span class="number">1</span>]).add(pairs[i][<span class="number">0</span>]);  <span class="comment">// 构建b-&gt;a</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; words1.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (words1[i].equals(words2[i])) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (map.get(words1[i]) == <span class="literal">null</span> || !map.get(words1[i]).contains(words2[i])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="735-asteroid-collision"><a href="#735-asteroid-collision" class="headerlink" title="735. asteroid-collision"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/asteroid-collision/description/">735. asteroid-collision</a></h4><ul>
<li>给一个int数组，表示原子。正数向右移动，负数向左移动，可能会发生碰撞，如果绝对值相等则会抵消，否则绝对值更大的会把小的给干掉。求碰撞完后的数组。</li>
<li>直接用一个List，正数直接存，负数就需要与list中末尾的元素比较，如果是负就直接push，是正就需要比较看看谁更大。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] asteroidCollision(<span class="type">int</span>[] asteroids) &#123;</span><br><span class="line">        <span class="keyword">if</span> (asteroids == <span class="literal">null</span> || asteroids.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> asteroids;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> asteroid : asteroids) &#123;</span><br><span class="line">            <span class="keyword">if</span> (asteroid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">needAdd</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">while</span> (!list.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (list.get(list.size() - <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (-asteroid &gt; list.get(list.size() - <span class="number">1</span>)) &#123;</span><br><span class="line">                        list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (-asteroid == list.get(list.size() - <span class="number">1</span>)) &#123;</span><br><span class="line">                        list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">                        needAdd = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;   <span class="comment">// cancelled with each other</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        needAdd = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needAdd) &#123;</span><br><span class="line">                    list.add(asteroid);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                list.add(asteroid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ret = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ret.length; i++) &#123;</span><br><span class="line">            ret[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>更巧妙的做法是直接用一个数组模拟stack，然后用加法判断是否抵消。每次都强行取栈顶元素出来，如果没有被干掉就再放回去。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] asteroidCollision(<span class="type">int</span>[] asteroids) &#123;</span><br><span class="line">        <span class="keyword">if</span> (asteroids == <span class="literal">null</span> || asteroids.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> asteroids;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] stack = <span class="keyword">new</span> <span class="title class_">int</span>[asteroids.length + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        stack[<span class="number">0</span>] = -<span class="number">1</span>;  <span class="comment">// 第一个放负数placeholder让pop终止</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> asteroid : asteroids) &#123;</span><br><span class="line">            <span class="keyword">while</span> (stack[size - <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; asteroid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> asteroid + stack[size - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;      <span class="comment">// 负数被干掉了</span></span><br><span class="line">                    asteroid = stack[size - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">                    asteroid = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                size--;     <span class="comment">// 始终pop栈顶</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (asteroid != <span class="number">0</span>) &#123;</span><br><span class="line">                stack[size++] = asteroid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(stack, <span class="number">1</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="737-sentence-similarity-ii"><a href="#737-sentence-similarity-ii" class="headerlink" title="737. sentence-similarity-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sentence-similarity-ii/description/">737. sentence-similarity-ii</a></h4><ul>
<li>给一堆同义词<code>[(&quot;restaurant&quot;, &quot;cafe&quot;), (&quot;ratings&quot;, &quot;reviews&quot;), ...]</code>，再给一些queries<code>[(&quot;restaurant ratings&quot;, &quot;cafe reviews&quot;), ...]</code>，要求返回每个query里的对应词是否都是synonym。注意这些同义词具有传递性，<code>a=b, b=c -&gt; a=c</code>。</li>
<li>方法一：图论题，每个词都是一个节点，对于每个节点维护一个Set，通过DFS遍历所有可达的节点。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和前一个版本的区别是这个可以无限传递a=b=c=d...</span></span><br><span class="line"><span class="comment">// 还是map维护每个单词等价的单词，但匹配不上的话还得看它的set里所有单词对应的单词是否能匹配到</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">areSentencesSimilarTwo</span><span class="params">(String[] words1, String[] words2, String[][] pairs)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (words1 == <span class="literal">null</span> || words2 == <span class="literal">null</span> || pairs == <span class="literal">null</span></span><br><span class="line">        || words1.length != words2.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 表示每个单词直接相连的同义词</span></span><br><span class="line">    Map&lt;String, Set&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pairs.length; i++) &#123;        <span class="comment">// O(N)</span></span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(pairs[i][<span class="number">0</span>])) &#123;</span><br><span class="line">            map.put(pairs[i][<span class="number">0</span>], <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(pairs[i][<span class="number">1</span>])) &#123;</span><br><span class="line">            map.put(pairs[i][<span class="number">1</span>], <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        map.get(pairs[i][<span class="number">0</span>]).add(pairs[i][<span class="number">1</span>]);  <span class="comment">// 构建a-&gt;b</span></span><br><span class="line">        map.get(pairs[i][<span class="number">1</span>]).add(pairs[i][<span class="number">0</span>]);  <span class="comment">// 构建b-&gt;a</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; words1.length; i++) &#123;       <span class="comment">// O(N*N)</span></span><br><span class="line">        <span class="keyword">if</span> (words1[i].equals(words2[i])) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(words1[i])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!dfs(words1[i], words2[i], map, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(String start, String end, Map&lt;String, Set&lt;String&gt;&gt; map, Set&lt;String&gt; visited)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (map.get(start).contains(end)) &#123;     <span class="comment">// 终止条件：start连接着end</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visited.add(start);</span><br><span class="line">    Set&lt;String&gt; neighbors = map.get(start);</span><br><span class="line">    <span class="keyword">if</span> (neighbors == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (String neighbor : neighbors) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited.contains(neighbor) &amp;&amp; dfs(neighbor, end, map, visited)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：并查集，初始化时每个单词都是自己的root；然后根据同义词关系将前者的老大设为后者。判断句子是否同义时就找两个单词的老大是否相等即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并查集。初始化时每个单词都是自己的root；然后根据同义词关系将前者的老大设为后者。</span></span><br><span class="line"><span class="comment">// 判断句子是否同义时就找两个单词的老大是否相等即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">areSentencesSimilarTwo</span><span class="params">(String[] words1, String[] words2, String[][] pairs)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (words1.length != words2.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String[] pair : pairs) &#123;     <span class="comment">// 开始时每个老大都是自己</span></span><br><span class="line">        map.put(pair[<span class="number">0</span>], pair[<span class="number">0</span>]);</span><br><span class="line">        map.put(pair[<span class="number">1</span>], pair[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (String[] pair : pairs) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">par1</span> <span class="operator">=</span> findParent(pair[<span class="number">0</span>], map);</span><br><span class="line">        <span class="type">String</span> <span class="variable">par2</span> <span class="operator">=</span> findParent(pair[<span class="number">1</span>], map);</span><br><span class="line">        <span class="keyword">if</span> (!par1.equals(par2)) &#123;</span><br><span class="line">            map.put(par1, par2);    <span class="comment">// par1的老大设为par2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; words1.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (words1[i].equals(words2[i])) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(words1[i]) || !map.containsKey(words2[i])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">par1</span> <span class="operator">=</span> findParent(words1[i], map);</span><br><span class="line">        <span class="type">String</span> <span class="variable">par2</span> <span class="operator">=</span> findParent(words2[i], map);</span><br><span class="line">        <span class="keyword">if</span> (!par1.equals(par2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">findParent</span><span class="params">(String str, Map&lt;String,String&gt; map)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!str.equals(map.get(str))) &#123; <span class="comment">// 追溯str的老大</span></span><br><span class="line">            str = map.get(str);              </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="739-daily-temperatures"><a href="#739-daily-temperatures" class="headerlink" title="739. daily-temperatures"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/daily-temperatures/description/">739. daily-temperatures</a></h4><ul>
<li>给一个int数组表示气温，返回一个数组表示该日最短需要多少天才会有更温暖的日子。例如<code>[73, 74, 75, 71, 69, 72, 76, 73]</code>输出<code>[1, 1, 4, 2, 1, 1, 0, 0]</code>。</li>
<li>解法：维护一个Stack存放索引，每次读入新的温度时就和栈顶对应的温度比较，如果更高，就弹出并设置该索引处的天数。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temperatures == <span class="literal">null</span> || temperatures.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] nextWarmer = <span class="keyword">new</span> <span class="title class_">int</span> [temperatures.length];</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; temperatures.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 比较当前温度和栈顶索引对应温度 </span></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty()</span><br><span class="line">                &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                nextWarmer[index] = i - index;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);                  <span class="comment">// 栈剩下的都比当前大</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            nextWarmer[stack.pop()] = <span class="number">0</span>;    <span class="comment">// 其实Java数组原本就是0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextWarmer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="740-delete-and-earn"><a href="#740-delete-and-earn" class="headerlink" title="740. delete-and-earn"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/delete-and-earn/">740. delete-and-earn</a></h4><ul>
<li>给一个int数组，每次从中取出一个数字<code>num</code>作为score，同时将所有<code>num + 1</code>和<code>num - 1</code>抹去。求能得到的最多的score。</li>
<li>DP。对于每个数字只有两种情况，要么选中成为score，要么忽略等着选中其他的num被抹去，因此维护一个take、一个skip，take的前一位一定是skip（相邻的不可能同时pick）、skip的前一位取不取都可以，选更大者即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteAndEarn</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] bucket = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10001</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            bucket[num] += num;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">skip</span> <span class="operator">=</span> <span class="number">0</span>, take = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">takeNew</span> <span class="operator">=</span> bucket[i] + skip;</span><br><span class="line">            <span class="type">int</span> <span class="variable">skipNew</span> <span class="operator">=</span> Math.max(take, skip);</span><br><span class="line">            take = takeNew;</span><br><span class="line">            skip = skipNew;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(skip, take);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="741-cherry-pickup"><a href="#741-cherry-pickup" class="headerlink" title="741. cherry-pickup"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/cherry-pickup/">741. cherry-pickup</a></h4><ul>
<li>给一个只含有<code>-1, 0, 1</code>的<code>NxN</code>棋盘，从左上角出发只能往右&#x2F;往下挪到右下角后，再往左&#x2F;往上挪回起点。-1表示障碍物，1为cherry，求往返之后能收集到的最多的cherry数目。</li>
<li>既然只能往右、往下，那么第一趟所能走过的步数是固定的，就是2N，往回走也是一样。为了简化问题，可以想像成有两个人同时从起点往终点向右、向下挪，收集cherry时如果在同一个格子就只计算一次。采用dfs即可遍历所有可能的row1, col1, row2, col2组合。时间复杂度为<code>O(N^4)</code>. 相比之下如果不加memo就是纯暴力对于每个可能都要来一次递归，就是<code>O(4^(N*N))</code>.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cherryPickup</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="keyword">return</span> Math.max(dfs(grid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">Integer</span>[N][N][N][N]), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> row1, <span class="type">int</span> col1, <span class="type">int</span> row2, <span class="type">int</span> col2, Integer[][][][] memo)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="keyword">if</span> (row1 &gt;= N || col1 &gt;= N || </span><br><span class="line">           row2 &gt;= N || col2 &gt;= N || </span><br><span class="line">           grid[row1][col1] == -<span class="number">1</span> || grid[row2][col2] == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[row1][col1][row2][col2] != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[row1][col1][row2][col2];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((row1 == N - <span class="number">1</span> &amp;&amp; col1 == N - <span class="number">1</span>) ||</span><br><span class="line">           (row2 == N - <span class="number">1</span> &amp;&amp; col2 == N - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> grid[N - <span class="number">1</span>][N - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">currCount</span> <span class="operator">=</span> row1 == row2 &amp;&amp; col1 == col2 ? grid[row1][col1] : grid[row1][col1] + grid[row2][col2];</span><br><span class="line">        currCount += Math.max(</span><br><span class="line">            Math.max(dfs(grid, row1 + <span class="number">1</span>, col1, row2 + <span class="number">1</span>, col2, memo), dfs(grid, row1 + <span class="number">1</span>, col1, row2, col2 + <span class="number">1</span>, memo)),</span><br><span class="line">            Math.max(dfs(grid, row1, col1 + <span class="number">1</span>, row2 + <span class="number">1</span>, col2, memo),</span><br><span class="line">                              dfs(grid, row1, col1 + <span class="number">1</span>, row2, col2 + <span class="number">1</span>, memo)));</span><br><span class="line">        memo[row1][col1][row2][col2] = currCount;</span><br><span class="line">        <span class="keyword">return</span> currCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>一个优化是，这里row1 + col1 &#x3D;&#x3D; row2 + col2，因此其实只需要3个变量，三维的memo即可。</li>
</ul>
<h4 id="742-closest-leaf-in-a-binary-tree"><a href="#742-closest-leaf-in-a-binary-tree" class="headerlink" title="742. closest-leaf-in-a-binary-tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/closest-leaf-in-a-binary-tree/description/">742. closest-leaf-in-a-binary-tree</a></h4><ul>
<li>给一个二叉树和一个其中必定存在的值k，求这个节点到最近的leaf节点的距离。注意不是BST。</li>
<li>纯粹用Tree来思考有点困难，需要抽象成graph来思考：给定一个target点，怎么找最近的满足一定条件的neighbor？BFS。因此先dfs一波找到target节点，同时记录target节点怎么往parent走。然后从target节点开始BFS找最近的leaf节点即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findClosestLeaf</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;TreeNode, TreeNode&gt; prevNodeMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Set&lt;TreeNode&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">targetNode</span> <span class="operator">=</span> dfs(root, k, prevNodeMap);</span><br><span class="line">        </span><br><span class="line">        q.offer(targetNode);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            visited.add(curr);</span><br><span class="line">            <span class="keyword">if</span> (curr.left == <span class="literal">null</span> &amp;&amp; curr.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> curr.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curr.left != <span class="literal">null</span> &amp;&amp; !visited.contains(curr.left)) &#123;</span><br><span class="line">                q.offer(curr.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curr.right != <span class="literal">null</span> &amp;&amp; !visited.contains(curr.right)) &#123;</span><br><span class="line">                q.offer(curr.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (prevNodeMap.containsKey(curr) &amp;&amp; !visited.contains(prevNodeMap.get(curr))) &#123;</span><br><span class="line">                q.offer(prevNodeMap.get(curr));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> k, Map&lt;TreeNode, TreeNode&gt; prevNodeMap)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.val == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            prevNodeMap.put(root.left, root);</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> dfs(root.left, k, prevNodeMap);</span><br><span class="line">            <span class="keyword">if</span> (left != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            prevNodeMap.put(root.right, root);</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> dfs(root.right, k, prevNodeMap);</span><br><span class="line">            <span class="keyword">if</span> (right != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="743-network-delay-time"><a href="#743-network-delay-time" class="headerlink" title="743. network-delay-time"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/network-delay-time/description/">743. network-delay-time</a></h4><ul>
<li>总共有1、2、3、…、N个节点，给一个times数组表示从node A到node B需要传播的时间，给定起始点K，求最长需要消耗的时间。类似于求最短路，BFS搞定。注意需要更新到达节点所需要的时间。</li>
</ul>
<h4 id="744-find-smallest-letter-greater-than-target"><a href="#744-find-smallest-letter-greater-than-target" class="headerlink" title="744. find-smallest-letter-greater-than-target"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-smallest-letter-greater-than-target/description/">744. find-smallest-letter-greater-than-target</a></h4><ul>
<li>给一个排好序的a-z的char数组，给一个target，求比他大的字符，若是最后一个则wrap到前面如比z大的就是最前面的字符。</li>
<li>二分查找，找last occurence，直接返回「下一个」字符。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">nextGreatestLetter</span><span class="params">(<span class="type">char</span>[] letters, <span class="type">char</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (letters == <span class="literal">null</span> || letters.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> -<span class="number">1</span>, end = letters.length;</span><br><span class="line">        <span class="keyword">while</span> (end - start &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (letters[mid] &lt;= target) &#123;   <span class="comment">// 相等也要把start往后推，找到最后一个occurence</span></span><br><span class="line">                start = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                end = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不论start处是不是target，直接返回下一位即可</span></span><br><span class="line">        <span class="keyword">return</span> start &lt; letters.length - <span class="number">1</span> ? letters[start + <span class="number">1</span>] : letters[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="745-prefix-and-suffix-search"><a href="#745-prefix-and-suffix-search" class="headerlink" title="745. prefix-and-suffix-search"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/prefix-and-suffix-search/description/">745. prefix-and-suffix-search</a></h4><ul>
<li>给一个字符串数组，之后给一些query，这些query含有前缀和后缀（0～10个字符），求符合前缀的单词的索引。</li>
<li>有多个答案怎么办？返回最后一个出现的。</li>
<li>方法一：encode的方式将每个单词所有可能的前缀后缀组合作为key存入map，索引作为value，这样在query的时候直接再encode一下就可以直接get了。初始化时间复杂度O(N * wordLen^2)，query时间复杂度O(1)，空间占用O(N * wordLen^2).</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WordFilter</span> &#123;</span><br><span class="line">    Map&lt;String, Integer&gt; map;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WordFilter</span><span class="params">(String[] words)</span> &#123; </span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; words.length; index++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">wordLen</span> <span class="operator">=</span> words[index].length();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">10</span> &amp;&amp; i &lt;= wordLen; i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">front</span> <span class="operator">=</span> words[index].substring(<span class="number">0</span>, i);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= <span class="number">10</span> &amp;&amp; j &lt;= wordLen; j++) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">back</span> <span class="operator">=</span> words[index].substring(wordLen - j);  <span class="comment">// 组成&quot;a...#p..&quot;的key</span></span><br><span class="line">                    map.put(front + <span class="string">&quot;#&quot;</span> + back, index);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(String prefix, String suffix)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> prefix + <span class="string">&quot;#&quot;</span> + suffix;</span><br><span class="line">        <span class="keyword">return</span> map.containsKey(key)? map.get(key) : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：拆分成两个map，一个专门维护前缀、一个专门维护后缀，value都是索引的List。在query的时候需要把两个List取出来，然后O(N)扫描看看有没有交点。初始化时间复杂度O(N * wordLen)，query时间复杂度O(N)，空间占用O(N * wordLen).</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WordFilter</span> &#123;</span><br><span class="line">    Map&lt;String, List&lt;Integer&gt;&gt; mapPrefix;</span><br><span class="line">    Map&lt;String, List&lt;Integer&gt;&gt; mapSuffix;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WordFilter</span><span class="params">(String[] words)</span> &#123; </span><br><span class="line">        mapPrefix = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        mapSuffix = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; words.length; index++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">wordLen</span> <span class="operator">=</span> words[index].length();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">10</span> &amp;&amp; i &lt;= wordLen; i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">front</span> <span class="operator">=</span> words[index].substring(<span class="number">0</span>, i);</span><br><span class="line">                <span class="keyword">if</span> (!mapPrefix.containsKey(front)) &#123;</span><br><span class="line">                    mapPrefix.put(front, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">                &#125;</span><br><span class="line">                mapPrefix.get(front).add(index);</span><br><span class="line">                </span><br><span class="line">                <span class="type">String</span> <span class="variable">back</span> <span class="operator">=</span> words[index].substring(wordLen - i);</span><br><span class="line">                <span class="keyword">if</span> (!mapSuffix.containsKey(back)) &#123;</span><br><span class="line">                    mapSuffix.put(back, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">                &#125;</span><br><span class="line">                mapSuffix.get(back).add(index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(String prefix, String suffix)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; listPrefix = mapPrefix.get(prefix);</span><br><span class="line">        List&lt;Integer&gt; listSuffix = mapSuffix.get(suffix);</span><br><span class="line">        <span class="keyword">if</span> (listPrefix == <span class="literal">null</span> || listSuffix == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> listPrefix.size() - <span class="number">1</span>, j = listSuffix.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;          <span class="comment">// 因为要返回最后一个，所以要从后往前找交点</span></span><br><span class="line">            <span class="keyword">if</span> (listPrefix.get(i) &gt; listSuffix.get(j)) &#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (listPrefix.get(i) &lt; listSuffix.get(j)) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> listPrefix.get(i);   <span class="comment">// 注意不能直接对Integer用==判断相等！</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法三：直接使用内建函数startsWith和endsWith。初始化时间复杂度O(1)，query时间复杂度O(N * wordLen)，空间占用O(1).</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WordFilter</span> &#123;</span><br><span class="line">    String[] words;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WordFilter</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.words = words;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(String prefix, String suffix)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> words.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (words[i].startsWith(prefix) &amp;&amp; words[i].endsWith(suffix)) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="747-largest-number-at-least-twice-of-others"><a href="#747-largest-number-at-least-twice-of-others" class="headerlink" title="747. largest-number-at-least-twice-of-others"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/largest-number-at-least-twice-of-others/">747. largest-number-at-least-twice-of-others</a></h4><ul>
<li>给一个只包含<code>[1, 50]</code>范围内的数组，求其中最大的、且至少是次大的数两倍的数的index。若不存在则返回-1. 第一次提交遗漏了更新次大数的条件。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dominantIndex</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>, secondMax = <span class="number">0</span>, maxIndex = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (max &lt;= nums[i]) &#123;</span><br><span class="line">                secondMax = max;</span><br><span class="line">                max = nums[i];</span><br><span class="line">                maxIndex = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (secondMax &lt; nums[i]) &#123;</span><br><span class="line">                secondMax = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (secondMax == <span class="number">0</span> &amp;&amp; max &gt; secondMax) || (max &gt;= <span class="number">2</span> * secondMax) ? maxIndex : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="748-shortest-completing-word"><a href="#748-shortest-completing-word" class="headerlink" title="748. shortest-completing-word"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/shortest-completing-word/description/">748. shortest-completing-word</a></h4><ul>
<li>给一个licensePlate，再给一个words数组，求其中最短的字符串使得licensePlate出现过的字母都有。例如<code>licensePlate = &quot;1s3 PSt&quot;中只用关注S P S T, words = [&quot;step&quot;, &quot;steps&quot;, &quot;stripe&quot;, &quot;stepple&quot;]</code>，输出<code>steps</code>。</li>
<li>licensePlate有哪些字符、确定只关注字母？（-是的）字母大小写？（-忽略大小写）</li>
<li>解法：先统计licensePlate中字母出现次数，然后<code>O(N)</code>遍历字符串数组，对于每一个单词判断是否包含licensePlate的所有字母（<code>O(26)</code>），再找最短的返回。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="type">int</span> <span class="variable">LETTER_NUM</span> <span class="operator">=</span> <span class="number">26</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">shortestCompletingWord</span><span class="params">(String licensePlate, String[] words)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (licensePlate == <span class="literal">null</span> || words == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 统计licensePlate里字母的出现次数</span></span><br><span class="line">        <span class="type">char</span>[] letterCount = <span class="keyword">new</span> <span class="title class_">char</span> [LETTER_NUM];</span><br><span class="line">        <span class="type">char</span>[] lChar = licensePlate.toLowerCase().toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lChar.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Character.isLetter(lChar[i])) &#123;</span><br><span class="line">                letterCount[lChar[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对于每个单词判断是否complete，然后找最短的</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minLen</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (String word: words) &#123;</span><br><span class="line">            <span class="keyword">if</span> (checkComplete(word, letterCount)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word.length() &lt; minLen) &#123;</span><br><span class="line">                    minLen = word.length();</span><br><span class="line">                    ans = word;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 统计当前单词的字母出现次数，然后再一波O（26）和licensePlate的字母Count比较</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkComplete</span><span class="params">(String word, <span class="type">char</span>[] letterCount)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] wChar = word.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] thisCount = <span class="keyword">new</span> <span class="title class_">char</span> [LETTER_NUM];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; wChar.length; i++) &#123;</span><br><span class="line">            thisCount[wChar[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; LETTER_NUM; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (letterCount[i] &gt; <span class="number">0</span> &amp;&amp; thisCount[i] &lt; letterCount[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="749-contain-virus"><a href="#749-contain-virus" class="headerlink" title="749. contain-virus"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/contain-virus">749. contain-virus</a></h4><ul>
<li>给一个只含有0和1的二维数组，1表示带病毒的细胞、0是健康细胞，每分钟病毒会传染给上下左右直接相邻的健康细胞。假设从最开始可以选择一团带病毒的细胞在他们和健康细胞之间建隔离带，<code>0|1</code>这样会消耗一个隔离带。每次选择相邻健康细胞最多的一团进行隔离，然后经过一分钟剩下部分完成感染后在继续建隔离带。求这样的策略下最终需要多少隔离带（结果可能是完成了隔离、抑或全部都被感染）。</li>
<li>本质上就是DFS。先找出所有团簇，然后相邻健康细胞取最多的进行隔离，然后模拟感染扩散，然后再循环找团簇隔离。。。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Region</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; infectedSet, uninfectedSet;</span><br><span class="line">        <span class="type">int</span> wallCount;</span><br><span class="line">        Region() &#123;</span><br><span class="line">            <span class="built_in">this</span>.infectedSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">            <span class="built_in">this</span>.uninfectedSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">            <span class="built_in">this</span>.wallCount = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">containVirus</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> grid.length, cols = grid[<span class="number">0</span>].length, retVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            LinkedList&lt;Region&gt; regions = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[rows][cols];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>; row &lt; rows; row++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; cols; col++) &#123;</span><br><span class="line">                    <span class="comment">// 找到未被访问过的染病细胞</span></span><br><span class="line">                    <span class="keyword">if</span> (grid[row][col] == <span class="number">1</span> &amp;&amp; !visited[row][col]) &#123;</span><br><span class="line">                        <span class="type">Region</span> <span class="variable">region</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Region</span>();</span><br><span class="line">                        dfs(grid, row, col, visited, region);</span><br><span class="line">                        <span class="comment">// 只有当它有相邻的健康细胞才可能继续传染</span></span><br><span class="line">                        <span class="keyword">if</span> (!region.uninfectedSet.isEmpty()) &#123;</span><br><span class="line">                            regions.add(region);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (regions.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            regions.sort((a, b) -&gt; b.uninfectedSet.size() - a.uninfectedSet.size());</span><br><span class="line">            <span class="type">Region</span> <span class="variable">most</span> <span class="operator">=</span> regions.pollFirst();</span><br><span class="line">            retVal += most.wallCount;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> point : most.infectedSet) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> point / cols;</span><br><span class="line">                <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> point % cols;</span><br><span class="line">                grid[row][col] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (!regions.isEmpty()) &#123;</span><br><span class="line">                <span class="type">Region</span> <span class="variable">region</span> <span class="operator">=</span> regions.pollFirst();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> point : region.uninfectedSet) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> point / cols;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> point % cols;</span><br><span class="line">                    grid[row][col] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] dirs = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">boolean</span>[][] visited, Region region)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> grid.length, cols = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= rows || col &lt; <span class="number">0</span> || col &gt;= cols || grid[row][col] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (grid[row][col] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[row][col]) &#123;</span><br><span class="line">                visited[row][col] = <span class="literal">true</span>;</span><br><span class="line">                region.infectedSet.add(row * cols + col);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                    dfs(grid, row + dirs[i], col + dirs[i + <span class="number">1</span>], visited, region);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            region.uninfectedSet.add(row * cols + col);</span><br><span class="line">            region.wallCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="750-number-of-corner-rectangles"><a href="#750-number-of-corner-rectangles" class="headerlink" title="750. number-of-corner-rectangles"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/number-of-corner-rectangles/description/">750. number-of-corner-rectangles</a></h4><ul>
<li>给一个只含有0和1的二维数组，求其中四个1所能组成矩形的个数。矩形的边必须横、竖两个方向。</li>
<li>扫描线的思路，取两个行，同时扫竖线，统计同时出现1的pair数作为竖线，然后把这些竖线组合一下即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 两行一起往右挪找是否有同时为1的，然后根据该平行线的pair数简单排列组合就可以了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countCornerRectangles</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; grid.length; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; grid[<span class="number">0</span>].length; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (grid[i][k] == <span class="number">1</span> &amp;&amp; grid[j][k] == <span class="number">1</span>) &#123;   <span class="comment">// 两平行线同一列同为1</span></span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans += count * (count - <span class="number">1</span>) / <span class="number">2</span>;     <span class="comment">// combination</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="752-open-the-lock"><a href="#752-open-the-lock" class="headerlink" title="752. open-the-lock"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/open-the-lock/description/">752. open-the-lock</a></h4><ul>
<li>假如有一个锁头从<code>0000</code>开始转，每次只能只能转四位中的一位，给一个String数组表示这些数字不可以转到，给一个target表示最终开锁的密码。求最短需要多少次才能开锁，不可能打开则返回-1。</li>
<li>这种最短路径问题就想到了BFS，不过需要小心的是target本身不可达以及起始点就不可达的情况。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">openLock</span><span class="params">(String[] deadends, String target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (deadends == <span class="literal">null</span> || deadends.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String deadend : deadends) &#123;</span><br><span class="line">            visited.add(deadend);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (visited.contains(target)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Queue&lt;StringBuilder&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">start</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (visited.contains(start.toString())) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q.offer(start);</span><br><span class="line">        visited.add(start.toString());</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> q.size();</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">curr</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> curr.charAt(i);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> -<span class="number">1</span>; j &lt;= <span class="number">1</span>; j += <span class="number">2</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (c == <span class="string">&#x27;0&#x27;</span> &amp;&amp; j == -<span class="number">1</span>) &#123;</span><br><span class="line">                            curr.setCharAt(i, <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;9&#x27;</span> &amp;&amp; j == <span class="number">1</span>) &#123;</span><br><span class="line">                            curr.setCharAt(i, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            curr.setCharAt(i, (<span class="type">char</span>)(c + j));</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">currStr</span> <span class="operator">=</span> curr.toString();</span><br><span class="line">                        <span class="keyword">if</span> (!visited.contains(currStr)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (currStr.equals(target)) &#123;</span><br><span class="line">                                <span class="keyword">return</span> count;</span><br><span class="line">                            &#125;</span><br><span class="line">                            q.offer(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(currStr));</span><br><span class="line">                            visited.add(currStr);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    curr.setCharAt(i, c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>以上是basic的BFS，如果要提速，可以进行<a target="_blank" rel="noopener" href="https://leetcode.com/problems/open-the-lock/discuss/110237/Regular-java-BFS-solution-and-2-end-BFS-solution-with-improvement">双向的BFS</a>，也就是维护两个Set，一个begin作为开始、一个end作为结束，每次switch角色，搞完begin就将end补过来、将当前begin的邻居点作为新的end。</li>
</ul>
<h4 id="759-employee-free-time"><a href="#759-employee-free-time" class="headerlink" title="759. employee-free-time"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/employee-free-time/description/">759. employee-free-time</a></h4><ul>
<li>给一个List of List，每一个子List存放每个employee的工作时间，求所有employee的共同空闲时间。没有则返回空List。</li>
<li>直接将List flatten，然后按照工作开始时间从小到大排序，再往后依次取工作时间，若当前开始时间比之前的结束时间长，说明出现了空闲时间；否则需要更新prev的end，保证prev的结束时间cover到所有结束时间，即取max。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Interval&gt; <span class="title function_">employeeFreeTime</span><span class="params">(List&lt;List&lt;Interval&gt;&gt; schedule)</span> &#123;</span><br><span class="line">    List&lt;Interval&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (schedule == <span class="literal">null</span> || schedule.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Interval&gt; workingTimes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    schedule.forEach(e -&gt; workingTimes.addAll(e));</span><br><span class="line">    Collections.sort(workingTimes, (a, b) -&gt; a.start - b.start);</span><br><span class="line">    <span class="type">Interval</span> <span class="variable">prev</span> <span class="operator">=</span> workingTimes.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; workingTimes.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (workingTimes.get(i).start &gt; prev.end) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">Interval</span>(prev.end, workingTimes.get(i).start));</span><br><span class="line">            prev = workingTimes.get(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev.end = Math.max(prev.end, workingTimes.get(i).end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="760-find-anagram-mappings"><a href="#760-find-anagram-mappings" class="headerlink" title="760. find-anagram-mappings"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-anagram-mappings/description/">760. find-anagram-mappings</a></h4><ul>
<li>给两个数组，求对应出现的位置。skip.</li>
</ul>
<h4 id="763-partition-labels"><a href="#763-partition-labels" class="headerlink" title="763. partition-labels"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/partition-labels/description/">763. partition-labels</a></h4><ul>
<li>给一个字符串，尝试将它进行partition使得每个字符至多只出现在一个partition，划分处尽量多的partition，求每个partition的长度。</li>
<li>方法一：LinkedHashMap搞定。统计每个字符出现的初始位置和最后一次出现的位置，然后遍历，当前后无法相连则说明这是一个新的partition。</li>
<li>方法二：不需要对每一个字母同时存放start和end，而是对于一个partition维护start和end。遍历字符串时若当前索引正是当前字符的最后一次出现的索引，且到达了当前partition的end，说明partition结束；否则需要适当更新end。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">partitionLabels</span><span class="params">(String S)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (S == <span class="literal">null</span> || S.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] lastOccurance = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; S.length(); i++) &#123;</span><br><span class="line">            lastOccurance[S.charAt(i) - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, end = <span class="number">0</span>;     </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; S.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> S.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (lastOccurance[index] != i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lastOccurance[index] &gt; end) &#123;</span><br><span class="line">                    end = lastOccurance[index]; <span class="comment">// 若有更靠后的索引则更新end</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">                    ans.add(end - start + <span class="number">1</span>);</span><br><span class="line">                    end = i + <span class="number">1</span>;</span><br><span class="line">                    start = i + <span class="number">1</span>;  <span class="comment">// start只在每个partition开始时更新一次</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="764-largest-plus-sign"><a href="#764-largest-plus-sign" class="headerlink" title="764. largest-plus-sign"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/largest-plus-sign/description/">764. largest-plus-sign</a></h4><ul>
<li>给定N表示棋盘的长和宽，默认棋盘中每个cell都是1，再给一些坐标表示该处是0。求棋盘中最大的加号的长度。</li>
<li>可以利用grid本身记录上下左右四个方向最长延伸出去多长。最原始的想法是每个方向都维护一个二维数组专门记录到该cell的最长长度是多少，不过经过改进可以将所有的计算都合并到一个grid中完成。开始时初始化每个cell的长度都为N，然后直接从前、后、上、下同时更新，不过每一步循环中更新的其实是四个不同的cell，最后循环结束时每个cell都会被更新四次。时间复杂度O(N^2)。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">orderOfLargestPlusSign</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span>[][] mines)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (N &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] grid = <span class="keyword">new</span> <span class="title class_">int</span> [N][N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            Arrays.fill(grid[i], N);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] mine : mines) &#123;</span><br><span class="line">            grid[mine[<span class="number">0</span>]][mine[<span class="number">1</span>]] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>, k = N - <span class="number">1</span>, l = <span class="number">0</span>, r = <span class="number">0</span>, t = <span class="number">0</span>, b = <span class="number">0</span>; j &lt; N; j++, k--) &#123;</span><br><span class="line">                <span class="comment">// 分别统计左右、上下有多少延伸出去的长度，每个cell会被访问到4次，每次都取min</span></span><br><span class="line">                grid[i][j] = Math.min(grid[i][j], l = grid[i][j] == <span class="number">0</span> ? <span class="number">0</span> : l + <span class="number">1</span>);</span><br><span class="line">                grid[i][k] = Math.min(grid[i][k], r = grid[i][k] == <span class="number">0</span> ? <span class="number">0</span> : r + <span class="number">1</span>);</span><br><span class="line">                grid[j][i] = Math.min(grid[j][i], t = grid[j][i] == <span class="number">0</span> ? <span class="number">0</span> : t + <span class="number">1</span>);</span><br><span class="line">                grid[k][i] = Math.min(grid[k][i], b = grid[k][i] == <span class="number">0</span> ? <span class="number">0</span> : b + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                ans = Math.max(grid[i][j], ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="765-couples-holding-hands"><a href="#765-couples-holding-hands" class="headerlink" title="765. couples-holding-hands"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/couples-holding-hands/description/">765. couples-holding-hands</a></h4><ul>
<li>给一个int数组表示每个位置坐的人，假设0-1, 2-3, 4-5…是一对，问最少通过几次交换座位可以让没对情侣都相邻而坐��</li>
<li>可以用greedy的办法，每发现一个坐错位置的人，就让他和应该在这个位置的人swap一次。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSwapsCouples</span><span class="params">(<span class="type">int</span>[] row)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (row == <span class="literal">null</span> || row.length == <span class="number">0</span> || row.length % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] pos = <span class="keyword">new</span> <span class="title class_">int</span>[row.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row.length; i++) &#123;</span><br><span class="line">            pos[row[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">expected</span> <span class="operator">=</span> row[i] % <span class="number">2</span> == <span class="number">0</span> ? row[i] + <span class="number">1</span> : row[i] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (row[i + <span class="number">1</span>] != expected) &#123;</span><br><span class="line">                pos[row[i + <span class="number">1</span>]] = pos[expected];</span><br><span class="line">                row[pos[expected]] = row[i + <span class="number">1</span>];</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="767-reorganize-string"><a href="#767-reorganize-string" class="headerlink" title="767. reorganize-string"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reorganize-string/description/">767. reorganize-string</a></h4><ul>
<li>给一个只含有小写字母的字符串，将这些字符重新排列使得相邻字母不同，若不存在则返回””;</li>
<li>greedy，先统计每一个字符出现的次数，存入priorityqueue使得次数多的先取，取后若仍有剩余则需要更新次数并重新放回pq。注意若当前取出的次数最多的字母是上一次append的，则需要取第二多的字符，若没有后续字符说明没法这么存，返回””即可。</li>
</ul>
<h4 id="768-max-chunks-to-make-sorted-ii"><a href="#768-max-chunks-to-make-sorted-ii" class="headerlink" title="768. max-chunks-to-make-sorted-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/max-chunks-to-make-sorted-ii/description/">768. max-chunks-to-make-sorted-ii</a></h4><ul>
<li>给一个int数组，将这个数组分成若干个chunk后在每个chunk内部排序之后拼接能得到sorted的数组，求最多划分成多少个这样的chunk。</li>
<li>形成chunk的条件是「chunk中最大值小于等于右侧所有数的最小值」。因此维护两个数组存放当前位置的左侧最大值和右侧最小值即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxChunksToSorted</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] maxOfLeft = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];    <span class="comment">// 左侧的最大值</span></span><br><span class="line">        maxOfLeft[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            maxOfLeft[i] = Math.max(maxOfLeft[i - <span class="number">1</span>], arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] minOfRight = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];   <span class="comment">// 右侧的最小值</span></span><br><span class="line">        minOfRight[arr.length - <span class="number">1</span>] = arr[arr.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            minOfRight[i] = Math.min(minOfRight[i + <span class="number">1</span>], arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;<span class="comment">// 当左侧最大值都小于右侧最小值，说明当前位之前都可以自己排个序了</span></span><br><span class="line">            <span class="keyword">if</span> (maxOfLeft[i] &lt;= minOfRight[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="769-max-chunks-to-make-sorted"><a href="#769-max-chunks-to-make-sorted" class="headerlink" title="769. max-chunks-to-make-sorted"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/max-chunks-to-make-sorted/description/">769. max-chunks-to-make-sorted</a></h4><ul>
<li>给一个int数组，其中含有元素<code>[0, 1, ..., arr.length - 1]</code>（顺序不一定是这样的，是一个permutation），将这个数组分成若干个chunk后在每个chunk内部排序之后拼接能得到sorted的数组，求最多划分成多少个这样的chunk。如<code>[4,3,2,1,0]</code>必须整个作为一个chunk排序，<code>[1,0,2,3,4]</code>则分成<code>[1, 0], [2], [3], [4]</code>来排序。</li>
<li>既然元素和index是能对应填充的，考虑他们之间的关系。要想形成chunk，必须chunk的最大值在最右侧index的左侧，维护一个max即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxChunksToSorted</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            max = Math.max(max, arr[i]);</span><br><span class="line">            <span class="keyword">if</span> (i == max) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="771-jewels-and-stones"><a href="#771-jewels-and-stones" class="headerlink" title="771. jewels-and-stones"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/jewels-and-stones/">771. jewels-and-stones</a></h4><ul>
<li>简单的bucket计数，pass。</li>
</ul>
<h4 id="773-sliding-puzzle"><a href="#773-sliding-puzzle" class="headerlink" title="773. sliding-puzzle"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sliding-puzzle/">773. sliding-puzzle</a></h4><ul>
<li>给一个2x3的board，只含有数字0-5。只有0可以与相邻的元素swap，问最少经过多少swap能得到<code>[[1, 2, 3], [5, 6, 0]]</code>.</li>
<li>转换为BFS问题，每个状态就是一个可达的节点，最关键的其实就是看<code>0</code>能否和周围数字swap。从当前节点到下一个节点，就是找出所有<code>0</code>与邻居swap之后的状态。这里还有一个trick就是将二维数组转化成一维的string，直接通过字符串比较高效很多。时间复杂度为<code>O(row * col * (row * col)!)</code>.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] neighbors = <span class="keyword">new</span> <span class="title class_">int</span>[][] &#123;</span><br><span class="line">        &#123; <span class="number">1</span>, <span class="number">3</span> &#125;,</span><br><span class="line">        &#123; <span class="number">0</span>, <span class="number">4</span>, <span class="number">2</span> &#125;,</span><br><span class="line">        &#123; <span class="number">1</span>, <span class="number">5</span> &#125;,</span><br><span class="line">        &#123; <span class="number">0</span>, <span class="number">4</span> &#125;,</span><br><span class="line">        &#123; <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span> &#125;,</span><br><span class="line">        &#123; <span class="number">4</span>, <span class="number">2</span> &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">target</span> <span class="operator">=</span> <span class="string">&quot;123450&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> <span class="number">2</span>, cols = <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">slidingPuzzle</span><span class="params">(<span class="type">int</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>; row &lt; rows; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; cols; col++) &#123;</span><br><span class="line">                sb.append(board[row][col]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;String&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        q.offer(sb.toString());</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">steps</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> q.size();</span><br><span class="line">            <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">curr</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                <span class="keyword">if</span> (curr.equals(target)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> steps;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index0</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">char</span> c : curr.toCharArray()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (c == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    index0++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> neighbor : neighbors[index0]) &#123;</span><br><span class="line">                    <span class="type">StringBuilder</span> <span class="variable">next</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(curr);</span><br><span class="line">                    next.setCharAt(index0, curr.charAt(neighbor));</span><br><span class="line">                    next.setCharAt(neighbor, curr.charAt(index0));</span><br><span class="line">                    <span class="type">String</span> <span class="variable">nextStr</span> <span class="operator">=</span> next.toString();</span><br><span class="line">                    <span class="keyword">if</span> (!visited.contains(nextStr)) &#123;</span><br><span class="line">                        visited.add(nextStr);</span><br><span class="line">                        q.add(nextStr);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            steps++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="775-global-and-local-inversions"><a href="#775-global-and-local-inversions" class="headerlink" title="775. global-and-local-inversions"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/global-and-local-inversions">775. global-and-local-inversions</a></h4><ul>
<li>给一个长度为N、元素值为<code>0 ~ N-1</code>的int数组，判断它的global inversion数量和local inversion数量是否相等。global表示任意一对儿数字逆序了、local表示相邻前后数字逆序了。</li>
<li>本质上就是判断是否有「非相邻前后数字」逆序的情况。直接loop判断<code>A[i] - i</code>的绝对值即可，只要他们差值大于1就说明有跨度超过1的逆序对了。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isIdealPermutation</span><span class="params">(<span class="type">int</span>[] A)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || A.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(A[i] - i) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="776-split-bst"><a href="#776-split-bst" class="headerlink" title="776. split-bst"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/split-bst/description/">776. split-bst</a></h4><ul>
<li>给一个BST和一个value，这个value不一定存在于BST中，要求以这个value为临界点将BST分成小于等于&amp;大于两部分。</li>
<li>在split的时候比较节点与value，若value更大则split点会出现在右子树且split后会得到两个split之后的子树，需要将小于等于的那个子树拼接到当前节点的右侧。若value不大于当前节点，则需要到左子树去搜索split点，同样需要将split之后较大的那个子树拼接到当前子树的左侧。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode[] splitBST(TreeNode root, <span class="type">int</span> V) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>[] &#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val &lt;= V) &#123;</span><br><span class="line">        TreeNode[] splitted = splitBST(root.right, V);</span><br><span class="line">        root.right = splitted[<span class="number">0</span>];</span><br><span class="line">        splitted[<span class="number">0</span>] = root;</span><br><span class="line">        <span class="keyword">return</span> splitted;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        TreeNode[] splitted = splitBST(root.left, V);</span><br><span class="line">        root.left = splitted[<span class="number">1</span>];</span><br><span class="line">        splitted[<span class="number">1</span>] = root;</span><br><span class="line">        <span class="keyword">return</span> splitted;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="777-swap-adjacent-in-lr-string"><a href="#777-swap-adjacent-in-lr-string" class="headerlink" title="777. swap-adjacent-in-lr-string"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/swap-adjacent-in-lr-string/">777. swap-adjacent-in-lr-string</a></h4><ul>
<li>给两个字符串<code>start</code>和<code>end</code>，其中类似<code>RX</code>的可以转化成<code>XR</code>，<code>XL</code>的可以转化成<code>LX</code>，但是<code>RL</code>就无法挪动了。判断是否可以成功转化。</li>
<li>首先需要判断两个字符串中L和R的相对位置是否一致，如果可以match上，再逐步判断<code>start</code>中的<code>R</code>是否都再<code>end</code>中<code>R</code>的前面、<code>start</code>中的<code>L</code>是否都再<code>end</code>中<code>L</code>的后面。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canTransform</span><span class="params">(String start, String end)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start == <span class="literal">null</span> || end == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (start.length() != end.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!start.replaceAll(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;&quot;</span>).equals(end.replaceAll(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;&quot;</span>))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> <span class="number">0</span>, endIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (startIndex &lt; start.length()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (startIndex &lt; start.length() &amp;&amp; start.charAt(startIndex) == <span class="string">&#x27;X&#x27;</span>) &#123;</span><br><span class="line">                startIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (endIndex &lt; end.length() &amp;&amp; end.charAt(endIndex) == <span class="string">&#x27;X&#x27;</span>) &#123;</span><br><span class="line">                endIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (startIndex == start.length()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (start.charAt(startIndex) == <span class="string">&#x27;R&#x27;</span> &amp;&amp; endIndex &lt; startIndex) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (start.charAt(startIndex) == <span class="string">&#x27;L&#x27;</span> &amp;&amp; startIndex &lt; endIndex) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            startIndex++;</span><br><span class="line">            endIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="778-swim-in-rising-water"><a href="#778-swim-in-rising-water" class="headerlink" title="778. swim-in-rising-water"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/swim-in-rising-water/">778. swim-in-rising-water</a></h4><ul>
<li>给一个<code>NxN</code>的grid，其中的值为[1,…, N*N]。如果当前时间t &gt; val则可以瞬间到达该坐标，求最小的t使得从左上角能移动到右下角。</li>
<li>方法一：最朴素的想法，二分查找来“猜”最终答案，每次对猜的答案进行DFS&#x2F;BFS验证是否可以从左上到右下，若可以到达，则缩小上界以尽可能找最小值，若不能到达说明t不够，提升下界。时间复杂度为<code>log(N*N)*N*N</code>.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">swimInWater</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> -<span class="number">1</span>, right = grid.length * grid.length;</span><br><span class="line">        <span class="keyword">while</span> (right - left &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (canGo(grid, mid)) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>[] dir = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">canGo</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> currTime)</span> &#123;</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> grid.length, cols = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[rows][cols];</span><br><span class="line">        <span class="keyword">if</span> (currTime &gt;= grid[<span class="number">0</span>][<span class="number">0</span>]) &#123;</span><br><span class="line">            q.offer(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">            visited[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span>[] curr = q.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">rowNext</span> <span class="operator">=</span> curr[<span class="number">0</span>] + dir[i];</span><br><span class="line">                <span class="type">int</span> <span class="variable">colNext</span> <span class="operator">=</span> curr[<span class="number">1</span>] + dir[i + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (rowNext &gt;= <span class="number">0</span> &amp;&amp; rowNext &lt; rows &amp;&amp;</span><br><span class="line">                    colNext &gt;= <span class="number">0</span> &amp;&amp; colNext &lt; cols &amp;&amp;</span><br><span class="line">                    !visited[rowNext][colNext] &amp;&amp;</span><br><span class="line">                    currTime &gt;= grid[rowNext][colNext]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (rowNext == rows - <span class="number">1</span> &amp;&amp; colNext == cols - <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        q.offer(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;rowNext, colNext&#125;);</span><br><span class="line">                        visited[rowNext][colNext] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：贪心算法，使用priorityqueue取代queue进行BFS，每次push的时候存入当前坐标已经到达当前坐标所需的时间，每次从pq中取坐标都可以找到当前可达范围内的最小的时间。时间复杂度和上面其实一样，毕竟需要在pq中维护顺序<code>O(NlogN)</code>，也就是这里的<code>N*N*log(N*N)</code>。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">swimInWater</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a[<span class="number">2</span>] - b[<span class="number">2</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[N][N];</span><br><span class="line">        pq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">0</span>, <span class="number">0</span>, grid[<span class="number">0</span>][<span class="number">0</span>]&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span>[] curr = pq.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">rowNext</span> <span class="operator">=</span> curr[<span class="number">0</span>] + dir[i];</span><br><span class="line">                <span class="type">int</span> <span class="variable">colNext</span> <span class="operator">=</span> curr[<span class="number">1</span>] + dir[i + <span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">currTime</span> <span class="operator">=</span> curr[<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">if</span> (rowNext &lt; <span class="number">0</span> || rowNext &gt;= N ||</span><br><span class="line">                   colNext &lt; <span class="number">0</span> || colNext &gt;= N ||</span><br><span class="line">                   visited[rowNext][colNext]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                visited[rowNext][colNext] = <span class="literal">true</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">newTime</span> <span class="operator">=</span> Math.max(currTime, grid[rowNext][colNext]);</span><br><span class="line">                <span class="keyword">if</span> (rowNext == N - <span class="number">1</span> &amp;&amp; colNext == N - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> newTime;</span><br><span class="line">                &#125;</span><br><span class="line">                pq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;rowNext, colNext, newTime&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>[] dir = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="785-is-graph-bipartite"><a href="#785-is-graph-bipartite" class="headerlink" title="785. is-graph-bipartite"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/is-graph-bipartite/description/">785. is-graph-bipartite</a></h4><ul>
<li>给一个数组，每个index对应着该node的所有邻接点。问这个graph能否只用两个颜色给node上色使得相邻两个点的颜色都不一样。</li>
<li>方法一：DFS。对于每一个点都一波直接深度搜索上色，用一个数组存储上色状态，0表示未访问过，-1和1分别表示两个颜色，在dfs时对于当前的点若已经访问过就判断是否符合当前给定的颜色，若未访问则直接上色并DFS到它所有邻接点。需要注意可能有若干独立的cluster，因此不能一次DFS搜索就结束了，而是需要一个循环保证对所有未访问过的点都进行一次DFS。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBipartite</span><span class="params">(<span class="type">int</span>[][] graph)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (graph == <span class="literal">null</span> || graph.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] colors = <span class="keyword">new</span> <span class="title class_">int</span>[graph.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (colors[i] == <span class="number">0</span> &amp;&amp; !checkColor(graph, colors, -<span class="number">1</span>, i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkColor</span><span class="params">(<span class="type">int</span>[][] graph, <span class="type">int</span>[] colors, <span class="type">int</span> currColor, <span class="type">int</span> currNode)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (colors[currNode] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> colors[currNode] == currColor;</span><br><span class="line">        &#125;</span><br><span class="line">        colors[currNode] = currColor;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> neighbor : graph[currNode]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!checkColor(graph, colors, -currColor, neighbor)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：BFS，还是用queue存放所有邻接点然后逐一上色。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBipartite</span><span class="params">(<span class="type">int</span>[][] graph)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (graph == <span class="literal">null</span> || graph.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] colors = <span class="keyword">new</span> <span class="title class_">int</span>[graph.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; graph.length; i++) &#123;    <span class="comment">// 只check没有访问过的点，即各个独立的cluster</span></span><br><span class="line">            <span class="keyword">if</span> (colors[i] == <span class="number">0</span> &amp;&amp; !checkColor(graph, colors, -<span class="number">1</span>, i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkColor</span><span class="params">(<span class="type">int</span>[][] graph, <span class="type">int</span>[] colors, <span class="type">int</span> currColor, <span class="type">int</span> currNode)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (colors[currNode] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> colors[currNode] == currColor;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">color</span> <span class="operator">=</span> currColor;</span><br><span class="line">        q.offer(currNode);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> q.size();</span><br><span class="line">            <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">node</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                <span class="keyword">if</span> (colors[node] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (colors[node] != color) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    colors[node] = color;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> neighbor : graph[node]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (colors[neighbor] == <span class="number">0</span>) q.offer(neighbor);   <span class="comment">// 避免回头路</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            color = -color;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="787-cheapest-flights-within-k-stops"><a href="#787-cheapest-flights-within-k-stops" class="headerlink" title="787. cheapest-flights-within-k-stops"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/cheapest-flights-within-k-stops/description/">787. cheapest-flights-within-k-stops</a></h4><ul>
<li>给一组city和航班信息，在最多stop k次的情况下求从src到dst最便宜的航班价格。</li>
<li>经典grpah最短路问题，首先用Map记录每一个city的邻居city航班，然后从src出发BFS，维护一个minPrice数组，发现更低价格时就更新对应city的到达所需价格。在BFS过程中，每扩散一轮就算作stop一次，利用一个flightCount保证最多停k次。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findCheapestPrice</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] flights, <span class="type">int</span> src, <span class="type">int</span> dst, <span class="type">int</span> K)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flights == <span class="literal">null</span> || flights.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, List&lt;<span class="type">int</span>[]&gt;&gt; flightMap = getGraph(flights);</span><br><span class="line">        <span class="type">int</span>[] minPrices = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(minPrices, Integer.MAX_VALUE);</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">flightCount</span> <span class="operator">=</span> K + <span class="number">1</span>;</span><br><span class="line">        q.offer(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;src, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty() &amp;&amp; flightCount-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> q.size();</span><br><span class="line">            <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span>[] currCity = q.poll();</span><br><span class="line">                List&lt;<span class="type">int</span>[]&gt; neighbors = flightMap.get(currCity[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">if</span> (neighbors == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span>[] neighbor : neighbors) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> currCity[<span class="number">1</span>] + neighbor[<span class="number">2</span>];</span><br><span class="line">                    <span class="keyword">if</span> (price &lt; minPrices[neighbor[<span class="number">1</span>]]) &#123;</span><br><span class="line">                        minPrices[neighbor[<span class="number">1</span>]] = price;</span><br><span class="line">                        q.offer(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;neighbor[<span class="number">1</span>], price&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minPrices[dst] == Integer.MAX_VALUE ? -<span class="number">1</span> : minPrices[dst];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, List&lt;<span class="type">int</span>[]&gt;&gt; getGraph(<span class="type">int</span>[][] flights) &#123;</span><br><span class="line">        Map&lt;Integer, List&lt;<span class="type">int</span>[]&gt;&gt; flightMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] flight : flights) &#123;</span><br><span class="line">            flightMap.putIfAbsent(flight[<span class="number">0</span>], <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="type">int</span>[]&gt;());</span><br><span class="line">            flightMap.get(flight[<span class="number">0</span>]).add(flight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flightMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="788-rotated-digits"><a href="#788-rotated-digits" class="headerlink" title="788. rotated-digits"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/rotated-digits/">788. rotated-digits</a></h4><ul>
<li>给一个数字N，求1～N范围内将各位数字上下反转180度后能得到与它本身不同数字的个数。</li>
<li>当前数字需要依赖之前几位数字的情况，因此考虑简单的DP。第一想法是维护一个map存反转信息，这样确实更直接明白，但速度会慢很多。其实可以直接用if判断。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; map = Stream.of(<span class="keyword">new</span> <span class="title class_">Integer</span>[][] &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">5</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>, <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="number">6</span>, <span class="number">9</span>&#125;,</span><br><span class="line">        &#123;<span class="number">8</span>, <span class="number">8</span>&#125;,</span><br><span class="line">        &#123;<span class="number">9</span>, <span class="number">6</span>&#125;</span><br><span class="line">    &#125;).collect(Collectors.toMap(data -&gt; data[<span class="number">0</span>], data -&gt; data[<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rotatedDigits</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>];  <span class="comment">// -1不合法，0合法相同数字，1不同数字</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newDigit</span> <span class="operator">=</span> i % <span class="number">10</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">prevNum</span> <span class="operator">=</span> i / <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(newDigit)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map.get(newDigit) == newDigit) &#123;</span><br><span class="line">                    dp[i] = dp[prevNum];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i] = dp[prevNum] &gt;= <span class="number">0</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="791-custom-sort-string"><a href="#791-custom-sort-string" class="headerlink" title="791. custom-sort-string"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/custom-sort-string/description/">791. custom-sort-string</a></h4><ul>
<li>给两个String，S只含有不重复的小写字母表示custom定义的顺序，需要将T按照这个给定顺序进行排序，对于没有出现过的字母随便放哪里都可以。</li>
<li>方法一：遍历S，在循环内层遍历T，遇到当前字符就往前swap，时间复杂度O(N^2).</li>
<li>方法二：木桶排序，既然只会出现小写字母，就用26个木桶统计出现个数，然后遍历S取处相应的append即可，最后再把S中没有的字母拼接到最后即可。时间O(N).</li>
</ul>
<h4 id="792-number-of-matching-subsequences"><a href="#792-number-of-matching-subsequences" class="headerlink" title="792. number-of-matching-subsequences"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/number-of-matching-subsequences/">792. number-of-matching-subsequences</a></h4><ul>
<li>给一个源字符串S和一个字符串数组，求数组中有多少个是S的子序列。</li>
<li>方法一：朴素的逐个判断。缓存入seq和nonSeq两个集合，遍历数组中每个字符串，判断是seq，对应存入两个set即可。这两个set并不是必须的，而是提速的，作为缓存来应付重复call的情况。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numMatchingSubseq</span><span class="params">(String S, String[] words)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (S == <span class="literal">null</span> || S.length() == <span class="number">0</span> || words == <span class="literal">null</span> || words.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Set&lt;String&gt; isSeqSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; notSeqSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isSeqSet.contains(word)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (notSeqSet.contains(word)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isSubSeq(S, word)) &#123;</span><br><span class="line">                isSeqSet.add(word);</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                notSeqSet.add(word);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSubSeq</span><span class="params">(String source, String target)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] targetCharArray = target.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> targetChar : targetCharArray) &#123;</span><br><span class="line">            index = source.indexOf(targetChar, index + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：为了加速在源字符串中的查找，将每个字母在S中出现的索引存入TreeSet中，每次查找时直接从TreeSet中拿大于等于当前SIndex的索引，如果找不到就直接false。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numMatchingSubseq</span><span class="params">(String S, String[] words)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (S == <span class="literal">null</span> || S.length() == <span class="number">0</span> || words == <span class="literal">null</span> || words.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeSet&lt;Integer&gt;[] bucket = buildBucket(S);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isMatch(word, bucket)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> TreeSet&lt;Integer&gt;[] buildBucket(String S) &#123;</span><br><span class="line">        TreeSet&lt;Integer&gt;[] bucket = <span class="keyword">new</span> <span class="title class_">TreeSet</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">char</span>[] charArray = S.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; charArray.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> charArray[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (bucket[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                bucket[index] = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            bucket[index].add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bucket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String word, TreeSet&lt;Integer&gt;[] bucket)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">indexInS</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span>[] charArray = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; charArray.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket[charArray[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">index</span> <span class="operator">=</span> bucket[charArray[i] - <span class="string">&#x27;a&#x27;</span>].ceiling(indexInS);</span><br><span class="line">            <span class="keyword">if</span> (index == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            indexInS = index + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="794-valid-tic-tac-toe-state"><a href="#794-valid-tic-tac-toe-state" class="headerlink" title="794. valid-tic-tac-toe-state"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-tic-tac-toe-state/">794. valid-tic-tac-toe-state</a></h4><ul>
<li>给一个3x3的棋盘，判断是否是一个合法的OOXX状态。默认X先走，三连就退出。</li>
<li>和之前design-tic-tac-toe类似，X持续加，O持续减。最后来几个if判断即可。没啥意思。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validTicTacToe</span><span class="params">(String[] board)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="literal">null</span> || board.length != <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] rows = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="type">int</span>[] cols = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">diag1</span> <span class="operator">=</span> <span class="number">0</span>, diag2 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">countX</span> <span class="operator">=</span> <span class="number">0</span>, countO = <span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">winX</span> <span class="operator">=</span> <span class="literal">false</span>, winO = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>; row &lt; <span class="number">3</span>; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; <span class="number">3</span>; col++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[row].charAt(col) == <span class="string">&#x27;X&#x27;</span>) &#123;</span><br><span class="line">                    countX++;</span><br><span class="line">                    rows[row] += <span class="number">1</span>;</span><br><span class="line">                    cols[col] += <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (row == col) &#123;</span><br><span class="line">                        diag1 += <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (row + col == <span class="number">2</span>) &#123;</span><br><span class="line">                        diag2 += <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (board[row].charAt(col) == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                    countO++;</span><br><span class="line">                    rows[row] -= <span class="number">1</span>;</span><br><span class="line">                    cols[col] -= <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (row == col) &#123;</span><br><span class="line">                        diag1 -= <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (row + col == <span class="number">2</span>) &#123;</span><br><span class="line">                        diag2 -= <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (rows[row] == <span class="number">3</span>) &#123;</span><br><span class="line">                    winX = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rows[row] == -<span class="number">3</span>) &#123;</span><br><span class="line">                    winO = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cols[col] == <span class="number">3</span>) &#123;</span><br><span class="line">                    winX = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cols[col] == -<span class="number">3</span>) &#123;</span><br><span class="line">                    winO = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (diag1 == <span class="number">3</span>) &#123;</span><br><span class="line">                    winX = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (diag1 == -<span class="number">3</span>) &#123;</span><br><span class="line">                    winO = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (diag2 == <span class="number">3</span>) &#123;</span><br><span class="line">                    winX = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (diag2 == -<span class="number">3</span>) &#123;</span><br><span class="line">                    winO = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (countX != countO &amp;&amp; countX != countO + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ((winX &amp;&amp; winO) || (winO &amp;&amp; countX != countO) ||</span><br><span class="line">           (winX &amp;&amp; countX != countO + <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="795-number-of-subarrays-with-bounded-maximum"><a href="#795-number-of-subarrays-with-bounded-maximum" class="headerlink" title="795. number-of-subarrays-with-bounded-maximum"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/number-of-subarrays-with-bounded-maximum/description/">795. number-of-subarrays-with-bounded-maximum</a></h4><ul>
<li>给一个数组和一个范围[L, R]，求该数组有多少个子数组，使得子数组的最大值落在[L, R]中。</li>
<li>首先想到DP，<code>dp[i][j]</code>表示从i到j的子数组的最大值，O(N^2)遍历的时候就可以顺便判断。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSubarrayBoundedMax</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> L, <span class="type">int</span> R)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || A.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span>  <span class="operator">=</span> A.length, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len][len];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                    dp[i][j] = A[j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j - <span class="number">1</span>], A[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &gt;= L &amp;&amp; dp[i][j] &lt;= R) &#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>follow-up：进一步优化，不使用额外的空间，同时时间复杂度降到O(N).</li>
<li>子数组的总量是一定的，既然求的是range，那首先求所有数都不超过max的子数组数量，然后求所有数都不超过(min - 1)的子数组的数量，两个一减就得到了在[min, max]之间的子数组的数量。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSubarrayBoundedMax</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> L, <span class="type">int</span> R)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || A.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> countSubarray(A, R) - countSubarray(A, L - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">countSubarray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> max)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curr</span> <span class="operator">=</span> <span class="number">0</span>, total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            curr = num &lt;= max ? curr + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            total += curr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="796-rotate-string"><a href="#796-rotate-string" class="headerlink" title="796. rotate-string"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/rotate-string/description/">796. rotate-string</a></h4><ul>
<li>给两个String，判断A能否通过shift变成B。</li>
<li>经典。观察可以得出A拼接上自身之后必须包含B才能保证shift得到B。时间复杂度<code>O(N^2)</code>.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">rotateString</span><span class="params">(String A, String B)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> A != <span class="literal">null</span> &amp;&amp; B != <span class="literal">null</span> &amp;&amp; A.length() == B.length() &amp;&amp; (A + A).contains(B);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>既然涉及在一个str中找另一个str，那么KMP也可以应用。首先对B做一个KMP存放common prefix&#x2F;suffix，然后在<code>S = A+A</code>中对B进行查找，注意S的索引只会一路向前移动，B的索引会在没匹配上时就能回退到”上一个同样前缀最后出现的位置”。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">rotateString</span><span class="params">(String A, String B)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || B == <span class="literal">null</span> || A.length() != B.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (A.equals(B)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对目标B构建fail function的数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> B.length();</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> dp[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; B.charAt(i) != B.charAt(j)) &#123;</span><br><span class="line">                j = dp[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (B.charAt(i) == B.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> A + A;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// 尝试比对B和S，不匹配就直接从fail function对应的前一段出现的相同前缀尾巴处继续比较，直到匹配或者耗尽可用前缀</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; B.charAt(j) != s.charAt(i)) &#123;</span><br><span class="line">                j = dp[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (B.charAt(j) == s.charAt(i)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == len) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
              <a href="/tags/algorithm/" rel="tag"># algorithm</a>
              <a href="/tags/interview/" rel="tag"># interview</a>
              <a href="/tags/leetcode/" rel="tag"># leetcode</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2017/11/28/udacity/" rel="prev" title="有代西滴">
                  <i class="fa fa-angle-left"></i> 有代西滴
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2018/01/05/java_leetcode6/" rel="next" title="Note for LeetCode in Java (800~1200)">
                  Note for LeetCode in Java (800~1200) <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2016 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="futbol-o"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Bob</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"bobbyliujb","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js" defer></script>

</body>
</html>
