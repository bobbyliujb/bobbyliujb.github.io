<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"bobbyliujb.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"hide","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="刷题。祝我好运。">
<meta property="og:type" content="article">
<meta property="og:title" content="Note for LeetCode in Java (800~1200)">
<meta property="og:url" content="https://bobbyliujb.github.io/2018/01/05/java_leetcode6/index.html">
<meta property="og:site_name" content="Bob&#39;s Blog">
<meta property="og:description" content="刷题。祝我好运。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2018-01-06T00:49:39.000Z">
<meta property="article:modified_time" content="2021-05-23T23:03:16.810Z">
<meta property="article:author" content="Bob">
<meta property="article:tag" content="java">
<meta property="article:tag" content="algorithm">
<meta property="article:tag" content="interview">
<meta property="article:tag" content="leetcode">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://bobbyliujb.github.io/2018/01/05/java_leetcode6/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://bobbyliujb.github.io/2018/01/05/java_leetcode6/","path":"2018/01/05/java_leetcode6/","title":"Note for LeetCode in Java (800~1200)"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Note for LeetCode in Java (800~1200) | Bob's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-118868735-1"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-118868735-1","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js" defer></script>








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Bob's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#802-find-eventual-safe-states"><span class="nav-number">1.</span> <span class="nav-text">802. find-eventual-safe-states</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#804-unique-morse-code-words"><span class="nav-number">2.</span> <span class="nav-text">804. unique-morse-code-words</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#805-find-mode-in-binary-search-tree"><span class="nav-number">3.</span> <span class="nav-text">805. find-mode-in-binary-search-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#806-number-of-lines-to-write-string"><span class="nav-number">4.</span> <span class="nav-text">806. number-of-lines-to-write-string</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#807-max-increase-to-keep-city-skyline"><span class="nav-number">5.</span> <span class="nav-text">807. max-increase-to-keep-city-skyline</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#809-expressive-words"><span class="nav-number">6.</span> <span class="nav-text">809. expressive-words</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#814-binary-tree-pruning"><span class="nav-number">7.</span> <span class="nav-text">814. binary-tree-pruning</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#817-linked-list-components"><span class="nav-number">8.</span> <span class="nav-text">817. linked-list-components</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#819-most-common-word"><span class="nav-number">9.</span> <span class="nav-text">819. most-common-word</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#821-shortest-distance-to-a-character"><span class="nav-number">10.</span> <span class="nav-text">821. shortest-distance-to-a-character</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#825-friends-of-appropriate-ages"><span class="nav-number">11.</span> <span class="nav-text">825. friends-of-appropriate-ages</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#827-making-a-large-island"><span class="nav-number">12.</span> <span class="nav-text">827. making-a-large-island</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#829-consecutive-numbers-sum"><span class="nav-number">13.</span> <span class="nav-text">829. consecutive-numbers-sum</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#833-find-and-replace-in-string"><span class="nav-number">14.</span> <span class="nav-text">833. find-and-replace-in-string</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#834-sum-of-distances-in-tree"><span class="nav-number">15.</span> <span class="nav-text">834. sum-of-distances-in-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#835-image-overlap"><span class="nav-number">16.</span> <span class="nav-text">835. image-overlap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#836-rectangle-overlap"><span class="nav-number">17.</span> <span class="nav-text">836. rectangle-overlap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#838-push-dominoes"><span class="nav-number">18.</span> <span class="nav-text">838. push-dominoes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#839-similar-string-groups"><span class="nav-number">19.</span> <span class="nav-text">839. similar-string-groups</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#841-keys-and-rooms"><span class="nav-number">20.</span> <span class="nav-text">841. keys-and-rooms</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#843-guess-the-word"><span class="nav-number">21.</span> <span class="nav-text">843. guess-the-word</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#844-backspace-string-compare"><span class="nav-number">22.</span> <span class="nav-text">844. backspace-string-compare</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#846-hand-of-straights"><span class="nav-number">23.</span> <span class="nav-text">846. hand-of-straights</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#849-maximize-distance-to-closest-person"><span class="nav-number">24.</span> <span class="nav-text">849. maximize-distance-to-closest-person</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#853-car-fleet"><span class="nav-number">25.</span> <span class="nav-text">853. car-fleet</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#854-k-similar-strings"><span class="nav-number">26.</span> <span class="nav-text">854. k-similar-strings</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#855-exam-room"><span class="nav-number">27.</span> <span class="nav-text">855. exam-room</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#858-mirror-reflection"><span class="nav-number">28.</span> <span class="nav-text">858. mirror-reflection</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#860-lemonade-change"><span class="nav-number">29.</span> <span class="nav-text">860. lemonade-change</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#863-all-nodes-distance-k-in-binary-tree"><span class="nav-number">30.</span> <span class="nav-text">863. all-nodes-distance-k-in-binary-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#864-shortest-path-to-get-all-keys"><span class="nav-number">31.</span> <span class="nav-text">864. shortest-path-to-get-all-keys</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#865-smallest-subtree-with-all-the-deepest-nodes"><span class="nav-number">32.</span> <span class="nav-text">865. smallest-subtree-with-all-the-deepest-nodes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#866-prime-palindrome"><span class="nav-number">33.</span> <span class="nav-text">866. prime-palindrome</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#872-leaf-similar-trees"><span class="nav-number">34.</span> <span class="nav-text">872. leaf-similar-trees</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#873-length-of-longest-fibonacci-subsequence"><span class="nav-number">35.</span> <span class="nav-text">873. length-of-longest-fibonacci-subsequence</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#875-koko-eating-bananas"><span class="nav-number">36.</span> <span class="nav-text">875. koko-eating-bananas</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#876-middle-of-the-linked-list"><span class="nav-number">37.</span> <span class="nav-text">876. middle-of-the-linked-list</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#877-stone-game"><span class="nav-number">38.</span> <span class="nav-text">877. stone-game</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#881-boats-to-save-people"><span class="nav-number">39.</span> <span class="nav-text">881. boats-to-save-people</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#885-spiral-matrix-iii"><span class="nav-number">40.</span> <span class="nav-text">885. spiral-matrix-iii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#886-possible-bipartition"><span class="nav-number">41.</span> <span class="nav-text">886. possible-bipartition</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#888-fair-candy-swap"><span class="nav-number">42.</span> <span class="nav-text">888. fair-candy-swap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#889-construct-binary-tree-from-preorder-and-postorder-traversal"><span class="nav-number">43.</span> <span class="nav-text">889. construct-binary-tree-from-preorder-and-postorder-traversal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#890-find-and-replace-pattern"><span class="nav-number">44.</span> <span class="nav-text">890. find-and-replace-pattern</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#891-sum-of-subsequence-widths"><span class="nav-number">45.</span> <span class="nav-text">891. sum-of-subsequence-widths</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#896-monotonic-array"><span class="nav-number">46.</span> <span class="nav-text">896. monotonic-array</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#897-increasing-order-search-tree"><span class="nav-number">47.</span> <span class="nav-text">897. increasing-order-search-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#901-online-stock-span"><span class="nav-number">48.</span> <span class="nav-text">901. online-stock-span</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#904-fruit-into-baskets"><span class="nav-number">49.</span> <span class="nav-text">904. fruit-into-baskets</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#905-sort-array-by-parity"><span class="nav-number">50.</span> <span class="nav-text">905. sort-array-by-parity</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#907-sum-of-subarray-minimums"><span class="nav-number">51.</span> <span class="nav-text">907. sum-of-subarray-minimums</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#909-snakes-and-ladders"><span class="nav-number">52.</span> <span class="nav-text">909. snakes-and-ladders</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#914-x-of-a-kind-in-a-deck-of-cards"><span class="nav-number">53.</span> <span class="nav-text">914. x-of-a-kind-in-a-deck-of-cards</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#915-partition-array-into-disjoint-intervals"><span class="nav-number">54.</span> <span class="nav-text">915. partition-array-into-disjoint-intervals</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#917-reverse-only-letters"><span class="nav-number">55.</span> <span class="nav-text">917. reverse-only-letters</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#918-maximum-sum-circular-subarray"><span class="nav-number">56.</span> <span class="nav-text">918. maximum-sum-circular-subarray</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#919-complete-binary-tree-inserter"><span class="nav-number">57.</span> <span class="nav-text">919. complete-binary-tree-inserter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#921-minimum-add-to-make-parentheses-valid"><span class="nav-number">58.</span> <span class="nav-text">921. minimum-add-to-make-parentheses-valid</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#930-binary-subarrays-with-sum"><span class="nav-number">59.</span> <span class="nav-text">930. binary-subarrays-with-sum</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#931-minimum-falling-path-sum-https-leetcode-com-problems-minimum-falling-path-sum"><span class="nav-number">60.</span> <span class="nav-text">[931.minimum-falling-path-sum] (https:&#x2F;&#x2F;leetcode.com&#x2F;problems&#x2F;minimum-falling-path-sum&#x2F;)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#935-knight-dialer"><span class="nav-number">61.</span> <span class="nav-text">935. knight-dialer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#937-reorder-data-in-log-files"><span class="nav-number">62.</span> <span class="nav-text">937. reorder-data-in-log-files</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#938-range-sum-of-bst"><span class="nav-number">63.</span> <span class="nav-text">938. range-sum-of-bst</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#939-minimum-area-rectangle"><span class="nav-number">64.</span> <span class="nav-text">939. minimum-area-rectangle</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#941-valid-mountain-array"><span class="nav-number">65.</span> <span class="nav-text">941. valid-mountain-array</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#942-di-string-match"><span class="nav-number">66.</span> <span class="nav-text">942. di-string-match</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#945-minimum-increment-to-make-array-unique"><span class="nav-number">67.</span> <span class="nav-text">945. minimum-increment-to-make-array-unique</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#946-validate-stack-sequences"><span class="nav-number">68.</span> <span class="nav-text">946. validate-stack-sequences</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#947-most-stones-removed-with-same-row-or-column"><span class="nav-number">69.</span> <span class="nav-text">947. most-stones-removed-with-same-row-or-column</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#950-reveal-cards-in-increasing-order"><span class="nav-number">70.</span> <span class="nav-text">950. reveal-cards-in-increasing-order</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#951-flip-equivalent-binary-trees"><span class="nav-number">71.</span> <span class="nav-text">951. flip-equivalent-binary-trees</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#953-verifying-an-alien-dictionary"><span class="nav-number">72.</span> <span class="nav-text">953. verifying-an-alien-dictionary</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#957-prison-cells-after-n-days"><span class="nav-number">73.</span> <span class="nav-text">957. prison-cells-after-n-days</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#958-check-completeness-of-a-binary-tree"><span class="nav-number">74.</span> <span class="nav-text">958. check-completeness-of-a-binary-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#963-minimum-area-rectangle-ii"><span class="nav-number">75.</span> <span class="nav-text">963. minimum-area-rectangle-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#965-univalued-binary-tree"><span class="nav-number">76.</span> <span class="nav-text">965. univalued-binary-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#968-binary-tree-cameras"><span class="nav-number">77.</span> <span class="nav-text">968. binary-tree-cameras</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#969-pancake-sorting"><span class="nav-number">78.</span> <span class="nav-text">969. pancake-sorting</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#971-flip-binary-tree-to-match-preorder-traversal"><span class="nav-number">79.</span> <span class="nav-text">971. flip-binary-tree-to-match-preorder-traversal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#973-k-closest-points-to-origin"><span class="nav-number">80.</span> <span class="nav-text">973. k-closest-points-to-origin</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#977-squares-of-a-sorted-array"><span class="nav-number">81.</span> <span class="nav-text">977. squares-of-a-sorted-array</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#979-distribute-coins-in-binary-tree"><span class="nav-number">82.</span> <span class="nav-text">979. distribute-coins-in-binary-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#981-time-based-key-value-store"><span class="nav-number">83.</span> <span class="nav-text">981. time-based-key-value-store</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#983-minimum-cost-for-tickets"><span class="nav-number">84.</span> <span class="nav-text">983. minimum-cost-for-tickets</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#986-interval-list-intersections"><span class="nav-number">85.</span> <span class="nav-text">986. interval-list-intersections</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#987-vertical-order-traversal-of-a-binary-tree"><span class="nav-number">86.</span> <span class="nav-text">987. vertical-order-traversal-of-a-binary-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#988-smallest-string-starting-from-leaf"><span class="nav-number">87.</span> <span class="nav-text">988. smallest-string-starting-from-leaf</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#992-subarrays-with-k-different-integers"><span class="nav-number">88.</span> <span class="nav-text">992. subarrays-with-k-different-integers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#993-cousins-in-binary-tree"><span class="nav-number">89.</span> <span class="nav-text">993. cousins-in-binary-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#994-rotting-oranges"><span class="nav-number">90.</span> <span class="nav-text">994. rotting-oranges</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#997-find-the-town-judge"><span class="nav-number">91.</span> <span class="nav-text">997. find-the-town-judge</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#998-maximum-binary-tree-ii"><span class="nav-number">92.</span> <span class="nav-text">998. maximum-binary-tree-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1003-check-if-word-is-valid-after-substitutions"><span class="nav-number">93.</span> <span class="nav-text">1003. check-if-word-is-valid-after-substitutions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1004-max-consecutive-ones-iii"><span class="nav-number">94.</span> <span class="nav-text">1004. max-consecutive-ones-iii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1007-minimum-domino-rotations-for-equal-row"><span class="nav-number">95.</span> <span class="nav-text">1007. minimum-domino-rotations-for-equal-row</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1008-construct-binary-search-tree-from-preorder-traversal"><span class="nav-number">96.</span> <span class="nav-text">1008. construct-binary-search-tree-from-preorder-traversal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1010-pairs-of-songs-with-total-durations-divisible-by-60"><span class="nav-number">97.</span> <span class="nav-text">1010. pairs-of-songs-with-total-durations-divisible-by-60</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1011-capacity-to-ship-packages-within-d-days"><span class="nav-number">98.</span> <span class="nav-text">1011. capacity-to-ship-packages-within-d-days</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1014-best-sightseeing-pair"><span class="nav-number">99.</span> <span class="nav-text">1014. best-sightseeing-pair</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1019-next-greater-node-in-linked-list"><span class="nav-number">100.</span> <span class="nav-text">1019. next-greater-node-in-linked-list</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1021-remove-outermost-parentheses"><span class="nav-number">101.</span> <span class="nav-text">1021. remove-outermost-parentheses</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1022-sum-of-root-to-leaf-binary-numbers"><span class="nav-number">102.</span> <span class="nav-text">1022. sum-of-root-to-leaf-binary-numbers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1024-video-stitching"><span class="nav-number">103.</span> <span class="nav-text">1024. video-stitching</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1026-maximum-difference-between-node-and-ancestor"><span class="nav-number">104.</span> <span class="nav-text">1026. maximum-difference-between-node-and-ancestor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1027-longest-arithmetic-sequence"><span class="nav-number">105.</span> <span class="nav-text">1027. longest-arithmetic-sequence</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1029-two-city-scheduling"><span class="nav-number">106.</span> <span class="nav-text">1029. two-city-scheduling</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1031-maximum-sum-of-two-non-overlapping-subarrays"><span class="nav-number">107.</span> <span class="nav-text">1031. maximum-sum-of-two-non-overlapping-subarrays</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1039-minimum-score-triangulation-of-polygon"><span class="nav-number">108.</span> <span class="nav-text">1039. minimum-score-triangulation-of-polygon</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1041-robot-bounded-in-circle"><span class="nav-number">109.</span> <span class="nav-text">1041. robot-bounded-in-circle</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1047-remove-all-adjacent-duplicates-in-string"><span class="nav-number">110.</span> <span class="nav-text">1047. remove-all-adjacent-duplicates-in-string</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1048-longest-string-chain"><span class="nav-number">111.</span> <span class="nav-text">1048. longest-string-chain</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1049-last-stone-weight-ii"><span class="nav-number">112.</span> <span class="nav-text">1049. last-stone-weight-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1051-height-checker"><span class="nav-number">113.</span> <span class="nav-text">1051. height-checker</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1052-grumpy-bookstore-owner"><span class="nav-number">114.</span> <span class="nav-text">1052. grumpy-bookstore-owner</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1053-previous-permutation-with-one-swap"><span class="nav-number">115.</span> <span class="nav-text">1053. previous-permutation-with-one-swap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1055-shortest-way-to-form-string"><span class="nav-number">116.</span> <span class="nav-text">1055. shortest-way-to-form-string</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1057-campus-bikes"><span class="nav-number">117.</span> <span class="nav-text">1057. campus-bikes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1060-missing-element-in-sorted-array"><span class="nav-number">118.</span> <span class="nav-text">1060. missing-element-in-sorted-array</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1062-longest-repeating-substring"><span class="nav-number">119.</span> <span class="nav-text">1062. longest-repeating-substring</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1066-campus-bikes-ii"><span class="nav-number">120.</span> <span class="nav-text">1066. campus-bikes-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1076-number-of-submatrices-that-sum-to-target"><span class="nav-number">121.</span> <span class="nav-text">1076. number-of-submatrices-that-sum-to-target</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1091-shortest-path-in-binary-matrix"><span class="nav-number">122.</span> <span class="nav-text">1091. shortest-path-in-binary-matrix</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1093-statistics-from-a-large-sample"><span class="nav-number">123.</span> <span class="nav-text">1093. statistics-from-a-large-sample</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1094-car-pooling"><span class="nav-number">124.</span> <span class="nav-text">1094. car-pooling</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1099-two-sum-less-than-k"><span class="nav-number">125.</span> <span class="nav-text">1099. two-sum-less-than-k</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1102-path-with-maximum-minimum-value"><span class="nav-number">126.</span> <span class="nav-text">1102. path-with-maximum-minimum-value</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1104-path-in-zigzag-labelled-binary-tree"><span class="nav-number">127.</span> <span class="nav-text">1104. path-in-zigzag-labelled-binary-tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1105-filling-bookcase-shelves"><span class="nav-number">128.</span> <span class="nav-text">1105. filling-bookcase-shelves</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1109-corporate-flight-bookings"><span class="nav-number">129.</span> <span class="nav-text">1109. corporate-flight-bookings</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1110-delete-nodes-and-return-forest"><span class="nav-number">130.</span> <span class="nav-text">1110. delete-nodes-and-return-forest</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1120-maximum-average-subtree"><span class="nav-number">131.</span> <span class="nav-text">1120. maximum-average-subtree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1122-relative-sort-array"><span class="nav-number">132.</span> <span class="nav-text">1122. relative-sort-array</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1123-lowest-common-ancestor-of-deepest-leaves"><span class="nav-number">133.</span> <span class="nav-text">1123. lowest-common-ancestor-of-deepest-leaves</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1130-minimum-cost-tree-from-leaf-values"><span class="nav-number">134.</span> <span class="nav-text">1130. minimum-cost-tree-from-leaf-values</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1140-stone-game-ii"><span class="nav-number">135.</span> <span class="nav-text">1140. stone-game-ii</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1143-longest-common-subsequence"><span class="nav-number">136.</span> <span class="nav-text">1143. longest-common-subsequence</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1145-binary-tree-coloring-game"><span class="nav-number">137.</span> <span class="nav-text">1145. binary-tree-coloring-game</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1146-snapshot-array"><span class="nav-number">138.</span> <span class="nav-text">1146. snapshot-array</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1152-analyze-user-website-visit-pattern"><span class="nav-number">139.</span> <span class="nav-text">1152. analyze-user-website-visit-pattern</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1153-string-transforms-into-another-string"><span class="nav-number">140.</span> <span class="nav-text">1153. string-transforms-into-another-string</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1154-ordinal-number-of-date"><span class="nav-number">141.</span> <span class="nav-text">1154.ordinal-number-of-date</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1155-number-of-dice-rolls-with-target-sum"><span class="nav-number">142.</span> <span class="nav-text">1155. number-of-dice-rolls-with-target-sum</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1167-minimum-cost-to-connect-sticks"><span class="nav-number">143.</span> <span class="nav-text">1167. minimum-cost-to-connect-sticks</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1171-remove-zero-sum-consecutive-nodes-from-linked-list"><span class="nav-number">144.</span> <span class="nav-text">1171. remove-zero-sum-consecutive-nodes-from-linked-list</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1177-can-make-palindrome-from-substring"><span class="nav-number">145.</span> <span class="nav-text">1177. can-make-palindrome-from-substring</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1181-before-and-after-puzzle"><span class="nav-number">146.</span> <span class="nav-text">1181. before-and-after-puzzle</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1185-day-of-the-week"><span class="nav-number">147.</span> <span class="nav-text">1185. day-of-the-week</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1186-maximum-subarray-sum-with-one-deletion"><span class="nav-number">148.</span> <span class="nav-text">1186.maximum-subarray-sum-with-one-deletion&#x2F;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1187-make-array-strictly-increasing"><span class="nav-number">149.</span> <span class="nav-text">1187. make-array-strictly-increasing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1190-reverse-substrings-between-each-pair-of-parentheses"><span class="nav-number">150.</span> <span class="nav-text">1190. reverse-substrings-between-each-pair-of-parentheses</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1192-critical-connections-in-a-network"><span class="nav-number">151.</span> <span class="nav-text">1192. critical-connections-in-a-network</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1197-minimum-knight-moves"><span class="nav-number">152.</span> <span class="nav-text">1197. minimum-knight-moves</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Bob"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Bob</p>
  <div class="site-description" itemprop="description">I'm a Software Engineer!</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">48</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">49</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://bobbyliujb.github.io/2018/01/05/java_leetcode6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bob">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bob's Blog">
      <meta itemprop="description" content="I'm a Software Engineer!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Note for LeetCode in Java (800~1200) | Bob's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Note for LeetCode in Java (800~1200)
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-01-05 16:49:39" itemprop="dateCreated datePublished" datetime="2018-01-05T16:49:39-08:00">2018-01-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-05-23 16:03:16" itemprop="dateModified" datetime="2021-05-23T16:03:16-07:00">2021-05-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Tech/" itemprop="url" rel="index"><span itemprop="name">Tech</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2018/01/05/java_leetcode6/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/01/05/java_leetcode6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>刷题。祝我好运。</p>
<span id="more"></span>

<h4 id="802-find-eventual-safe-states"><a href="#802-find-eventual-safe-states" class="headerlink" title="802. find-eventual-safe-states"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-eventual-safe-states/description/">802. find-eventual-safe-states</a></h4><ul>
<li>给一个2D array，每一个行数组表示该index的邻居，所有的点和边可以形成directed graph。求所有最终能稳定的点（所有的邻居点都不会陷入一个无限循环的path）。</li>
<li>DFS过程中记录当前path的visited情况，一旦回头了就说明当前节点是有环（无限）的。利用memo来提升DFS性能，防止重复DFS。事实上可以利用bucket代替visited的功能，例如赋一个特殊值表示on path。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">eventualSafeNodes</span><span class="params">(<span class="type">int</span>[][] graph)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (graph == <span class="literal">null</span> || graph.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span>[] bucket = <span class="keyword">new</span> <span class="title class_">int</span>[graph.length];</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[graph.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dfs(graph, i, bucket, visited)) &#123;</span><br><span class="line">                ans.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] graph, <span class="type">int</span> index, <span class="type">int</span>[] bucket, <span class="type">boolean</span>[] visited)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (bucket[index] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bucket[index] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[index] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> neighbor : graph[index]) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (visited[neighbor] || !dfs(graph, neighbor, bucket, visited)) &#123;</span><br><span class="line">                bucket[index] = -<span class="number">1</span>;</span><br><span class="line">                visited[index] = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[index] = <span class="literal">false</span>;</span><br><span class="line">        bucket[index] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="804-unique-morse-code-words"><a href="#804-unique-morse-code-words" class="headerlink" title="804. unique-morse-code-words"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/unique-morse-code-words/description/">804. unique-morse-code-words</a></h4><ul>
<li>摩斯电码转换，记录总共出现了几种不同的组合。skip.</li>
</ul>
<h4 id="805-find-mode-in-binary-search-tree"><a href="#805-find-mode-in-binary-search-tree" class="headerlink" title="805. find-mode-in-binary-search-tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-mode-in-binary-search-tree/">805. find-mode-in-binary-search-tree</a></h4><ul>
<li>给一个特殊BST（左右子树不是严格小于&#x2F;大于，可以等于），求节点的众数，可能有多个众树，按任意顺序返回。不能使用Map。</li>
<li>inorder + twopass.第一次先求出众数，第二次则是将计数与众数匹配的存入结果。pass。</li>
</ul>
<h4 id="806-number-of-lines-to-write-string"><a href="#806-number-of-lines-to-write-string" class="headerlink" title="806. number-of-lines-to-write-string"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/number-of-lines-to-write-string/description/">806. number-of-lines-to-write-string</a></h4><ul>
<li>输出字母求需要占用多少宽度。skip.</li>
</ul>
<h4 id="807-max-increase-to-keep-city-skyline"><a href="#807-max-increase-to-keep-city-skyline" class="headerlink" title="807. max-increase-to-keep-city-skyline"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/max-increase-to-keep-city-skyline/description/">807. max-increase-to-keep-city-skyline</a></h4><ul>
<li>给一个二维数组表示各个摩天大楼的高度，从左右两侧和前后两侧看的skyline相同的情况下，最多共可以升高多少。skip.</li>
</ul>
<h4 id="809-expressive-words"><a href="#809-expressive-words" class="headerlink" title="809. expressive-words"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/expressive-words/">809. expressive-words</a></h4><ul>
<li>给一个字符串<code>S</code>和一个字符串数组，判断数组中有多少个可以stretch成<code>S</code>. stretch规则是，对于一组相同的字母可以通过扩展得到S中相应的一组、且stretch后S中该组字母组个数不少于3个。</li>
<li>暴力解。通过cache提速。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">expressiveWords</span><span class="params">(String S, String[] words)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (S == <span class="literal">null</span> || S.length() == <span class="number">0</span> || words == <span class="literal">null</span> || words.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Set&lt;String&gt; matchSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; notMatchSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matchSet.contains(word)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (notMatchSet.contains(word)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isStretchy(S, word)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                matchSet.add(word);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                notMatchSet.add(word);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isStretchy</span><span class="params">(String source, String target)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] sourceCharArray = source.toCharArray(), targetCharArray = target.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sourceIndex</span> <span class="operator">=</span> <span class="number">0</span>, targetIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (sourceIndex &lt; sourceCharArray.length &amp;&amp; targetIndex &lt; targetCharArray.length) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> sourceCharArray[sourceIndex];</span><br><span class="line">            <span class="type">int</span> <span class="variable">sourceCount</span> <span class="operator">=</span> <span class="number">0</span>, targetCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (sourceIndex &lt; sourceCharArray.length &amp;&amp; sourceCharArray[sourceIndex] == c) &#123;</span><br><span class="line">                sourceCount++;</span><br><span class="line">                sourceIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (targetIndex &lt; targetCharArray.length &amp;&amp; targetCharArray[targetIndex] == c) &#123;</span><br><span class="line">                targetCount++;</span><br><span class="line">                targetIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (targetCount &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                (targetCount == sourceCount || (sourceCount &gt; targetCount &amp;&amp; sourceCount &gt;= <span class="number">3</span>))) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;   <span class="comment">// 注意必须sourceCount超过sourceCount</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sourceIndex == sourceCharArray.length &amp;&amp; targetIndex == targetCharArray.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="814-binary-tree-pruning"><a href="#814-binary-tree-pruning" class="headerlink" title="814. binary-tree-pruning"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-pruning/">814. binary-tree-pruning</a></h4><ul>
<li>给一个只含有1&#x2F;0的二叉树，如果一个subtree只含有0，需要把这部分消去。返回消去后的树。</li>
<li>递归搞定。pass。</li>
</ul>
<h4 id="817-linked-list-components"><a href="#817-linked-list-components" class="headerlink" title="817. linked-list-components"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/linked-list-components/description/">817. linked-list-components</a></h4><ul>
<li>给一个链表表示int之间的链接关系，给一个数组，求数组中在链表中连续出现的团簇数。</li>
<li>将数组的元素放入Set后开始遍历链表，Set中存在该元素就remove掉，不存在则结束统计前一个团簇，开始找下一个团簇，最后return之前还需要判断是否已经找到了团簇。</li>
</ul>
<h4 id="819-most-common-word"><a href="#819-most-common-word" class="headerlink" title="819. most-common-word"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/most-common-word/description/">819. most-common-word</a></h4><ul>
<li>给一段String文本，给一个banned数组作为stopword，求最频繁出现的词。split之后统计频数即可，skip。</li>
</ul>
<h4 id="821-shortest-distance-to-a-character"><a href="#821-shortest-distance-to-a-character" class="headerlink" title="821. shortest-distance-to-a-character"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/shortest-distance-to-a-character/">821. shortest-distance-to-a-character</a></h4><ul>
<li>给一个字符串S和一个特定字符C，C一定会出现在S中，求各个位置的字符距离最近的字符C的距离。</li>
<li>2-pass的做法，首先从左往右更新，若当前字符为C则将index设为该索引，这样后续的距离就是i - index了。需要注意的是初始化时为了让i - index尽量大，需要初始化为负的数组长度。这一波结束之后，得到的是距离左边最近的C的距离，那么再从右往左更新即可，注意由于index可能比i小，需要取abs。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] shortestToChar(String S, <span class="type">char</span> C) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S == <span class="literal">null</span> || S.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] retVal = <span class="keyword">new</span> <span class="title class_">int</span>[S.length()];</span><br><span class="line">        <span class="type">char</span>[] charS = S.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -S.length();    <span class="comment">// 保证一开始的字符足够大</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; charS.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (charS[i] == C) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">            retVal[i] = i - index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> charS.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (charS[i] == C) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">            retVal[i] = Math.min(Math.abs(index - i), retVal[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="825-friends-of-appropriate-ages"><a href="#825-friends-of-appropriate-ages" class="headerlink" title="825. friends-of-appropriate-ages"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/friends-of-appropriate-ages/">825. friends-of-appropriate-ages</a></h4><ul>
<li>给一个int数组表示用户的年龄，假设<code>age[B] &lt;= 0.5 * age[A] + 7</code>, <code>age[B] &gt; age[A]</code>, <code>age[B] &gt; 100 &amp;&amp; age[A] &lt; 100</code>的情况下A都不会给B发好友request，求共有多少个request。</li>
<li>首先把题目条件简化得到「A会给B发好友request」的区间，然后考虑如何快速得到对应年龄范围的人数——runningSum法。之后就是对每一个年龄求他和多少好友会发request，注意for-loop的起始索引。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numFriendRequests</span><span class="params">(<span class="type">int</span>[] ages)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ages == <span class="literal">null</span> || ages.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ageCount = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">121</span>];  <span class="comment">// 每个年龄有多少人</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> age : ages) &#123;</span><br><span class="line">            ageCount[age]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] sums = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">121</span>];      <span class="comment">// runningSum快速求给定年龄区间的人数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; ageCount.length; i++) &#123;</span><br><span class="line">            sums[i] = sums[i - <span class="number">1</span>] + ageCount[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">15</span>; i &lt; sums.length; i++) &#123;    <span class="comment">// 注意需要从15开始</span></span><br><span class="line">            <span class="keyword">if</span> (ageCount[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> sums[i] - sums[i / <span class="number">2</span> + <span class="number">7</span>];  <span class="comment">// 当前与合适范围年龄的request数</span></span><br><span class="line">            ans += count * ageCount[i] - ageCount[i];   <span class="comment">// 减去自己给自己的request</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="827-making-a-large-island"><a href="#827-making-a-large-island" class="headerlink" title="827. making-a-large-island"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/making-a-large-island/description/">827. making-a-large-island</a></h4><ul>
<li>给一个只含有0和1的grid，求将其中某一个0替换成1后形成island的最大面积。如果没有0则是整个棋盘的面积。</li>
<li>对于每一个1进行连通上色，同时维护一个colorMap表示每种颜色对应的island有多少。最后再遍历每一个0看看它周围四个方向分别是什么颜色，然后对应取个数即可。用一个getValue的wrapper函数专门用于访问matrix中的值，让代码简洁了不少。BFS和DFS都差不多。BFS需要注意上色时机，在加入queue的时候就需要上色，否则上下左右的时候可能会重复上色。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestIsland</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> grid.length, cols = grid[<span class="number">0</span>].length;</span><br><span class="line">        List&lt;Integer&gt; colorSize = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();   <span class="comment">// force color starts with 2</span></span><br><span class="line">        colorSize.add(<span class="number">0</span>);</span><br><span class="line">        colorSize.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// colorSize.add(dfs(grid, i, j, colorSize.size()));</span></span><br><span class="line">                    colorSize.add(bfs(grid, i, j, colorSize.size()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">                    set.add(getValue(grid, i - <span class="number">1</span>, j));</span><br><span class="line">                    set.add(getValue(grid, i + <span class="number">1</span>, j));</span><br><span class="line">                    set.add(getValue(grid, i, j - <span class="number">1</span>));</span><br><span class="line">                    set.add(getValue(grid, i, j + <span class="number">1</span>));</span><br><span class="line">                    <span class="type">int</span> <span class="variable">curr</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span> (Integer color : set) &#123;</span><br><span class="line">                        curr += colorSize.get(color);</span><br><span class="line">                    &#125;</span><br><span class="line">                    max = Math.max(curr + <span class="number">1</span>, max);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max == <span class="number">0</span> ? rows * cols : max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// wrap到一个函数中去访问cell，省去很多判断</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (i &lt; <span class="number">0</span> || i &gt;= grid.length || j &lt; <span class="number">0</span> || j &gt;= grid[<span class="number">0</span>].length) ? <span class="number">0</span> : grid[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> color)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (getValue(grid, i, j) != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j] = color;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + dfs(grid, i - <span class="number">1</span>, j, color) + dfs(grid, i + <span class="number">1</span>, j, color)</span><br><span class="line">            + dfs(grid, i, j - <span class="number">1</span>, color) + dfs(grid, i, j + <span class="number">1</span>, color);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> color)</span> &#123;</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.offer(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;i, j&#125;);</span><br><span class="line">        grid[i][j] = color;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">currSize</span> <span class="operator">=</span> q.size();</span><br><span class="line">            size += currSize;</span><br><span class="line">            <span class="keyword">while</span> (currSize-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span>[] temp = q.poll();</span><br><span class="line">                <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> temp[<span class="number">0</span>], col = temp[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (getValue(grid, row - <span class="number">1</span>, col) == <span class="number">1</span>) &#123;</span><br><span class="line">                    q.offer(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;row - <span class="number">1</span>, col&#125;);</span><br><span class="line">                    grid[row - <span class="number">1</span>][col] = color;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (getValue(grid, row + <span class="number">1</span>, col) == <span class="number">1</span>) &#123;</span><br><span class="line">                    q.offer(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;row + <span class="number">1</span>, col&#125;);</span><br><span class="line">                    grid[row + <span class="number">1</span>][col] = color;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (getValue(grid, row, col - <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                    q.offer(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;row, col - <span class="number">1</span>&#125;);</span><br><span class="line">                    grid[row][col - <span class="number">1</span>] = color;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (getValue(grid, row, col + <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                    q.offer(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;row, col + <span class="number">1</span>&#125;);</span><br><span class="line">                    grid[row][col + <span class="number">1</span>] = color;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="829-consecutive-numbers-sum"><a href="#829-consecutive-numbers-sum" class="headerlink" title="829. consecutive-numbers-sum"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/consecutive-numbers-sum/">829. consecutive-numbers-sum</a></h4><ul>
<li>给一个正整数N，求它等于多少组连续正整数之和。例如<code>1</code>就它本身1种，<code>9 = 9 = 4 + 5 = 2 + 3 + 4</code>共3种。</li>
<li>数学规律，<a target="_blank" rel="noopener" href="https://leetcode.com/problems/consecutive-numbers-sum/discuss/129015/5-lines-C%2B%2B-solution-with-detailed-mathematical-explanation.">这里</a>有很好的解释。本质上就是遍历可能的k求模，如果可以整除就说明是一种可能。时间复杂度<code>log(sqrtN)</code>.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">consecutiveNumbersSum</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (N &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt; Math.sqrt(<span class="number">2</span> * N); k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((N - (k - <span class="number">1</span>) * k / <span class="number">2</span>) % k == <span class="number">0</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="833-find-and-replace-in-string"><a href="#833-find-and-replace-in-string" class="headerlink" title="833. find-and-replace-in-string"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-and-replace-in-string/description/">833. find-and-replace-in-string</a></h4><ul>
<li>给一个原字符串S，给indexes索引数组和两个字符串数组sources和targets，对于indexes中每一个索引判断是否由sources中对应的字符串startsWith，是则替换撑targets。</li>
<li>由于target替换后对原字符串的长度可能有影响，因此不能直接用index来替换。使用一个indexDelta记录每次成功替换之后后续的index需要平移多少。注意需要保证index是从小到大进行替换的，否则后面的平移不应该影响到前面的平移。</li>
</ul>
<h4 id="834-sum-of-distances-in-tree"><a href="#834-sum-of-distances-in-tree" class="headerlink" title="834. sum-of-distances-in-tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sum-of-distances-in-tree/">834. sum-of-distances-in-tree</a></h4><ul>
<li>给一个共有N个节点的无向连通树，编号为<code>0 ~ N-1</code>，求每一个节点到其他所有节点的距离和。</li>
<li>从一个节点出发到其他所有节点是<code>O(N)</code>，如果暴力求每个节点那就是<code>O(N^2)</code>. 但是在遍历的过程中显然有很多重复的计算。观察到一个规律就是从一个parent节点到它的孩子节点时，parent节点到前序节点的距离变长、到后续节点的距离变近。如果给定一个节点能够知道它subtree总共含有多少个节点，那么距离就加&#x2F;减这部分节点即可。因此解法是，构建图（树）之后，首先进行后序遍历维护一个nodeCounts数组来知道每个节点及其下方有多少节点，采用后序是因为parent需要依赖于所有孩子节点的nodeCounts。遍历过程中可以通过prev来防止往回递归。在后序遍历的同时维护result数组表示每个节点到它所有的孩子节点的距离只和。下一步进行前序遍历，对于每一个孩子节点都依赖于parent节点的距离和，到paernt即前序节点的距离++、到该孩子后序节点的距离–，对应过来就是<code>result[parent] - nodeCounts[child] + (N - nodeCounts[child])</code>.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sumOfDistancesInTree(<span class="type">int</span> N, <span class="type">int</span>[][] edges) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edges == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt;[] graph = buildGraph(N, edges);</span><br><span class="line">        <span class="type">int</span>[] nodeCounts = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        postOrder(-<span class="number">1</span>, <span class="number">0</span>, graph, nodeCounts, result);</span><br><span class="line">        preOrder(-<span class="number">1</span>, <span class="number">0</span>, graph, nodeCounts, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(<span class="type">int</span> prev, <span class="type">int</span> curr, Set&lt;Integer&gt;[] graph, <span class="type">int</span>[] nodeCounts, <span class="type">int</span>[] result)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> neighbor : graph[curr]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (neighbor == prev) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            postOrder(curr, neighbor, graph, nodeCounts, result);</span><br><span class="line">            nodeCounts[curr] += nodeCounts[neighbor];</span><br><span class="line">            result[curr] += result[neighbor] + nodeCounts[neighbor];</span><br><span class="line">        &#125;</span><br><span class="line">        nodeCounts[curr]++; <span class="comment">// curr本身</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(<span class="type">int</span> prev, <span class="type">int</span> curr, Set&lt;Integer&gt;[] graph, <span class="type">int</span>[] nodeCounts, <span class="type">int</span>[] result)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> neighbor : graph[curr]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (neighbor == prev) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result[neighbor] = result[curr] - nodeCounts[neighbor] + (nodeCounts.length - nodeCounts[neighbor]);</span><br><span class="line">            preOrder(curr, neighbor, graph, nodeCounts, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Integer&gt;[] buildGraph(<span class="type">int</span> N, <span class="type">int</span>[][] edges) &#123;</span><br><span class="line">        Set&lt;Integer&gt;[] graph = <span class="keyword">new</span> <span class="title class_">Set</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">            graph[edge[<span class="number">0</span>]].add(edge[<span class="number">1</span>]);</span><br><span class="line">            graph[edge[<span class="number">1</span>]].add(edge[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> graph;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="835-image-overlap"><a href="#835-image-overlap" class="headerlink" title="835. image-overlap"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/image-overlap/description/">835. image-overlap</a></h4><ul>
<li>给两个binary square matrix，只有0和1两个数值，将两个矩阵上下左右移动，问重叠的1最多有多少个。</li>
<li>将二维问题flatten成一维，然后在一维List中遍历每一个cell与另一个矩阵的每一个cell重叠后是否都是1，然后将结果存入map。如何判定是否是相同的平移之后的结果呢？利用一维List的索引之差即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestOverlap</span><span class="params">(<span class="type">int</span>[][] A, <span class="type">int</span>[][] B)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || B == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> A.length;</span><br><span class="line">        List&lt;Integer&gt; listA = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; listB = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N * N; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i / N][i % N] == <span class="number">1</span>) &#123;</span><br><span class="line">                listA.add(i / N * <span class="number">100</span> + i % N);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (B[i / N][i % N] == <span class="number">1</span>) &#123;</span><br><span class="line">                listB.add(i / N * <span class="number">100</span> + i % N);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        Map&lt;Integer, Integer&gt; count = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : listA) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j : listB) &#123;</span><br><span class="line">                count.put(i - j, count.getOrDefault(i - j, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> val : count.values()) &#123;</span><br><span class="line">            max = Math.max(max, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="836-rectangle-overlap"><a href="#836-rectangle-overlap" class="headerlink" title="836. rectangle-overlap"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/rectangle-overlap/description/">836. rectangle-overlap</a></h4><ul>
<li>给两个数组表示二维平面中矩形左下角的定点和右上角的定点。判断是否overlap。</li>
<li>转换成一维线段来判断，两个线段有overlap的充分必要条件是<code>left1 &lt; right2 &amp;&amp; left2 &lt; right1</code>，那么推广到2D中就是x方向上用一次、y方向上用一次，都满足就一定有overlap了。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isRectangleOverlap</span><span class="params">(<span class="type">int</span>[] rec1, <span class="type">int</span>[] rec2)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rec1[<span class="number">0</span>] &lt; rec2[<span class="number">2</span>] &amp;&amp; rec2[<span class="number">0</span>] &lt; rec1[<span class="number">2</span>] &amp;&amp; rec1[<span class="number">1</span>] &lt; rec2[<span class="number">3</span>] &amp;&amp; rec2[<span class="number">1</span>] &lt; rec1[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="838-push-dominoes"><a href="#838-push-dominoes" class="headerlink" title="838. push-dominoes"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/push-dominoes/">838. push-dominoes</a></h4><ul>
<li>给一个只含有<code>R</code>, <code>L</code>, <code>.</code>的字符串，表示往右或者往左推多米诺骨牌，假设所有推都同时发力，求最后的倾斜状态。</li>
<li>方法一：双指针一前一后，如果前后指针指向的是一样的方向，那这段中间直接填满即可；如果恰好是后指针是向右、前指针是向左，则填充中间部分即可。其他情况直接维持原字符串不变。需要在一头一尾加上<code>L</code>、<code>R</code>。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">pushDominoes</span><span class="params">(String dominoes)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (dominoes == <span class="literal">null</span> || dominoes.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dominoes;</span><br><span class="line">        &#125;</span><br><span class="line">        dominoes = <span class="string">&quot;L&quot;</span> + dominoes + <span class="string">&quot;R&quot;</span>;</span><br><span class="line">        <span class="type">char</span>[] chars = dominoes.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>, len = chars.length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (left &lt; len - <span class="number">1</span>) &#123;</span><br><span class="line">            right = left + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (right &lt; len &amp;&amp; chars[right] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (chars[left] == chars[right]) &#123;</span><br><span class="line">                Arrays.fill(chars, left, right + <span class="number">1</span>, chars[left]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (chars[left] == <span class="string">&#x27;R&#x27;</span> &amp;&amp; chars[right] == <span class="string">&#x27;L&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">delta</span> <span class="operator">=</span> (right - left - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                Arrays.fill(chars, left, left + delta + <span class="number">1</span>, chars[left]);</span><br><span class="line">                Arrays.fill(chars, right - delta, right + <span class="number">1</span>, chars[right]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            left = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(Arrays.copyOfRange(chars, <span class="number">1</span>, len - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：物理法，需要维护一个force数组，从左到右看看R有多强、从右到左看L有多强，在每一个对应点根据正、负情况来赋字符即可。</li>
</ul>
<h4 id="839-similar-string-groups"><a href="#839-similar-string-groups" class="headerlink" title="839. similar-string-groups"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/similar-string-groups/description/">839. similar-string-groups</a></h4><ul>
<li>给一个长度相同且互为anagram的String数组，求总共有多少组similar的词。similar指的是A只swap一对儿字符能够equal B。</li>
<li>DFS&#x2F;BFS均可，访问每个word时往后搜只有两位字符不同的标记为visited，这样当前dfs完成后就是一个similar group.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSimilarGroups</span><span class="params">(String[] A)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || A.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[A.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                visited[i] = <span class="literal">true</span>;</span><br><span class="line">                dfs(A, A[i], visited);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(String[] A, String str, <span class="type">boolean</span>[] visited)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i] &amp;&amp; isDiffBy2(str, A[i])) &#123;</span><br><span class="line">                visited[i] = <span class="literal">true</span>;</span><br><span class="line">                dfs(A, A[i], visited);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isDiffBy2</span><span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str1.charAt(i) != str2.charAt(i)) &#123;</span><br><span class="line">                diff++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (diff &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="841-keys-and-rooms"><a href="#841-keys-and-rooms" class="headerlink" title="841. keys-and-rooms"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/keys-and-rooms/description/">841. keys-and-rooms</a></h4><ul>
<li>给一个rooms nested list，每一个row list表示该room存放的所有key list，一开始只有room 0可以进入，其余房间都必须有对应钥匙才能进入。判断能否进所有的房间。BFS和DFS都可以搞定。</li>
</ul>
<h4 id="843-guess-the-word"><a href="#843-guess-the-word" class="headerlink" title="843. guess-the-word"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/guess-the-word/description/">843. guess-the-word</a></h4><ul>
<li>给一个String数组，每一个词都是6个字符，通过调用给定的API猜其中的一个secret word，每次调用API时都会返回所给词和secret词的match字符数。</li>
<li>通过random的办法，随机选取一个String猜，然后根据返回的字符匹配数，将原List中所有和所给字符串匹配数相等的字符保留下来，然后继续随机取字符串去猜。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findSecretWord</span><span class="params">(String[] wordlist, Master master)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (wordlist == <span class="literal">null</span> || wordlist.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; wordList = Arrays.asList(wordlist);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, ret = <span class="number">0</span>; i &lt; <span class="number">10</span> &amp;&amp; ret &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> wordList.get(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(wordList.size()));</span><br><span class="line">            ret = master.guess(input);</span><br><span class="line">            List&lt;String&gt; wordListNew = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (String word : wordList) &#123;</span><br><span class="line">                <span class="keyword">if</span> (getMatchCount(word, input) == ret) &#123;</span><br><span class="line">                    wordListNew.add(word);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            wordList = wordListNew;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMatchCount</span><span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str1.charAt(i) == str2.charAt(i)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>纯粹的随机并不是一个最优策略，可以先在给定的String数组内部找到「与其他字符串完全不match最少的」字符串来猜。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findSecretWord</span><span class="params">(String[] wordlist, Master master)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (wordlist == <span class="literal">null</span> || wordlist.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; wordList = Arrays.asList(wordlist);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, ret = <span class="number">0</span>; i &lt; <span class="number">10</span> &amp;&amp; ret &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            Map&lt;String, Integer&gt; zeroMatchCount = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (String str1 : wordList) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String str2 : wordList) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (getMatchCount(str1, str2) == <span class="number">0</span>) &#123;</span><br><span class="line">                        zeroMatchCount.put(str1, zeroMatchCount.getOrDefault(str1, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">minZeroCount</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">            <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (String str : wordList) &#123;</span><br><span class="line">                <span class="keyword">if</span> (zeroMatchCount.getOrDefault(str, <span class="number">0</span>) &lt; minZeroCount) &#123;</span><br><span class="line">                    input = str;</span><br><span class="line">                    minZeroCount = zeroMatchCount.getOrDefault(str, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret = master.guess(input);</span><br><span class="line">            List&lt;String&gt; wordListNew = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (String word : wordList) &#123;</span><br><span class="line">                <span class="keyword">if</span> (getMatchCount(word, input) == ret) &#123;</span><br><span class="line">                    wordListNew.add(word);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            wordList = wordListNew;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="844-backspace-string-compare"><a href="#844-backspace-string-compare" class="headerlink" title="844. backspace-string-compare"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/backspace-string-compare/description/">844. backspace-string-compare</a></h4><ul>
<li>给两个字符串，含有<code>#</code>表示backspace回删符号，判断这两个字符串是否相等。</li>
<li>面试原题，从后往前判断即可达到O(1)空间。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backspaceCompare</span><span class="params">(String S, String T)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (S == <span class="literal">null</span> || T == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">indexS</span> <span class="operator">=</span> S.length() - <span class="number">1</span>, indexT = T.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            indexS = getPrevIndex(S, indexS);</span><br><span class="line">            indexT = getPrevIndex(T, indexT);</span><br><span class="line">            <span class="keyword">if</span> (indexS &lt; <span class="number">0</span> &amp;&amp; indexT &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (indexS &lt; <span class="number">0</span> || indexT &lt; <span class="number">0</span> || S.charAt(indexS) != T.charAt(indexT)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            indexS--;</span><br><span class="line">            indexT--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getPrevIndex</span><span class="params">(String str, <span class="type">int</span> currIndex)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">delCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (currIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(currIndex) == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                delCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (delCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    delCount--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;   <span class="comment">// 直到找到新的可供对比的字符</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            currIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="846-hand-of-straights"><a href="#846-hand-of-straights" class="headerlink" title="846. hand-of-straights"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/hand-of-straights/description/">846. hand-of-straights</a></h4><ul>
<li>给一个int数组表示一手牌，给一个整数W表示每一组牌的个数，判断是否可以重新整理形成顺子，每组顺子size都是W。</li>
<li>对于每一个顺子，每一个数的总出现次数必须比最小的数的出现次数大，才能保证顺子的形成。因此考虑使用一个TreeMap将每个value和count存起来，然后从最小值开始遍历，将顺子中需要的value的count都对应消耗掉与最小值相等的量，一旦不符合就说明顺子断了。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNStraightHand</span><span class="params">(<span class="type">int</span>[] hand, <span class="type">int</span> W)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hand == <span class="literal">null</span> || hand.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (W == <span class="number">0</span> || hand.length % W != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : hand) &#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(num) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> W - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;  <span class="comment">// 遍历顺子中每个值</span></span><br><span class="line">                    <span class="keyword">if</span> (map.getOrDefault(num + i, <span class="number">0</span>) &lt; map.get(num)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    map.put(num + i, map.get(num + i) - map.get(num));  <span class="comment">// 必须消耗掉与最小值对应的数量</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="849-maximize-distance-to-closest-person"><a href="#849-maximize-distance-to-closest-person" class="headerlink" title="849. maximize-distance-to-closest-person"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximize-distance-to-closest-person/description/">849. maximize-distance-to-closest-person</a></h4><ul>
<li>给一个只含有0和1的数组，0表示没人坐，1表示有人坐，求某一个0使得离最近的人最远，返回最远距离。</li>
<li>分情况讨论，如果最远出现在两侧以及出现在两个1之间。skip。</li>
</ul>
<h4 id="853-car-fleet"><a href="#853-car-fleet" class="headerlink" title="853. car-fleet"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/car-fleet/description/">853. car-fleet</a></h4><ul>
<li>若干辆车朝着target开，给一个position数组表示开始时车的位置，给一个speed数组表示每台车的速度。若后续车辆追上前面车则融合成一个以前面车的速度继续开。求到达终点的共有几台车。初识时每台车都在不同位置。</li>
<li>利用TreeMap，每台车的剩余距离作为key、每台车的到达终点所需时间作为value，在TreeMap中按照剩余距离从小到大排序后从头遍历剩余时间，若后续车辆剩余时间比前面的短或相等，就说明会追上；若后续车辆所需时间比前面大，必定赶不上，因此它就作为后续集团的leading car。本质就是求有多少个leading car.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">carFleet</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] position, <span class="type">int</span>[] speed)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (position == <span class="literal">null</span> || position.length == <span class="number">0</span></span><br><span class="line">           || speed == <span class="literal">null</span> || speed.length == <span class="number">0</span></span><br><span class="line">           || position.length != speed.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeMap&lt;Integer, Double&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; position.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">distanceRemain</span> <span class="operator">=</span> target - position[i];</span><br><span class="line">            map.put(distanceRemain, (<span class="type">double</span>)(distanceRemain) / speed[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">prevTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">double</span> time : map.values()) &#123;  <span class="comment">// values按照distanceRemain从小到大排列</span></span><br><span class="line">            <span class="keyword">if</span> (time &gt; prevTime) &#123;          <span class="comment">// 若当前所需时间大于前面的时间</span></span><br><span class="line">                prevTime = time;            <span class="comment">// 则形成新的fleet</span></span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="854-k-similar-strings"><a href="#854-k-similar-strings" class="headerlink" title="854. k-similar-strings"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/k-similar-strings/description/">854. k-similar-strings</a></h4><ul>
<li>给A和B两个字符串，求最少需要swap多少次A中的字符使得最终能得到B。如果不可能则返回Integer.MAX_VALUE。</li>
<li>从头开始遍历两个字符串，一旦遇到不同的字符，就在A中往后寻找B中该位的字符，尝试swap，然后从该位继续往后dfs一路搜下去。利用Map作为memo减少重复计算。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kSimilarity</span><span class="params">(String A, String B)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || B == <span class="literal">null</span> || A.length() != B.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(A.toCharArray(), B, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[] charA, String B, <span class="type">int</span> index, Map&lt;String, Integer&gt; memo)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">A</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(charA);</span><br><span class="line">        <span class="keyword">if</span> (A.equals(B)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo.containsKey(A)) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo.get(A);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; charA.length &amp;&amp; charA[i] == B.charAt(i)) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; charA.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (charA[j] == B.charAt(i)) &#123;      <span class="comment">// 往后找对应字符出现的位置，一个个比较</span></span><br><span class="line">                swap(charA, i, j);</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextMin</span> <span class="operator">=</span> dfs(charA, B, i + <span class="number">1</span>, memo);</span><br><span class="line">                <span class="keyword">if</span> (nextMin != Integer.MAX_VALUE &amp;&amp; nextMin + <span class="number">1</span> &lt; min) &#123;</span><br><span class="line">                    min = nextMin + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                swap(charA, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memo.put(A, min);</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="855-exam-room"><a href="#855-exam-room" class="headerlink" title="855. exam-room"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/exam-room/">855. exam-room</a></h4><ul>
<li>一条线上可以容纳N个学生考试，调用<code>seat()</code>的时候表示需要新插入一个学生，返回与现有相邻学生距离最远的座位index，在相邻距离都一样的情况下，取index较小的available seat；调用<code>leave(index)</code>时则让相应位置的座位空出、之后可以使用。</li>
<li>贪心，想像成切割&#x2F;合并线段，每次新加入的学生就需要插入到线段两端最长的那个线段中点、如果相同则取index较小的。拿掉学生则是将相邻两个线段合并起来放回available线段集合中。为了每次取线段都能按照插入学生最方便的顺序来取，需要用到treeSet进行logN的插入、删除，排序的标准则是按照线段中点到两端的距离从大到小、相同的情况下按照起点index从小到大。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExamRoom</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, <span class="type">int</span>[]&gt; start2Interval;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, <span class="type">int</span>[]&gt; end2Interval;</span><br><span class="line">    <span class="keyword">private</span> TreeSet&lt;<span class="type">int</span>[]&gt; treeSet;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExamRoom</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line">        start2Interval = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        end2Interval = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;((a, b) -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> getLength(a), len2 = getLength(b);</span><br><span class="line">            <span class="keyword">return</span> len1 == len2 ? a[<span class="number">0</span>] - b[<span class="number">0</span>] : len2 - len1;</span><br><span class="line">        &#125;);</span><br><span class="line">        addInterval(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, N&#125;);     <span class="comment">// 虚拟线段(-1, N)</span></span><br><span class="line">        <span class="built_in">this</span>.N = N;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">seat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] interval = treeSet.first();</span><br><span class="line">        removeInterval(interval);</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> interval[<span class="number">0</span>], right = interval[<span class="number">1</span>], seat = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (left == -<span class="number">1</span>) &#123;   <span class="comment">// 说明当前为空，直接取第一位</span></span><br><span class="line">            seat = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right == N) &#123;    <span class="comment">// 说明当前除了第一位都为空，入座最后一位</span></span><br><span class="line">            seat = N - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            seat = left + (right - left) / <span class="number">2</span>;  <span class="comment">// 取中点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        addInterval(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;left, seat&#125;);</span><br><span class="line">        addInterval(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;seat, right&#125;);</span><br><span class="line">        <span class="keyword">return</span> seat;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leave</span><span class="params">(<span class="type">int</span> p)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] right = start2Interval.get(p);</span><br><span class="line">        <span class="type">int</span>[] left = end2Interval.get(p);</span><br><span class="line">        removeInterval(left);</span><br><span class="line">        removeInterval(right);</span><br><span class="line">        addInterval(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;left[<span class="number">0</span>], right[<span class="number">1</span>]&#125;); <span class="comment">// 合并两旁的线段</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(<span class="type">int</span>[] interval)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> interval[<span class="number">0</span>], right = interval[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (left == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right == N) &#123;</span><br><span class="line">            <span class="keyword">return</span> N - <span class="number">1</span> - left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (right - left) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeInterval</span><span class="params">(<span class="type">int</span>[] interval)</span> &#123;</span><br><span class="line">        treeSet.remove(interval);</span><br><span class="line">        start2Interval.remove(interval[<span class="number">0</span>]);</span><br><span class="line">        end2Interval.remove(interval[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addInterval</span><span class="params">(<span class="type">int</span>[] interval)</span> &#123;</span><br><span class="line">        treeSet.add(interval);</span><br><span class="line">        start2Interval.put(interval[<span class="number">0</span>], interval);</span><br><span class="line">        end2Interval.put(interval[<span class="number">1</span>], interval);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="858-mirror-reflection"><a href="#858-mirror-reflection" class="headerlink" title="858. mirror-reflection"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/mirror-reflection/description/">858. mirror-reflection</a></h4><ul>
<li>给整数p和q，p表示正方形空间的边长，q表示初始激光从左下射出的高度，在右下、右上、左上各右一个receptor标号为0、1、2，可以保证一定可以接收到，求接收到的receptor的id。</li>
<li>激光射出后纵向移动达到q时，横向移动一定为p。假设把天花板去掉，无限往上反射x次，最终射到某个corner的时候，纵向上移动的距离恰好是p的某个倍数<code>q*x == y*p</code>，因此问题转换为求p和q的最小公倍数lcm，而<code>lcm = p * q / gcd</code>，用最大公约数可破。若<code>lcm / p % 2 == 0</code>，说明反射到了下面这个receptor，即0；否则再判断<code>lcm / q % 2 == 0</code>看看是否回到了左侧的recptor，即2。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//   lcm / p % 2 + 1 - lcm / q % 2 </span></span><br><span class="line"><span class="comment">// = p * q / gcd / p % 2 + 1 - p * q / gcd / q % 2</span></span><br><span class="line"><span class="comment">// = 1 + q / gcd % 2 - p / gcd % 2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mirrorReflection</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &lt; <span class="number">1</span> || q &gt; p) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">gcd</span> <span class="operator">=</span> getGCD(p, q);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + q / gcd % <span class="number">2</span> - p / gcd % <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getGCD</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> q != <span class="number">0</span> ? getGCD(q, p % q) : p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="860-lemonade-change"><a href="#860-lemonade-change" class="headerlink" title="860. lemonade-change"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/lemonade-change/description/">860. lemonade-change</a></h4><ul>
<li>给一个数组表示买柠檬汁的顾客的钱，只有5、10、20三种面额，每个顾客只买一杯柠檬汁，一开始手头没钱，判断按照顺序这样收银能否保证每个顾客都能找到钱。skip。</li>
</ul>
<h4 id="863-all-nodes-distance-k-in-binary-tree"><a href="#863-all-nodes-distance-k-in-binary-tree" class="headerlink" title="863. all-nodes-distance-k-in-binary-tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/description/">863. all-nodes-distance-k-in-binary-tree</a></h4><ul>
<li>给一个二叉树和其中的一个节点target，求二叉树中距离target为K的所有节点。</li>
<li>先一波DFS从root到target的backward path，然后从target开始沿三个方向开始BFS。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">distanceK</span><span class="params">(TreeNode root, TreeNode target, <span class="type">int</span> K)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> || target == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;TreeNode, TreeNode&gt; prevNodeMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Set&lt;TreeNode&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (!buildBackPath(target, root, <span class="literal">null</span>, prevNodeMap)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.offer(target);</span><br><span class="line">        visited.add(target);</span><br><span class="line">        <span class="type">int</span> <span class="variable">distance</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty() &amp;&amp; distance &lt; K) &#123;    </span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> q.size();</span><br><span class="line">            <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                <span class="keyword">if</span> (prevNodeMap.containsKey(curr) &amp;&amp; !visited.contains(prevNodeMap.get(curr))) &#123;</span><br><span class="line">                    visited.add(prevNodeMap.get(curr));</span><br><span class="line">                    q.offer(prevNodeMap.get(curr));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (curr.left != <span class="literal">null</span> &amp;&amp; !visited.contains(curr.left)) &#123;</span><br><span class="line">                    visited.add(curr.left);</span><br><span class="line">                    q.offer(curr.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (curr.right != <span class="literal">null</span> &amp;&amp; !visited.contains(curr.right)) &#123;</span><br><span class="line">                    visited.add(curr.right);</span><br><span class="line">                    q.offer(curr.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            distance++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            ans.add(q.poll().val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">buildBackPath</span><span class="params">(TreeNode target, TreeNode node, TreeNode prev, Map&lt;TreeNode, TreeNode&gt; prevNodeMap)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span>) &#123;</span><br><span class="line">            prevNodeMap.put(node, prev);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (buildBackPath(target, node.left, node, prevNodeMap)</span><br><span class="line">           || buildBackPath(target, node.right, node, prevNodeMap)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="864-shortest-path-to-get-all-keys"><a href="#864-shortest-path-to-get-all-keys" class="headerlink" title="864. shortest-path-to-get-all-keys"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/shortest-path-to-get-all-keys/description/">864. shortest-path-to-get-all-keys</a></h4><ul>
<li>给一个二维的grid，<code>.</code>表示空地、<code>@</code>表示起点（也可以看作空地）、<code>a~f</code>表示锁、<code>A~F</code>表示对应的门，要想到对应的门必须先有对应的钥匙。求从起点最少需要走几步拿到所有钥匙。</li>
<li>这种求graph中最短路径的问题通常用BFS就可以。问题在于这个锁和钥匙的问题，拿到钥匙之后可能需要原路返回，这和通常BFS不走回头路的做法不同。但注意现在的状态区别就是持有钥匙的不同，而且只需要统计每一种钥匙是否出现，可以直接用一个int的bit来表示。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">        <span class="type">int</span> row, col, keyBits;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> keyBits)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.row = row;</span><br><span class="line">            <span class="built_in">this</span>.col = col;</span><br><span class="line">            <span class="built_in">this</span>.keyBits = keyBits;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestPathAllKeys</span><span class="params">(String[] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rowCount</span> <span class="operator">=</span> grid.length, colCount = grid[<span class="number">0</span>].length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">rowStart</span> <span class="operator">=</span> -<span class="number">1</span>, colStart = -<span class="number">1</span>, keyTotal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rowCount; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; colCount; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i].charAt(j) == <span class="string">&#x27;@&#x27;</span>) &#123;</span><br><span class="line">                    rowStart = i;</span><br><span class="line">                    colStart = j;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[i].charAt(j) &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; grid[i].charAt(j) &lt;= <span class="string">&#x27;f&#x27;</span>) &#123;</span><br><span class="line">                    keyTotal++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rowStart == -<span class="number">1</span> || keyTotal == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">steps</span> <span class="operator">=</span> -<span class="number">1</span>, keyTotalBits = (<span class="number">1</span> &lt;&lt; keyTotal) - <span class="number">1</span>;</span><br><span class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;Point&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.offer(<span class="keyword">new</span> <span class="title class_">Point</span> (rowStart, colStart, <span class="number">0</span>));</span><br><span class="line">        visited.add(getStateString(rowStart, colStart, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> q.size();</span><br><span class="line">            steps++;</span><br><span class="line">            <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">Point</span> <span class="variable">curr</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                <span class="type">char</span> <span class="variable">currChar</span> <span class="operator">=</span> grid[curr.row].charAt(curr.col);</span><br><span class="line">                <span class="keyword">if</span> (currChar &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; currChar &lt;= <span class="string">&#x27;f&#x27;</span>) &#123;</span><br><span class="line">                    curr.keyBits |= (<span class="number">1</span> &lt;&lt; (currChar - <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (curr.keyBits == keyTotalBits) &#123;</span><br><span class="line">                    <span class="keyword">return</span> steps;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (validatePos(grid, curr.row - <span class="number">1</span>, curr.col, visited, curr.keyBits)) &#123;</span><br><span class="line">                    q.offer(<span class="keyword">new</span> <span class="title class_">Point</span>(curr.row - <span class="number">1</span>, curr.col, curr.keyBits));</span><br><span class="line">                    visited.add(getStateString(curr.row - <span class="number">1</span>, curr.col, curr.keyBits));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (validatePos(grid, curr.row + <span class="number">1</span>, curr.col, visited, curr.keyBits)) &#123;</span><br><span class="line">                    q.offer(<span class="keyword">new</span> <span class="title class_">Point</span>(curr.row + <span class="number">1</span>, curr.col, curr.keyBits));</span><br><span class="line">                    visited.add(getStateString(curr.row + <span class="number">1</span>, curr.col, curr.keyBits));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (validatePos(grid, curr.row, curr.col - <span class="number">1</span>, visited, curr.keyBits)) &#123;</span><br><span class="line">                    q.offer(<span class="keyword">new</span> <span class="title class_">Point</span>(curr.row, curr.col - <span class="number">1</span>, curr.keyBits));</span><br><span class="line">                    visited.add(getStateString(curr.row, curr.col - <span class="number">1</span>, curr.keyBits));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (validatePos(grid, curr.row, curr.col + <span class="number">1</span>, visited, curr.keyBits)) &#123;</span><br><span class="line">                    q.offer(<span class="keyword">new</span> <span class="title class_">Point</span>(curr.row, curr.col + <span class="number">1</span>, curr.keyBits));</span><br><span class="line">                    visited.add(getStateString(curr.row, curr.col + <span class="number">1</span>, curr.keyBits));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> <span class="title function_">getChar</span><span class="params">(String[] grid, <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (row &gt;= <span class="number">0</span> &amp;&amp; row &lt; grid.length &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; grid[row].length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> grid[row].charAt(col);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getStateString</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> keyCount)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> row + <span class="string">&quot;,&quot;</span> + col + <span class="string">&quot;:&quot;</span> + keyCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">validatePos</span><span class="params">(String[] grid, <span class="type">int</span> row, <span class="type">int</span> col, Set&lt;String&gt; visited, <span class="type">int</span> keyBits)</span> &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">currChar</span> <span class="operator">=</span> getChar(grid, row, col);</span><br><span class="line">        <span class="keyword">return</span> ((currChar == <span class="string">&#x27;.&#x27;</span> || </span><br><span class="line">                 currChar == <span class="string">&#x27;@&#x27;</span> ||</span><br><span class="line">                currChar &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; currChar &lt;= <span class="string">&#x27;f&#x27;</span> || </span><br><span class="line">                currChar &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; currChar &lt;= <span class="string">&#x27;F&#x27;</span> &amp;&amp; ((keyBits &amp; (<span class="number">1</span> &lt;&lt; (currChar - <span class="string">&#x27;A&#x27;</span>))) != <span class="number">0</span>))</span><br><span class="line">                    &amp;&amp; !visited.contains(getStateString(row, col, keyBits)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="865-smallest-subtree-with-all-the-deepest-nodes"><a href="#865-smallest-subtree-with-all-the-deepest-nodes" class="headerlink" title="865. smallest-subtree-with-all-the-deepest-nodes"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/">865. smallest-subtree-with-all-the-deepest-nodes</a></h4><ul>
<li>给一个二叉树，求包含所有最深节点的最小子树的根。</li>
<li>可以拆解成求深度、然后求LCA的问题，但这样是2-pass。1-pass的做法从根节点出发的同时就求深度，如果左右两边的深度相等则当前这个节点就是LCA了，如果左边的更深则应当返回左边的某个LCA，右边也是同理。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">NodeInfo</span> &#123;</span><br><span class="line">        <span class="type">int</span> depth;</span><br><span class="line">        TreeNode root;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">NodeInfo</span><span class="params">(<span class="type">int</span> depth, TreeNode root)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.depth = depth;</span><br><span class="line">            <span class="built_in">this</span>.root = root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">subtreeWithAllDeepest</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getNodeInfo(root).root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> NodeInfo <span class="title function_">getNodeInfo</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NodeInfo</span>(<span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">NodeInfo</span> <span class="variable">leftInfo</span> <span class="operator">=</span> getNodeInfo(node.left), rightInfo = getNodeInfo(node.right);</span><br><span class="line">        <span class="keyword">if</span> (leftInfo.depth == rightInfo.depth) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NodeInfo</span>(leftInfo.depth + <span class="number">1</span>, node);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (leftInfo.depth &gt; rightInfo.depth) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NodeInfo</span>(leftInfo.depth + <span class="number">1</span>, leftInfo.root);     <span class="comment">// 保留左边返回回来的LCA</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NodeInfo</span>(rightInfo.depth + <span class="number">1</span>, rightInfo.root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="866-prime-palindrome"><a href="#866-prime-palindrome" class="headerlink" title="866. prime-palindrome"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/prime-palindrome/">866. prime-palindrome</a></h4><ul>
<li>给一个正整数N(<code>1 &lt;= N &lt;= 10^8</code>)，求大于等于N的、最小的自对称素数(保证<code>ans &lt; 2 * 10^8</code>)。</li>
<li>数学题。所有位数为双数的自对称数都是11的倍数，因此目标只能锁定在位数为奇数的自对称数，再加个判断素数即可。但还有一个更暴力的办法，直接生成下一个最接近的自对称数(可参考<a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-the-closest-palindrome/">564. Find the Closest Palindrome</a>)，再判断是否素数。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">primePalindrome</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">8</span> &lt;= N &amp;&amp; N &lt;= <span class="number">11</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Integer.toString(i), rev = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s).reverse().toString();</span><br><span class="line">            <span class="type">int</span> <span class="variable">pal</span> <span class="operator">=</span> Integer.valueOf(s + rev.substring(<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span> (pal &gt;= N &amp;&amp; isPrime(pal)) &#123;</span><br><span class="line">                <span class="keyword">return</span> pal;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">2</span> || num % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> num == <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i * i &lt;= num; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="872-leaf-similar-trees"><a href="#872-leaf-similar-trees" class="headerlink" title="872. leaf-similar-trees"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/leaf-similar-trees/description/">872. leaf-similar-trees</a></h4><ul>
<li>给两个二叉树的root节点，判断他们的叶子节点组成的sequence是否相同。DFS搞定，skip。</li>
</ul>
<h4 id="873-length-of-longest-fibonacci-subsequence"><a href="#873-length-of-longest-fibonacci-subsequence" class="headerlink" title="873. length-of-longest-fibonacci-subsequence"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/length-of-longest-fibonacci-subsequence/">873. length-of-longest-fibonacci-subsequence</a></h4><ul>
<li>给一个单调递增的int数组，求其中最长的斐波那契子序列长度。</li>
<li>当前状态依赖于之前的状态，自然想到dp。<code>dp[i][j]</code>表示以<code>A[i]</code>和<code>A[j]</code>结尾的斐波那契数列长度，没到达一个新的索引，如果之前数组中出现过<code>当前索引的值 - 某个索引的值</code>，那当前长度就是之前长度 + 1，否则就默认是2。由于斐波那契数列成立的长度至少是3，最后判断一下再返回。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lenLongestFibSubseq</span><span class="params">(<span class="type">int</span>[] A)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || A.length &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; index = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[A.length][A.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> <span class="number">0</span>; last &lt; A.length; last++) &#123;</span><br><span class="line">            index.put(A[last], last);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>; mid &lt; last; mid++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> index.getOrDefault(A[last] - A[mid], -<span class="number">1</span>);</span><br><span class="line">                dp[mid][last] = prev &lt; mid &amp;&amp; prev &gt;= <span class="number">0</span> ? dp[prev][mid] + <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">                maxLen = Math.max(dp[mid][last], maxLen);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen &gt; <span class="number">2</span> ? maxLen : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="875-koko-eating-bananas"><a href="#875-koko-eating-bananas" class="headerlink" title="875. koko-eating-bananas"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/koko-eating-bananas/">875. koko-eating-bananas</a></h4><ul>
<li>给一个int数组表示若干堆香蕉，假设一个人每个小时能吃K个，每次只能选择一堆持续吃直到吃完，守卫H小时后回来，求最小的K值。例如<code>[3,6,7,11], H = 8</code>时，K &#x3D; 4.</li>
<li>利用假设二分查找法，假设一个K值，验证吃一波需要多久，与H比较后再换一个K值继续验证。这里同样采用了模版二分查找最左边的match值，需要注意的是invariant condition不是直接根据<code>num[mid] &gt;= target -&gt; right = mid</code>，而是需要转换成当前所需时间和H。时间复杂度为O(NlogM)，其中N为香蕉堆数，M为香蕉个数最大值。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minEatingSpeed</span><span class="params">(<span class="type">int</span>[] piles, <span class="type">int</span> H)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (piles == <span class="literal">null</span> || piles.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> pile : piles) &#123;</span><br><span class="line">            right = Math.max(right, pile);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>, currentHours = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> pile : piles) &#123;</span><br><span class="line">                currentHours += (pile + mid - <span class="number">1</span>) / mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (currentHours &lt;= H) &#123;  <span class="comment">// 注意这里currentHours &lt;= H 等价于TimeToTake(mid) &gt;= target</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：直接定位到某个很可能的值之后，线性查找。这个很可能的值就是<code>ceil(sum / H)</code>。时间复杂度理论上是O(N*M)，其中M为delta(target - initial)，实际会比二分查找快。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minEatingSpeed</span><span class="params">(<span class="type">int</span>[] piles, <span class="type">int</span> H)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (piles == <span class="literal">null</span> || piles.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> pile : piles) &#123;</span><br><span class="line">            sum += pile;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">bananaPerHour</span> <span class="operator">=</span> (<span class="type">int</span>) ((sum + H - <span class="number">1</span>) / H), currentHours = getHours(piles, bananaPerHour);</span><br><span class="line">        <span class="keyword">while</span> (currentHours &gt; H) &#123;</span><br><span class="line">            bananaPerHour++;</span><br><span class="line">            currentHours = getHours(piles, bananaPerHour);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) bananaPerHour;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getHours</span><span class="params">(<span class="type">int</span>[] piles, <span class="type">int</span> bananaPerHour)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">currentHours</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> pile : piles) &#123;</span><br><span class="line">            currentHours += (pile + bananaPerHour - <span class="number">1</span>) / bananaPerHour;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currentHours;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="876-middle-of-the-linked-list"><a href="#876-middle-of-the-linked-list" class="headerlink" title="876. middle-of-the-linked-list"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/middle-of-the-linked-list">876. middle-of-the-linked-list</a></h4><ul>
<li>给一个链表，求中间节点，若中间节点是两个，返回第二个。</li>
<li>快慢指针搞定。pass。</li>
</ul>
<h4 id="877-stone-game"><a href="#877-stone-game" class="headerlink" title="877. stone-game"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/stone-game/">877. stone-game</a></h4><ul>
<li>给一个int数组表示若干堆石头，两个人每人选择从数组的一侧取数字，最后总共取得多的人获胜，判断先取的人是否可以获胜。</li>
<li>DP。假设<code>dp[i][j]</code>表示<code>从i到j</code>的部分，先取的人可以多取多少石头。从头部取<code>piles[i]</code>则对方下一步为<code>dp[i + 1][j]</code>，从尾部取<code>piles[j]</code>则下一步对方多取<code>dp[i][j - 1]</code>，因此状态转移为<code>dp[i][j] = max(piles[i] - dp[i + 1][j], piles[j] - dp[i][j - 1]</code>.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">stoneGame</span><span class="params">(<span class="type">int</span>[] piles)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (piles == <span class="literal">null</span> || piles.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> piles.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][i] = piles[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>; len &lt; n; len++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - len; i++) &#123;</span><br><span class="line">                dp[i][i + len] = Math.max(piles[i] - dp[i + <span class="number">1</span>][i + len], piles[i + len] - dp[i][i + len - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>] &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>优化，这个dp其实每次只需要用到1-D Array即可，因为len变量在外循环，在内层循环看来column是固定的。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">stoneGame</span><span class="params">(<span class="type">int</span>[] piles)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (piles == <span class="literal">null</span> || piles.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> piles.length;</span><br><span class="line">        <span class="type">int</span>[] dp = Arrays.copyOf(piles, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>; len &lt; n; len++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - len; i++) &#123;</span><br><span class="line">                dp[i] = Math.max(piles[i] - dp[i + <span class="number">1</span>], piles[i + len] - dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>] &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><a target="_blank" rel="noopener" href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/dong-tai-gui-hua-zhi-bo-yi-wen-ti">follow-up</a>: 给一个int数组表示若干堆石头，两个人每人选择从数组的一侧取数字，每个人都能在剩余石头当中做到全局最优，最后总共取得多的人获胜，求先取的人和后取的人能得到分数之差。</li>
<li>还是DP，只不过这次在每一段区间<code>[i, j]</code>内需要存储先手和后手所能得到的石头数。状态转换非常有意思，作为先手选择完左边或者右边的石头后，就相应转变了后手，因此需要取相应段dp的后手值，即<code>dp[i][j].fir = max(piles[i] + dp[i+1][j].sec, piles[j] + dp[i][j-1].sec)</code>. 初始状态则是只有一个石头的时候，先手取得全部、后手为0，也就是每一个石头堆对应一个base case，在dp数组中呈对角线. 遍历的方向则需要观察，<code>dp[i][j]</code>需要下方<code>dp[i+1][j]</code>和左方<code>dp[i][j-1]</code>的值，也就需要斜着遍历了。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">        <span class="type">int</span> fir, sec;</span><br><span class="line">        Pair(<span class="type">int</span> fir, <span class="type">int</span> sec) &#123;</span><br><span class="line">            <span class="built_in">this</span>.fir = fir;</span><br><span class="line">            <span class="built_in">this</span>.sec = sec;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">stoneGameFollowUp</span><span class="params">(<span class="type">int</span>[] piles)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (piles == <span class="literal">null</span> || piles.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> piles.length;</span><br><span class="line">        Pair[][] dp = <span class="keyword">new</span> <span class="title class_">Pair</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = <span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化对角线[i, i]，先手取得全部石头，后手为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][i].fir = piles[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>; len &lt; n; len++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = i + len; j &lt; n; i++, j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> piles[i] + dp[i + <span class="number">1</span>][j].sec;</span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> piles[j] + dp[i][j - <span class="number">1</span>].sec;</span><br><span class="line">                <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">                    dp[i][j].fir = left;</span><br><span class="line">                    dp[i][j].sec = dp[i + <span class="number">1</span>][j].fir;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j].fir = right;</span><br><span class="line">                    dp[i][j].sec = dp[i][j - <span class="number">1</span>].fir;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>].fir - dp[<span class="number">0</span>][n - <span class="number">1</span>].sec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="881-boats-to-save-people"><a href="#881-boats-to-save-people" class="headerlink" title="881. boats-to-save-people"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/boats-to-save-people/">881. boats-to-save-people</a></h4><ul>
<li>给一个int表示人的体重，假设一个船最多载2人，给限重limit，求至少需要多少船。</li>
<li>排序后双指针。pass。</li>
<li>可能会问：如果限制k人呢？如果没有限制人数只是看重量呢？感觉也是排序后，猜一个船数<code>N/2</code>，判断是否可行，可行二分继续二分查找。</li>
</ul>
<h4 id="885-spiral-matrix-iii"><a href="#885-spiral-matrix-iii" class="headerlink" title="885. spiral-matrix-iii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/spiral-matrix-iii/">885. spiral-matrix-iii</a></h4><ul>
<li>给一个行数和列数表示一个矩阵的形状，给起点坐标，求spiral遍历的坐标数组。</li>
<li>发现规律移动的方式是<code>1,1,2,2,3,3...</code>，因此考虑直接从起点这样挪，只将合法的坐标存入数组即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>[][] directions = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] spiralMatrixIII(<span class="type">int</span> R, <span class="type">int</span> C, <span class="type">int</span> r0, <span class="type">int</span> c0) &#123;</span><br><span class="line">        <span class="keyword">if</span> (R &lt;= <span class="number">0</span> || C &lt;= <span class="number">0</span> || !isValidPosition(R, C, r0, c0)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] ans = <span class="keyword">new</span> <span class="title class_">int</span>[R * C][<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">1</span>, directionIndex = <span class="number">0</span>, r = r0, c = c0, turnCounter = <span class="number">0</span>, moveCounter = <span class="number">0</span>;</span><br><span class="line">        ans[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;r0, c0&#125;;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; ans.length) &#123;</span><br><span class="line">            r += directions[directionIndex][<span class="number">0</span>];</span><br><span class="line">            c += directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">            moveCounter++;    <span class="comment">// 记录在当前方向上每次移动</span></span><br><span class="line">            <span class="keyword">if</span> (isValidPosition(R, C, r, c)) &#123;</span><br><span class="line">                ans[index++] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;r, c&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (moveCounter == turnCounter / <span class="number">2</span> + <span class="number">1</span>) &#123;   <span class="comment">// 得到1,1,2,2,3,3...的数组</span></span><br><span class="line">                moveCounter = <span class="number">0</span>;</span><br><span class="line">                turnCounter++;</span><br><span class="line">                directionIndex = (directionIndex + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValidPosition</span><span class="params">(<span class="type">int</span> rowCount, <span class="type">int</span> colCount, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> r &gt;= <span class="number">0</span> &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; r &lt; rowCount &amp;&amp; c &lt; colCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="886-possible-bipartition"><a href="#886-possible-bipartition" class="headerlink" title="886. possible-bipartition"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/possible-bipartition/">886. possible-bipartition</a></h4><ul>
<li>给N个人物之间的关系edges，在一个edges两端的两个人不能在同一个群组中，判断是否可能将这堆人分成两组。</li>
<li>图论经典上色问题，根据edges构建图之后，将起点上色为<code>1</code>、将相邻节点上色为<code>-1</code>，持续递归，一旦出现相邻的节点已经上色且有冲突就不可能了。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">possibleBipartition</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span>[][] dislikes)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (dislikes == <span class="literal">null</span> || dislikes.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt;[] graph = getGraph(N, dislikes);</span><br><span class="line">        <span class="type">int</span>[] colors = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (colors[i] == <span class="number">0</span> &amp;&amp; !dfs(i, colors, -<span class="number">1</span>, graph)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt;[] getGraph(<span class="type">int</span> N, <span class="type">int</span>[][] dislikes) &#123;</span><br><span class="line">        List&lt;Integer&gt;[] graph = <span class="keyword">new</span> <span class="title class_">List</span>[N + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] dislike : dislikes) &#123;</span><br><span class="line">            graph[dislike[<span class="number">0</span>]].add(dislike[<span class="number">1</span>]);</span><br><span class="line">            graph[dislike[<span class="number">1</span>]].add(dislike[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> graph;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span>[] colors, <span class="type">int</span> currColor, List&lt;Integer&gt;[] graph)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (colors[node] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> colors[node] == currColor;</span><br><span class="line">        &#125;</span><br><span class="line">        colors[node] = currColor;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> neighbor : graph[node]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dfs(neighbor, colors, -currColor, graph)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="888-fair-candy-swap"><a href="#888-fair-candy-swap" class="headerlink" title="888. fair-candy-swap"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/fair-candy-swap/">888. fair-candy-swap</a></h4><ul>
<li>给两个int数组，求需要交换其中哪两个int可以使得两个数组的和相等。</li>
<li>对两个数组求和，二者的差&#x2F;2就是需要给另一方补充的diff。将第一个数组存入set，从第二个数组中逐个元素加上diff看看是否在第一个数组中出现过，出现过则直接交换这两个数组就可以抹平差距了。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] fairCandySwap(<span class="type">int</span>[] A, <span class="type">int</span>[] B) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || B == <span class="literal">null</span> || A.length == <span class="number">0</span> || B.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> (IntStream.of(A).sum() - IntStream.of(B).sum()) / <span class="number">2</span>; <span class="comment">// A比B多多少</span></span><br><span class="line">        Set&lt;Integer&gt; setA = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a : A) &#123;</span><br><span class="line">            setA.add(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b : B) &#123;</span><br><span class="line">            <span class="keyword">if</span> (setA.contains(b + diff)) &#123;      <span class="comment">// 若存在，则交换后A - diff, B + diff, 差距就抹平了</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;b + diff, b&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="889-construct-binary-tree-from-preorder-and-postorder-traversal"><a href="#889-construct-binary-tree-from-preorder-and-postorder-traversal" class="headerlink" title="889. construct-binary-tree-from-preorder-and-postorder-traversal"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">889. construct-binary-tree-from-preorder-and-postorder-traversal</a></h4><ul>
<li>给一个树的前序遍历和后续遍历的结果，还原这个树。每个节点的值都不一样，保证一定有对应的树。</li>
<li>方法一：递归。前序遍历特定是第一次接触就输出，后序则是当最后离开这个节点的时候才输出，这意味着见到后序节点的时候，这部分子树就已经构造完成了。因此前序中的每一个元素都可以直接构造成节点，若该节点不是后续节点，则说明还需要构建子树。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">preIndex</span> <span class="operator">=</span> <span class="number">0</span>, postIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructFromPrePost</span><span class="params">(<span class="type">int</span>[] pre, <span class="type">int</span>[] post)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(pre[preIndex++]);</span><br><span class="line">        <span class="keyword">if</span> (root.val != post[postIndex]) &#123;      <span class="comment">// 通过与后序遍历比较判断当前根是否完全遍历</span></span><br><span class="line">            root.left = constructFromPrePost(pre, post);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val != post[postIndex]) &#123;</span><br><span class="line">            root.right = constructFromPrePost(pre, post);</span><br><span class="line">        &#125;</span><br><span class="line">        postIndex++;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：遍历。利用Stack的思路存放尚未在后序遍历中出现的点，一旦在后序遍历中出现就说明这个节点已经拼装完成，可以直接pop出来。当前节点需要先尝试拼入栈顶节点的左子树，若已经存在再拼入右子树。最终全部拼完后，返回栈最底部的节点。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructFromPrePost</span><span class="params">(<span class="type">int</span>[] pre, <span class="type">int</span>[] post)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; s = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        s.offer(<span class="keyword">new</span> <span class="title class_">TreeNode</span>(pre[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">preIndex</span> <span class="operator">=</span> <span class="number">1</span>, postIndex = <span class="number">0</span>; preIndex &lt; pre.length; preIndex++) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(pre[preIndex]);</span><br><span class="line">            <span class="keyword">while</span> (s.getLast().val == post[postIndex]) &#123;    <span class="comment">// 通过与后序遍历比较判断栈顶是否完全遍历</span></span><br><span class="line">                s.pollLast();</span><br><span class="line">                postIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s.getLast().left == <span class="literal">null</span>) &#123; <span class="comment">// 从栈顶的左边开始链接节点</span></span><br><span class="line">                s.getLast().left = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s.getLast().right = node;</span><br><span class="line">            &#125;</span><br><span class="line">            s.offer(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.getFirst();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="890-find-and-replace-pattern"><a href="#890-find-and-replace-pattern" class="headerlink" title="890. find-and-replace-pattern"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-and-replace-pattern/">890. find-and-replace-pattern</a></h4><ul>
<li>给一个string数组和一个pattern，返回一个string数组，其中每个string都可以转换成pattern的形式，如pattern为<code>cdc</code>则<code>aba</code>, <code>QAQ</code>是符合的，而<code>abb</code>就不符合。</li>
<li>方法一：最朴素的替换存入map的方法，需要一个set来存放pattern判断是否出现过。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findAndReplacePattern</span><span class="params">(String[] words, String pattern)</span> &#123;</span><br><span class="line">        List&lt;String&gt; matchedList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (words == <span class="literal">null</span> || words.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> matchedList;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isMatch(word.toCharArray(), pattern.toCharArray())) &#123;</span><br><span class="line">                matchedList.add(word);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matchedList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(<span class="type">char</span>[] word, <span class="type">char</span>[] pattern)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (word.length != pattern.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character, Character&gt; mapping = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Set&lt;Character&gt; patternSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mapping.containsKey(word[i])) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mapping.get(word[i]) != pattern[i]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (patternSet.contains(pattern[i])) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mapping.put(word[i], pattern[i]);</span><br><span class="line">                    patternSet.add(pattern[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：normalizing word的方法，将pattern先encode成某个形式，如数字数组，再对所有word apply相同的函数即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findAndReplacePattern</span><span class="params">(String[] words, String pattern)</span> &#123;</span><br><span class="line">        List&lt;String&gt; matchedList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (words == <span class="literal">null</span> || words.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> matchedList;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] patternEncoded = encode(pattern);</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Arrays.equals(encode(word), patternEncoded)) &#123;</span><br><span class="line">                matchedList.add(word);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matchedList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] encode(String str) &#123;</span><br><span class="line">        <span class="type">int</span>[] retVal = <span class="keyword">new</span> <span class="title class_">int</span>[str.length()];</span><br><span class="line">        Map&lt;Character, Integer&gt; char2Int = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            char2Int.putIfAbsent(str.charAt(i), char2Int.size());</span><br><span class="line">            retVal[i] = char2Int.get(str.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="891-sum-of-subsequence-widths"><a href="#891-sum-of-subsequence-widths" class="headerlink" title="891. sum-of-subsequence-widths"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sum-of-subsequence-widths/">891. sum-of-subsequence-widths</a></h4><ul>
<li>给一个int数组，求所有子序列的width之和。width定义为该部分序列的最大值减最小值。结果可能很大，mod一个<code>1e9 + 7</code>。</li>
<li>本质上就是找所有子序列的最大值和最小值。先对原数组排个序，对于i-th数，总共有<code>2 ^ i</code>个子序列以它为最大值、<code>2 ^ (n - i - 1)</code>个子序列以它为最小值。为了做到one-pass，在从左往右遍历的时候可以同时进行加减，使用<code>c = 1</code>不断<code>c *= 2</code>，以当前元素A[i]为最大值的有c个、以对称处元素<code>A[n - i - 1]</code>为最小值的有c个.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumSubseqWidths</span><span class="params">(<span class="type">int</span>[] A)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || A.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(A);</span><br><span class="line">        <span class="type">long</span> <span class="variable">retVal</span> <span class="operator">=</span> <span class="number">0</span>, c = <span class="number">1</span>, MOD = (<span class="type">long</span>)<span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; A.length; i++, c = c * <span class="number">2</span> % MOD) &#123;</span><br><span class="line">            retVal = (retVal + A[i] * c - A[A.length - i - <span class="number">1</span>] * c) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) ((retVal + MOD) % MOD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="896-monotonic-array"><a href="#896-monotonic-array" class="headerlink" title="896. monotonic-array"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/monotonic-array/">896. monotonic-array</a></h4><ul>
<li>给一个数组，判断是否单调，直接用一个tone变量标记当前情况即可。pass。</li>
</ul>
<h4 id="897-increasing-order-search-tree"><a href="#897-increasing-order-search-tree" class="headerlink" title="897. increasing-order-search-tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/increasing-order-search-tree">897. increasing-order-search-tree</a></h4><ul>
<li>给一个BST，转换成只有右子树的BST链表，也需要从小到大。需要通过全局变量记录全局的head以及上一次整理之后的prev节点，通过中序遍历递归搞定。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">TreeNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>, prev = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">increasingBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        increasingBST(root.left);       <span class="comment">// 先整理左子树</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;             <span class="comment">// 若head从未设置，先设head</span></span><br><span class="line">            head = root;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                        <span class="comment">// head设置则prev一定设置过了</span></span><br><span class="line">            prev.right = root;</span><br><span class="line">            root.left = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = root;                    <span class="comment">// 更新prev为当前节点</span></span><br><span class="line">        increasingBST(root.right);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="901-online-stock-span"><a href="#901-online-stock-span" class="headerlink" title="901. online-stock-span"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/online-stock-span/">901. online-stock-span</a></h4><ul>
<li>在表示股价的一串int流中，每输入一个新的股价就要返回之前连续几天价格是低于或等于当前价格的。例如<code>[100, 80, 60, 70, 60, 75, 85]</code>返回<code>[1, 1, 1, 2, 1, 4, 6]</code>.</li>
<li>用stack解决。stack中存放股价和计数，如果新输入的股价比栈顶大，则弹出并把栈顶的计数累积到当前计数。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StockSpanner</span> &#123;</span><br><span class="line">    Stack&lt;<span class="type">int</span>[]&gt; stack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StockSpanner</span><span class="params">()</span> &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">(<span class="type">int</span> price)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; price &gt;= stack.peek()[<span class="number">0</span>]) &#123;</span><br><span class="line">            count += stack.pop()[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;price, count&#125;);</span><br><span class="line">        <span class="keyword">return</span> stack.peek()[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your StockSpanner object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * StockSpanner obj = new StockSpanner();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.next(price);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="904-fruit-into-baskets"><a href="#904-fruit-into-baskets" class="headerlink" title="904. fruit-into-baskets"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/fruit-into-baskets/">904. fruit-into-baskets</a></h4><ul>
<li>给一个int数组表示水果，假设你只能取两种水果，而且从某一个点开始后就要一直往后取这两种，一旦碰到别的水果就必须停止。求最多可以拿到多少个水果。双指针，本身没啥意思，但是学到了<code>map.remove(key, value)</code>这个操作。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalFruit</span><span class="params">(<span class="type">int</span>[] tree)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tree == <span class="literal">null</span> || tree.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>, retVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; right &lt; tree.length; right++) &#123;</span><br><span class="line">            map.put(tree[right], map.getOrDefault(tree[right], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (map.size() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                map.put(tree[left], map.get(tree[left]) - <span class="number">1</span>);</span><br><span class="line">                map.remove(tree[left++], <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            retVal = Math.max(retVal, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="905-sort-array-by-parity"><a href="#905-sort-array-by-parity" class="headerlink" title="905. sort-array-by-parity"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sort-array-by-parity/">905. sort-array-by-parity</a></h4><ul>
<li>给一个数组，要求将所有偶数都挪到奇数前面。双指针前后夹击即可，pass.</li>
</ul>
<h4 id="907-sum-of-subarray-minimums"><a href="#907-sum-of-subarray-minimums" class="headerlink" title="907. sum-of-subarray-minimums"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sum-of-subarray-minimums/">907. sum-of-subarray-minimums</a></h4><ul>
<li>给一个数组，求其中所有subarray中的最小值之和。<code>[1,3,2]</code>就有<code>[1], [3], [2], [1,3], [3,2], [1,3,2]</code>这些子数组，求和为<code>1+3+2+1+2+1</code>.</li>
<li>观察规律，以1为最小值的子数组有3个，以3为最小值的子数组有1个，以2为最小值的子数组有2个。对于每一个索引处都需要求它前面和它后面的次小值，或者说需要直到往前和往后多远就会破坏自己是最小值这个条件。因此考虑用monotone stack来维护这样一个单调递增的索引栈，当前索引减去栈顶索引就是距离了。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumSubarrayMins</span><span class="params">(<span class="type">int</span>[] A)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || A.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> A.length, sum = <span class="number">0</span>, MOD = <span class="number">1_000_000_007</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] left = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="type">int</span>[] right = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123; <span class="comment">// 首先假设每个索引自己都是最小值</span></span><br><span class="line">            left[i] = i + <span class="number">1</span>;    <span class="comment">// 当前到最左共有i + 1个元素</span></span><br><span class="line">            right[i] = len - i; <span class="comment">// 当前到最右共有len - i个元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; A[i] &lt; A[stack.peek()]) &#123;</span><br><span class="line">                stack.pop();    <span class="comment">// 当前元素更小，需要尽可能丢到栈底</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                left[i] = i - stack.peek(); <span class="comment">// 与前方更小值的距离</span></span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; A[i] &lt; A[stack.peek()]) &#123;</span><br><span class="line">                right[stack.peek()] = i - stack.peek(); <span class="comment">// 当前元素更小，则栈顶到当前元素就是后续第一个更小值了</span></span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            sum = (sum + A[i] * left[i] * right[i]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="909-snakes-and-ladders"><a href="#909-snakes-and-ladders" class="headerlink" title="909. snakes-and-ladders"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/snakes-and-ladders/">909. snakes-and-ladders</a></h4><ul>
<li>给一个<code>N*N</code>棋盘，从左下方开始作为1，蛇形向右向上向左向上这样编号，直到<code>N*N</code>. 其中如果是-1就固定，如果是整数则需要跳到该编号对应的位置（只跳一次，不能无穷跳）。假设每次可以从当前位置向后走1～6步，求最短的到达<code>N*N</code>所需步数。</li>
<li>见到棋盘、最短步数就应该想到BFS，只要第一个碰到终点的就是最短步数。比较tricky的是从编号到位置的转化，每次从编号转换成位置再到棋盘里看是否需要继续往后跳。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">snakesAndLadders</span><span class="params">(<span class="type">int</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="literal">null</span> || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> board.length;</span><br><span class="line">        Map&lt;Integer, Integer&gt; idSteps = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.offer(<span class="number">1</span>);</span><br><span class="line">        idSteps.put(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">currId</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="keyword">if</span> (currId == N * N) &#123;</span><br><span class="line">                <span class="keyword">return</span> idSteps.get(currId);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">nextId</span> <span class="operator">=</span> currId + <span class="number">1</span>; nextId &lt;= Math.min(currId + <span class="number">6</span>, N * N); nextId++) &#123;</span><br><span class="line">                <span class="type">int</span>[] nextLocation = getLocation(nextId, N);</span><br><span class="line">                <span class="type">int</span> <span class="variable">rowNext</span> <span class="operator">=</span> nextLocation[<span class="number">0</span>], colNext = nextLocation[<span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextIdFinal</span> <span class="operator">=</span> board[rowNext][colNext] == -<span class="number">1</span> ? nextId : board[rowNext][colNext];</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (!idSteps.containsKey(nextIdFinal)) &#123;</span><br><span class="line">                    idSteps.put(nextIdFinal, idSteps.get(currId) + <span class="number">1</span>);</span><br><span class="line">                    q.offer(nextIdFinal);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] getLocation(<span class="type">int</span> id, <span class="type">int</span> N) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> (id - <span class="number">1</span>) / N;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> (id - <span class="number">1</span>) % N;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> N - <span class="number">1</span> - q;</span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> row % <span class="number">2</span> == N % <span class="number">2</span> ? (N - <span class="number">1</span> - r) : r;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;row, col&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="914-x-of-a-kind-in-a-deck-of-cards"><a href="#914-x-of-a-kind-in-a-deck-of-cards" class="headerlink" title="914. x-of-a-kind-in-a-deck-of-cards"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/x-of-a-kind-in-a-deck-of-cards/">914. x-of-a-kind-in-a-deck-of-cards</a></h4><ul>
<li>给一个int数组表示一堆牌，判断是否可能将这堆牌划分成若干个子集，使得每个子集每张牌都相同且多于一张。</li>
<li>本质上就是求每种牌面的出现次数是否可以被某个大于2的数整除。主要是不知道怎么写GCD，复习一下。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasGroupsSizeX</span><span class="params">(<span class="type">int</span>[] deck)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (deck == <span class="literal">null</span> || deck.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] bucket = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : deck) &#123;</span><br><span class="line">            bucket[num]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">gcd</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bucket.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (gcd == -<span class="number">1</span>) &#123;</span><br><span class="line">                    gcd = bucket[i];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    gcd = findGcd(bucket[i], gcd);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> gcd &gt;= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findGcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b == <span class="number">0</span> ? a : findGcd(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="915-partition-array-into-disjoint-intervals"><a href="#915-partition-array-into-disjoint-intervals" class="headerlink" title="915. partition-array-into-disjoint-intervals"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/partition-array-into-disjoint-intervals/">915. partition-array-into-disjoint-intervals</a></h4><ul>
<li>给一个数组，假设一定存在一种划分方式使得左半边的所有元素比右半边所有元素小或相等，求最短的左半边长度（保证是两侧都是非空的）。</li>
<li>方法一：维护两个数组，一个求左边到当前位置的最大元素、一个求右边到当前位置的最小元素，只要最大元素都小于右边的最小元素了就是合法划分了。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partitionDisjoint</span><span class="params">(<span class="type">int</span>[] A)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || A.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> A.length;</span><br><span class="line">        <span class="type">int</span>[] minRight = <span class="keyword">new</span> <span class="title class_">int</span>[len], maxLeft = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        minRight[len - <span class="number">1</span>] = A[len - <span class="number">1</span>];</span><br><span class="line">        maxLeft[<span class="number">0</span>] = A[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            minRight[len - i - <span class="number">1</span>] = Math.min(minRight[len - i], A[len - i - <span class="number">1</span>]);</span><br><span class="line">            maxLeft[i] = Math.max(maxLeft[i - <span class="number">1</span>], A[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxLeft[i - <span class="number">1</span>] &lt;= minRight[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>follow-up如何优化空间？我们不需要track每个位置的最小、最大元素。维护一个partition的index，只要partition左边的最大值小于等于当前所有遍历到的值就可以了，而一旦大于说明当前位置也必须包括在partition里面，同时更新左边最大值为当前遍历过的元素中的最大值。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partitionDisjoint</span><span class="params">(<span class="type">int</span>[] A)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || A.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftPartMax</span> <span class="operator">=</span> A[<span class="number">0</span>], currMax = A[<span class="number">0</span>], leftPartEndIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftPartMax &gt; A[i]) &#123;</span><br><span class="line">                leftPartEndIndex = i;</span><br><span class="line">                leftPartMax = currMax;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                currMax = Math.max(currMax, A[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftPartEndIndex + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="917-reverse-only-letters"><a href="#917-reverse-only-letters" class="headerlink" title="917. reverse-only-letters"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-only-letters/">917. reverse-only-letters</a></h4><ul>
<li>将字符串中的letter反转，其余字符都保留。如<code>Test1ng-Leet=code-Q!</code>变成<code>Qedo1ct-eeLg=ntse-T!</code>.</li>
<li>前后指针夹逼即可。pass.</li>
</ul>
<h4 id="918-maximum-sum-circular-subarray"><a href="#918-maximum-sum-circular-subarray" class="headerlink" title="918. maximum-sum-circular-subarray"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-sum-circular-subarray/">918. maximum-sum-circular-subarray</a></h4><ul>
<li>给一个int数组，假设他是circular的，求最大的非空的subarray的和。</li>
<li>circular与以往不同的就是前后可以相连，前后各有一部分的和最大，那么将这个情况转换一下就是「中间部分最小」。因此维护最大和最小两种值，最后用总和减去最小值就得到前后断开的情况的最大值了。corner case就是当所有数都是负数的时候，如果直接返回最大值就是total - sumMin &#x3D; 0，这就意味着子数组为空了，因此你们媒体本身也要判断，如果最大的子数组之和小于0，就要直接返回这个最大的负数值才是。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubarraySumCircular</span><span class="params">(<span class="type">int</span>[] A)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (A == <span class="literal">null</span> || A.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">currMax</span> <span class="operator">=</span> <span class="number">0</span>, currMin = <span class="number">0</span>, sumMax = -<span class="number">30000</span>, sumMin = <span class="number">30000</span>, total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : A) &#123;</span><br><span class="line">        currMax = Math.max(num, currMax + num);     <span class="comment">// 要么继续取，要么抛弃之前的只从当前开始取</span></span><br><span class="line">        sumMax = Math.max(sumMax, currMax);         <span class="comment">// 保留最大的和</span></span><br><span class="line">        currMin = Math.min(num, currMin + num);</span><br><span class="line">        sumMin = Math.min(sumMin, currMin);</span><br><span class="line">        total += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(sumMax, total - sumMin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="919-complete-binary-tree-inserter"><a href="#919-complete-binary-tree-inserter" class="headerlink" title="919. complete-binary-tree-inserter"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/complete-binary-tree-inserter">919. complete-binary-tree-inserter</a></h4><ul>
<li>实现一个完全二叉树的插入。在经过初始化后，实现<code>O(1)</code>的插入，返回插入点的parent值。</li>
<li>一开始用了两个queue，但这就没有利用好「完全」二叉树的性质。如果将这些节点都存入一个数组，那么孩子节点的索引就是parent节点索引的2倍(+1)<br>.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CBTInserter</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;TreeNode&gt; nodeList;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CBTInserter</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        nodeList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        nodeList.add(root);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nodeList.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nodeList.get(i).left != <span class="literal">null</span>) &#123;</span><br><span class="line">                nodeList.add(nodeList.get(i).left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nodeList.get(i).right != <span class="literal">null</span>) &#123;</span><br><span class="line">                nodeList.add(nodeList.get(i).right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> nodeList.size();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(v);</span><br><span class="line">        <span class="keyword">if</span> (size % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            nodeList.get((size - <span class="number">1</span>) / <span class="number">2</span>).left = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nodeList.get((size - <span class="number">1</span>) / <span class="number">2</span>).right = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        nodeList.add(newNode);</span><br><span class="line">        <span class="keyword">return</span> nodeList.get((size - <span class="number">1</span>) / <span class="number">2</span>).val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">get_root</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nodeList.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="921-minimum-add-to-make-parentheses-valid"><a href="#921-minimum-add-to-make-parentheses-valid" class="headerlink" title="921. minimum-add-to-make-parentheses-valid"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/">921. minimum-add-to-make-parentheses-valid</a></h4><ul>
<li>给一个只有小括号的字符串，可能valid也可能invalid，判断最少需要插入几个小括号才能使它valid。贪心法，直接用一个leftCount算左括号数，右括号来的时候就减，不够就说明要插入。pass.</li>
</ul>
<h4 id="930-binary-subarrays-with-sum"><a href="#930-binary-subarrays-with-sum" class="headerlink" title="930. binary-subarrays-with-sum"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-subarrays-with-sum/">930. binary-subarrays-with-sum</a></h4><ul>
<li>给一个只含有0和1的数组，给一个targetSum，求有多少个subarray的和等于它。</li>
<li>双指针，右指针一直往后加，一旦超过了targetSum就需要移动左指针。不过需要注意的是由于0的存在，一旦当前的<code>sum == targetSum</code>，左指针指的可能是0，因此需要在此时将左指针往右的部分都算进去。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSubarraysWithSum</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> S)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || A.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>, sum = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; A.length) &#123;</span><br><span class="line">            sum += A[right];</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; sum &gt; S) &#123;</span><br><span class="line">                sum -= A[left++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum == S) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt; right &amp;&amp; sum == S &amp;&amp; A[i] == <span class="number">0</span>; i++) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="931-minimum-falling-path-sum-https-leetcode-com-problems-minimum-falling-path-sum"><a href="#931-minimum-falling-path-sum-https-leetcode-com-problems-minimum-falling-path-sum" class="headerlink" title="[931.minimum-falling-path-sum] (https://leetcode.com/problems/minimum-falling-path-sum/)"></a>[931.minimum-falling-path-sum] (<a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-falling-path-sum/">https://leetcode.com/problems/minimum-falling-path-sum/</a>)</h4><ul>
<li>给一个matrix，若每次下坠只能从上方、左上方、右上方下坠，求从最顶上下坠到最下面经过的所有数字和的最小值。</li>
<li>DP，每次就根据上方、左上方、右上方来更新。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minFallingPathSum</span><span class="params">(<span class="type">int</span>[][] A)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || A.length == <span class="number">0</span> || A[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> A.length, cols = A[<span class="number">0</span>].length, retVal = Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[cols];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; cols; c++) &#123;</span><br><span class="line">            dp[c] = A[<span class="number">0</span>][c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">1</span>; r &lt; rows; r++) &#123;</span><br><span class="line">            <span class="type">int</span>[] dpTemp = <span class="keyword">new</span> <span class="title class_">int</span>[cols];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; cols; c++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> A[r][c] + dp[c];</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> c &gt; <span class="number">0</span> ? A[r][c] + dp[c - <span class="number">1</span>] : Integer.MAX_VALUE;</span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> c + <span class="number">1</span> &lt; cols ? A[r][c] + dp[c + <span class="number">1</span>] : Integer.MAX_VALUE;</span><br><span class="line">                dpTemp[c] = Math.min(mid, Math.min(left, right));</span><br><span class="line">            &#125;</span><br><span class="line">            dp = dpTemp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : dp) &#123;</span><br><span class="line">            retVal = Math.min(retVal, num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="935-knight-dialer"><a href="#935-knight-dialer" class="headerlink" title="935. knight-dialer"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/knight-dialer/">935. knight-dialer</a></h4><ul>
<li>假设一个knight只能走「日」字，求它在拨号盘上走N步可以走多少种不同的号码。</li>
<li>转换成图论题，就是从一个点到另一个节点有多少种路径。先用数组构图表示当前数字能走到哪里，然后就可以考虑DFS或者DP。dp表示走到当前数字有多少种不同路径，后续的数字就是前序节点的路径数之和。注意取模防止overflow。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>[][] graph = <span class="keyword">new</span> <span class="title class_">int</span>[][] &#123;&#123;<span class="number">4</span>, <span class="number">6</span>&#125;, </span><br><span class="line">                                            &#123;<span class="number">6</span>, <span class="number">8</span>&#125;,</span><br><span class="line">                                            &#123;<span class="number">7</span>, <span class="number">9</span>&#125;,</span><br><span class="line">                                            &#123;<span class="number">4</span>, <span class="number">8</span>&#125;,</span><br><span class="line">                                            &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">9</span>&#125;,</span><br><span class="line">                                            &#123;&#125;,</span><br><span class="line">                                            &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">7</span>&#125;,</span><br><span class="line">                                            &#123;<span class="number">2</span>, <span class="number">6</span>&#125;,</span><br><span class="line">                                            &#123;<span class="number">1</span>, <span class="number">3</span>&#125;,</span><br><span class="line">                                            &#123;<span class="number">2</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">knightDialer</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (N &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[][] memo = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">        memo[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= <span class="number">9</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k : graph[j]) &#123;</span><br><span class="line">                memo[i][j] = ((memo[i - <span class="number">1</span>][k] % MOD) + memo[i][j]) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">        sum = (memo[N][i] + sum) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum % MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="937-reorder-data-in-log-files"><a href="#937-reorder-data-in-log-files" class="headerlink" title="937. reorder-data-in-log-files"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reorder-data-in-log-files/">937. reorder-data-in-log-files</a></h4><ul>
<li>按照规定顺序排序，自己实现comparator即可。pass.</li>
</ul>
<h4 id="938-range-sum-of-bst"><a href="#938-range-sum-of-bst" class="headerlink" title="938. range-sum-of-bst"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/range-sum-of-bst/">938. range-sum-of-bst</a></h4><ul>
<li>给一个BST和范围[L, R]，求落在范围内的节点值之和。递归搞定，不过需要注意可以通过if省去一些判断。pass。</li>
</ul>
<h4 id="939-minimum-area-rectangle"><a href="#939-minimum-area-rectangle" class="headerlink" title="939. minimum-area-rectangle"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-area-rectangle/">939. minimum-area-rectangle</a></h4><ul>
<li>给一个二维空间中点坐标的数组，求这些点所能组成的矩形的最小面积，若没有则返回0.</li>
<li>将坐标按照<code>x -&gt; y</code>的映射关系存入<code>map: int -&gt; set</code>，然后O(N^2)两重循环逐个取出点来判断能否组成矩形，然后更新面积。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minAreaRect</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (points == <span class="literal">null</span> || points.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    Map&lt;Integer, Set&lt;Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] point : points) &#123;</span><br><span class="line">        map.putIfAbsent(point[<span class="number">0</span>], <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line">        map.get(point[<span class="number">0</span>]).add(point[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] point1 : points) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] point2 : points) &#123;</span><br><span class="line">            <span class="keyword">if</span> (point1[<span class="number">0</span>] &gt;= point2[<span class="number">0</span>] || point1[<span class="number">1</span>] &gt;= point2[<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (map.get(point1[<span class="number">0</span>]).contains(point2[<span class="number">1</span>]) &amp;&amp; map.get(point2[<span class="number">0</span>]).contains(point1[<span class="number">1</span>])) &#123;</span><br><span class="line">                area = Math.min((point2[<span class="number">0</span>] - point1[<span class="number">0</span>]) * (point2[<span class="number">1</span>] - point1[<span class="number">1</span>]), area);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area == Integer.MAX_VALUE ? <span class="number">0</span> : area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="941-valid-mountain-array"><a href="#941-valid-mountain-array" class="headerlink" title="941. valid-mountain-array"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-mountain-array/">941. valid-mountain-array</a></h4><ul>
<li>给一个数组，判断它是否严格mountain array，即长度大于等于3且相邻数字严格上升接严格下降。pass.</li>
</ul>
<h4 id="942-di-string-match"><a href="#942-di-string-match" class="headerlink" title="942. di-string-match"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/di-string-match/">942. di-string-match</a></h4><ul>
<li>给一个只含有<code>I</code>或者<code>D</code>的字符串s，返回任意的permutation int数组，其中的数字是<code>0 ~ s.length()</code>且满足<code>I</code>上升、<code>D</code>下降的indicator。greedy搞定。pass。</li>
</ul>
<h4 id="945-minimum-increment-to-make-array-unique"><a href="#945-minimum-increment-to-make-array-unique" class="headerlink" title="945. minimum-increment-to-make-array-unique"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-increment-to-make-array-unique/">945. minimum-increment-to-make-array-unique</a></h4><ul>
<li>给一个int数组，可以给其中的数字+1，问总共最少加多少能让数组中数字各不相同。</li>
<li>方法一：sort + 前后比较。下一个数字必须是前一个数字 + 1才能保证唯一。排序后从前往后遍历，如果当前数字比需要的数字小，说明有重复了，差值就是需要的inc。需要的数字由当前数字+1或者当前需要的数字+1中最大值得到。时间复杂度<code>O(NlogN)</code>。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minIncrementForUnique</span><span class="params">(<span class="type">int</span>[] A)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || A.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(A);</span><br><span class="line">        <span class="type">int</span> <span class="variable">minInc</span> <span class="operator">=</span> <span class="number">0</span>, need = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : A) &#123;</span><br><span class="line">            <span class="comment">// 如果num本身都比need大，那不用加了</span></span><br><span class="line">            minInc += Math.max(need - num, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 下一个需要的数字是当前数字和need较大者 + 1才能保证唯一</span></span><br><span class="line">            need = Math.max(num, need) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minInc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：用TreeMap统计数字出现的频数顺便排序，然后从小到大取数字。如果当前数字小于need，那么需要inc的就是count个<code>(need - num)</code>，再加上后续的累加。而下一个need就是当前need和num的较大者加上count，因为需要隔开count个才能保证不重复。时间复杂度<code>O(NlogK)</code>，空间<code>O(K)</code>，K为不同的数字个数。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minIncrementForUnique</span><span class="params">(<span class="type">int</span>[] A)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || A.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeMap&lt;Integer, Integer&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : A) &#123;</span><br><span class="line">            treeMap.put(num, treeMap.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minInc</span> <span class="operator">=</span> <span class="number">0</span>, need = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : treeMap.keySet()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> treeMap.get(num);</span><br><span class="line">            <span class="comment">// (1 + count-1) * (count-1) / 2就是从need开始后续需要继续累加的数目</span></span><br><span class="line">            minInc += count * Math.max(need - num, <span class="number">0</span>) + count * (count - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            need = Math.max(need, num) + count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minInc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法三：bucket placement。将count丢入木桶中之后，从前往后找空闲的木桶，放进去即可。一个技巧是，当发现有重复元素的时候就直接减去dup，之后找到空闲时再加上空闲的元素free，本质上就还是加上(free - dup).</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minIncrementForUnique</span><span class="params">(<span class="type">int</span>[] A)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || A.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] bucket = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : A) &#123;</span><br><span class="line">            bucket[num]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minInc</span> <span class="operator">=</span> <span class="number">0</span>, dupCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>; num &lt; <span class="number">100000</span>; num++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket[num] &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                dupCount += (bucket[num] - <span class="number">1</span>);</span><br><span class="line">                minInc -= (bucket[num] - <span class="number">1</span>) * num;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dupCount &gt; <span class="number">0</span> &amp;&amp; bucket[num] == <span class="number">0</span>) &#123;</span><br><span class="line">                dupCount--;</span><br><span class="line">                minInc += num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minInc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="946-validate-stack-sequences"><a href="#946-validate-stack-sequences" class="headerlink" title="946. validate-stack-sequences"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/validate-stack-sequences/">946. validate-stack-sequences</a></h4><ul>
<li>给两个int数组，一个是push到栈的顺序，另一个是pop出来的顺序，问是否能按push的顺序最后得到pop的结果。</li>
<li>模拟一遍即可。pass.</li>
</ul>
<h4 id="947-most-stones-removed-with-same-row-or-column"><a href="#947-most-stones-removed-with-same-row-or-column" class="headerlink" title="947. most-stones-removed-with-same-row-or-column"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/">947. most-stones-removed-with-same-row-or-column</a></h4><ul>
<li>给一系列二维平面上点的坐标，当每个点的横或纵坐标上有其他点的时候它才能被拿掉，求最多拿掉多少点。</li>
<li>抽象问题：当一个点的横或纵坐标上有其他点时，它们可以看作是「一伙的」，问题转换为求总共有多少个这样的独立island，总数减去独立island数即为所求。而算island数量除了DFS，还可以利用并查集来确定每个点所属的根节点，然后。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parents;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeStones</span><span class="params">(<span class="type">int</span>[][] stones)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stones == <span class="literal">null</span> || stones.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        parents = <span class="keyword">new</span> <span class="title class_">int</span>[stones.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stones.length; i++) &#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stones.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; stones.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (shouldUnion(stones[i], stones[j])) &#123;</span><br><span class="line">                    union(i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> stones.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parents.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parents[i] == i) &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">shouldUnion</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span>[] b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] == b[<span class="number">0</span>] || a[<span class="number">1</span>] == b[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">xParent</span> <span class="operator">=</span> find(x);</span><br><span class="line">        <span class="type">int</span> <span class="variable">yParent</span> <span class="operator">=</span> find(y);</span><br><span class="line">        <span class="keyword">if</span> (xParent != yParent) &#123;</span><br><span class="line">            parents[yParent] = xParent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">retVal</span> <span class="operator">=</span> parents[x];</span><br><span class="line">        <span class="keyword">while</span> (retVal != parents[retVal]) &#123;</span><br><span class="line">            parents[retVal] = parents[parents[retVal]];</span><br><span class="line">            retVal = parents[retVal];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="950-reveal-cards-in-increasing-order"><a href="#950-reveal-cards-in-increasing-order" class="headerlink" title="950. reveal-cards-in-increasing-order"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reveal-cards-in-increasing-order/">950. reveal-cards-in-increasing-order</a></h4><ul>
<li>给一副扑克牌，从顶上抽取一张后紧接着塞到最底下，然后继续抽最顶上的，直到所有牌抽完。给一个int数组表示扑克牌，返回适当的顺序使得最后依次抽取所得的是从小到大的顺序。</li>
<li>利用队列模拟之。首先对所给的数组排序，这就是最终抽取出来希望得到的顺序。用队列来模拟取的牌的索引，初始时往队列中存入0~n表示这些牌对应的索引。一开始取的是最顶上的牌，<code>ans[0] = deckSorted[0]</code>，然后将<code>1</code>出队再塞到队尾。接下来应当取的是<code>ans[2] = deckSorted[1]</code>，以此类推。。。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] deckRevealedIncreasing(<span class="type">int</span>[] deck) &#123;</span><br><span class="line">        <span class="keyword">if</span> (deck == <span class="literal">null</span> || deck.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(deck);  <span class="comment">// deck从小到大排好序</span></span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; deck.length; i++) &#123;</span><br><span class="line">            q.offer(i); <span class="comment">// 先将索引入队，表示最终取出的顺序</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[deck.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; deck.length; i++) &#123;</span><br><span class="line">            ans[q.poll()] = deck[i];    <span class="comment">// 接下来从ans中取的卡片应该以队首为索引，对应deck[i]</span></span><br><span class="line">            q.offer(q.poll());          <span class="comment">// 将后一个索引重新塞到最底下</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="951-flip-equivalent-binary-trees"><a href="#951-flip-equivalent-binary-trees" class="headerlink" title="951. flip-equivalent-binary-trees"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/flip-equivalent-binary-trees/">951. flip-equivalent-binary-trees</a></h4><ul>
<li>给两个二叉树，判断是否可以通过左右孩子互换的方式从一个树得到另一个树。</li>
<li>直接递归解决。若两个节点val都不一样，直接就false了。如果一样，则可能需要左右孩子互换，抑或不用。</li>
<li>值得注意的是时间复杂度分析。<a target="_blank" rel="noopener" href="https://leetcode.com/problems/flip-equivalent-binary-trees/discuss/200514/Java-3-liner-with-explanation-time-and-space%3A-O(n).">大神们分析这个时间复杂度是O(N^2)</a>，但我理解中每个节点只会被访问一次，难道不是O(N)吗？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">flipEquiv</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">null</span> &amp;&amp; root2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">null</span> || root2 == <span class="literal">null</span> || root1.val != root2.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (flipEquiv(root1.left, root2.left) &amp;&amp; flipEquiv(root1.right, root2.right)) ||</span><br><span class="line">            (flipEquiv(root1.left, root2.right) &amp;&amp; flipEquiv(root1.right, root2.left));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="953-verifying-an-alien-dictionary"><a href="#953-verifying-an-alien-dictionary" class="headerlink" title="953. verifying-an-alien-dictionary"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/verifying-an-alien-dictionary/">953. verifying-an-alien-dictionary</a></h4><ul>
<li>给一个只有小写字母的外星人字典的顺序，给一个String数组，判断这个数组是否符合该字典序。直接用一个数组模拟字符到排名的map，然后前后两个字符串判断是否符合即可。skip.</li>
</ul>
<h4 id="957-prison-cells-after-n-days"><a href="#957-prison-cells-after-n-days" class="headerlink" title="957. prison-cells-after-n-days"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/prison-cells-after-n-days/">957. prison-cells-after-n-days</a></h4><ul>
<li>给一个只含有0和1的int数组，若左右两个元素相同，则转换为1，否则转换为0.求N天之后的状态。</li>
<li>实现转换到下一天的方法不难，主要是要注意这个N可能很大，因此猜测其中可能存在环，如果之前出现过当前这个组合，就可以通过模运算省去很多次转换。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] prisonAfterNDays(<span class="type">int</span>[] cells, <span class="type">int</span> N) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cells == <span class="literal">null</span> || cells.length == <span class="number">0</span> || N &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">hasCycle</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="type">int</span>[] next = findNext(cells);</span><br><span class="line">            <span class="type">String</span> <span class="variable">encoded</span> <span class="operator">=</span> Arrays.toString(next);</span><br><span class="line">            <span class="keyword">if</span> (set.contains(encoded)) &#123;</span><br><span class="line">                hasCycle = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set.add(encoded);</span><br><span class="line">                cells = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hasCycle) &#123;</span><br><span class="line">            N %= set.size();</span><br><span class="line">            <span class="keyword">while</span> (N-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                cells = findNext(cells);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cells;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] findNext(<span class="type">int</span>[] cells) &#123;</span><br><span class="line">        <span class="type">int</span>[] retVal = <span class="keyword">new</span> <span class="title class_">int</span>[cells.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i + <span class="number">1</span> &lt; cells.length; i++) &#123;</span><br><span class="line">            retVal[i] = cells[i - <span class="number">1</span>] == cells[i + <span class="number">1</span>] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="958-check-completeness-of-a-binary-tree"><a href="#958-check-completeness-of-a-binary-tree" class="headerlink" title="958. check-completeness-of-a-binary-tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/check-completeness-of-a-binary-tree/">958. check-completeness-of-a-binary-tree</a></h4><ul>
<li>给一个二叉树，判断它是否是complete的，即除了最后一层可以不满，其余层都全满，且最后一层节点尽可能靠左。</li>
<li>既然是只有最后一层才可以出现叶子节点，且要尽量靠左，则可以考虑层级遍历的时候将null也放入，这样一旦遍历时出现了null，就说明后续不能再出现非null的节点了，如果后续还有正常节点就返回false。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCompleteTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">end</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> q.poll();</span><br><span class="line">        <span class="keyword">if</span> (curr == <span class="literal">null</span>) &#123;</span><br><span class="line">            end = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (end) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;    </span><br><span class="line">            &#125;</span><br><span class="line">            q.offer(curr.left);</span><br><span class="line">            q.offer(curr.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>递归的一个做法是数节点的个数，然后假设每个节点都处在正确的位置，也就有正确的index。递归遍历时判断实际index是否超过了总节点数，因为一旦之前出现了null，后续的节点就一定会有偏大的index。这个做法的坏处是要pass两次，第一次求得总节点数，第二次是判断index。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCompleteTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">totalNodes</span> <span class="operator">=</span> countNodes(root);</span><br><span class="line">    <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> checkIndex(root, startIndex, totalNodes);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkIndex</span><span class="params">(TreeNode root, <span class="type">int</span> startIndex, <span class="type">int</span> maxIndex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt; maxIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左孩子是当前节点*2，右孩子是当前*2+1</span></span><br><span class="line">    <span class="keyword">return</span> checkIndex(root.left, startIndex * <span class="number">2</span>, maxIndex) &amp;&amp; checkIndex(root.right, startIndex * <span class="number">2</span> + <span class="number">1</span>, maxIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="963-minimum-area-rectangle-ii"><a href="#963-minimum-area-rectangle-ii" class="headerlink" title="963. minimum-area-rectangle-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-area-rectangle-ii/">963. minimum-area-rectangle-ii</a></h4><ul>
<li>给一组点的坐标，求它们所能组成的最小的矩形的面积。</li>
<li>矩形的重要特征是对角线相等，因此考虑即线段两两之间的中心点和距离进行归类存入map，同一个key下的即为距离相等的线段，在其中遍历找最小面积即可。时间复杂度乍一看是O(N^2)但主要瓶颈在最后遍历求最小面积这一步，显然不是单纯的双重循环，因为可能的距离-中点的所有组成线段都得遍历。貌似最坏情况是<code>O(N^4)</code>?</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">minAreaFreeRect</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (points == <span class="literal">null</span> || points.length &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, List&lt;<span class="type">int</span>[]&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; points.length; j++) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">dist</span> <span class="operator">=</span> getSqrtDist(points[i], points[j]);</span><br><span class="line">                <span class="type">long</span> <span class="variable">midX</span> <span class="operator">=</span> points[i][<span class="number">0</span>] + points[j][<span class="number">0</span>];</span><br><span class="line">                <span class="type">long</span> <span class="variable">midY</span> <span class="operator">=</span> points[i][<span class="number">1</span>] + points[j][<span class="number">1</span>];</span><br><span class="line">                <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> dist + <span class="string">&quot;-&quot;</span> + midX + <span class="string">&quot;,&quot;</span> + midY;</span><br><span class="line">                map.putIfAbsent(key, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">                map.get(key).add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> <span class="variable">min</span> <span class="operator">=</span> Double.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (List&lt;<span class="type">int</span>[]&gt; list : map.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list.size() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; list.size(); j++) &#123;</span><br><span class="line">                        <span class="type">int</span>[] point1 = points[list.get(i)[<span class="number">0</span>]];</span><br><span class="line">                        <span class="type">int</span>[] point2 = points[list.get(i)[<span class="number">1</span>]];</span><br><span class="line">                        <span class="type">int</span>[] point3 = points[list.get(j)[<span class="number">0</span>]];</span><br><span class="line">                        <span class="type">double</span> <span class="variable">dist1</span> <span class="operator">=</span> getDist(point1, point3);</span><br><span class="line">                        <span class="type">double</span> <span class="variable">dist2</span> <span class="operator">=</span> getDist(point2, point3);</span><br><span class="line">                        min = Math.min(dist1 * dist2, min);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min == Double.MAX_VALUE ? <span class="number">0</span> : min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">getSqrtDist</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span>[] b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (a[<span class="number">0</span>] - b[<span class="number">0</span>]) * (a[<span class="number">0</span>] - b[<span class="number">0</span>]) + (a[<span class="number">1</span>] - b[<span class="number">1</span>]) * (a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="title function_">getDist</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span>[] b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(getSqrtDist(a, b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="965-univalued-binary-tree"><a href="#965-univalued-binary-tree" class="headerlink" title="965. univalued-binary-tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/univalued-binary-tree/">965. univalued-binary-tree</a></h4><ul>
<li>给一个二叉树，判断其中所有节点是否是一样的value。</li>
</ul>
<h4 id="968-binary-tree-cameras"><a href="#968-binary-tree-cameras" class="headerlink" title="968. binary-tree-cameras"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-cameras/">968. binary-tree-cameras</a></h4><ul>
<li>给一个二叉树，在一个节点处放置camera可以监控它本身、父节点、子节点。求最少需要放置多少camera可以监控所有的节点。</li>
<li>方法一：贪心。树中如果将camera放置在叶子结点，它只能覆盖parent和叶子本身。如果放到叶子的parent处，则可以覆盖从它的parent到它的叶子三层，因此最佳化就是将camera放在叶子的parent处。因此进行dfs时，尽可能放置到叶子parent处，然后回溯时忽略已经被下层覆盖到的节点，直到回到root. 可以利用状态<code>0</code>表示”叶子”节点（不一定真的是叶子，只是表明它需要上层的cover）、<code>1</code>表示叶子的parent（要把camera放在这里）、<code>2</code>表示叶子parent的parent（已经被下层的cover到了）。如果当前节点为null就当作它已经被覆盖，如果左或者右孩子需要cover则当前就必须放camera，如果左或者右孩子已经有camera了则当前的已经被覆盖了。时间复杂度<code>O(N)</code>, 空间复杂度为树的高度<code>O(logN)</code>.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCameraCover</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (dfs(root) &lt; <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>) + count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;   <span class="comment">// 不需要覆盖</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> dfs(root.left), right = dfs(root.right);</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">0</span> || right == <span class="number">0</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;   <span class="comment">// 当前必须放camera</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只要下方有一个camera，当前就不需要覆盖了</span></span><br><span class="line">        <span class="keyword">return</span> (left == <span class="number">1</span> || right == <span class="number">1</span>) ? <span class="number">2</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：DP。和上一个思路一样，每个节点只有三种可能：<code>0</code>需要被覆盖、<code>1</code>放置了camera和<code>2</code>已经被覆盖到了。当前节点如果是0，则下方两个节点必须都是<code>2</code>；如果当前节点是<code>1</code>，则下方两个节点3种情况都有可能；如果当前节点是<code>2</code>，则下方两个节点有一个必须是<code>1</code>.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCameraCover</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ans = solve(root);</span><br><span class="line">        <span class="keyword">return</span> Math.min(ans[<span class="number">1</span>], ans[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// retVal有三个值，分别表示当前需要覆盖、当前放了camera、当前已被覆盖的camera数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] solve(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">0</span>, <span class="number">1001</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] left = solve(root.left), right = solve(root.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">minLeft12</span> <span class="operator">=</span> Math.min(left[<span class="number">1</span>], left[<span class="number">2</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">minRight12</span> <span class="operator">=</span> Math.min(right[<span class="number">1</span>], right[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count0</span> <span class="operator">=</span> left[<span class="number">2</span>] + right[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">count1</span> <span class="operator">=</span> <span class="number">1</span> + Math.min(left[<span class="number">0</span>], minLeft12) + Math.min(right[<span class="number">0</span>], minRight12);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count2</span> <span class="operator">=</span> Math.min(left[<span class="number">1</span>] + minRight12, right[<span class="number">1</span>] + minLeft12);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;count0, count1, count2&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="969-pancake-sorting"><a href="#969-pancake-sorting" class="headerlink" title="969. pancake-sorting"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/pancake-sorting/">969. pancake-sorting</a></h4><ul>
<li>给一个长度为len的、只含有<code>[1, len]</code>的整数数组，求flip的长度组成的数组，使得flip完成后形成有序数组。</li>
<li>很无聊的题。很直接的<code>O(N^2)</code>解法，每次找到当前范围内最大的数字，先flip到最前方，再flip到末尾，直到所有数字都在他们应该在的位置。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">pancakeSort</span><span class="params">(<span class="type">int</span>[] A)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || A.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> getIndexOf(A, A.length - i);</span><br><span class="line">            <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index != <span class="number">0</span>) &#123;</span><br><span class="line">                reverse(A, index);</span><br><span class="line">                ans.add(index + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; A.length - <span class="number">1</span>) &#123;</span><br><span class="line">                reverse(A, A.length - i - <span class="number">1</span>);</span><br><span class="line">                ans.add(A.length - i); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getIndexOf</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> lastIndex)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = lastIndex;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> A[left];</span><br><span class="line">            A[left++] = A[right];</span><br><span class="line">            A[right--] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="971-flip-binary-tree-to-match-preorder-traversal"><a href="#971-flip-binary-tree-to-match-preorder-traversal" class="headerlink" title="971. flip-binary-tree-to-match-preorder-traversal"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/flip-binary-tree-to-match-preorder-traversal/">971. flip-binary-tree-to-match-preorder-traversal</a></h4><ul>
<li>给一个二叉树，各个节点值各不相同。给一个int数组表示节点前序遍历的结果，返回一个需要flip（将该节点的左右孩子对调）的节点值的list，不存在则返回<code>[-1]</code>.</li>
<li>对二叉树进行前序遍历，用一个全局索引往后遍历voyage数组，如果当前节点和该数字不匹配说明当前这个行不通。如果当前节点有左孩子且值不匹配，则尝试用右孩子去比较。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; retVal = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">flipMatchVoyage</span><span class="params">(TreeNode root, <span class="type">int</span>[] voyage)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (voyage == <span class="literal">null</span> || voyage.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> retVal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(root, voyage) ? retVal : Arrays.asList(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span>[] voyage)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val != voyage[index++]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span> &amp;&amp; root.left.val != voyage[index]) &#123;</span><br><span class="line">            retVal.add(root.val);</span><br><span class="line">            <span class="keyword">return</span> dfs(root.right, voyage) &amp;&amp; dfs(root.left, voyage);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(root.left, voyage) &amp;&amp; dfs(root.right, voyage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="973-k-closest-points-to-origin"><a href="#973-k-closest-points-to-origin" class="headerlink" title="973. k-closest-points-to-origin"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/k-closest-points-to-origin/">973. k-closest-points-to-origin</a></h4><ul>
<li>给一个含有二维坐标点的数组，求这些点到原点最近的top-k个。返回的顺序无所谓，不用从小到大排。</li>
<li>方法一：max heap，用优先队列从大到小排，若超过k个则poll掉。时间复杂度<code>O(NlogN)</code>. 直接排序个序取k个也是一样的。</li>
<li>方法二：要求提升时间复杂度到<code>O(N)</code>，那么就要思考如何利用”返回顺序无所谓”这个条件了。因此可以考虑利用quicksort取第k个元素类似的原理，将原数组「部分排序」，只要保证前K个是最小的即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] kClosest(<span class="type">int</span>[][] points, <span class="type">int</span> K) &#123;</span><br><span class="line">        <span class="keyword">if</span> (points == <span class="literal">null</span> || points.length == <span class="number">0</span> || K &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> points;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> points.length, left = <span class="number">0</span>, right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> partition(points, left, right);</span><br><span class="line">            <span class="keyword">if</span> (mid == K) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid &lt; K) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(points, <span class="number">0</span>, K);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[][] points, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> start, right = end + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] pivot = points[start];</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (compare(points[++left], pivot) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (left == end) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (compare(points[--right], pivot) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (right == start) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(points, left, right);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(points, start, right);</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[][] points, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;points[i][<span class="number">0</span>], points[i][<span class="number">1</span>]&#125;;</span><br><span class="line">        points[i][<span class="number">0</span>] = points[j][<span class="number">0</span>];</span><br><span class="line">        points[i][<span class="number">1</span>] = points[j][<span class="number">1</span>];</span><br><span class="line">        points[j][<span class="number">0</span>] = temp[<span class="number">0</span>];</span><br><span class="line">        points[j][<span class="number">1</span>] = temp[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="title function_">getDist</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt((<span class="type">double</span>)a[<span class="number">0</span>] * a[<span class="number">0</span>] + (<span class="type">double</span>)a[<span class="number">1</span>] * a[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] point1, <span class="type">int</span>[] point2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Double.compare(getDist(point1), getDist(point2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="977-squares-of-a-sorted-array"><a href="#977-squares-of-a-sorted-array" class="headerlink" title="977. squares-of-a-sorted-array"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/squares-of-a-sorted-array/">977. squares-of-a-sorted-array</a></h4><ul>
<li>给一个非降序的数组，返回从小到大排好序的各元素平方的数组。双指针搞定，skip.</li>
</ul>
<h4 id="979-distribute-coins-in-binary-tree"><a href="#979-distribute-coins-in-binary-tree" class="headerlink" title="979. distribute-coins-in-binary-tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/distribute-coins-in-binary-tree/">979. distribute-coins-in-binary-tree</a></h4><ul>
<li>在二叉树中每一个节点都放着若干coins，求将每个节点的coin都变为1总共需要挪动多少步，注意从根到子&#x2F;从子到根都算作1步。给出根节点，一定有解，求步数。</li>
<li>递归的思路，后序遍历将左子树和右子树能提供的coin数拿到，加上当前节点的coin数减去留下的1枚coin，就是当前节点能提供给上层的coin数。移动数则直接就是左子树和右子树能提供coin数的绝对值。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">move</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">distributeCoins</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> move;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> traverse(root.left);     <span class="comment">// 左边能提供多少coin</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> traverse(root.right);   <span class="comment">// 右边能提供多少coin</span></span><br><span class="line">        move += Math.abs(left) + Math.abs(right);</span><br><span class="line">        <span class="keyword">return</span> root.val + left + right - <span class="number">1</span>; <span class="comment">// 能提供的所有coin数减去要留下的1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="981-time-based-key-value-store"><a href="#981-time-based-key-value-store" class="headerlink" title="981. time-based-key-value-store"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/time-based-key-value-store/">981. time-based-key-value-store</a></h4><ul>
<li>实现一个带有timestamp的key-value store，给定key和timestamp，可以返回不超过该时刻的value，若不存在则返回<code>&quot;&quot;</code>。</li>
<li>显然需要对每个key维护一个有序的timestamp序列，想到TreeMap，利用floor可以找到「小于等于该时刻」的timestamp了。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimeMap</span> &#123;    </span><br><span class="line">    Map&lt;String, TreeMap&lt;Integer, String&gt;&gt; map;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TimeMap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, String value, <span class="type">int</span> timestamp)</span> &#123;</span><br><span class="line">        map.putIfAbsent(key, <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;());</span><br><span class="line">        map.get(key).put(timestamp, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(String key, <span class="type">int</span> timestamp)</span> &#123;</span><br><span class="line">        TreeMap&lt;Integer, String&gt; treeMap = map.get(key);</span><br><span class="line">        <span class="keyword">if</span> (treeMap == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map.Entry&lt;Integer, String&gt; entry = treeMap.floorEntry(timestamp);</span><br><span class="line">        <span class="keyword">if</span> (entry == <span class="literal">null</span>) &#123;    <span class="comment">// 没有比timestamp早的值，返回空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> entry.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="983-minimum-cost-for-tickets"><a href="#983-minimum-cost-for-tickets" class="headerlink" title="983. minimum-cost-for-tickets"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-cost-for-tickets/">983. minimum-cost-for-tickets</a></h4><ul>
<li>给一个出差天数的数组(值为<code>[1, 365]</code>)，假设出差过程中可以购买1日票、7日票和30日票，对应价格存在一个数组中给出。求覆盖所有出差天数所需要的最少开销。</li>
<li>方法一：DP + binarySearch. 数组中存放该位置对应日期的最小开销，每次往前查找可能的天数，<code>dp[i] = dp[prev] + cost[x]</code>更新。时间复杂度为<code>O(NlogN)</code>.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>[] VALID_PERIODS = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>, <span class="number">7</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mincostTickets</span><span class="params">(<span class="type">int</span>[] days, <span class="type">int</span>[] costs)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (days == <span class="literal">null</span> || days.length == <span class="number">0</span> ||</span><br><span class="line">           costs == <span class="literal">null</span> || costs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[days.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; days.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">startDay</span> <span class="operator">=</span> days[i] - VALID_PERIODS[j] + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> startDay &lt; <span class="number">1</span> ? <span class="number">0</span> : Arrays.binarySearch(days, startDay);</span><br><span class="line">                <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    index = -index - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i] = index &gt; <span class="number">0</span> ? dp[index - <span class="number">1</span>] + costs[j] : costs[j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i] = Math.min(dp[i], index &gt; <span class="number">0</span> ? dp[index - <span class="number">1</span>] + costs[j] : costs[j]);</span><br><span class="line">                &#125;      </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[days.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：既然天数是固定的，我们完全可以固定一个<code>[1, 365]</code>数组来查找。这样就可以将时间变为<code>O(N)</code>,空间也为<code>O(N)</code>、或者说<code>O(366)</code>. 当然还可以对空间进行优化，利用modulo重复利用空间，这样可以缩小空间为<code>O(30)</code>.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>[] VALID_PERIODS = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>, <span class="number">7</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DAYS_IN_A_YEAR</span> <span class="operator">=</span> <span class="number">365</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mincostTickets</span><span class="params">(<span class="type">int</span>[] days, <span class="type">int</span>[] costs)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (days == <span class="literal">null</span> || days.length == <span class="number">0</span> ||</span><br><span class="line">           costs == <span class="literal">null</span> || costs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>, lastDay = days[days.length - <span class="number">1</span>], maxValidPeriod = VALID_PERIODS[VALID_PERIODS.length - <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[DAYS_IN_A_YEAR + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> days[<span class="number">0</span>]; day &lt;= lastDay; day++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (days[index] != day) &#123;</span><br><span class="line">                dp[day] = dp[day - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[day] = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                    dp[day] = Math.min(dp[day], dp[(Math.max(day - VALID_PERIODS[j], <span class="number">0</span>))] + costs[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[lastDay];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="986-interval-list-intersections"><a href="#986-interval-list-intersections" class="headerlink" title="986. interval-list-intersections"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/interval-list-intersections/">986. interval-list-intersections</a></h4><ul>
<li>给两个排好序的、自身互不重叠的interval数组，返回他们互相重叠的部分。用暴力if分类讨论搞定，具体情况比较复杂，但还是可以想清楚的。skip.</li>
</ul>
<h4 id="987-vertical-order-traversal-of-a-binary-tree"><a href="#987-vertical-order-traversal-of-a-binary-tree" class="headerlink" title="987. vertical-order-traversal-of-a-binary-tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/">987. vertical-order-traversal-of-a-binary-tree</a></h4><ul>
<li>给一个二叉树，要求返回垂直方向上节点value的遍历List of lists，在统一垂直线上浅的节点需要排在深的节点前面，若垂直方向相同、深浅相同，则按value从小到大排。</li>
<li>一开始没有注意顺序问题，直接递归方法做了，利用一个index变量记录当前节点与root的相对偏移。而如果要考虑顺序，则首先考虑如何保证深浅——，利用一个变量level作为key，即可保证插入是level由浅到深的，而value则需要保证节点值从小到大，可直接用PriorityQueue.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">leftMostIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">verticalTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, TreeMap&lt;Integer, PriorityQueue&lt;Integer&gt;&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        helper(root, <span class="number">0</span>, <span class="number">0</span>, map);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; map.size(); index++) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            TreeMap&lt;Integer, PriorityQueue&lt;Integer&gt;&gt; treeMap = map.get(index + leftMostIndex); <span class="comment">// 全局偏移</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> level : treeMap.keySet()) &#123;</span><br><span class="line">                PriorityQueue&lt;Integer&gt; pq = treeMap.get(level);</span><br><span class="line">                <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">                    ans.get(index).add(pq.poll());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">helper</span><span class="params">(TreeNode root, <span class="type">int</span> index, <span class="type">int</span> level, Map&lt;Integer, TreeMap&lt;Integer, PriorityQueue&lt;Integer&gt;&gt;&gt; map)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        leftMostIndex = Math.min(index, leftMostIndex);     <span class="comment">// 更新最左节点的index作为全局偏移</span></span><br><span class="line">        map.putIfAbsent(index, <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;());            <span class="comment">// 在当前index插入新的TreeMap</span></span><br><span class="line">        map.get(index).putIfAbsent(level, <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;());   <span class="comment">// 插入新的pq</span></span><br><span class="line">        map.get(index).get(level).offer(root.val);</span><br><span class="line">        helper(root.left, index - <span class="number">1</span>, level + <span class="number">1</span>, map);</span><br><span class="line">        helper(root.right, index + <span class="number">1</span>, level + <span class="number">1</span>, map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="988-smallest-string-starting-from-leaf"><a href="#988-smallest-string-starting-from-leaf" class="headerlink" title="988. smallest-string-starting-from-leaf"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/smallest-string-starting-from-leaf/">988. smallest-string-starting-from-leaf</a></h4><ul>
<li>给一个二叉树，其中的数字只含有<code>[0, 26]</code>，表示小写字母。求从叶子到根的最小字典序的字符串。</li>
<li>一开始理解错了字典序。字典序与长度无关，直接是按字母排的，因此用BFS没有任何优势。DFS写出来的代码还更简洁。</li>
</ul>
<h4 id="992-subarrays-with-k-different-integers"><a href="#992-subarrays-with-k-different-integers" class="headerlink" title="992. subarrays-with-k-different-integers"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/subarrays-with-k-different-integers/">992. subarrays-with-k-different-integers</a></h4><ul>
<li>给一个int数组，求含有k个不同数字的子数组的个数。</li>
<li>和<a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/">340</a>类似，可以利用滑动窗口求至多<code>K</code>个不同数字的子数组个数和至多<code>K - 1</code>个不同数字的子数组个数，相减就是恰好<code>K</code>个不同数字的子数组个数。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraysWithKDistinct</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> K)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || A.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> atMostKDistinct(A, K) - atMostKDistinct(A, K - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">atMostKDistinct</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            map.put(nums[j], map.getOrDefault(nums[j], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (map.size() &gt; k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map.get(nums[i]) == <span class="number">1</span>) &#123;</span><br><span class="line">                    map.remove(nums[i]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    map.put(nums[i], map.get(nums[i]) - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            count += (j - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="993-cousins-in-binary-tree"><a href="#993-cousins-in-binary-tree" class="headerlink" title="993. cousins-in-binary-tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/cousins-in-binary-tree/">993. cousins-in-binary-tree</a></h4><ul>
<li>给一个各节点值各不相同的二叉树，给两个值，判断他们是否是cousin（depth相同而parent不同）。</li>
<li>可以用map来track每个节点的depth和parent。也可以进行level traversal，放入null来进行分隔。如果找到的两个节点之间没有null说明是紧挨着的亲兄弟。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCousins</span><span class="params">(TreeNode root, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">found</span> <span class="operator">=</span> <span class="literal">false</span>, sibling = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            Queue&lt;TreeNode&gt; next = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                <span class="keyword">if</span> (curr == <span class="literal">null</span>) &#123;</span><br><span class="line">                    sibling = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (curr.val == x || curr.val == y) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (found) &#123;</span><br><span class="line">                        <span class="keyword">return</span> !sibling;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        found = <span class="literal">true</span>;</span><br><span class="line">                        sibling = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (curr.left != <span class="literal">null</span> || curr.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    next.offer(curr.left);</span><br><span class="line">                    next.offer(curr.right);</span><br><span class="line">                    next.offer(<span class="literal">null</span>);       <span class="comment">// 强行分隔</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (found) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            q = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="994-rotting-oranges"><a href="#994-rotting-oranges" class="headerlink" title="994. rotting-oranges"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/rotting-oranges/">994. rotting-oranges</a></h4><ul>
<li>给一个二维数组，0表示空、1表示好的橘子、2表示烂的橘子，每分钟烂橘子会感染上下左右相邻的好橘子，问经过多久所有橘子都会烂掉，若不可能全烂掉则返回-1.</li>
<li>BFS即可，需要注意的是一开始要统计所有橘子数量，然后在BFS的过程中不断减去烂掉的橘子，最后如果还剩有橘子说明无法全部感染。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] directions = <span class="keyword">new</span> <span class="title class_">int</span>[][] &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">orangesRotting</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rowCount</span> <span class="operator">=</span> grid.length, colCount = grid[<span class="number">0</span>].length, count = <span class="number">0</span>, orange = <span class="number">0</span>;</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rowCount; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; colCount; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    orange++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>) &#123;</span><br><span class="line">                    q.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> q.size();</span><br><span class="line">            orange -= size;</span><br><span class="line">            <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span>[] curr = q.poll();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; directions.length; i++) &#123;</span><br><span class="line">                    <span class="type">int</span>[] position = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;curr[<span class="number">0</span>] + directions[i][<span class="number">0</span>], curr[<span class="number">1</span>] + directions[i][<span class="number">1</span>]&#125;;</span><br><span class="line">                    <span class="keyword">if</span> (isValid(position, rowCount, colCount) &amp;&amp; grid[position[<span class="number">0</span>]][position[<span class="number">1</span>]] == <span class="number">1</span>) &#123;</span><br><span class="line">                        grid[position[<span class="number">0</span>]][position[<span class="number">1</span>]] = <span class="number">2</span>;</span><br><span class="line">                        q.offer(position);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!q.isEmpty()) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> orange == <span class="number">0</span> ? count : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">int</span>[] position, <span class="type">int</span> rowCount, <span class="type">int</span> colCount)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> position[<span class="number">0</span>] &gt;= <span class="number">0</span> &amp;&amp; position[<span class="number">0</span>] &lt; rowCount</span><br><span class="line">            &amp;&amp; position[<span class="number">1</span>] &gt;= <span class="number">0</span> &amp;&amp; position[<span class="number">1</span>] &lt; colCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="997-find-the-town-judge"><a href="#997-find-the-town-judge" class="headerlink" title="997. find-the-town-judge"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-the-town-judge/">997. find-the-town-judge</a></h4><ul>
<li>给一个二维数组，每一项为一个pair表示a trusts b，求所有人都trust且他不trust任何人的的那个数字。</li>
<li>一开始使用map和set完成。但题目说了数组中各项不会重复，因此可以放心的利用图的入度来判断。没有一次过是因为有个测试没有想到，留个玄机。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findJudge</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span>[][] trust)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (trust == <span class="literal">null</span> || trust.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> N == <span class="number">1</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] inDegrees = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] pair : trust) &#123;</span><br><span class="line">            inDegrees[pair[<span class="number">0</span>]]--;</span><br><span class="line">            inDegrees[pair[<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDegrees[i] == N - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="998-maximum-binary-tree-ii"><a href="#998-maximum-binary-tree-ii" class="headerlink" title="998. maximum-binary-tree-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-binary-tree-ii/">998. maximum-binary-tree-ii</a></h4><ul>
<li>给一个二叉树，每个节点比它下方的所有节点都大。给一个val，插入这个max-tree，如果比root大就直接是新的root，如果小就到右子树继续插入。</li>
<li>递归写法很直接，时间空间都是O(N)。为了优化递归所需的stack space，需要想iterative实现，尽可能潜入右子树，直到右节点值小于插入值。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoMaxTree</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val), curr = root;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> || root.val &lt; val) &#123;</span><br><span class="line">            node.left = root;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curr.right != <span class="literal">null</span> &amp;&amp; curr.right.val &gt; val) &#123;</span><br><span class="line">            curr = curr.right;</span><br><span class="line">        &#125;</span><br><span class="line">        node.left = curr.right;</span><br><span class="line">        curr.right = node;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1003-check-if-word-is-valid-after-substitutions"><a href="#1003-check-if-word-is-valid-after-substitutions" class="headerlink" title="1003. check-if-word-is-valid-after-substitutions"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/check-if-word-is-valid-after-substitutions/">1003. check-if-word-is-valid-after-substitutions</a></h4><ul>
<li>stack搞定。注意java中建议用arraydeque: <code>Please consider using ArrayDeque instead of Stack for your Java solutions. Stack is an extension of Vector which is depricated List. It&#39;s methods are also synchronized which slows down the execution time.</code>. 或者最暴力的直接循环替换<code>S.replace(&quot;abc&quot;)</code>.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String S)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (S == <span class="literal">null</span> || S.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayDeque&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span>[] chars = S.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : chars) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;c&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stack.size() &gt;= <span class="number">2</span> &amp;&amp; stack.pop() == <span class="string">&#x27;b&#x27;</span> &amp;&amp; stack.pop() == <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1004-max-consecutive-ones-iii"><a href="#1004-max-consecutive-ones-iii" class="headerlink" title="1004. max-consecutive-ones-iii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/max-consecutive-ones-iii/">1004. max-consecutive-ones-iii</a></h4><ul>
<li>给一个只含有0或1的数组，假设可以将其中K个0换成1，问最长可以有多少连续的1.</li>
<li>双指针，之间的范围就是至多替换K次后的序列。right持续往后走，若当前没有剩余的credit了，就挪动left知道恢复credit。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestOnes</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> K)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || A.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>, maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; A.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[right] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (K == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (A[left++] == <span class="number">0</span>) &#123;</span><br><span class="line">                        K++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                K--;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">            maxLen = Math.max(maxLen, right - left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1007-minimum-domino-rotations-for-equal-row"><a href="#1007-minimum-domino-rotations-for-equal-row" class="headerlink" title="1007. minimum-domino-rotations-for-equal-row"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-domino-rotations-for-equal-row/">1007. minimum-domino-rotations-for-equal-row</a></h4><ul>
<li>给两个数组，表示两排的骰子值。求最小的swap次数使得任意一排的骰子值完全一样。若不存在则返回-1.</li>
<li>方法一：暴力尝试，要么是第一排骰子的值、要么是取第二排的，就分两次尝试。在每次尝试中要么使得第一排一致、要么使得第二排一致。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDominoRotations</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span>[] B)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || B == <span class="literal">null</span> || A.length != B.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">retVal</span> <span class="operator">=</span> getSwapWithTarget(A, B, A[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> retVal &gt;= <span class="number">0</span> ? retVal : getSwapWithTarget(A, B, B[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getSwapWithTarget</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span>[] B, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, equalTop = <span class="number">0</span>, equalBottom = <span class="number">0</span>; i &lt; A.length &amp;&amp; (A[i] == target || B[i] == target); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] != target) &#123;</span><br><span class="line">                equalTop++; <span class="comment">// 使得上面一排一致，因此需要swap一次</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (B[i] != target) &#123;</span><br><span class="line">                equalBottom++;  <span class="comment">// 使得下面一排一致</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == A.length - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Math.min(equalTop, equalBottom);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：取并集的思路，对两排分别统计6个点数的出现次数，同时需要统计两排的值一样的次数。要想有答案，则必须存在一个点数使得上下两排的长度和除去重复部分后，足够覆盖整一排，最后最小的交换次数就是<code>min(A, B) - (A &amp; B)</code>了。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDominoRotations</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span>[] B)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || B == <span class="literal">null</span> || A.length != B.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] countA = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">7</span>];</span><br><span class="line">        <span class="type">int</span>[] countB = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">7</span>];</span><br><span class="line">        <span class="type">int</span>[] union = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">7</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            countA[A[i]]++;</span><br><span class="line">            countB[B[i]]++;</span><br><span class="line">            <span class="keyword">if</span> (A[i] == B[i]) &#123;</span><br><span class="line">                union[A[i]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (countA[i] + countB[i] - union[i] &gt;= A.length) &#123;</span><br><span class="line">                <span class="keyword">return</span> Math.min(countA[i], countB[i]) - union[i]; <span class="comment">// 上下相同就不用交换了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1008-construct-binary-search-tree-from-preorder-traversal"><a href="#1008-construct-binary-search-tree-from-preorder-traversal" class="headerlink" title="1008. construct-binary-search-tree-from-preorder-traversal"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/">1008. construct-binary-search-tree-from-preorder-traversal</a></h4><ul>
<li>给一个BST前序遍历得到的int数组，求还原成的BST。</li>
<li>方法一：从当前节点往后找左子树和右子树，然后分别build，但是这样效率很低，因为需要重复比较大小。</li>
<li>方法二：设置一个max值表示当前这个节点的上界，如果超过就可以直接返回null，然后也是递归找。关键是用一个全局的索引表示当前处理到数组的第几位了，就不需要重复比较大小了。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">bstFromPreorder</span><span class="params">(<span class="type">int</span>[] preorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder == <span class="literal">null</span> || preorder.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> build(preorder, Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span> max)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start == preorder.length || preorder[start] &gt; max) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[start++]);</span><br><span class="line">        root.left = build(preorder, root.val);</span><br><span class="line">        root.right = build(preorder, max);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1010-pairs-of-songs-with-total-durations-divisible-by-60"><a href="#1010-pairs-of-songs-with-total-durations-divisible-by-60" class="headerlink" title="1010. pairs-of-songs-with-total-durations-divisible-by-60"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/">1010. pairs-of-songs-with-total-durations-divisible-by-60</a></h4><ul>
<li>给一个int数组，求其中有多少对儿之和可以是60的倍数。</li>
<li>本质上就是类似求two-sum，只是不求具体的索引。给一个时长t，在数组中找是否有其他时长x满足<code>(x + t) % 60 == 0 -&gt; x % 60 + t % 60 == 60 -&gt; x % 60 == 60 - t % 60</code>。但是edge case是t恰好是60的整数倍的时候，这时<code>60 - t % 60 == 60</code>，而我们希望它是<code>0</code>.直接的办法就是再摸一个。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numPairsDivisibleBy60</span><span class="params">(<span class="type">int</span>[] time)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (time == <span class="literal">null</span> || time.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">60</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] bucket = <span class="keyword">new</span> <span class="title class_">int</span>[MOD];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> t : time) &#123;</span><br><span class="line">            count += bucket[(MOD - t % MOD) % MOD];</span><br><span class="line">            bucket[t % MOD]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1011-capacity-to-ship-packages-within-d-days"><a href="#1011-capacity-to-ship-packages-within-d-days" class="headerlink" title="1011. capacity-to-ship-packages-within-d-days"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/">1011. capacity-to-ship-packages-within-d-days</a></h4><ul>
<li>给一个物品重量的int数组，再给一个天数D，要求将这些物品按顺序在D天之内用同一艘船运出，该船每天只能运一趟。求这艘船最少需要承受多少重量。</li>
<li>经典的背包问题。可以利用二分查找找到最小重量，搜索下界是最终的一个物品、上届是所有物品的和。若mid符合条件，则尝试将上界挪到mid；若无法实现，则将下界挪到mid + 1.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shipWithinDays</span><span class="params">(<span class="type">int</span>[] weights, <span class="type">int</span> D)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (weights == <span class="literal">null</span> || weights.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> weight : weights) &#123;</span><br><span class="line">            sum += weight;</span><br><span class="line">            max = Math.max(weight, max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> max, right = sum;</span><br><span class="line">        <span class="keyword">while</span> (left != right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (isPossible(weights, mid, D)) &#123;</span><br><span class="line">                right = mid;    <span class="comment">// mid仍是可能的答案，需要保留在有效范围内</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>; <span class="comment">// 不用再包含mid了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPossible</span><span class="params">(<span class="type">int</span>[] weights, <span class="type">int</span> capacity, <span class="type">int</span> days)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> weight : weights) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum + weight &gt; capacity) &#123;</span><br><span class="line">                days--;</span><br><span class="line">                sum = weight;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += weight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> days &gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1014-best-sightseeing-pair"><a href="#1014-best-sightseeing-pair" class="headerlink" title="1014. best-sightseeing-pair"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-sightseeing-pair/">1014. best-sightseeing-pair</a></h4><ul>
<li>给一个int数组，求其中最大的<code>sum = A[left] + A[right] - (right - left)</code>，即值之和减索引之差。</li>
<li>one pass的做法真的妙哉，将上式转换称<code>sum = A[left] + left + A[right] - right</code>，在从左往右循环时只需要保留left索引即可比较。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxScoreSightseeingPair</span><span class="params">(<span class="type">int</span>[] A)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || A.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">retVal</span> <span class="operator">=</span> <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> A[i] - i + A[left] + left;</span><br><span class="line">            retVal = Math.max(retVal, temp);</span><br><span class="line">            <span class="keyword">if</span> (A[i] + i &gt; A[left] + left) &#123;</span><br><span class="line">                left = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1019-next-greater-node-in-linked-list"><a href="#1019-next-greater-node-in-linked-list" class="headerlink" title="1019. next-greater-node-in-linked-list"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/next-greater-node-in-linked-list/">1019. next-greater-node-in-linked-list</a></h4><ul>
<li>给一个链表头节点，返回一个数组存放其中每一个元素的后续第一个比它大的元素。</li>
<li>经典monotone问题，用stack解决。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nextLargerNodes(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;<span class="type">int</span>[]&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; head.val &gt; stack.peek()[<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span>[] top = stack.pop();</span><br><span class="line">                list.set(top[<span class="number">0</span>], head.val);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; index++, head.val &#125;);</span><br><span class="line">            list.add(<span class="number">0</span>);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] retVal = <span class="keyword">new</span> <span class="title class_">int</span>[index];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            retVal[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1021-remove-outermost-parentheses"><a href="#1021-remove-outermost-parentheses" class="headerlink" title="1021. remove-outermost-parentheses"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-outermost-parentheses/">1021. remove-outermost-parentheses</a></h4><ul>
<li>给一个valid的括号字符串，求将最外层括号移除后的新字符串。例如<code>(()())(())(()(()))</code>可以拆分成<code>(()()), (()), (()(()))</code>，将每个部分的最外层移除后得到的就是<code>()()()()(())</code>。直接用一个计数来存左括号数目即可。pass。</li>
</ul>
<h4 id="1022-sum-of-root-to-leaf-binary-numbers"><a href="#1022-sum-of-root-to-leaf-binary-numbers" class="headerlink" title="1022. sum-of-root-to-leaf-binary-numbers"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/">1022. sum-of-root-to-leaf-binary-numbers</a></h4><ul>
<li>给一个只含有0和1的二叉树，从根到叶子表示二进制的数，求所有表示出来的数的和。直接在每一节点处累加，如果后续还有节点就左移1后继续累加。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRootToLeaf</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        val += root.val;</span><br><span class="line">        <span class="keyword">return</span> root.left == root.right ? val : dfs(root.left, val &lt;&lt; <span class="number">1</span>) + dfs(root.right, val &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1024-video-stitching"><a href="#1024-video-stitching" class="headerlink" title="1024. video-stitching"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/video-stitching/">1024. video-stitching</a></h4><ul>
<li>给一个视频的clip起始终止时间戳interval的数组，给目标终止时间T，求能拼接成<code>[0, T]</code>完整视频所需要的最少的clip数量。</li>
<li>方法一：greedy。首先根据起始时间戳对所有clips从小到大排序。从clips中不断取比当前<code>start</code>小的所有clips，取它们中最大的<code>end</code>作为下一步循环的<code>start</code>。如果<code>start</code>和<code>end</code>都没有任何变化，说明中间断掉了，不可能拼成完整视频。时间复杂度<code>O(N*logN)</code>。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">videoStitching</span><span class="params">(<span class="type">int</span>[][] clips, <span class="type">int</span> T)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (clips == <span class="literal">null</span> || clips.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(clips, (a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, start = <span class="number">0</span>, end = <span class="number">0</span>; start &lt; T; start = end, count++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; clips.length &amp;&amp; clips[i][<span class="number">0</span>] &lt;= start; i++) &#123;</span><br><span class="line">                end = Math.max(end, clips[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：DP。利用一个dp数组记录以i结束的视频所需的最小clips数，每次只取恰好能覆盖当前i的clip进行更新，转换方程是<code>dp[i] = dp[起始时间戳] + 1</code>。时间复杂度<code>O(T*N)</code>.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">videoStitching</span><span class="params">(<span class="type">int</span>[][] clips, <span class="type">int</span> T)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (clips == <span class="literal">null</span> || clips.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[T + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, T + <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= T; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] clip : clips) &#123;</span><br><span class="line">                <span class="keyword">if</span> (clip[<span class="number">0</span>] &lt;= i &amp;&amp; clip[<span class="number">1</span>] &gt;= i) &#123;</span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[clip[<span class="number">0</span>]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[T] == T + <span class="number">1</span> ? -<span class="number">1</span> : dp[T];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1026-maximum-difference-between-node-and-ancestor"><a href="#1026-maximum-difference-between-node-and-ancestor" class="headerlink" title="1026. maximum-difference-between-node-and-ancestor"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/">1026. maximum-difference-between-node-and-ancestor</a></h4><ul>
<li>给一个二叉树，求祖先和孩子节点的最大差的绝对值，求差的两个节点必须是同一个flow下来的，而不能是siblings。</li>
<li>方法一：bottom-up, 全局变量+最大最小值搞定。需要注意的是一开始想当然地只取了最小值，但实际上需要同时求孩子节点中的最小和最大，和当前节点的作差求绝对值才完整。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxDiff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxAncestorDiff</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getMinMax(root);</span><br><span class="line">        <span class="keyword">return</span> maxDiff;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] getMinMax(TreeNode node) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minNew</span> <span class="operator">=</span> node.val;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxNew</span> <span class="operator">=</span> node.val;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span>[] leftMinMax = getMinMax(node.left);</span><br><span class="line">            minNew = Math.min(minNew, leftMinMax[<span class="number">0</span>]);</span><br><span class="line">            maxNew = Math.max(maxNew, leftMinMax[<span class="number">1</span>]);</span><br><span class="line">            maxDiff = Math.max(maxDiff, Math.max(Math.abs(node.val - leftMinMax[<span class="number">0</span>]), Math.abs(node.val - leftMinMax[<span class="number">1</span>])));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span>[] rightMinMax = getMinMax(node.right);</span><br><span class="line">            minNew = Math.min(minNew, rightMinMax[<span class="number">0</span>]);</span><br><span class="line">            maxNew = Math.max(maxNew, rightMinMax[<span class="number">1</span>]);</span><br><span class="line">            maxDiff = Math.max(maxDiff, Math.max(Math.abs(node.val - rightMinMax[<span class="number">0</span>]), Math.abs(node.val - rightMinMax[<span class="number">1</span>])));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; minNew, maxNew &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：top-down，反正都是求差的绝对值，完全可以将祖先的最大最小值传入孩子节点再作差，不需要返回成数组形式到上层。最终是在null节点结束递归返回maxDiff，直接用<code>max - min</code>即可.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxDiff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxAncestorDiff</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(root, root.val, root.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode node, <span class="type">int</span> min, <span class="type">int</span> max)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> max - min;</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(node.val, max);</span><br><span class="line">        min = Math.min(node.val, min);</span><br><span class="line">        <span class="keyword">return</span> Math.max(dfs(node.left, min, max), dfs(node.right, min, max));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="1027-longest-arithmetic-sequence"><a href="#1027-longest-arithmetic-sequence" class="headerlink" title="1027. longest-arithmetic-sequence"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-arithmetic-sequence/">1027. longest-arithmetic-sequence</a></h4><ul>
<li>给一个int数组，求其中最长子等差序列的长度。例如<code>[20,1,15,3,10,5,8]</code>最长的就是<code>[20,15,10,5]</code>.</li>
<li>DP。在每一个节点处存放之前所有的信息diff+长度，这样从后面往前减的时候就直接能知道以这个差值往前还有多长。时间复杂度<code>O(N^2)</code>。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestArithSeqLength</span><span class="params">(<span class="type">int</span>[] A)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || A.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt;[] dp = <span class="keyword">new</span> <span class="title class_">HashMap</span>[A.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            dp[i] = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> A[i] - A[j];</span><br><span class="line">                <span class="keyword">if</span> (dp[i].containsKey(diff)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i].put(diff, dp[j].getOrDefault(diff, <span class="number">1</span>) + <span class="number">1</span>);   </span><br><span class="line">                max = Math.max(dp[i].get(diff), max);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1029-two-city-scheduling"><a href="#1029-two-city-scheduling" class="headerlink" title="1029. two-city-scheduling"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/two-city-scheduling/">1029. two-city-scheduling</a></h4><ul>
<li>公司需要面试2N个人，安排到2个城市onsite，给一个二维int数组表示每个人前往两个城市的开销，求每个城市分别去N个人的最小总开销。</li>
<li>方法一：DP，每个人只有两种选择，去A或者去B，<code>dp[i][j]</code>表示安排i个人到A、j个人到B的总开销，<code>dp[i][j]</code>等于A处少一人加去A的开销或B处少一人加去B的开销的最小值，最后求<code>dp[N][N]</code>即可。时间复杂度<code>O(N^2)</code></li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">twoCitySchedCost</span><span class="params">(<span class="type">int</span>[][] costs)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (costs == <span class="literal">null</span> || costs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> costs.length / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][N + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + costs[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>] + costs[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= N; j++) &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j] + costs[i + j - <span class="number">1</span>][<span class="number">0</span>], dp[i][j - <span class="number">1</span>] + costs[i + j - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[N][N];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：假设先把所有人一股脑丢到A，然后考虑把一半的人丢到B会产生多少diff，这个refund实际上就是costB - costA，负值说明选择B就能拿到refund，因此直接对所有diff从小到大排序即可，取前N个最小的refund就是了。<code>O(NlogN)</code>.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">twoCitySchedCost</span><span class="params">(<span class="type">int</span>[][] costs)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (costs == <span class="literal">null</span> || costs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> costs.length / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[] diff = <span class="keyword">new</span> <span class="title class_">int</span> [costs.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; costs.length; i++) &#123;</span><br><span class="line">            sum += costs[i][<span class="number">0</span>];</span><br><span class="line">            diff[i] = costs[i][<span class="number">1</span>] - costs[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(diff);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            sum += diff[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1031-maximum-sum-of-two-non-overlapping-subarrays"><a href="#1031-maximum-sum-of-two-non-overlapping-subarrays" class="headerlink" title="1031. maximum-sum-of-two-non-overlapping-subarrays"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-sum-of-two-non-overlapping-subarrays/">1031. maximum-sum-of-two-non-overlapping-subarrays</a></h4><ul>
<li>prefixSum之后固定L，分别求左右两侧以M为长度的最大subarray。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSumTwoNoOverlap</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> L, <span class="type">int</span> M)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || A.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> A.length;</span><br><span class="line">        <span class="type">int</span>[] sum = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + A[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// SUM(A[i]...A[j]) = sum[j + 1] - sum[i];</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">retVal</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> L; i &lt; sum.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sumL</span> <span class="operator">=</span> sum[i] - sum[i - L];</span><br><span class="line">            <span class="type">int</span> <span class="variable">sumLeft</span> <span class="operator">=</span> getMaxSum(sum, <span class="number">0</span>, i - L, M);</span><br><span class="line">            <span class="type">int</span> <span class="variable">sumRight</span> <span class="operator">=</span> getMaxSum(sum, i, len, M);</span><br><span class="line">            retVal = Math.max(sumL + Math.max(sumLeft, sumRight), retVal);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMaxSum</span><span class="params">(<span class="type">int</span>[] sum, <span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> M)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">retVal</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> from + M; i &lt;= to; i++) &#123;</span><br><span class="line">            retVal = Math.max(sum[i] - sum[i - M], retVal);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>真·<code>O(N)</code>解法。最终结果只有两种情况，<code>[L]</code>子数组在左，<code>[M]</code>子数组在右；或者<code>[M]</code>子数组在左，<code>[L]</code>子数组在右. 因此最开始假设最大和retVal为<code>[L,M]</code>，maxL表示<code>当前索引-M</code>之前的长度为L的子数组最大值，maxM表示<code>当前索引-L</code>之前的长度为M的子数组最大值。遍历时同时更新maxL和maxM，再用retVal与<code>maxL + (当前索引 - M这段)</code>和<code>maxM + (当前索引 - L这段)</code>.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSumTwoNoOverlap</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> L, <span class="type">int</span> M)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || A.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> A.length;</span><br><span class="line">        <span class="type">int</span>[] sum = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + A[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// SUM(A[i]...A[j]) = sum[j + 1] - sum[i];</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">retVal</span> <span class="operator">=</span> sum[L + M], maxL = sum[L], maxM = sum[M];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> L + M + <span class="number">1</span>; i &lt; sum.length; i++) &#123;</span><br><span class="line">            maxL = Math.max(maxL, sum[i - M] - sum[i - L - M]); <span class="comment">// i-M之前的长度为L的最大值</span></span><br><span class="line">            maxM = Math.max(maxM, sum[i - L] - sum[i - L - M]); <span class="comment">// i-L之前的长度为M的最大值</span></span><br><span class="line">            retVal = Math.max(retVal, Math.max(maxL + sum[i] - sum[i - M], maxM + sum[i] - sum[i - L]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1039-minimum-score-triangulation-of-polygon"><a href="#1039-minimum-score-triangulation-of-polygon" class="headerlink" title="1039. minimum-score-triangulation-of-polygon"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-score-triangulation-of-polygon/">1039. minimum-score-triangulation-of-polygon</a></h4><ul>
<li>给一个数组表示一个N边形各个顶点的权重。在N边形内部连上N-2条边构成多个三角形，每个三角形顶点求乘积，最后将乘积求和作为score。问最小score是多少。</li>
<li>bottom-up DP。<code>dp[i][j]</code>表示从i顶点到j顶点的最小score，那么假设从k处拆分成前后两部分并将i, j, k顶点相连作为一个三角形，那么<code>dp[i][j] = dp[i][k] + dp[k][j] + 三个顶点乘积</code>。需要注意为了形成三角形，必须满足<code>i &lt; k &lt; j</code>。首先固定i和j之间距离为2，然后再慢慢增加为<code>3, ..., A.length-1</code>.时间复杂度<code>O(N^3)</code>.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minScoreTriangulation</span><span class="params">(<span class="type">int</span>[] A)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || A.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[A.length][A.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">2</span>; len &lt; A.length; len++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; left + len &lt; A.length; left++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> left + len;</span><br><span class="line">                dp[left][right] = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + <span class="number">1</span>; mid &lt; right; mid++) &#123;</span><br><span class="line">                    dp[left][right] = Math.min(dp[left][right], dp[left][mid] + dp[mid][right] + A[left] * A[right] * A[mid]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][A.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1041-robot-bounded-in-circle"><a href="#1041-robot-bounded-in-circle" class="headerlink" title="1041. robot-bounded-in-circle"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/robot-bounded-in-circle/">1041. robot-bounded-in-circle</a></h4><ul>
<li>假设一个机器人在一个平面直角坐标系中的原点，面向北方，给它一个字符串作为指令，L左转、R右转、G前进，判断无限次执行这个命令后它是否会回到原点。</li>
<li>规律：如果指令执行一次结束时机器人已经回到原点，那之后肯定也会回到原点。如果没到原点，看它面向那个方向，如果是北方意味着它会越走越远，否则经过1次或3次命令后它还是会回到原点。关键就在于举出它“无法回到原点”的反例并总结规律。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="type">int</span>[][] dirs = <span class="keyword">new</span> <span class="title class_">int</span>[][] &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isRobotBounded</span><span class="params">(String instructions)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = <span class="number">0</span>, dirIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : instructions.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">                dirIndex = (dirIndex + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;L&#x27;</span>) &#123;</span><br><span class="line">                dirIndex = (dirIndex + <span class="number">3</span>) % <span class="number">4</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                x += dirs[dirIndex][<span class="number">0</span>];</span><br><span class="line">                y += dirs[dirIndex][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>) || dirIndex != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1047-remove-all-adjacent-duplicates-in-string"><a href="#1047-remove-all-adjacent-duplicates-in-string" class="headerlink" title="1047. remove-all-adjacent-duplicates-in-string"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/">1047. remove-all-adjacent-duplicates-in-string</a></h4><ul>
<li>给一个字符串，返回删除相邻相同字符后的字符串。StringBuilder不断删即可。pass。</li>
</ul>
<h4 id="1048-longest-string-chain"><a href="#1048-longest-string-chain" class="headerlink" title="1048. longest-string-chain"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-string-chain/">1048. longest-string-chain</a></h4><ul>
<li>给一个字符串数组，组成chain的条件是前后两个字符串满足<code>prev</code>加上一个字符可以得到<code>next</code>。求这些字符串最多可以组成多长的chain。</li>
<li>注意没有要求按顺序从原数组中取，因此可以任意组成chain，只要前后满足条件。那么利用类似DP的思路，维护一个<code>string-&gt;int</code>的map，对于每一个字符串尝试去掉一个字符看看map是否有对应的前序字符串。注意的是必须对原数组从短到长排序，这样从前往后取字符串的时候才能保证短的字符串在map中已经得到最终的count.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestStrChain</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (words == <span class="literal">null</span> || words.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 必须从短到长排序</span></span><br><span class="line">        Arrays.sort(words, (a, b) -&gt; a.length() - b.length());</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">prev</span> <span class="operator">=</span> word.substring(<span class="number">0</span>, i) + word.substring(i + <span class="number">1</span>);</span><br><span class="line">                max = Math.max(max, map.getOrDefault(prev, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(word, max);</span><br><span class="line">            ans = Math.max(max, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1049-last-stone-weight-ii"><a href="#1049-last-stone-weight-ii" class="headerlink" title="1049. last-stone-weight-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/last-stone-weight-ii/">1049. last-stone-weight-ii</a></h4><ul>
<li>给一个int数组表示一堆石头，石头两两之间如果重量相同则合成为0，若不同则合成之后剩余为重量差。求将所有石头合成之后剩下最后的最小重量。</li>
<li>以三个石头为例，他们之间取差后求和实际上只有8-2 &#x3D; 6种情况，都是在一部分石头取正、另一部分取负求和的最小值，即<code>positiveSum - negativeSum = positiveSum - (sum - positiveSum) = 2 * positiveSum - sum</code>的最小值，因此取最小的那个能凑成的positiveSum就是所求了。<code>dp[i]</code>表示以i为sum的部分是否可以凑成，从<code>dp[sum]</code>开始往前看<code>dp[i] - stone</code>是否存在。最后从sum&#x2F;2开始找positiveSum即为所求。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastStoneWeightII</span><span class="params">(<span class="type">int</span>[] stones)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stones == <span class="literal">null</span> || stones.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stones.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> stones[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> IntStream.of(stones).sum();</span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[sum + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> stone : stones) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">tempSum</span> <span class="operator">=</span> sum; tempSum &gt;= <span class="number">0</span>; tempSum--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tempSum - stone &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[tempSum - stone]) &#123;</span><br><span class="line">                    dp[tempSum] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">positiveSum</span> <span class="operator">=</span> (sum + <span class="number">1</span>) / <span class="number">2</span>; positiveSum &lt;= sum; positiveSum++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[positiveSum]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span> * positiveSum - sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1051-height-checker"><a href="#1051-height-checker" class="headerlink" title="1051. height-checker"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/height-checker/">1051. height-checker</a></h4><ul>
<li>给一个数组，求其中位置不对的整数个数。</li>
<li>木桶排序后直接逐位比较即可。pass.</li>
</ul>
<h4 id="1052-grumpy-bookstore-owner"><a href="#1052-grumpy-bookstore-owner" class="headerlink" title="1052. grumpy-bookstore-owner"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/grumpy-bookstore-owner/">1052. grumpy-bookstore-owner</a></h4><ul>
<li>给两个数组，一个表示该分钟时进入商店的人数，一个表示店主的心情，0表示可以、1表示爆炸。假设店主有能力控制K分钟内不爆炸，求最多能让顾客满意的人数。<code>customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3</code>时，控制最后三分钟不爆炸就可以让人数达到16个。</li>
<li>双指针O(N)搞定。pass。</li>
</ul>
<h4 id="1053-previous-permutation-with-one-swap"><a href="#1053-previous-permutation-with-one-swap" class="headerlink" title="1053. previous-permutation-with-one-swap"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/previous-permutation-with-one-swap/">1053. previous-permutation-with-one-swap</a></h4><ul>
<li>给一个int数组，求任意swap一对儿数字之后得到的恰好比当前permutation小的前一个排列。若已经最小了则直接放回本身。</li>
<li>和next permutation很类似。这个就从后往前找第一个破坏了递减特性的数字，再从后往前找第一个比该数小的，注意如果有多个相同的则需要找到最前面的那个，将他们swap即得。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] prevPermOpt1(<span class="type">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || A.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> A.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i - <span class="number">1</span>] &gt; A[i]) &#123;</span><br><span class="line">                index = i - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> A;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> A.length - <span class="number">1</span>; i &gt; index; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &lt; A[index] &amp;&amp; A[i] != A[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> A[index];</span><br><span class="line">                A[index] = A[i];</span><br><span class="line">                A[i] = temp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1055-shortest-way-to-form-string"><a href="#1055-shortest-way-to-form-string" class="headerlink" title="1055. shortest-way-to-form-string"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/shortest-way-to-form-string/">1055. shortest-way-to-form-string</a></h4><ul>
<li>给一个source字符串和一个target字符串(只含有小写字母)，求最少需要多少个source的子序列能够拼接出target，若不可能则返回<code>-1</code>。例如<code>target = abbbbc, source = abc</code>，就需要<code>ab + b + b + bc</code>总共4个子序列。</li>
<li>方法一：近乎暴力的双指针，从target开始遍历，每次扫一遍source进行尽可能多的匹配，如果没有挪动说明完全没有match的字符串，直接返回-1. 时间复杂度<code>O(M*N)</code>.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestWay</span><span class="params">(String source, String target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (source == <span class="literal">null</span> || target == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] sourceChar = source.toCharArray(), targetChar = target.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">targetIndex</span> <span class="operator">=</span> <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (targetIndex &lt; targetChar.length) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">targetIndexPrev</span> <span class="operator">=</span> targetIndex;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">sourceIndex</span> <span class="operator">=</span> <span class="number">0</span>; sourceIndex &lt; sourceChar.length &amp;&amp; targetIndex &lt; targetChar.length; sourceIndex++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (targetChar[targetIndex] == sourceChar[sourceIndex]) &#123;</span><br><span class="line">                    targetIndex++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (targetIndex == targetIndexPrev) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：缩短在source中搜索的时间，对于source中每个字符维护一个<code>List&lt;Integer&gt;</code>，这样就可以用二分查找快速找到字符的理论位置（必须大于等于某个索引）。遍历target，取得当前字符在source中的所有index，用二分查找找出下一个可用索引。如果已经到头了说明用掉了一个source，否则source后续部分还可以继续用，只是要在下次二分搜索时搜当前source索引的下一位。时间复杂度<code>O(N * logM)</code></li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestWay</span><span class="params">(String source, String target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (source == <span class="literal">null</span> || target == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt;[] indexes = <span class="keyword">new</span> <span class="title class_">List</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">char</span>[] sourceChar = source.toCharArray(), targetChar = target.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sourceChar.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indexes[sourceChar[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">null</span>) &#123;</span><br><span class="line">                indexes[sourceChar[i] - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            indexes[sourceChar[i] - <span class="string">&#x27;a&#x27;</span>].add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">targetIndex</span> <span class="operator">=</span> <span class="number">0</span>, sourceIndex = <span class="number">0</span>, count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (targetIndex &lt; targetChar.length) &#123;</span><br><span class="line">            List&lt;Integer&gt; index = indexes[targetChar[targetIndex] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (index == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Collections.binarySearch(index, sourceIndex);</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                i = -i - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == index.size()) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                sourceIndex = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sourceIndex = index.get(i) + <span class="number">1</span>;  <span class="comment">// source后续部分可能可以继续用</span></span><br><span class="line">                targetIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1057-campus-bikes"><a href="#1057-campus-bikes" class="headerlink" title="1057. campus-bikes"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/campus-bikes/">1057. campus-bikes</a></h4><ul>
<li>给一组workers坐标和bikes坐标，要求每一个worker取车时取的时距离自己最近的bike，其中距离是用manhatten算的，即横纵坐标各自的差的绝对值之和。其中每一个坐标都在0~999，每一个坐标都是不同的。要求按照worker的索引顺序返回bike的索引。</li>
<li>方法一：本质上就是要对所有可能<code>&lt;worker, bike&gt;</code>pair的排序。首先根据距离排序，其次根据worker索引排序，再其次根据bike索引排序。这样就能保证每次从里面取出来的是距离最短的。</li>
<li>方法二：排序还可以更快。既然规定了坐标范围，那么最远的坐标就在<code>(0,0)-(999,999)</code>这一组产生，即<code>1998</code>。根据距离进行木桶排序，每个木桶的索引表示距离，里面存放的是一个List，表示所有这个距离的<code>&lt;w, b&gt;</code>pair。首先来一波<code>O(N*M)</code>的双重循环把两两之间的距离都存进去，然后就从小到大取距离中的list of pairs，每个pair中如果worker没有分配且bike没有被取走，就是一个合法的pair了。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] assignBikes(<span class="type">int</span>[][] workers, <span class="type">int</span>[][] bikes) &#123;</span><br><span class="line">        <span class="keyword">if</span> (workers == <span class="literal">null</span> || workers.length == <span class="number">0</span> ||</span><br><span class="line">           bikes == <span class="literal">null</span> || bikes.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt;[] bucket = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[<span class="number">2001</span>]; <span class="comment">// 每个distance的所有w,b组合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; workers.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; bikes.length; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">dis</span> <span class="operator">=</span> getDistance(workers[i], bikes[j]);</span><br><span class="line">                <span class="keyword">if</span> (bucket[dis] == <span class="literal">null</span>) &#123;</span><br><span class="line">                    bucket[dis] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="type">int</span>[]&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                bucket[dis].add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">boolean</span>[] bikeVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[bikes.length];</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[workers.length];</span><br><span class="line">        Arrays.fill(ans, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="number">0</span>; dis &lt; bucket.length; dis++) &#123;</span><br><span class="line">            List&lt;<span class="type">int</span>[]&gt; pairs = bucket[dis];</span><br><span class="line">            <span class="keyword">if</span> (pairs != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span>[] pair : pairs) &#123;</span><br><span class="line">                    <span class="comment">// 若这个w没有被分配且b没有被取</span></span><br><span class="line">                    <span class="keyword">if</span> (ans[pair[<span class="number">0</span>]] == -<span class="number">1</span> &amp;&amp; !bikeVisited[pair[<span class="number">1</span>]]) &#123;</span><br><span class="line">                        ans[pair[<span class="number">0</span>]] = pair[<span class="number">1</span>];</span><br><span class="line">                        bikeVisited[pair[<span class="number">1</span>]] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getDistance</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span>[] b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(a[<span class="number">0</span>] - b[<span class="number">0</span>]) + Math.abs(a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1060-missing-element-in-sorted-array"><a href="#1060-missing-element-in-sorted-array" class="headerlink" title="1060. missing-element-in-sorted-array"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/missing-element-in-sorted-array/">1060. missing-element-in-sorted-array</a></h4><ul>
<li>给一个排好序的数据和一个k，求从最小数开始第k个missing的数字。例如<code>[1,5,8], 2</code>就是<code>3</code>。</li>
<li>方法一：最朴素的O(N)，从左往右遍历找。</li>
<li>方法二：一看到排好序的就需要敏感点，想到O(logN)的二分查找。根据missing数字的个数来决定往左半部分还是右半部分进行搜索。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missingElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length, left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">missingCountLeft</span> <span class="operator">=</span> nums[mid] - nums[left] - mid + left;</span><br><span class="line">            <span class="keyword">if</span> (k &lt;= missingCountLeft) &#123;  <span class="comment">// 说明在左半部分</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">                k -= missingCountLeft;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left] + k &gt;= nums[right] ?</span><br><span class="line">            nums[left] + k + <span class="number">1</span> :</span><br><span class="line">            nums[left] + k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1062-longest-repeating-substring"><a href="#1062-longest-repeating-substring" class="headerlink" title="1062. longest-repeating-substring"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-repeating-substring/">1062. longest-repeating-substring</a></h4><ul>
<li>给一个字符串，求其自身中最长的重复子字符串，可以重叠。</li>
<li>DP。<code>dp[i][j]</code>表示以i结尾和以j结尾的子字符串相等部分长度，在更新过程中求最大的即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestRepeatingSubstring</span><span class="params">(String S)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (S == <span class="literal">null</span> || S.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> S.length(), maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">1</span>][len + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt;= len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (S.charAt(i - <span class="number">1</span>) == S.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                maxLen = Math.max(maxLen, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>二分查找+set。猜一个长度，然后用sliding window逐个取子字符串存入set，看之前是否出现过。最坏情况时间复杂度是<code>O(N^2)</code>，平均是<code>O(NlogN)</code>. 空间复杂度为<code>O(N^2)</code>，可以直接存成int的str.hashCode来降到<code>O(N)</code>.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(String S, <span class="type">int</span> n, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        HashSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        String curr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> <span class="number">0</span>; from &lt; n - len + <span class="number">1</span>; from++) &#123;</span><br><span class="line">            curr = S.substring(from, from + len);</span><br><span class="line">            <span class="keyword">if</span> (set.contains(curr)) &#123;</span><br><span class="line">                <span class="keyword">return</span> from;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(curr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestRepeatingSubstring</span><span class="params">(String S)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (S == <span class="literal">null</span> || S.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> S.length(), maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>, right = n;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (binarySearch(S, n, mid) != -<span class="number">1</span>) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1066-campus-bikes-ii"><a href="#1066-campus-bikes-ii" class="headerlink" title="1066. campus-bikes-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/campus-bikes-ii/">1066. campus-bikes-ii</a></h4><ul>
<li>延续上一个给worker分配bike的任务，这次的要求是每个pair的mahattan distance之和最小。</li>
<li>暴力解法，直接DFS，固定一个pair并进行相应的标记之后就dfs到下一层。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">totalDistMin</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">assignBikes</span><span class="params">(<span class="type">int</span>[][] workers, <span class="type">int</span>[][] bikes)</span> &#123;</span><br><span class="line">        dfs(workers, bikes, <span class="keyword">new</span> <span class="title class_">boolean</span>[bikes.length], <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> totalDistMin;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] workers, <span class="type">int</span>[][] bikes, <span class="type">boolean</span>[] bikeVisited, <span class="type">int</span> workerId, <span class="type">int</span> totalDist)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (workerId == workers.length) &#123;</span><br><span class="line">            totalDistMin = Math.min(totalDistMin, totalDist);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (totalDist &gt;= totalDistMin) &#123;    <span class="comment">// 已经不可能更小了</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">bikeId</span> <span class="operator">=</span> <span class="number">0</span>; bikeId &lt; bikes.length; bikeId++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!bikeVisited[bikeId]) &#123;</span><br><span class="line">                bikeVisited[bikeId] = <span class="literal">true</span>;</span><br><span class="line">                dfs(workers, bikes, bikeVisited, workerId + <span class="number">1</span>, totalDist + getDist(workers[workerId], bikes[bikeId]));</span><br><span class="line">                bikeVisited[bikeId] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getDist</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span>[] b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(a[<span class="number">0</span>] - b[<span class="number">0</span>]) + Math.abs(a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1076-number-of-submatrices-that-sum-to-target"><a href="#1076-number-of-submatrices-that-sum-to-target" class="headerlink" title="1076. number-of-submatrices-that-sum-to-target"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/number-of-submatrices-that-sum-to-target/">1076. number-of-submatrices-that-sum-to-target</a></h4><ul>
<li>给一个int matrix，求其中有多少个submatrix的sum等于给定的target。</li>
<li>对每一行求好prefixSum后，暴力求每个可能的submatrix sum。固定左列索引，右列索引不断向后，每到一列就开始从上到下遍历行，将<code>0 ~ row</code>和<code>left ~ right</code>这部分所夹的sum作为key存入map，value则是这个sum出现的次数。这样在从上到下遍历的过程中，如果能出现target，则必须满足<code>currSum - prefixSum == target</code>，因此直接在map中查找<code>currSum - target</code>出现的次数即可。时间复杂度<code>O(col * col * row)</code>，空间如果不算输入部分则为map的<code>O(row)</code>. 如果将方向调转一下也可以将时间变成<code>O(row * row * col)</code>，因此实际上看row和col谁更小了。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSubmatrixSumTarget</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> matrix.length, cols = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>; r &lt; rows; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">1</span>; c &lt; cols; c++) &#123;</span><br><span class="line">                matrix[r][c] += matrix[r][c - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; sumCount = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">colLeft</span> <span class="operator">=</span> <span class="number">0</span>; colLeft &lt; cols; colLeft++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">colRight</span> <span class="operator">=</span> colLeft; colRight &lt; cols; colRight++) &#123;</span><br><span class="line">                sumCount.clear();</span><br><span class="line">                sumCount.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">currSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>; row &lt; rows; row++) &#123;</span><br><span class="line">                    currSum += matrix[row][colRight] - (colLeft == <span class="number">0</span> ? <span class="number">0</span> : matrix[row][colLeft - <span class="number">1</span>]);</span><br><span class="line">                    count += sumCount.getOrDefault(currSum - target, <span class="number">0</span>);</span><br><span class="line">                    sumCount.put(currSum, sumCount.getOrDefault(currSum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1091-shortest-path-in-binary-matrix"><a href="#1091-shortest-path-in-binary-matrix" class="headerlink" title="1091. shortest-path-in-binary-matrix"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/shortest-path-in-binary-matrix/">1091. shortest-path-in-binary-matrix</a></h4><ul>
<li>给一个只含有0和1的矩阵，1是障碍物，0是通道，八个方向都可以走，求从左上到右下的最小步数。</li>
<li>经典BFS，但是需要注意处理edge case，例如起点终点本身是障碍物、起点就是终点等。需要将return放在size那层循环外面才能在没有邻居（起点就是终点）的情况下返回。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="type">int</span>[][] directions = <span class="keyword">new</span> <span class="title class_">int</span>[][] &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestPathBinaryMatrix</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> grid.length, cols = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (grid[<span class="number">0</span>][<span class="number">0</span>] != <span class="number">0</span> || grid[rows - <span class="number">1</span>][cols - <span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[rows][cols];</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.offer(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">0</span>, <span class="number">0</span> &#125;);</span><br><span class="line">        visited[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">steps</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> q.size();</span><br><span class="line">            steps++;</span><br><span class="line">            <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span>[] curr = q.poll();</span><br><span class="line">                <span class="keyword">if</span> (curr[<span class="number">0</span>] == rows - <span class="number">1</span> &amp;&amp; curr[<span class="number">1</span>] == cols - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> steps;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span>[] direction : directions) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">rowNew</span> <span class="operator">=</span> curr[<span class="number">0</span>] + direction[<span class="number">0</span>];</span><br><span class="line">                    <span class="type">int</span> <span class="variable">colNew</span> <span class="operator">=</span> curr[<span class="number">1</span>] + direction[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (rowNew &lt; <span class="number">0</span> || rowNew &gt;= rows ||</span><br><span class="line">                        colNew &lt; <span class="number">0</span> || colNew &gt;= cols ||</span><br><span class="line">                        visited[rowNew][colNew] ||</span><br><span class="line">                        grid[rowNew][colNew] != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    visited[rowNew][colNew] = <span class="literal">true</span>;</span><br><span class="line">                    q.offer(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;rowNew, colNew&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1093-statistics-from-a-large-sample"><a href="#1093-statistics-from-a-large-sample" class="headerlink" title="1093. statistics-from-a-large-sample"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/statistics-from-a-large-sample/">1093. statistics-from-a-large-sample</a></h4><ul>
<li>给一个int数组，<code>count[num]</code>表示num出现了那么多次。返回这些数的minimum, maximum, mean, median, and mode，统统用double.</li>
<li>可以two-pass先求总共有多少个数字，然后再直接挪到中间求median. 也可以双指针一个从前往后、一个从后往前，只要找到中间交汇处即可。没啥意思。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span>[] sampleStats(<span class="type">int</span>[] count) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="literal">null</span> || count.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">double</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = count.length - <span class="number">1</span>, total = <span class="number">0</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">min</span> <span class="operator">=</span> <span class="literal">null</span>, max = <span class="literal">null</span>, modeNum = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftPart</span> <span class="operator">=</span> <span class="number">0</span>, rightPart = <span class="number">0</span>, leftMax = <span class="number">0</span>, rightMin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right &amp;&amp; count[left] == <span class="number">0</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (right &gt;= left &amp;&amp; count[right] == <span class="number">0</span>) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="literal">null</span>) &#123;</span><br><span class="line">                min = left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (max == <span class="literal">null</span>) &#123;</span><br><span class="line">                max = right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (leftPart &lt;= rightPart) &#123;</span><br><span class="line">                <span class="keyword">if</span> (modeNum == <span class="literal">null</span> || count[modeNum] &lt; count[left]) &#123;</span><br><span class="line">                    modeNum = left;</span><br><span class="line">                &#125;</span><br><span class="line">                sum += (count[left] * left);</span><br><span class="line">                total += count[left];</span><br><span class="line">                leftPart += count[left];</span><br><span class="line">                leftMax = left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (modeNum == <span class="literal">null</span> || count[modeNum] &lt; count[right]) &#123;</span><br><span class="line">                    modeNum = right;</span><br><span class="line">                &#125;</span><br><span class="line">                sum += (count[right] * right);</span><br><span class="line">                total += count[right];</span><br><span class="line">                rightPart += count[right];</span><br><span class="line">                rightMin = right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> <span class="variable">mean</span> <span class="operator">=</span> sum / total;</span><br><span class="line">        <span class="type">double</span> <span class="variable">median</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (leftPart &gt; rightPart) &#123;</span><br><span class="line">            median = leftMax;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (leftPart == rightPart) &#123;</span><br><span class="line">            median = (leftMax + rightMin) / <span class="number">2.0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            median = rightMin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">double</span>[] &#123;(<span class="type">double</span>) min, (<span class="type">double</span>) max, mean, median, (<span class="type">double</span>) modeNum&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1094-car-pooling"><a href="#1094-car-pooling" class="headerlink" title="1094. car-pooling"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/car-pooling/">1094. car-pooling</a></h4><ul>
<li>给一个carpool信息数组，每个信息组成为<code>[乘客数，上车坐标，下车坐标]</code>，再给一个车子最大容量，判断是否可能从左到右将乘客一次性carpool完成。</li>
<li>方法一：和interval类似，首先按照上车顺序排序，之后需要知道接下来下车的是谁，因此需要一个优先队列按照下车顺序从小到大排好。每次上车就扣除剩余容量，下车就增加容量。时间复杂度<code>O(NlogN)</code>，空间<code>O(N)</code>.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">carPooling</span><span class="params">(<span class="type">int</span>[][] trips, <span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (trips == <span class="literal">null</span> || trips.length == <span class="number">0</span> || trips[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(trips, (a, b) -&gt; a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a[<span class="number">2</span>] - b[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] trip : trips) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!pq.isEmpty() &amp;&amp; pq.peek()[<span class="number">2</span>] &lt;= trip[<span class="number">1</span>]) &#123;</span><br><span class="line">                capacity += pq.poll()[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            capacity -= trip[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pq.offer(trip);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：和253题非常像，按照时间顺序（上下车坐标）来track可用的容量。将上下车的坐标作为key、乘客加减数量变化为value存入TreeMap，然后取出所有的value看看是否有任何时候使得capacity负了。时间、空间复杂度和方法一一样。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">carPooling</span><span class="params">(<span class="type">int</span>[][] trips, <span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (trips == <span class="literal">null</span> || trips.length == <span class="number">0</span> || trips[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeMap&lt;Integer, Integer&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] trip : trips) &#123;</span><br><span class="line">            treeMap.put(trip[<span class="number">1</span>], treeMap.getOrDefault(trip[<span class="number">1</span>], <span class="number">0</span>) + trip[<span class="number">0</span>]);</span><br><span class="line">            treeMap.put(trip[<span class="number">2</span>], treeMap.getOrDefault(trip[<span class="number">2</span>], <span class="number">0</span>) - trip[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> change : treeMap.values()) &#123;</span><br><span class="line">            capacity -= change;</span><br><span class="line">            <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1099-two-sum-less-than-k"><a href="#1099-two-sum-less-than-k" class="headerlink" title="1099. two-sum-less-than-k"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/two-sum-less-than-k/">1099. two-sum-less-than-k</a></h4><ul>
<li>给一个数组，求其中小于等于给定值K的最大的两个数之和。</li>
<li>对数组拍个序，然后双指针一前一后往中间夹逼，小于K就移动下界并取这个值与现有最大值比较，否则移动上界。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">twoSumLessThanK</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> K)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || A.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(A);</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = A.length - <span class="number">1</span>, max = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> A[left] + A[right];</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; K) &#123;</span><br><span class="line">                max = Math.max(sum, max);</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1102-path-with-maximum-minimum-value"><a href="#1102-path-with-maximum-minimum-value" class="headerlink" title="1102. path-with-maximum-minimum-value"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/path-with-maximum-minimum-value/">1102. path-with-maximum-minimum-value</a></h4><ul>
<li>给一个grid，从左上角到右下角的路径cost为所经过元素的最小值。求所有路径中的最大cost。</li>
<li>贪心，与一般BFS的区别就是需要用到PriorityQueue并且存入坐标对应的值，每次都从pq中取相邻未访问过元素的最大值。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] dir = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumMinimumPath</span><span class="params">(<span class="type">int</span>[][] A)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || A.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> A.length, cols = A[<span class="number">0</span>].length;</span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b[<span class="number">0</span>] - a[<span class="number">0</span>]);   <span class="comment">// 从大到小</span></span><br><span class="line">        <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[rows][cols];</span><br><span class="line"></span><br><span class="line">        pq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;A[<span class="number">0</span>][<span class="number">0</span>], <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        visited[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> A[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span>[] curr = pq.poll();</span><br><span class="line">            max = Math.min(max, curr[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span> (curr[<span class="number">1</span>] == rows - <span class="number">1</span> &amp;&amp; curr[<span class="number">2</span>] == cols - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">rowNew</span> <span class="operator">=</span> curr[<span class="number">1</span>] + dir[i];</span><br><span class="line">                <span class="type">int</span> <span class="variable">colNew</span> <span class="operator">=</span> curr[<span class="number">2</span>] + dir[i + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (rowNew &gt;= <span class="number">0</span> &amp;&amp; rowNew &lt; rows &amp;&amp;</span><br><span class="line">                   colNew &gt;= <span class="number">0</span> &amp;&amp; colNew &lt; cols &amp;&amp;</span><br><span class="line">                   !visited[rowNew][colNew]) &#123;</span><br><span class="line">                    visited[rowNew][colNew] = <span class="literal">true</span>;</span><br><span class="line">                    pq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; A[rowNew][colNew], rowNew, colNew &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1104-path-in-zigzag-labelled-binary-tree"><a href="#1104-path-in-zigzag-labelled-binary-tree" class="headerlink" title="1104. path-in-zigzag-labelled-binary-tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/path-in-zigzag-labelled-binary-tree">1104. path-in-zigzag-labelled-binary-tree</a></h4><ul>
<li>给一个「无限」的满二叉树，标号从根1开始，蛇形走位，上一层从小到大、下一层从大到小。给定一个节点，求从根到它的路径。</li>
<li>观察规律，二叉树的标号和二次幂&#x2F;对数有很大关系，给定一个节点，它所处的层数就是log2(N)，它到该层最大值的offset就对应到上一层到最小值的offset，一层层向上找直到1就行了。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">pathInZigZagTree</span><span class="params">(<span class="type">int</span> label)</span> &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (label &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        list.addFirst(label);</span><br><span class="line">        <span class="keyword">while</span> (label != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.log(label) / Math.log(<span class="number">2</span>));</span><br><span class="line">            <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> (<span class="type">int</span>)Math.pow(<span class="number">2</span>, level + <span class="number">1</span>) - <span class="number">1</span> - label;</span><br><span class="line">            label = (<span class="type">int</span>)(Math.pow(<span class="number">2</span>, level) + offset) / <span class="number">2</span>;</span><br><span class="line">            list.addFirst(label);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1105-filling-bookcase-shelves"><a href="#1105-filling-bookcase-shelves" class="headerlink" title="1105. filling-bookcase-shelves"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/filling-bookcase-shelves/">1105. filling-bookcase-shelves</a></h4><ul>
<li>给一个书本厚度和高度的数组，给定书架的宽度，求将这些书按照给定顺序放上书架所需要的最小高度。</li>
<li>DP。对于每一本书只有两种情况，要么另开一行新的书架，要么沿用当前的书架。首先假设另开新的一行书架，新的这一行高度就是这本书的高度；然后在逐本书往前，尝试将他们放下来，只要宽度够就放进来，然后比较这样得到的全部最小高度和最开始假设直接单独新开一行的总高度。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minHeightShelves</span><span class="params">(<span class="type">int</span>[][] books, <span class="type">int</span> shelfWidth)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (books == <span class="literal">null</span> || books.length == <span class="number">0</span> || books[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[books.length + <span class="number">1</span>];   <span class="comment">// dp[i]表示[0, i)部分的最小高度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= books.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> books[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> books[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + height;          <span class="comment">// 假设新开一行，[0, i - 1)最小高度加上当前高度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>; j &gt; <span class="number">0</span> &amp;&amp; books[j - <span class="number">1</span>][<span class="number">0</span>] + width &lt;= shelfWidth; j--) &#123;</span><br><span class="line">                height = Math.max(height, books[j - <span class="number">1</span>][<span class="number">1</span>]);   <span class="comment">// 取和前一本书的较高者</span></span><br><span class="line">                width += books[j - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">                dp[i] = Math.min(dp[j - <span class="number">1</span>] + height, dp[i]);  <span class="comment">// [0, j - 1)的最小高度加当前高度</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[books.length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1109-corporate-flight-bookings"><a href="#1109-corporate-flight-bookings" class="headerlink" title="1109. corporate-flight-bookings"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/corporate-flight-bookings/">1109. corporate-flight-bookings</a></h4><ul>
<li>给一个int数组表示<code>[start, end, ticketNum]</code>，总共有n个航班，求每个航班定了多少票。</li>
<li>直觉是嵌套循环，其实更好办的是从头遍历，只在start处加上ticketnum，在结尾的后一个slot事先减去ticketnum。最后一波流从头到尾累加即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] corpFlightBookings(<span class="type">int</span>[][] bookings, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bookings == <span class="literal">null</span> || bookings.length == <span class="number">0</span> || n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] booking : bookings) &#123;</span><br><span class="line">            ans[booking[<span class="number">0</span>] - <span class="number">1</span>] += booking[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (booking[<span class="number">1</span>] &lt; n) ans[booking[<span class="number">1</span>]] -= booking[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans[i] += ans[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1110-delete-nodes-and-return-forest"><a href="#1110-delete-nodes-and-return-forest" class="headerlink" title="1110. delete-nodes-and-return-forest"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/delete-nodes-and-return-forest/">1110. delete-nodes-and-return-forest</a></h4><ul>
<li>给一个二叉树，其中每个节点的val都不同，在[1, 1000]之间。再给一个数组表示需要删除的节点val，返回删除这些节点之后的forest，以<code>List&lt;TreeNode&gt;</code>的形式返回。</li>
<li>递归方法。首先将toDelete数组存入一个set方便查询。对于每一个节点，首先判断它是否需要删除，不用删除的根节点就需要加到结果列表中了。然后继续对左右孩子递归，如果当前节点需要删除，那么对应的左右孩子就可能可以作为根节点了。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">delNodes</span><span class="params">(TreeNode root, <span class="type">int</span>[] toDelete)</span> &#123;</span><br><span class="line">        List&lt;TreeNode&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (toDelete == <span class="literal">null</span> || toDelete.length == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.add(root);</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; toDeleteSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> deleteVal : toDelete) &#123;</span><br><span class="line">            toDeleteSet.add(deleteVal);</span><br><span class="line">        &#125;</span><br><span class="line">        helper(root, toDeleteSet, ans, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">helper</span><span class="params">(TreeNode root, Set&lt;Integer&gt; toDeleteSet, List&lt;TreeNode&gt; ans, <span class="type">boolean</span> isRoot)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">shouldDelete</span> <span class="operator">=</span> toDeleteSet.contains(root.val);  <span class="comment">// 不需要删除、且是根节点，则需要返回</span></span><br><span class="line">        <span class="keyword">if</span> (isRoot &amp;&amp; !shouldDelete) &#123;</span><br><span class="line">            ans.add(root);</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = helper(root.left, toDeleteSet, ans, shouldDelete);  <span class="comment">// 当前节点需要删除-&gt;子节点可以作为根节点</span></span><br><span class="line">        root.right = helper(root.right, toDeleteSet, ans, shouldDelete);</span><br><span class="line">        <span class="keyword">return</span> shouldDelete ? <span class="literal">null</span> : root;  <span class="comment">// 父节点需要知道子节点是否被删，如果被删就需要设成null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1120-maximum-average-subtree"><a href="#1120-maximum-average-subtree" class="headerlink" title="1120. maximum-average-subtree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-average-subtree/">1120. maximum-average-subtree</a></h4><ul>
<li>给一个二叉树，求它所有子树的最大平均值。</li>
<li>全局变量+dfs。pass。</li>
</ul>
<h4 id="1122-relative-sort-array"><a href="#1122-relative-sort-array" class="headerlink" title="1122. relative-sort-array"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/relative-sort-array/">1122. relative-sort-array</a></h4><ul>
<li>给两个数组，arr2作为排序规则，arr1按照arr2中元素出现顺序排序。pass.</li>
</ul>
<h4 id="1123-lowest-common-ancestor-of-deepest-leaves"><a href="#1123-lowest-common-ancestor-of-deepest-leaves" class="headerlink" title="1123. lowest-common-ancestor-of-deepest-leaves"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/">1123. lowest-common-ancestor-of-deepest-leaves</a></h4><ul>
<li>给一个二叉树，求最深的叶子节点的LCA(最下层公共祖先). 例如<code>[1,2,3,4,5]</code>最深的节点就是2。</li>
<li>没想出来怎么做。拆分成两部分，求深度和更新公共祖先。在递归时传入当前节点和该节点深度，对该节点左右子节点继续求深度，若左右节点返回的深度都是最深深度，说明当前节点就是LCA了。但如果是当前节点自己就是最深叶子，它左右仍会返回一个不存在的下一层的深度，但是当前节点确实就是最深叶子节点的LCA了。都只用遍历一遍，因此<code>O(N)</code>.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">deepest</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">lca</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lcaDeepestLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        getDepth(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> lca;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getDepth</span><span class="params">(TreeNode node, <span class="type">int</span> currDepth)</span> &#123;</span><br><span class="line">        deepest = Math.max(deepest, currDepth);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> currDepth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftDepth</span> <span class="operator">=</span> getDepth(node.left, currDepth + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightDepth</span> <span class="operator">=</span> getDepth(node.right, currDepth + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (leftDepth == deepest &amp;&amp; rightDepth == deepest) &#123;</span><br><span class="line">            lca = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftDepth, rightDepth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1130-minimum-cost-tree-from-leaf-values"><a href="#1130-minimum-cost-tree-from-leaf-values" class="headerlink" title="1130. minimum-cost-tree-from-leaf-values"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/">1130. minimum-cost-tree-from-leaf-values</a></h4><ul>
<li>给一个int数组表示一棵二叉树的叶子节点，树中每个节点只能有0或者2个孩子。从叶子结点向上，parent是两个孩子之积。求这个数组能组成的所有树中，非叶子结点之和最小值。</li>
<li>翻一下：给一个int数组，将相邻的两个元素merge，保留较大的元素，cost是二者之积。持续将这个数组merge到只剩下一个元素吗，求最小cost。</li>
<li>方法一：DP。<code>dp[i][j]</code>表示<code>[i, j]</code>范围内的最小cost，如果给定最终的split点，那么<code>[start, end]</code>区间的cost为<code>dp[start][mid] + dp[mid + 1][end] + start~mid部分的最大元素 * mid+1~end部分的最大元素</code>. 时间复杂度为<code>O(N^3)</code>，空间<code>O(N^2)</code>.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mctFromLeafValues</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] maxBetween = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length][arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            maxBetween[i][i] = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                maxBetween[i][j] = Math.max(arr[j], maxBetween[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length][arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>; len &lt; arr.length; len++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; left &lt; arr.length - len; left++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> left + len;</span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[left][right] = arr[left] * arr[right];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[left][right] = Integer.MAX_VALUE;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left; mid &lt; right; mid++) &#123;</span><br><span class="line">                        dp[left][right] = Math.min(dp[left][right], dp[left][mid] + dp[mid + <span class="number">1</span>][right] + maxBetween[left][mid] * maxBetween[mid + <span class="number">1</span>][right]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][arr.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：贪心。对于相邻的两个元素<code>(a, b)</code>，假设<code>a &lt;= b</code>，merge后<code>a</code>就被删了，cost为<code>a * b</code>，因此我们要尽可能minimize b。贪心地选择尽可能选与前、后相比是最小的元素进行移除，cost就是<code>num * min(prev, after)</code>. 利用栈维护一个单调下降的序列，一旦比栈顶大，说明栈顶应该先被消掉才能保证cost最小，在pop时需要比较次栈顶元素和待入栈元素，选择较小的乘积。需要注意最开始要在栈顶存入MAX。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mctFromLeafValues</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayDeque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        stack.push(Integer.MAX_VALUE);</span><br><span class="line">        <span class="type">int</span> <span class="variable">retVal</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">            <span class="keyword">while</span> (stack.peek() &lt;= num) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                retVal += mid * Math.min(stack.peek(), num);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (stack.size() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            retVal += stack.pop() * stack.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1140-stone-game-ii"><a href="#1140-stone-game-ii" class="headerlink" title="1140. stone-game-ii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/stone-game-ii/">1140. stone-game-ii</a></h4><ul>
<li>给一个int数组表示piles of stones，两个人轮流取前<code>0 ~ X</code>堆，其中<code>X = [1, 2M]</code>，<code>M</code>初始化为1并随着过程更新为<code>max(X, M)</code>。假设A先操作，求A能取得的最大数目。</li>
<li>递归 + memo模拟操作过程。<code>memo[i][m]</code>记录的是从i开始、<code>M = m</code>的情况。若当前i到末尾的堆恰好在<code>[1, 2M]</code>之间了，那就无脑全部取掉。否则就遍历1 ～ 2M的所有情况，递归交给对方取，将对方所能取的所有情况都搞出来之后，目的就是选择一个最好的X让对方能取的最少。时间复杂度方面，DP的关键是看看每个状态被访问了多少次，对于<code>dp[i][j]</code>，<code>i = [0, n - 1]</code>，<code>j = [0, n - 1]</code>，内层对于X的取值还需要走一波<code>[1, 2 * M]</code>，因此总的时间复杂度为<code>O(N^3)</code>（把M也当作一个变量N）。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">stoneGameII</span><span class="params">(<span class="type">int</span>[] piles)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (piles == <span class="literal">null</span> || piles.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> piles.length;</span><br><span class="line">        <span class="type">int</span>[] sums = <span class="keyword">new</span> <span class="title class_">int</span>[len];  <span class="comment">// 从当前取到末尾的石头数</span></span><br><span class="line">        sums[len - <span class="number">1</span>] = piles[len - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            sums[i] = sums[i + <span class="number">1</span>] + piles[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] memo = <span class="keyword">new</span> <span class="title class_">int</span>[len][len];</span><br><span class="line">        <span class="keyword">return</span> getMaxCount(sums, memo, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMaxCount</span><span class="params">(<span class="type">int</span>[] sums, <span class="type">int</span>[][] memo, <span class="type">int</span> from, <span class="type">int</span> M)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> sums.length;</span><br><span class="line">        <span class="keyword">if</span> (from == len) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * M &gt;= len - from) &#123;  <span class="comment">// 如果能够取完剩余全部堆，就直接取完</span></span><br><span class="line">            <span class="keyword">return</span> sums[from];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[from][M] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[from][M];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">2</span> * M; i++) &#123;  <span class="comment">// 逐个尝试，当前选手取1～2M堆，看对手取多少</span></span><br><span class="line">            min = Math.min(min, getMaxCount(sums, memo, from + i, Math.max(i, M)));</span><br><span class="line">        &#125;</span><br><span class="line">        memo[from][M] = sums[from] - min;   <span class="comment">// 要想我取得最多，就等同于让对手取的在所有性中最小</span></span><br><span class="line">        <span class="keyword">return</span> memo[from][M];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1143-longest-common-subsequence"><a href="#1143-longest-common-subsequence" class="headerlink" title="1143. longest-common-subsequence"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-common-subsequence/">1143. longest-common-subsequence</a></h4><ul>
<li>给两个字符串，求二者最长的公共子序列。</li>
<li>DP。<code>dp[i][j]</code>表示s1取i、s2取j个字符时的最大子序列长度。若i和j处字符相等，则最长长度就是<code>dp[i - 1][j - 1] + 1</code>，否则就需要看s1少取一位或者s2少取一位的最长长度。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (text1 == <span class="literal">null</span> || text1.length() == <span class="number">0</span> ||</span><br><span class="line">           text2 == <span class="literal">null</span> || text2.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] chars1 = text1.toCharArray(), chars2 = text2.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> chars1.length, len2 = chars2.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len1 + <span class="number">1</span>][len2 + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= len1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= len2; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chars1[i - <span class="number">1</span>] == chars2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>优化：dp每次只用到了相邻的两行，因此可以压缩成两行的dp数组。</li>
</ul>
<h4 id="1145-binary-tree-coloring-game"><a href="#1145-binary-tree-coloring-game" class="headerlink" title="1145. binary-tree-coloring-game"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-coloring-game/">1145. binary-tree-coloring-game</a></h4><ul>
<li>给一个各个节点都不同的二叉树，共有<code>n</code>个节点且<code>n</code>是奇数。两个玩家取节点上色，A先选节点<code>x</code>，B选节点后，A先对所有能到达的节点上色，然后再轮到B上色，最终比较谁上色数更多，判断B能否赢。</li>
<li>当A确定了他的节点后，B其实只有三个选择：该节点的parent&#x2F;左&#x2F;右child.而且需要注意的是总共的节点数<code>n</code>也给出了，因此其实只需要统计A所选节点的两个孩子，一减就知道上面那条总共有多少节点了。判断B能不能赢就是看这三个选择包含的节点数是否超过<code>n / 2</code>.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> leftCount, rightCount, target;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">btreeGameWinningMove</span><span class="params">(TreeNode root, <span class="type">int</span> n, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        target = x;</span><br><span class="line">        countNodes(root);</span><br><span class="line">        <span class="keyword">return</span> Math.max(Math.max(leftCount, rightCount), n - leftCount - rightCount - <span class="number">1</span>) &gt; n / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> countNodes(root.left), right = countNodes(root.right);</span><br><span class="line">        <span class="keyword">if</span> (root.val == target) &#123;</span><br><span class="line">            leftCount = left;</span><br><span class="line">            rightCount = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left + right + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1146-snapshot-array"><a href="#1146-snapshot-array" class="headerlink" title="1146. snapshot-array"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/snapshot-array/">1146. snapshot-array</a></h4><ul>
<li>实现一个带有snapshot功能的array类，在get index的时候可以提供snapId，可能根据snapId来取array中的元素。</li>
<li>对于每一个index可以维护一个TreeMap，这样可以在<code>log(N)</code>的时间内取得小于等于snapId的元素。创建SnapshotArray的复杂度为<code>O(N)</code>，snap是<code>O(1)</code>, set是<code>O(logsnap调用次数)</code>, get是<code>O(logsnap调用次数)</code>.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SnapshotArray</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TreeMap[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> snapId;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SnapshotArray</span><span class="params">(<span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.snapId = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.array = <span class="keyword">new</span> <span class="title class_">TreeMap</span>[length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="built_in">this</span>.array[i] = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">            <span class="built_in">this</span>.array[i].put(<span class="built_in">this</span>.snapId, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; <span class="built_in">this</span>.array.length) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.array[index].put(<span class="built_in">this</span>.snapId, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">snap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.snapId++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> snapId)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (snapId &lt; <span class="number">0</span> || index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">this</span>.array.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) <span class="built_in">this</span>.array[index].floorEntry(snapId).getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1152-analyze-user-website-visit-pattern"><a href="#1152-analyze-user-website-visit-pattern" class="headerlink" title="1152. analyze-user-website-visit-pattern"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/analyze-user-website-visit-pattern/">1152. analyze-user-website-visit-pattern</a></h4><ul>
<li>给三个数组，分别存放用户名、时间戳和访问网址。求被不同用户访问最多的三个subsequence。</li>
<li>首先按照timestamp排序，然后统计每个用户访问的网址，然后取每个网址尝试拆分subsequence统计数目。pass.</li>
</ul>
<h4 id="1153-string-transforms-into-another-string"><a href="#1153-string-transforms-into-another-string" class="headerlink" title="1153. string-transforms-into-another-string"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/string-transforms-into-another-string/">1153. string-transforms-into-another-string</a></h4><ul>
<li>给两个只含有小写字母的字符串，判断是否能够从str1转换成str2，转换指的是将所有出现的字母替换成任意其他小写字母。</li>
<li>需要留意的是字母的替换顺序是matter的，例如先把aabcc中的a换成c，那么之后再把ccbcc中的c换成别的需要把四个c都换掉。实际上考点就在于这个cycle必须有一个中转字母，也就是不可以出现26个字母全部出现再替换的cycle里。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConvert</span><span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str1 == <span class="literal">null</span> || str2 == <span class="literal">null</span> || str2.length() != str1.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (str1.equals(str2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character, Character&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span>[] chars1 = str1.toCharArray(), chars2 = str2.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chars1.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(chars1[i])) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map.get(chars1[i]) != chars2[i]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(chars1[i], chars2[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Character&gt;(map.values()).size() &lt; <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1154-ordinal-number-of-date"><a href="#1154-ordinal-number-of-date" class="headerlink" title="1154.ordinal-number-of-date"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/ordinal-number-of-date/">1154.ordinal-number-of-date</a></h4><ul>
<li>给一个日期字符串，求它是该年的第几天。pass。</li>
</ul>
<h4 id="1155-number-of-dice-rolls-with-target-sum"><a href="#1155-number-of-dice-rolls-with-target-sum" class="headerlink" title="1155. number-of-dice-rolls-with-target-sum"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/number-of-dice-rolls-with-target-sum/">1155. number-of-dice-rolls-with-target-sum</a></h4><ul>
<li>给一个整数d表示骰子个数、f表示最大的点数、target表示目标值，求总共有多少种投骰子的组合。例如<code>3,3,5</code>总共就有6种。</li>
<li>一开始使用dfs，但是超时。既然是当前状态依赖于之前的状态，自然想到了dp。也就是每一次丢骰子的时候需要知道target减去当前骰子数值的情况下，有多少种组合，这是一种bottom-up的思路。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD_VALUE</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numRollsToTarget</span><span class="params">(<span class="type">int</span> d, <span class="type">int</span> f, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (d * f &lt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] memo = <span class="keyword">new</span> <span class="title class_">int</span>[d + <span class="number">1</span>][target + <span class="number">1</span>];</span><br><span class="line">        memo[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= d; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= target; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= f &amp;&amp; k &lt;= j; k++) &#123;</span><br><span class="line">                    memo[i][j] = ((memo[i][j] % MOD_VALUE) + (memo[i - <span class="number">1</span>][j - k] % MOD_VALUE)) % MOD_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[d][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1167-minimum-cost-to-connect-sticks"><a href="#1167-minimum-cost-to-connect-sticks" class="headerlink" title="1167. minimum-cost-to-connect-sticks"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-cost-to-connect-sticks/">1167. minimum-cost-to-connect-sticks</a></h4><ul>
<li>给一个int数组，将两个数组融合的开销就是他们的和，求将所有元素融合成一个的最小总开销。</li>
<li>贪心，需要尽可能晚融合较大的数。直接priorityqueue每次取头两个累加即可。pass。</li>
</ul>
<h4 id="1171-remove-zero-sum-consecutive-nodes-from-linked-list"><a href="#1171-remove-zero-sum-consecutive-nodes-from-linked-list" class="headerlink" title="1171. remove-zero-sum-consecutive-nodes-from-linked-list"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/">1171. remove-zero-sum-consecutive-nodes-from-linked-list</a></h4><ul>
<li>给一个单向链表，要求删除连续的、相加为0的子序列，返回形式仍是链表。例如<code>[1,2,3,-1,-2,-3,-4]</code>返回<code>[-4]</code>。</li>
<li>利用累加，同时维护一个<code>sum -&gt; node</code>的map。如果当前累加的结果在之前出现过，则之前出现过的位置对应节点之后的所有节点直到当前节点都要删除，同时将他们这一段累计的sum从map中删除。时间复杂度O(N)，空间O(N). 注意节点可能value&#x3D;0</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeZeroSumSublists</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        Map&lt;Integer, ListNode&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>, dummyHead);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            sum += head.val;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(sum)) &#123;</span><br><span class="line">                removeFromMap(map, map.get(sum).next, head, sum);</span><br><span class="line">                map.get(sum).next = head.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(sum, head);</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeFromMap</span><span class="params">(Map&lt;Integer, ListNode&gt; map, ListNode start, ListNode end, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (start != end) &#123;</span><br><span class="line">            sum += start.val;</span><br><span class="line">            map.remove(sum);</span><br><span class="line">            start = start.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1177-can-make-palindrome-from-substring"><a href="#1177-can-make-palindrome-from-substring" class="headerlink" title="1177. can-make-palindrome-from-substring"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/can-make-palindrome-from-substring/">1177. can-make-palindrome-from-substring</a></h4><ul>
<li>给一个只含有<code>a-z</code>的字符串，每个query给<code>[start, end]</code>表示节选字符串的某一段中通过重组、和最多k次任意替换能否形成一个自对称的字符串。例如<code>dbcdb, k=1</code>为true。</li>
<li>方法一：利用prefixSum求在字符串某索引之前的各个字母的出现频数，这样就可以在给定<code>[start, end]</code>时快速求出每个字母的出现频数。这时再统计其中有多少个出现次数是奇数，就需要进行替换，再和给定的k比较即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Boolean&gt; <span class="title function_">canMakePaliQueries</span><span class="params">(String s, <span class="type">int</span>[][] queries)</span> &#123;</span><br><span class="line">        List&lt;Boolean&gt; retVal = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span> || queries == <span class="literal">null</span> || queries.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> retVal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] prefix = <span class="keyword">new</span> <span class="title class_">int</span>[s.length() + <span class="number">1</span>][<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            prefix[i + <span class="number">1</span>] = prefix[i].clone();</span><br><span class="line">            prefix[i + <span class="number">1</span>][s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] query : queries) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                sum += (prefix[query[<span class="number">1</span>] + <span class="number">1</span>][i] - prefix[query[<span class="number">0</span>]][i]) % <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            retVal.add(sum / <span class="number">2</span> &lt;= query[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：其实我们并不关心每个字母出现的频数，只需要知道在给定范围内每个字母的频数是奇数还是偶数，完全可以用一个bit数组作异或来判断该字母是否需要进行替换。时间&amp;空间复杂度<code>O(s.length + query.length)</code>.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Boolean&gt; <span class="title function_">canMakePaliQueries</span><span class="params">(String s, <span class="type">int</span>[][] queries)</span> &#123;</span><br><span class="line">        List&lt;Boolean&gt; retVal = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span> || queries == <span class="literal">null</span> || queries.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> retVal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] bits = <span class="keyword">new</span> <span class="title class_">int</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            bits[i + <span class="number">1</span>] = bits[i] ^ (<span class="number">1</span> &lt;&lt; (s.charAt(i) - <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] query : queries) &#123;</span><br><span class="line">            retVal.add(Integer.bitCount(bits[query[<span class="number">1</span>] + <span class="number">1</span>] ^ bits[query[<span class="number">0</span>]]) / <span class="number">2</span> &lt;= query[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1181-before-and-after-puzzle"><a href="#1181-before-and-after-puzzle" class="headerlink" title="1181. before-and-after-puzzle"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/before-and-after-puzzle/">1181. before-and-after-puzzle</a></h4><ul>
<li>给一个只含有小写字母和空格的字符串数组，如果两个string的首word和最后一个word相同，则可以拼接成新的字符串。求所有可能的拼接，按字典序返回。</li>
<li>不难，直接维护一个首<code>word -&gt; string</code>和<code>lastWord -&gt; string</code>的map即可。事实上并不需要head和tail，只需要head。而且map中可以存放list of indexes而不是字符串本身。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">beforeAndAfterPuzzles</span><span class="params">(String[] phrases)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (phrases == <span class="literal">null</span> || phrases.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, Set&lt;String&gt;&gt; head = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(), tail = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;String, Integer&gt; count = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String phrase : phrases) &#123;</span><br><span class="line">            String[] splitted = phrase.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            head.computeIfAbsent(splitted[<span class="number">0</span>], s -&gt; <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;()).add(phrase);</span><br><span class="line">            tail.computeIfAbsent(splitted[splitted.length - <span class="number">1</span>], s -&gt; <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;()).add(phrase);</span><br><span class="line">            count.put(phrase, count.getOrDefault(phrase, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        TreeSet&lt;String&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String lastWord : tail.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!head.containsKey(lastWord)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (String phraseHead : head.get(lastWord)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String phraseTail : tail.get(lastWord)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!phraseHead.equals(phraseTail) || count.get(phraseHead) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                        treeSet.add(phraseTail + phraseHead.substring(lastWord.length()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(treeSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1185-day-of-the-week"><a href="#1185-day-of-the-week" class="headerlink" title="1185. day-of-the-week"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/day-of-the-week/">1185. day-of-the-week</a></h4><ul>
<li>给年月日，求该日期是星期几。所给日期在<code>[1971, 2100]</code>，且一定是valid的。</li>
<li>暴力做法，利用<code>01/01/1971</code>是星期五，算相差多少天即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] WEEK_DAY = &#123;<span class="string">&quot;Sunday&quot;</span>, <span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>, <span class="string">&quot;Thursday&quot;</span>, <span class="string">&quot;Friday&quot;</span>, <span class="string">&quot;Saturday&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DAYS_IN_YEAR</span> <span class="operator">=</span> <span class="number">365</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>[] DAYS_IN_MONTH = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">START_YEAR</span> <span class="operator">=</span> <span class="number">1971</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">dayOfTheWeek</span><span class="params">(<span class="type">int</span> day, <span class="type">int</span> month, <span class="type">int</span> year)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> START_YEAR; i &lt; year; i++) &#123;</span><br><span class="line">            count += DAYS_IN_YEAR;</span><br><span class="line">            <span class="keyword">if</span> (isLeapYear(i)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; month - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            count += DAYS_IN_MONTH[i];</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span> &amp;&amp; isLeapYear(year)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        count += (day - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> WEEK_DAY[(count + <span class="number">5</span>) % <span class="number">7</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isLeapYear</span><span class="params">(<span class="type">int</span> year)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (year % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> year % <span class="number">400</span> == <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> year % <span class="number">4</span> == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="1186-maximum-subarray-sum-with-one-deletion"><a href="#1186-maximum-subarray-sum-with-one-deletion" class="headerlink" title="1186.maximum-subarray-sum-with-one-deletion&#x2F;"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-subarray-sum-with-one-deletion/">1186.maximum-subarray-sum-with-one-deletion&#x2F;</a></h4><ul>
<li>给一个int数组，长度在<code>[1, 10^5]</code>，每个值在<code>[-10^4, 10^4]</code>。任意取其中非空的连续子数组，然后至多在上面删除一个元素，使得得到的和最大。求最大和。</li>
<li>类似于DP。对于每一个元素，只有两种可能，要么删、要么保留。但是走到当前元素的时候并不知道之前是否已经执行过一次删除了，因此就需要维护两个dp变量，一个dpExclude表示之前已经执行过删除的连续子数组最大和，一个是尚未执行删除的连续子数组最大和，这时在当前元素就可以选择删除（直接取dpInclude）或者保留当前元素。保留当前元素又有多种可能，一种是继续前面删除过的dpExclude往里加，一种是继续往dpInclude里加，最后一种是直接以当前元素为起始。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumSum</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dpInclude</span> <span class="operator">=</span> arr[<span class="number">0</span>], dpExclude = <span class="number">0</span>, maxSum = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;  <span class="comment">// 从第2个元素开始取，此时dpExclude表示不取第1个元素</span></span><br><span class="line">            dpExclude = Math.max(dpInclude, dpExclude + arr[i]);   <span class="comment">// 不取当前元素或者不取之前的某个元素</span></span><br><span class="line">            dpInclude = Math.max(dpInclude + arr[i], arr[i]);      <span class="comment">// 继续连续取元素或者作为新的起始 </span></span><br><span class="line">            maxSum = Math.max(maxSum, Math.max(dpExclude, dpInclude));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1187-make-array-strictly-increasing"><a href="#1187-make-array-strictly-increasing" class="headerlink" title="1187. make-array-strictly-increasing"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/make-array-strictly-increasing/">1187. make-array-strictly-increasing</a></h4><ul>
<li>给两个int数组<code>arr1</code>和<code>arr2</code>，尝试从<code>arr2</code>中取元素替换到<code>arr1</code>中使得<code>arr1</code>严格递增。最少的替换数，可能是0.</li>
<li>DP。<code>arr1</code>中每一个位置可能有多种值，greedy的想法一方面是要让这个值尽可能小（这样后续的元素要保证递增就容易些）、另一方面又要兼顾总共的替换次数最少。因此考虑将<code>arr2</code>中元素全部存入TreeSet，这样就可以用higher来取恰好更大的最小可替换值。<code>dp[i][j]</code>表示经过至多<code>i</code>次替换后<code>arr1[j]</code>的最小值。时间复杂度<code>O(logN * N * N)</code>。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">makeArrayIncreasing</span><span class="params">(<span class="type">int</span>[] arr1, <span class="type">int</span>[] arr2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr1 == <span class="literal">null</span> || arr2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeSet&lt;Integer&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : arr2) &#123;</span><br><span class="line">            treeSet.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[arr1.length + <span class="number">1</span>][arr1.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : dp) &#123;</span><br><span class="line">            Arrays.fill(row, Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = Integer.MIN_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= arr1.length; j++) &#123;    <span class="comment">// 总共j个元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= j; i++) &#123;          <span class="comment">// dp[i][j]表示index=j处、至多替换i次后的最小可能值</span></span><br><span class="line">                <span class="keyword">if</span> (arr1[j - <span class="number">1</span>] &gt; dp[i][j - <span class="number">1</span>]) &#123;   <span class="comment">// 当前元素已经比之前的元素大了，暂时取之</span></span><br><span class="line">                    dp[i][j] = arr1[j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; treeSet.higher(dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) != <span class="literal">null</span>) &#123;    <span class="comment">// 尝试替换成treeSet中比前一个位置、少一次替换的值大的最小值</span></span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], treeSet.higher(dp[i - <span class="number">1</span>][j - <span class="number">1</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j == dp.length - <span class="number">1</span> &amp;&amp; dp[i][j] != Integer.MAX_VALUE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1190-reverse-substrings-between-each-pair-of-parentheses"><a href="#1190-reverse-substrings-between-each-pair-of-parentheses" class="headerlink" title="1190. reverse-substrings-between-each-pair-of-parentheses"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/">1190. reverse-substrings-between-each-pair-of-parentheses</a></h4><ul>
<li>给一个只含有小写字母和小括号的字符串，返回将小括号包围的部分反转之后并舍弃小括号的字符串。如<code>(ed(et(oc))el)</code>返回<code>leetcode</code>。</li>
<li>方法一：Stack + StringBuilder.栈中存放当前的结果，若碰到左括号，则新建一个空的字符串存入栈，持续拼接到栈顶字符串；若碰到右括号，则将栈顶弹出并reverse，再拼入栈顶。由于需要再循环内部调用reverse，时间复杂度为<code>O(N^2)</code>，空间复杂度为<code>O(N)</code>.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseParentheses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        Stack&lt;StringBuilder&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>());</span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                stack.push(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (chars[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">last</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                stack.peek().append(last.reverse());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.peek().append(chars[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.pop().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：逆天的<code>O(N)</code>做法。从前往后遍历，遇见<code>(</code>就从对应的<code>)</code>出来向左继续遍历，碰到<code>)</code>则到对应的<code>(</code>出来向右继续遍历。不过需要先构建pair数组方便找到对应的左右括号。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseParentheses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] pair = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (chars[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">leftIndex</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                pair[leftIndex] = i;</span><br><span class="line">                pair[i] = leftIndex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, d = <span class="number">1</span>; i &lt; len; i += d) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[i] == <span class="string">&#x27;(&#x27;</span> || chars[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                i = pair[i];</span><br><span class="line">                d *= -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(chars[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1192-critical-connections-in-a-network"><a href="#1192-critical-connections-in-a-network" class="headerlink" title="1192. critical-connections-in-a-network"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/critical-connections-in-a-network/">1192. critical-connections-in-a-network</a></h4><ul>
<li>给一个数字n表示有多少服务器，给一个服务器之间edge的list。求所有critical edges，即去掉该edge就会使得至少一个服务器不可达。</li>
<li>特别有意思的题。关键是观察到critical edge和环的关系：连接两个环之间的edge就是不可删除的edge，每个节点本身都可以看作一个环。从0号节点开始对邻居节点进行DFS，遍历到时就赋予一个不断<code>++</code>的时间timestamp，从A点到B点如果只有一个路径，也就是先到的A才能到B，那么他们的timestamp关系一定是增加的。对于除了parent的所有邻接节点依次标记timestamp，最后当前节点取所有邻接节点（除了parent）的timestamp最小值。如果对邻接节点进行DFS后，最开始赋予当前节点的timestamp比邻接点依然小，说明通过当前节点才能到达该邻接点，说明当前节点是环的出口，因此当前节点到邻接节点就是一个critcal edge了。时间复杂度我觉得是<code>O(edge)</code>，因为每个边都只会被dfs一次。</li>
<li>下面这个解法还有一丝优化就是直接用timestamps的值来取代visited，如果timestamp是0（假设初始值为1）则说明该节点没有被访问过。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">timestamp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">criticalConnections</span><span class="params">(<span class="type">int</span> n, List&lt;List&lt;Integer&gt;&gt; connections)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (connections == <span class="literal">null</span> || connections.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;Integer&gt;[] graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; connection : connections) &#123;</span><br><span class="line">            graph[connection.get(<span class="number">0</span>)].add(connection.get(<span class="number">1</span>));</span><br><span class="line">            graph[connection.get(<span class="number">1</span>)].add(connection.get(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dfs(graph, -<span class="number">1</span>, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">boolean</span>[n], <span class="keyword">new</span> <span class="title class_">int</span>[n], ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(List&lt;Integer&gt;[] graph, <span class="type">int</span> fromNode, <span class="type">int</span> currNode, <span class="type">boolean</span>[] visited, <span class="type">int</span>[] timestamps, List&lt;List&lt;Integer&gt;&gt; ans)</span> &#123;</span><br><span class="line">        visited[currNode] = <span class="literal">true</span>;</span><br><span class="line">        timestamps[currNode] = timestamp++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">currTime</span> <span class="operator">=</span> timestamps[currNode];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> neighborNode : graph[currNode]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (neighborNode == fromNode) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!visited[neighborNode]) &#123;</span><br><span class="line">                dfs(graph, currNode, neighborNode, visited, timestamps, ans);</span><br><span class="line">            &#125;</span><br><span class="line">            timestamps[currNode] = Math.min(timestamps[currNode], timestamps[neighborNode]);</span><br><span class="line">            <span class="keyword">if</span> (currTime &lt; timestamps[neighborNode]) &#123;</span><br><span class="line">                ans.add(Arrays.asList(currNode, neighborNode));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1197-minimum-knight-moves"><a href="#1197-minimum-knight-moves" class="headerlink" title="1197. minimum-knight-moves"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-knight-moves/">1197. minimum-knight-moves</a></h4><ul>
<li>在一个无限大的棋盘上，马从<code>(0, 0)</code>开始走，给终点<code>(x, y)</code>，求最少需要多少步能走到，假设一定存在。</li>
<li>经典BFS。需要将坐标encode成方便比较的形式。需要注意的是BFS需要在第一次见到该坐标的时候就要放入visited集合，因为可能存在重复的情况。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] dir = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">// 8 possible moves.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minKnightMoves</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        x = Math.abs(x);</span><br><span class="line">        y = Math.abs(y);    <span class="comment">// 利用对称性</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">target</span> <span class="operator">=</span> buildString(x, y);</span><br><span class="line">        Queue&lt;String&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">String</span> <span class="variable">start</span> <span class="operator">=</span> buildString(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        q.offer(start);</span><br><span class="line">        <span class="type">int</span> <span class="variable">steps</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        visited.add(start);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> q.size();</span><br><span class="line">            <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">curr</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                <span class="keyword">if</span> (curr.equals(target)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> steps;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> curr.indexOf(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">nextX</span> <span class="operator">=</span> Integer.valueOf(curr.substring(<span class="number">0</span>, index)) + dir[i];</span><br><span class="line">                    <span class="type">int</span> <span class="variable">nextY</span> <span class="operator">=</span> Integer.valueOf(curr.substring(index + <span class="number">1</span>)) + dir[i + <span class="number">1</span>];</span><br><span class="line">                    <span class="type">String</span> <span class="variable">next</span> <span class="operator">=</span> buildString(nextX, nextY);</span><br><span class="line">                    <span class="keyword">if</span> (nextX &gt;= -<span class="number">2</span> &amp;&amp; nextY &gt;= -<span class="number">2</span> &amp;&amp; visited.add(next)) &#123;</span><br><span class="line">                        q.offer(next);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            steps++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">buildString</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(x).append(<span class="string">&quot;,&quot;</span>).append(y).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-knight-moves/discuss/387036/O(1)-formula.">数学的方法</a>，虽然效率爆炸，但是暂时不想管这个。。。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minKnightMoves</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="comment">// Symmetry for axes</span></span><br><span class="line">        x = Math.abs(x);</span><br><span class="line">        y = Math.abs(y);</span><br><span class="line">        <span class="comment">// Symmetry for diagonal</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; y) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> x;</span><br><span class="line">            x = y;</span><br><span class="line">            y = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span> &amp;&amp; y == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">2</span> &amp;&amp; y == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">delta</span> <span class="operator">=</span> x - y;</span><br><span class="line">        <span class="keyword">if</span> (y &gt; delta) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">int</span>) (delta - <span class="number">2</span> * Math.floor((<span class="type">float</span>) (delta - y) / <span class="number">3</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">int</span>) (delta - <span class="number">2</span> * Math.floor((delta - y) / <span class="number">4</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
              <a href="/tags/algorithm/" rel="tag"># algorithm</a>
              <a href="/tags/interview/" rel="tag"># interview</a>
              <a href="/tags/leetcode/" rel="tag"># leetcode</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2018/01/05/java_leetcode5/" rel="prev" title="Note for LeetCode in Java (401~800)">
                  <i class="fa fa-angle-left"></i> Note for LeetCode in Java (401~800)
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2018/01/15/groupon/" rel="next" title="谷入普昂">
                  谷入普昂 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2016 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="futbol-o"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Bob</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"bobbyliujb","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js" defer></script>

</body>
</html>
