<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"bobbyliujb.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"hide","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="迎难而上，祝我好运。面朝大海，春暖花开。">
<meta property="og:type" content="article">
<meta property="og:title" content="拼扯惹斯特">
<meta property="og:url" content="https://bobbyliujb.github.io/2018/09/29/pinterest/index.html">
<meta property="og:site_name" content="Bob&#39;s Blog">
<meta property="og:description" content="迎难而上，祝我好运。面朝大海，春暖花开。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://ww1.sinaimg.cn/large/9b3a5c2fly1fw447d2fm2j20q20q0tbb.jpg">
<meta property="article:published_time" content="2018-09-29T17:29:42.000Z">
<meta property="article:modified_time" content="2018-10-25T07:04:43.130Z">
<meta property="article:author" content="Bob">
<meta property="article:tag" content="java">
<meta property="article:tag" content="algorithm">
<meta property="article:tag" content="interview">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ww1.sinaimg.cn/large/9b3a5c2fly1fw447d2fm2j20q20q0tbb.jpg">


<link rel="canonical" href="https://bobbyliujb.github.io/2018/09/29/pinterest/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://bobbyliujb.github.io/2018/09/29/pinterest/","path":"2018/09/29/pinterest/","title":"拼扯惹斯特"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>拼扯惹斯特 | Bob's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-118868735-1"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-118868735-1","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js" defer></script>








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Bob's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#2018-8-9"><span class="nav-number">1.</span> <span class="nav-text">2018.8.9</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#269-alien-dictionary-x3"><span class="nav-number">1.1.</span> <span class="nav-text">269. alien-dictionary x3</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#271-encode-and-decode-strings"><span class="nav-number">1.2.</span> <span class="nav-text">271. encode-and-decode-strings</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2018-8-4-%E7%94%B5%E9%9D%A2"><span class="nav-number">2.</span> <span class="nav-text">2018.8.4 电面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2018-9-14-Onsite"><span class="nav-number">3.</span> <span class="nav-text">2018.9.14 Onsite</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#425-word-squares-x2"><span class="nav-number">3.1.</span> <span class="nav-text">425. word-squares x2</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2018-4-Onsite"><span class="nav-number">4.</span> <span class="nav-text">2018.4 Onsite</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#index-sum"><span class="nav-number">4.1.</span> <span class="nav-text">index sum</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#463-island-perimeter-x2"><span class="nav-number">4.2.</span> <span class="nav-text">463. island-perimeter x2</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2018-9-Onsite"><span class="nav-number">5.</span> <span class="nav-text">2018.9 Onsite</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#permutation%E7%B3%BB%E5%88%97"><span class="nav-number">5.1.</span> <span class="nav-text">permutation系列</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2016-8-onsite"><span class="nav-number">6.</span> <span class="nav-text">2016.8 onsite</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Letter-Combinations-of-a-Phone-Number-with-isWord-API"><span class="nav-number">6.1.</span> <span class="nav-text">Letter Combinations of a Phone Number with isWord() API</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Duplicate-Files-in-directory"><span class="nav-number">6.2.</span> <span class="nav-text">Duplicate Files in directory</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B5%B0%E5%88%B00"><span class="nav-number">6.3.</span> <span class="nav-text">走到0</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#merge-K-sorted-list"><span class="nav-number">6.4.</span> <span class="nav-text">merge K sorted list</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2018-4-Onsite-x2"><span class="nav-number">7.</span> <span class="nav-text">2018.4 Onsite x2</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#battle-ship%E6%B8%B8%E6%88%8F"><span class="nav-number">7.1.</span> <span class="nav-text">battle ship游戏</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#277-find-the-celebrity-x2"><span class="nav-number">7.2.</span> <span class="nav-text">277. find-the-celebrity x2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#759-employee-free-time"><span class="nav-number">7.3.</span> <span class="nav-text">759. employee-free-time</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B1%82%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E5%A4%9A%E4%BA%8En-4%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-number">7.4.</span> <span class="nav-text">求出现次数多于n&#x2F;4的元素</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2018-5-Oniste"><span class="nav-number">8.</span> <span class="nav-text">2018.5 Oniste</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#blacklist-of-words"><span class="nav-number">8.1.</span> <span class="nav-text">blacklist of words</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2018-3-Onsite-x2"><span class="nav-number">9.</span> <span class="nav-text">2018.3 Onsite x2</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Longest-increasing-path-in-the-binary-tree"><span class="nav-number">9.1.</span> <span class="nav-text">Longest increasing path in the binary tree</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2018-6-Onsite"><span class="nav-number">10.</span> <span class="nav-text">2018.6 Onsite</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2018-2-%E7%94%B5%E9%9D%A2"><span class="nav-number">11.</span> <span class="nav-text">2018.2 电面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2018-3-Onsite"><span class="nav-number">12.</span> <span class="nav-text">2018.3 Onsite</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#31-next-permutation"><span class="nav-number">12.1.</span> <span class="nav-text">31. next-permutation</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2018-7-Onsite"><span class="nav-number">13.</span> <span class="nav-text">2018.7 Onsite</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#133-clone-graph"><span class="nav-number">13.1.</span> <span class="nav-text">133. clone-graph</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#20-valid-parentheses"><span class="nav-number">13.2.</span> <span class="nav-text">20. valid-parentheses</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2018-5-Onsite"><span class="nav-number">14.</span> <span class="nav-text">2018.5 Onsite</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#29-divide-two-integers"><span class="nav-number">14.1.</span> <span class="nav-text">29. divide-two-integers</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2018-5-21-%E7%94%B5%E9%9D%A2"><span class="nav-number">15.</span> <span class="nav-text">2018.5.21 电面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2018-7-1-%E7%94%B5%E9%9D%A2-x2"><span class="nav-number">16.</span> <span class="nav-text">2018.7.1 电面 x2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2018-2-13-%E7%94%B5%E9%9D%A2-x3"><span class="nav-number">17.</span> <span class="nav-text">2018.2.13 电面 x3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2017-11-%E7%94%B5%E9%9D%A2"><span class="nav-number">18.</span> <span class="nav-text">2017.11 电面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2015-10-%E7%94%B5%E9%9D%A2"><span class="nav-number">19.</span> <span class="nav-text">2015.10 电面</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#785-is-graph-bipartite-x3"><span class="nav-number">19.1.</span> <span class="nav-text">785. is-graph-bipartite x3</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2017-10-%E7%94%B5%E9%9D%A2"><span class="nav-number">20.</span> <span class="nav-text">2017.10 电面</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#720-longest-word-in-dictionary"><span class="nav-number">20.1.</span> <span class="nav-text">720. longest-word-in-dictionary</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2018-3-%E7%94%B5%E9%9D%A2"><span class="nav-number">21.</span> <span class="nav-text">2018.3 电面</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#426-convert-binary-search-tree-to-sorted-doubly-linked-list"><span class="nav-number">21.1.</span> <span class="nav-text">426. convert-binary-search-tree-to-sorted-doubly-linked-list</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2017-12-%E7%94%B5%E9%9D%A2"><span class="nav-number">22.</span> <span class="nav-text">2017.12 电面</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#127-word-ladder"><span class="nav-number">22.1.</span> <span class="nav-text">127. word-ladder</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2017-10-%E7%94%B5%E9%9D%A2-x4"><span class="nav-number">23.</span> <span class="nav-text">2017.10 电面 x4</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2017-10-%E7%94%B5%E9%9D%A2-1"><span class="nav-number">24.</span> <span class="nav-text">2017.10 电面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2018-3-Onsite-1"><span class="nav-number">25.</span> <span class="nav-text">2018.3 Onsite</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#LC-146-LRU"><span class="nav-number">25.1.</span> <span class="nav-text">LC 146 LRU</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2018-1-Onsite"><span class="nav-number">26.</span> <span class="nav-text">2018.1 Onsite</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#437-path-sum-iii"><span class="nav-number">26.1.</span> <span class="nav-text">437. path-sum-iii</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#362-design-hit-counter"><span class="nav-number">26.2.</span> <span class="nav-text">362. design-hit-counter</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2017-12-Onsite"><span class="nav-number">27.</span> <span class="nav-text">2017.12 Onsite</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#392-is-subsequence"><span class="nav-number">27.1.</span> <span class="nav-text">392. is-subsequence</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2018-5-%E7%94%B5%E9%9D%A2"><span class="nav-number">28.</span> <span class="nav-text">2018.5 电面</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#67-add-binary"><span class="nav-number">28.1.</span> <span class="nav-text">67. add-binary</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2017-11-Onsite"><span class="nav-number">29.</span> <span class="nav-text">2017.11 Onsite</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#14-longest-common-prefix"><span class="nav-number">29.1.</span> <span class="nav-text">14. longest-common-prefix</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2018-8-Onsite"><span class="nav-number">30.</span> <span class="nav-text">2018.8 Onsite</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#560-subarray-sum-equals-k"><span class="nav-number">30.1.</span> <span class="nav-text">560. subarray-sum-equals-k</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2018-5-Onsite-1"><span class="nav-number">31.</span> <span class="nav-text">2018.5 Onsite</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#698-partition-to-k-equal-sum-subsets"><span class="nav-number">31.1.</span> <span class="nav-text">698. partition-to-k-equal-sum-subsets</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%8Equery-x2"><span class="nav-number">31.2.</span> <span class="nav-text">数组与query x2</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2017-11-Onsite-1"><span class="nav-number">32.</span> <span class="nav-text">2017.11 Onsite</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#139-word-break"><span class="nav-number">32.1.</span> <span class="nav-text">139. word-break</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#column%E6%94%BEpin"><span class="nav-number">32.2.</span> <span class="nav-text">column放pin</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Merge-interval"><span class="nav-number">32.3.</span> <span class="nav-text">Merge interval</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2018-7-Onsite-1"><span class="nav-number">33.</span> <span class="nav-text">2018.7 Onsite</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%B8%E4%BC%BCSet"><span class="nav-number">33.1.</span> <span class="nav-text">相似Set</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2016-5-Onsite"><span class="nav-number">34.</span> <span class="nav-text">[2016.5 Onsite]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#124-binary-tree-maximum-path-sum"><span class="nav-number">34.1.</span> <span class="nav-text">124. binary-tree-maximum-path-sum</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#meeting-rooms-ii%E5%8F%98%E7%A7%8D"><span class="nav-number">34.2.</span> <span class="nav-text">meeting-rooms-ii变种</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E7%9B%B8%E5%90%8C%E6%96%87%E4%BB%B6"><span class="nav-number">34.3.</span> <span class="nav-text">判断相同文件</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2018-5-Onsite-2"><span class="nav-number">35.</span> <span class="nav-text">2018.5 Onsite</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#read-n-characters-given-read4%E5%8F%98%E7%A7%8D"><span class="nav-number">35.1.</span> <span class="nav-text">read-n-characters-given-read4变种</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%81%E4%B8%8A%E9%9D%A2%E7%9A%84word-ladder"><span class="nav-number">35.2.</span> <span class="nav-text">见上面的word-ladder</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#36-valid-sudoku"><span class="nav-number">35.3.</span> <span class="nav-text">36. valid-sudoku</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B1%BB%E4%BC%BC362-design-hit-counter%E8%AF%A6%E6%83%85%E6%AF%8D%E9%B8%A1"><span class="nav-number">35.4.</span> <span class="nav-text">类似362. design-hit-counter详情母鸡</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A5%E4%B8%8B%E6%98%AF%E5%8D%A1%E6%8B%89%E7%89%B9%E9%9D%A2%E7%BB%8F"><span class="nav-number"></span> <span class="nav-text">以下是卡拉特面经</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%9F%E8%AE%A1%E7%82%B9%E5%87%BB%E7%8E%87"><span class="nav-number">1.</span> <span class="nav-text">统计点击率</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%82%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">2.</span> <span class="nav-text">求最长公共子数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%BA%8F%E5%88%97"><span class="nav-number">3.</span> <span class="nav-text">矩阵中最长上升序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2018-9-20-%E7%94%B5%E9%9D%A2"><span class="nav-number">4.</span> <span class="nav-text">2018.9.20 电面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2018-3-14%E7%94%B5%E9%9D%A2"><span class="nav-number">5.</span> <span class="nav-text">2018.3.14电面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2018-9-15-%E7%94%B5%E9%9D%A2"><span class="nav-number">6.</span> <span class="nav-text">2018.9.15 电面</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Bob"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Bob</p>
  <div class="site-description" itemprop="description">I'm a Software Engineer!</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">48</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">49</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://bobbyliujb.github.io/2018/09/29/pinterest/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Bob">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bob's Blog">
      <meta itemprop="description" content="I'm a Software Engineer!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="拼扯惹斯特 | Bob's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          拼扯惹斯特
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-09-29 10:29:42" itemprop="dateCreated datePublished" datetime="2018-09-29T10:29:42-07:00">2018-09-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2018-10-25 00:04:43" itemprop="dateModified" datetime="2018-10-25T00:04:43-07:00">2018-10-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Tech/" itemprop="url" rel="index"><span itemprop="name">Tech</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2018/09/29/pinterest/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/09/29/pinterest/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>迎难而上，祝我好运。面朝大海，春暖花开。</p>
<span id="more"></span>

<h4 id="2018-8-9"><a href="#2018-8-9" class="headerlink" title="2018.8.9"></a><a target="_blank" rel="noopener" href="http://www.1point3acres.com/bbs/thread-437282-1-1.html">2018.8.9</a></h4><h5 id="269-alien-dictionary-x3"><a href="#269-alien-dictionary-x3" class="headerlink" title="269. alien-dictionary x3"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/alien-dictionary/description/">269. alien-dictionary</a> x3</h5><ul>
<li>给一个按照某种外星人字典序排好序的String数组，只包含小写字母，求这些出现过的字母的顺序。若有多种可能（平级）则任意顺序均可。</li>
<li>topo排序问题，前后两个字符串逐个字符找到第一对不同的字符，确定先后顺序（前-&gt;后）构成一条边，两两字符串全部遍历完之后就形成了一个graph。维护一个inDegree，每次BFS时从入度为0的节点出发，将它可达的所有邻接点的入度都减1（删掉这些边），最后如果全部字符都遍历到了即可。如果出现了环，则一定会又入度不为0的点残留。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">alienOrder</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (words == <span class="literal">null</span> || words.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character, Set&lt;Character&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Character, Integer&gt; inDegree = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        initInDegree(words, inDegree);</span><br><span class="line">        buildGraph(words, graph, inDegree);</span><br><span class="line">        Queue&lt;Character&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : inDegree.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDegree.get(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                q.offer(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            sb.append(c);</span><br><span class="line">            <span class="keyword">if</span> (graph.containsKey(c)) &#123;</span><br><span class="line">                Set&lt;Character&gt; neighbors = graph.get(c);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">char</span> neighbor : neighbors) &#123;</span><br><span class="line">                    inDegree.put(neighbor, inDegree.get(neighbor) - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (inDegree.get(neighbor) == <span class="number">0</span>) &#123;</span><br><span class="line">                        q.offer(neighbor);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sb.length() != inDegree.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initInDegree</span><span class="params">(String[] words, Map&lt;Character, Integer&gt; inDegree)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">                inDegree.put(c, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildGraph</span><span class="params">(String[] words, Map&lt;Character, Set&lt;Character&gt;&gt; graph, Map&lt;Character, Integer&gt; inDegree)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">prev</span> <span class="operator">=</span> words[i - <span class="number">1</span>];</span><br><span class="line">            <span class="type">String</span> <span class="variable">curr</span> <span class="operator">=</span> words[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Math.min(prev.length(), curr.length());</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> prev.charAt(j);</span><br><span class="line">                <span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> curr.charAt(j);</span><br><span class="line">                <span class="keyword">if</span> (c1 != c2) &#123;     <span class="comment">// 找到第一个不同的字母</span></span><br><span class="line">                    graph.putIfAbsent(c1, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Character&gt;());</span><br><span class="line">                    <span class="keyword">if</span> (graph.get(c1).add(c2)) &#123;</span><br><span class="line">                        inDegree.put(c2, inDegree.get(c2) + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="271-encode-and-decode-strings"><a href="#271-encode-and-decode-strings" class="headerlink" title="271. encode-and-decode-strings"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/encode-and-decode-strings/description/">271. encode-and-decode-strings</a></h5><ul>
<li>实现encode和decode函数，将字符串List和单一条字符串互相转换。</li>
<li>字符含有哪些？（所有ASCII字符都可能出现）</li>
<li>由于每个符号都有可能出现，所以不能想着用某个特殊符号来拼接和拆分。因此需要额外的信息进行标记，这里用的是在<code>/</code>之前加上所跟字符串的长度的方式，decode时每次从特定位置开始找<code>/</code>，然后取出它前面的长度信息直接截取后面的子字符串。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line">    <span class="comment">// Encodes a list of strings to a single string.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">encode</span><span class="params">(List&lt;String&gt; strs)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            sb.append(str.length()).append(<span class="string">&quot;/&quot;</span>).append(str);    <span class="comment">// 长度 + / + 字符串内容</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes a single string to a list of strings.</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">decode</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.length()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> s.indexOf(<span class="string">&quot;/&quot;</span>, i);  </span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Integer.valueOf(s.substring(i, index));</span><br><span class="line">            ans.add(s.substring(index + <span class="number">1</span>, index + <span class="number">1</span> + len));</span><br><span class="line">            i = index + <span class="number">1</span> + len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2018-8-4-电面"><a href="#2018-8-4-电面" class="headerlink" title="2018.8.4 电面"></a><a target="_blank" rel="noopener" href="http://www.1point3acres.com/bbs/thread-436753-1-1.html">2018.8.4 电面</a></h4><ul>
<li>给一个n，返回所有可能的factor组合。<a target="_blank" rel="noopener" href="https://leetcode.com/problems/factor-combinations/">lc 254</a> x2</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">getFactors</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    getFactors(n, <span class="number">2</span>, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(), ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getFactors</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> start, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; ans)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;   <span class="comment">// 已经除尽了，说明没有更多factor</span></span><br><span class="line">        <span class="keyword">if</span> (path.size() &gt; <span class="number">1</span>) &#123;  <span class="comment">// 当前path就是一路走过来用过的factor</span></span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;   <span class="comment">// 可以整除，说明i是n的一个factor</span></span><br><span class="line">            path.add(i);    <span class="comment">// 将i加入path，将n除掉i，再递归从i开始继续往后找大于等于i的factor</span></span><br><span class="line">            getFactors(n / i, i, path, ans);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2018-9-14-Onsite"><a href="#2018-9-14-Onsite" class="headerlink" title="2018.9.14 Onsite"></a><a target="_blank" rel="noopener" href="http://www.1point3acres.com/bbs/thread-442892-1-1.html">2018.9.14 Onsite</a></h4><ul>
<li>给一个连接关系{A - &gt; B; B - &gt; A,C; C - &gt; B; D - &gt; E; E -&gt; D}，group这些node并返回这些group：[(A,B,C), (D,E)].</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Node&gt;&gt; <span class="title function_">getGroups</span><span class="params">(Map&lt;Node, List&lt;Node&gt;&gt; graph)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (graph == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;Node&gt; nodeSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Node key : graph) &#123;</span><br><span class="line">        nodeSet.add(key);</span><br><span class="line">        <span class="keyword">for</span> (Node neighbor : graph.get(key)) &#123;</span><br><span class="line">            nodeSet.add(neighbor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;List&lt;Node&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!nodeSet.isEmpty()) &#123;</span><br><span class="line">        List&lt;Node&gt; group = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Iterator&lt;Node&gt; it = nodeSet.iterator();</span><br><span class="line">        dfs(it.next(), graph, nodeSet, group);</span><br><span class="line">        ans.add(group);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Node curr, Map&lt;Node, List&lt;Node&gt;&gt; graph, Set&lt;Node&gt; nodeSet, List&lt;Node&gt; group)</span> &#123;</span><br><span class="line">    group.add(curr);</span><br><span class="line">    nodeSet.remove(curr);   <span class="comment">// 移除表示已访问</span></span><br><span class="line">    List&lt;Node&gt; neighbors = graph.get(curr);</span><br><span class="line">    <span class="keyword">if</span> (neighbors == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Node neighbor : neighbors) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodeSet.contains(neighbor)) &#123;</span><br><span class="line">            dfs(neighbor, graph, nodeSet, group);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="425-word-squares-x2"><a href="#425-word-squares-x2" class="headerlink" title="425. word-squares x2"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/word-squares/description/">425. word-squares</a> x2</h5><ul>
<li>给一个wordList，将List中的String放入matrix中使得行、列的单词都来自于这个List。</li>
<li>Trie + DFS，对于每个Trie节点，除了正常的nexts数组、isWord布尔值，额外维护一个List<String>保存以「到达当前TrieNode路径」为prefix的所有word。固定一个word之后，下一个词的prefix可以通过纵向append得到，具体规律见<a target="_blank" rel="noopener" href="https://leetcode.com/problems/word-squares/discuss/91333/Explained.-My-Java-solution-using-Trie-126ms-1616">这个discussion</a>.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">        TrieNode[] nexts;</span><br><span class="line">        List&lt;String&gt; prefixWords;</span><br><span class="line">        <span class="type">boolean</span> isWord;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TrieNode</span><span class="params">()</span> &#123;</span><br><span class="line">            nexts = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line">            prefixWords = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            isWord = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">        TrieNode root;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">            root = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">            <span class="keyword">for</span> (String word : words) &#123; </span><br><span class="line">                <span class="type">TrieNode</span> <span class="variable">curr</span> <span class="operator">=</span> root;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                    <span class="keyword">if</span> (curr.nexts[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                        curr.nexts[index] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    curr.prefixWords.add(word);</span><br><span class="line">                    curr = curr.nexts[index];</span><br><span class="line">                &#125;</span><br><span class="line">                curr.isWord = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getByPrefix</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">            List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">TrieNode</span> <span class="variable">curr</span> <span class="operator">=</span> root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prefix.length(); i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> prefix.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (curr.nexts[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">                curr = curr.nexts[index];</span><br><span class="line">            &#125;</span><br><span class="line">            ans.addAll(curr.prefixWords);</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> len, Trie trie, List&lt;List&lt;String&gt;&gt; ans, List&lt;String&gt; curr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (curr.size() == len) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(curr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> curr.size();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">prefix</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (String s : curr) &#123;</span><br><span class="line">            prefix.append(s.charAt(index));</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; candidates = trie.getByPrefix(prefix.toString());</span><br><span class="line">        <span class="keyword">for</span> (String candidate : candidates) &#123;</span><br><span class="line">            curr.add(candidate);</span><br><span class="line">            dfs(len, trie, ans, curr);</span><br><span class="line">            curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">wordSquares</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (words == <span class="literal">null</span> || words.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> words[<span class="number">0</span>].length();</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trie</span>(words);</span><br><span class="line">        List&lt;String&gt; curr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            curr.add(word);</span><br><span class="line">            dfs(len, root, ans, curr);</span><br><span class="line">            curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2018-4-Onsite"><a href="#2018-4-Onsite" class="headerlink" title="2018.4 Onsite"></a><a target="_blank" rel="noopener" href="http://www.1point3acres.com/bbs/thread-388024-1-1.html">2018.4 Onsite</a></h4><h5 id="index-sum"><a href="#index-sum" class="headerlink" title="index sum"></a>index sum</h5><ul>
<li>一个array自己跟自己的element可以组成一个pair，这个pair有个sum，求the kth sum分别对应的index。应该类似于<a target="_blank" rel="noopener" href="https://leetcode.com/problems/kth-largest-element-in-an-array/description/">lc 215 k-th element</a>吧，只不过需要多存一个index作为返回。</li>
<li>方法一：PriorityQueue维护top K元素即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        pq.offer(nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (pq.size() &gt; k) &#123;</span><br><span class="line">            pq.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pq.peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：quickSelect，用快排的partition来找到元素。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    shuffle(nums);</span><br><span class="line">    <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">0</span>, hi = nums.length - <span class="number">1</span>;</span><br><span class="line">    k = nums.length - k;    <span class="comment">// 转换成第k小的</span></span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> partition(nums, lo, hi);</span><br><span class="line">        <span class="keyword">if</span> (j == k) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &lt; k) &#123; <span class="comment">// 说明第k小的还在后面</span></span><br><span class="line">            lo = j + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 说明第k小的还在前面</span></span><br><span class="line">            hi = j - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo, j = hi + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (nums[++i] &lt; nums[lo]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == hi) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (nums[--j] &gt; nums[lo]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == lo) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, lo, j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        swap(arr, i, r.nextInt(i + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="463-island-perimeter-x2"><a href="#463-island-perimeter-x2" class="headerlink" title="463. island-perimeter x2"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/island-perimeter/description/">463. island-perimeter</a> x2</h5><ul>
<li>给一个0&#x2F;1二维矩阵，求其中为1的island的周长。</li>
<li>方法一：BFS，每个1都先算它有四条边，然后根据邻接情况减掉不是边的即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">islandPerimeter</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[grid.length][grid[<span class="number">0</span>].length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">perimeter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span> &amp;&amp; !visited[i][j]) &#123;</span><br><span class="line">                    perimeter += bfs(grid, i, j, visited);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> perimeter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] dirs = <span class="keyword">new</span> <span class="title class_">int</span>[][] &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">boolean</span>[][] visited)</span> &#123;</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;i, j&#125;);</span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">perimeter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span>[] curr = q.poll();</span><br><span class="line">            perimeter += <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] dir : dirs) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> curr[<span class="number">0</span>] + dir[<span class="number">0</span>], col = curr[<span class="number">1</span>] + dir[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (isIsland(grid, row, col)) &#123;</span><br><span class="line">                    perimeter--;</span><br><span class="line">                    <span class="keyword">if</span> (!visited[row][col]) &#123;</span><br><span class="line">                        q.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;row, col&#125;);</span><br><span class="line">                        visited[row][col] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> perimeter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isIsland</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= <span class="number">0</span> &amp;&amp; i &lt; grid.length</span><br><span class="line">            &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; grid[<span class="number">0</span>].length</span><br><span class="line">            &amp;&amp; grid[i][j] == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：找规律。对于每一个1的cell，看它的下方和右方neighbor是不是1，记录neighbor数，最后周长就是islands * 4 - neighbours * 2。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">islandPerimeter</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">islands</span> <span class="operator">=</span> <span class="number">0</span>, neighbours = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[i].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                islands++; <span class="comment">// count islands</span></span><br><span class="line">                <span class="keyword">if</span> (i &lt; grid.length - <span class="number">1</span> &amp;&amp; grid[i + <span class="number">1</span>][j] == <span class="number">1</span>) neighbours++; <span class="comment">// count down neighbours</span></span><br><span class="line">                <span class="keyword">if</span> (j &lt; grid[i].length - <span class="number">1</span> &amp;&amp; grid[i][j + <span class="number">1</span>] == <span class="number">1</span>) neighbours++; <span class="comment">// count right neighbours</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> islands * <span class="number">4</span> - neighbours * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2018-9-Onsite"><a href="#2018-9-Onsite" class="headerlink" title="2018.9 Onsite"></a><a target="_blank" rel="noopener" href="http://www.1point3acres.com/bbs/thread-440801-1-1.html">2018.9 Onsite</a></h4><h5 id="permutation系列"><a href="#permutation系列" class="headerlink" title="permutation系列"></a>permutation系列</h5><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/permutations/">Permutations(无重复元素全排列)</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">   List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   backtrack(list, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), nums, <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length]);</span><br><span class="line">   <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class="type">int</span>[] nums, <span class="type">boolean</span>[] used)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (tempList.size() == nums.length) &#123;</span><br><span class="line">      list.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tempList));</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123; </span><br><span class="line">         <span class="keyword">if</span> (used[i]) <span class="keyword">continue</span>;</span><br><span class="line">         tempList.add(nums[i]);</span><br><span class="line">         used[i] = <span class="literal">true</span>;</span><br><span class="line">         backtrack(list, tempList, nums);</span><br><span class="line">         used[i] = <span class="literal">false</span>;</span><br><span class="line">         tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/permutations-ii/">Permutations(有重复元素全排列)</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    backtrack(list, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), nums, <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length]);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class="type">int</span>[] nums, <span class="type">boolean</span>[] used)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tempList.size() == nums.length) &#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tempList));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i] || i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            tempList.add(nums[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>; </span><br><span class="line">            backtrack(list, tempList, nums, used);</span><br><span class="line">            used[i] = <span class="literal">false</span>; </span><br><span class="line">            tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2016-8-onsite"><a href="#2016-8-onsite" class="headerlink" title="2016.8 onsite"></a><a target="_blank" rel="noopener" href="http://www.1point3acres.com/bbs/thread-198446-1-1.html">2016.8 onsite</a></h4><h5 id="Letter-Combinations-of-a-Phone-Number-with-isWord-API"><a href="#Letter-Combinations-of-a-Phone-Number-with-isWord-API" class="headerlink" title="Letter Combinations of a Phone Number with isWord() API"></a>Letter Combinations of a Phone Number with isWord() API</h5><ul>
<li>和<a target="_blank" rel="noopener" href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/">lc 17 Letter Combinations of a Phone Number</a>类似，但会多给一个isWord()的API，需要判断生成的word是否在dict中。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">char</span>[][] num2Char = <span class="keyword">new</span> <span class="title class_">char</span> [][] &#123;</span><br><span class="line">    &#123;&#125;, </span><br><span class="line">    &#123;&#125;, </span><br><span class="line">    &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;, </span><br><span class="line">    &#123;<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>&#125;, </span><br><span class="line">    &#123;<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;, </span><br><span class="line">    &#123;<span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;, </span><br><span class="line">    &#123;<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;s&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;v&#x27;</span>&#125;, </span><br><span class="line">    &#123;<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否在给定的dict中</span></span><br><span class="line"><span class="comment">// public boolean isWord(String word);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (digits == <span class="literal">null</span> || digits.length() == <span class="number">0</span> </span><br><span class="line">        || digits.indexOf(<span class="string">&#x27;1&#x27;</span>) &gt;= <span class="number">0</span> || digits.indexOf(<span class="string">&#x27;0&#x27;</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>[] str = digits.toCharArray();</span><br><span class="line">    dfs(str, <span class="number">0</span>, num2Char, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(), ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[] str, <span class="type">int</span> index, <span class="keyword">final</span> <span class="type">char</span>[][] num2Char,</span></span><br><span class="line"><span class="params">                    StringBuilder sb, List&lt;String&gt; ans)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index == str.length &amp;&amp; isWord(sb.toString())) &#123;</span><br><span class="line">        ans.add(sb.toString());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> str[index] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num2Char[temp].length; i++) &#123;</span><br><span class="line">        sb.append(num2Char[temp][i]);</span><br><span class="line">        dfs(str, index + <span class="number">1</span>, num2Char, sb, ans);</span><br><span class="line">        sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Duplicate-Files-in-directory"><a href="#Duplicate-Files-in-directory" class="headerlink" title="Duplicate Files in directory"></a>Duplicate Files in directory</h5><ul>
<li>给一个文件目录，设计一个方法能够找出该目录下（包括子目录）所有的duplicate files（文件内容一样但文件名不一定一样），</li>
<li>先DFS把所有file找出来，然后用MD5哈希值作为Map的key、file的Set作为value，将相同key的Set中的文件两两比较，防止是不同文件因为collision而放到这里。</li>
<li>但如果目录中只有少量的重复文件也要全部扫一遍算MD5，这样很不划算。因此考虑利用文件大小来归类，然后只有文件大小相同的才有可能出现duplicate，但这样可能还是要计算很多个相同文件大小的MD5。</li>
<li>再考虑是不是可以不求整个文件的MD5，而是只取一部分来MD5求哈希作为key（例如前1k个bytes），然后对于size &gt; 1的组再根据<code>[1k + 1, 2k]</code>部分内容求MD5.这样如果只有少量的dulicate，通过这样拆分求key在前面几步就会把大量文件给排除了，后面求MD5的时候就少很多了。</li>
</ul>
<h5 id="走到0"><a href="#走到0" class="headerlink" title="走到0"></a>走到0</h5><ul>
<li>可能类似于<a target="_blank" rel="noopener" href="https://leetcode.com/problems/circular-array-loop/description/">lc 457 </a>，但是不是找loop，也不要求移动方向一致，只是找是否存在arr[index] &#x3D;&#x3D; 0。直接用Set存走过的index即可。或者也可以快慢指针，每次判断快指针是否指向了一个0即可，若快慢指针相遇都没有遇到0，说明不存在。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasZero</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span> || start &lt; <span class="number">0</span> || start &gt;= nums.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[start] == <span class="number">0</span>) &#123; <span class="comment">// 防止一个元素的时候slow == fast进不去while-loop</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length, slow = start, fast = getNextIndex(start, nums[start], n);</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[slow] == <span class="number">0</span> || nums[fast] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = getNextIndex(slow, nums[slow], n);   <span class="comment">// 慢快指针分别移动一步两步</span></span><br><span class="line">        fast = getNextIndex(fast, nums[fast], n);</span><br><span class="line">        fast = getNextIndex(fast, nums[fast], n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getNextIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> step, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">nextIndex</span> <span class="operator">=</span> index + step;</span><br><span class="line">    <span class="keyword">return</span> nextIndex &gt;= <span class="number">0</span> ? nextIndex % len : nextIndex % len + len; <span class="comment">// java的%求的是余数而不是真正的modulo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="merge-K-sorted-list"><a href="#merge-K-sorted-list" class="headerlink" title="merge K sorted list"></a>merge K sorted list</h5><ul>
<li>可以直接把元素通通存入PriorityQueue，然后从头取元素即可。或者用分治法递归来搞，</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lists == <span class="literal">null</span> || lists.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// last two params are used for dividing into sub problems</span></span><br><span class="line">    <span class="keyword">return</span> mergeKLists(lists, <span class="number">0</span>, lists.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (end - start == <span class="number">1</span>) &#123; <span class="comment">// only one list</span></span><br><span class="line">        <span class="keyword">return</span> lists[start];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end - start == <span class="number">2</span>) &#123;  <span class="comment">// merge two lists</span></span><br><span class="line">        <span class="keyword">return</span> mergeTwoLists(lists[start], lists[start + <span class="number">1</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// cut into first and second halves</span></span><br><span class="line">        <span class="keyword">return</span> mergeTwoLists(mergeKLists(lists, start, mid), </span><br><span class="line">                                mergeKLists(lists, mid, end)); <span class="comment">// warning not mid + 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">        l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2018-4-Onsite-x2"><a href="#2018-4-Onsite-x2" class="headerlink" title="2018.4 Onsite x2"></a><a target="_blank" rel="noopener" href="http://www.1point3acres.com/bbs/thread-410807-1-1.html">2018.4 Onsite</a> x2</h4><h5 id="battle-ship游戏"><a href="#battle-ship游戏" class="headerlink" title="battle ship游戏"></a>battle ship游戏</h5><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/battleships-in-a-board/description/">lc有个算battleship个数的</a>，直接O(NM)求第一次出现的ship坐标即可。但游戏应该是给一个坐标进行轰炸，如果反复调用O(NM)太慢了，可以考虑存坐标-船的map，这样就是O(1)了。</li>
</ul>
<h5 id="277-find-the-celebrity-x2"><a href="#277-find-the-celebrity-x2" class="headerlink" title="277. find-the-celebrity x2"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-the-celebrity/description/">277. find-the-celebrity</a> x2</h5><ul>
<li>给一个API函数判断i是否认识j，celebrity的定义是在n个人中，n-1个人都认识他、他却完全不认识他们。</li>
<li>naive方法是O(n^2)搞定，对于每个人，一旦他认识别人、或者别人不认识他就跳出循环。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The knows API is defined in the parent class Relation.</span></span><br><span class="line"><span class="comment">      boolean knows(int a, int b); */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> <span class="keyword">extends</span> <span class="title class_">Relation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findCelebrity</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">found</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == i) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!knows(j, i) || knows(i, j)) &#123;  <span class="comment">// 看别人是否都认识i且i完全不认识别人</span></span><br><span class="line">                    found = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (found) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>更巧妙的办法，从头开始一个pass，判断如果i认识j则把candidate设为j，如果i不认识j则j不可能是candidate；完了之后再一个pass看这个candidate是不是不认识所有人、且所有人都认识他。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findCelebrity</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">candidate</span> <span class="operator">=</span> <span class="number">0</span>;      <span class="comment">// 先假设第一个人是名人</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;   <span class="comment">// 他认识别人就，把他排除掉了</span></span><br><span class="line">        <span class="keyword">if</span> (knows(candidate, i)) candidate = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;   <span class="comment">// 确认他是否认识某个人或者某个人不认识他，那他也不是名人</span></span><br><span class="line">        <span class="keyword">if</span> (i != candidate &amp;&amp; (knows(candidate, i) || !knows(i, candidate))) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="759-employee-free-time"><a href="#759-employee-free-time" class="headerlink" title="759. employee-free-time"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/employee-free-time/description/">759. employee-free-time</a></h5><ul>
<li>给一个List of List，每一个子List存放每个employee的工作时间，求所有employee的共同空闲时间。没有则返回空List。</li>
<li>直接将List flatten，然后按照工作开始时间从小到大排序，再往后依次取工作时间，若当前开始时间比之前的结束时间长，说明出现了空闲时间；否则需要更新prev的end，保证prev的结束时间cover到所有结束时间，即取max。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Interval&gt; <span class="title function_">employeeFreeTime</span><span class="params">(List&lt;List&lt;Interval&gt;&gt; schedule)</span> &#123;</span><br><span class="line">    List&lt;Interval&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (schedule == <span class="literal">null</span> || schedule.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Interval&gt; workingTimes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    schedule.forEach(e -&gt; workingTimes.addAll(e));</span><br><span class="line">    Collections.sort(workingTimes, (a, b) -&gt; a.start - b.start);</span><br><span class="line">    <span class="type">Interval</span> <span class="variable">prev</span> <span class="operator">=</span> workingTimes.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; workingTimes.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (workingTimes.get(i).start &gt; prev.end) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">Interval</span>(prev.end, workingTimes.get(i).start));</span><br><span class="line">            prev = workingTimes.get(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev.end = Math.max(prev.end, workingTimes.get(i).end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="求出现次数多于n-4的元素"><a href="#求出现次数多于n-4的元素" class="headerlink" title="求出现次数多于n&#x2F;4的元素"></a>求出现次数多于n&#x2F;4的元素</h5><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/majority-element/#/description">169. majority-element</a>是求n&#x2F;2、<a target="_blank" rel="noopener" href="https://leetcode.com/problems/majority-element-ii/#/description">229. majority-element-ii</a>是求n&#x2F;3。区别是这些给的都不是sorted array. 这题已经排序了，可以想到的是用两个相隔n&#x2F;4的指针，若两端元素相等说明存在<code>n/4 + 1</code>个相同元素，这个就是其中一个答案了。</li>
</ul>
<h4 id="2018-5-Oniste"><a href="#2018-5-Oniste" class="headerlink" title="2018.5 Oniste"></a><a target="_blank" rel="noopener" href="http://www.1point3acres.com/bbs/thread-417745-1-1.html">2018.5 Oniste</a></h4><h5 id="blacklist-of-words"><a href="#blacklist-of-words" class="headerlink" title="blacklist of words"></a>blacklist of words</h5><ul>
<li>scan 某个query里面存不存在blacklist里面的word。借此机会复习一下trie吧。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> isWord;</span><br><span class="line">        TrieNode[] next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TrieNode</span><span class="params">()</span> &#123;</span><br><span class="line">            isWord = <span class="literal">false</span>;</span><br><span class="line">            next = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    TrieNode root;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (word == <span class="literal">null</span> || word.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] wordChar = word.toCharArray();</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">curr</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; wordChar.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> wordChar[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (curr.next[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                curr.next[index] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.next[index];</span><br><span class="line">        &#125;</span><br><span class="line">        curr.isWord = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (word == <span class="literal">null</span> || word.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] wordChar = word.toCharArray();</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">curr</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; wordChar.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> wordChar[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (curr.next[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.next[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr.isWord;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (prefix == <span class="literal">null</span> || prefix.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] prefixChar = prefix.toCharArray();</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">curr</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prefixChar.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> prefixChar[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (curr.next[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.next[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2018-3-Onsite-x2"><a href="#2018-3-Onsite-x2" class="headerlink" title="2018.3 Onsite x2"></a><a target="_blank" rel="noopener" href="http://www.1point3acres.com/bbs/thread-348442-1-1.html">2018.3 Onsite</a> x2</h4><h5 id="Longest-increasing-path-in-the-binary-tree"><a href="#Longest-increasing-path-in-the-binary-tree" class="headerlink" title="Longest increasing path in the binary tree"></a>Longest increasing path in the binary tree</h5><ul>
<li>具体题意不明，可能是从root到leaf的上升序列（类似<a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-longest-consecutive-sequence/description/">lc 298</a>），或者是可以转折的（类似<a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-longest-consecutive-sequence-ii/description/">lc 549</a>）。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;    <span class="comment">// 从上到下的单向路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        helper(root);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">helper</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;    <span class="comment">// 以当前节点结束，则长度为1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> helper(root.left), right = helper(root.right);</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span> &amp;&amp; root.left.val == root.val + <span class="number">1</span>) &#123;</span><br><span class="line">            len = left + <span class="number">1</span>; <span class="comment">// 根据孩子节点val判断长度是否累加</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span> &amp;&amp; root.right.val == root.val + <span class="number">1</span>) &#123;</span><br><span class="line">            len = Math.max(len, right + <span class="number">1</span>); <span class="comment">// 取两个孩子长度的max</span></span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(max, len);</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;    <span class="comment">// 允许转折的路径</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        helper(root);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] helper(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] left = helper(root.left), right = helper(root.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">inc</span> <span class="operator">=</span> <span class="number">1</span>, dec = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.left.val == root.val + <span class="number">1</span>) &#123;   <span class="comment">// 确认是否能和孩子形成升序/降序列</span></span><br><span class="line">                inc = left[<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (root.left.val == root.val - <span class="number">1</span>) &#123;</span><br><span class="line">                dec = left[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.right.val == root.val + <span class="number">1</span>) &#123;</span><br><span class="line">                inc = Math.max(inc, right[<span class="number">0</span>] + <span class="number">1</span>);  <span class="comment">// 取左右中最大的</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (root.right.val == root.val - <span class="number">1</span>) &#123;</span><br><span class="line">                dec = Math.max(dec, right[<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(inc + dec - <span class="number">1</span>, max);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;inc, dec&#125;;    <span class="comment">// 返回以当前节点为起点的上升、下降序列长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2018-6-Onsite"><a href="#2018-6-Onsite" class="headerlink" title="2018.6 Onsite"></a><a target="_blank" rel="noopener" href="http://www.1point3acres.com/bbs/thread-431111-1-1.html">2018.6 Onsite</a></h4><ul>
<li>实现min stack，需要多一个popMin方法. 思路是在push的时候如果min发生了变化就把当前的min push进去，再更新min。这样在pop的时候就可以通过对比min和当前pop的元素知道是否需要更新min，若min已经被pop了，那么前一个再pop出来就是当前的min。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> min;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">        min = Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">            min = x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (x &lt;= min) &#123;</span><br><span class="line">                stack.push(min);</span><br><span class="line">                min = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (temp == min &amp;&amp; !stack.isEmpty()) &#123;  <span class="comment">// means the min has gone </span></span><br><span class="line">            min = stack.pop();          <span class="comment">// need to update</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// return temp;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">popMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            temp = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (temp == min) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isEmpty()) &#123;</span><br><span class="line">                    min = stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2018-2-电面"><a href="#2018-2-电面" class="headerlink" title="2018.2 电面"></a><a target="_blank" rel="noopener" href="http://www.1point3acres.com/bbs/thread-321679-1-1.html">2018.2 电面</a></h4><ul>
<li>给一个grid，里面有空地、墙和守卫，求离最近守卫距离最远的点的坐标集合。</li>
<li>从所有守卫开始BFS，最后一个level到达的点就是所求了。类似<a target="_blank" rel="noopener" href="https://leetcode.com/problems/walls-and-gates/description/">lc 286</a>.</li>
</ul>
<h4 id="2018-3-Onsite"><a href="#2018-3-Onsite" class="headerlink" title="2018.3 Onsite"></a><a target="_blank" rel="noopener" href="http://www.1point3acres.com/bbs/thread-371197-1-1.html">2018.3 Onsite</a></h4><h5 id="31-next-permutation"><a href="#31-next-permutation" class="headerlink" title="31. next-permutation"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/next-permutation/#/description">31. next-permutation</a></h5><ul>
<li>给一个int数组，将它改造成按字典序的下一个排列，若不存在则直接按从小到大的顺序调整。要求In-place对原数组操作，不能申请额外空间。</li>
<li>从右往左找相邻的两个数使得<code>nums[i - 1] &lt; nums[i]</code>找到第一个升序对，然后再从右往左找首次出现的比<code>nums[i]</code>大的数<code>nums[j]</code>，二者对调，然后将<code>nums[i + 1]</code>及其之后的内容（一定是降序的）reverse一下即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nextPermutation</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i - <span class="number">1</span>] &lt; nums[i]) &#123;    <span class="comment">// 第一个升序对；后续一定是完美降序</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= i) &#123;            <span class="comment">// 找第一个恰好大于nums[i - 1]的数</span></span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    swap(nums, i - <span class="number">1</span>, j);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(nums, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start, j = nums.length - <span class="number">1</span>; i &lt; j; i++, j--) &#123;</span><br><span class="line">        swap(nums, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2018-7-Onsite"><a href="#2018-7-Onsite" class="headerlink" title="2018.7 Onsite"></a><a target="_blank" rel="noopener" href="http://www.1point3acres.com/bbs/thread-434011-1-1.html">2018.7 Onsite</a></h4><h5 id="133-clone-graph"><a href="#133-clone-graph" class="headerlink" title="133. clone-graph"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/clone-graph/#/description">133. clone-graph</a></h5><ul>
<li>给一个无向有环全联通图的其中一个节点，要求拷贝一个完整的无向有环图，并返回拷贝而成的对应的该节点。而且两个节点之间可以有多条通路。</li>
<li>直接用map + DFS搞，对于每一个节点直接new一个相同label的节点出来，然后遍历所有的邻居递归调用clone即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;Integer, UndirectedGraphNode&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> UndirectedGraphNode <span class="title function_">cloneGraph</span><span class="params">(UndirectedGraphNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> clone(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> UndirectedGraphNode <span class="title function_">clone</span><span class="params">(UndirectedGraphNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(node.label)) &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(node.label);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">UndirectedGraphNode</span> <span class="variable">cloned</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UndirectedGraphNode</span>(node.label);</span><br><span class="line">    map.put(clone.label, cloned);</span><br><span class="line">    <span class="keyword">for</span> (UndirectedGraphNode neighbor : node.neighbors) &#123;</span><br><span class="line">        cloned.neighbors.add(clone(neighbor));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloned;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="20-valid-parentheses"><a href="#20-valid-parentheses" class="headerlink" title="20. valid-parentheses"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-parentheses/#/description">20. valid-parentheses</a></h5><ul>
<li>给一个字符串，判断其中三种括号<code>(), [], &#123;&#125;</code>是否匹配。用stack搞即可。</li>
<li>follow-up: 求最少删几个字符可以使原字符串合法。例如<code>(([&#123;))</code>就是把中间两个删除即可。</li>
<li>思路应该类似<a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-invalid-parentheses/#/description">301. remove-invalid-parentheses</a>，也是一个图论BFS。从当前字符串开始出发，所有可达点就是「删除一个字符串所得的新字符串」，注意需要用Set防止重复。每次对相同level的字符串判断是否valid，一旦出现了valid，则当前level所有的valid的字符串就是「最少删除之后的valid字符串」。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">removeInvalidParentheses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    Set&lt;String&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    queue.add(s);</span><br><span class="line">    visited.add(s);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">found</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        curr = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (isValid(curr)) &#123;</span><br><span class="line">            res.add(curr);</span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (found) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// generate all possible states</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; curr.length(); i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">neighbor</span> <span class="operator">=</span> curr.substring(<span class="number">0</span>, i) + curr.substring(i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (!visited.contains(neighbor)) &#123;</span><br><span class="line">                queue.add(neighbor);</span><br><span class="line">                visited.add(neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">	Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Character&gt;();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">			stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">			stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">			stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (stack.isEmpty() || stack.pop() != c)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2018-5-Onsite"><a href="#2018-5-Onsite" class="headerlink" title="2018.5 Onsite"></a><a target="_blank" rel="noopener" href="http://www.1point3acres.com/bbs/thread-426959-1-1.html">2018.5 Onsite</a></h4><h5 id="29-divide-two-integers"><a href="#29-divide-two-integers" class="headerlink" title="29. divide-two-integers"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/divide-two-integers/#/description">29. divide-two-integers</a></h5><ul>
<li>给两个数字，不使用乘、除、模运算前者除以后者之商，若结果越界则返回MAX_INT。</li>
<li>除了傻傻地一路减法减下去，还可以用位运算提速。提取出正负号之后统一按照正long数来处理。用sum来累计当前已经用了多少除数(dividend)，将next初始化为除数，在循环中找到恰好让<code>sum + next &gt; longDividend</code>的<code>next</code>，然后把next往回移一位就是当前这一波累计的除数总和了，加到sum即可。同时用一个count计数记录用了多少个除数，这就是所求的商了，也是累计即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> dividend, <span class="type">int</span> divisor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((dividend == Integer.MIN_VALUE &amp;&amp; divisor == -<span class="number">1</span>)</span><br><span class="line">        || divisor == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dividend == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// using XOR to adjust sign</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sign</span> <span class="operator">=</span> (dividend &lt; <span class="number">0</span>) ^ (divisor &lt; <span class="number">0</span>) ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">longDividend</span> <span class="operator">=</span> Math.abs((<span class="type">long</span>)dividend);</span><br><span class="line">    <span class="type">long</span> <span class="variable">longDivisor</span> <span class="operator">=</span> Math.abs((<span class="type">long</span>)divisor);</span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (sum &lt; longDividend) &#123;    <span class="comment">// warning use long abs value!</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> -<span class="number">1</span>;     </span><br><span class="line">        <span class="type">long</span> <span class="variable">next</span> <span class="operator">=</span> longDivisor;</span><br><span class="line">        <span class="keyword">while</span> (sum + next &lt;= longDividend) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            next &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (next == longDivisor) &#123;  <span class="comment">// 没有变化</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += (next &gt;&gt; <span class="number">1</span>);     <span class="comment">// how much has accumulated</span></span><br><span class="line">        ans += (<span class="number">1</span> &lt;&lt; count);    <span class="comment">// how many divisor used</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sign * ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2018-5-21-电面"><a href="#2018-5-21-电面" class="headerlink" title="2018.5.21 电面"></a><a target="_blank" rel="noopener" href="http://www.1point3acres.com/bbs/thread-426112-1-1.html">2018.5.21 电面</a></h4><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/">lc 34 binary search</a></li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span> [] &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> searchFirst(nums, target);</span><br><span class="line">    <span class="keyword">if</span> (first == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span> [] &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> searchLast(nums, target);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;first, last&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">searchFirst</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">// hope to biase to the front</span></span><br><span class="line">    <span class="comment">// invariant relation: A[start] &lt; target &lt;= A[end] </span></span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> -<span class="number">1</span>, end = nums.length;</span><br><span class="line">    <span class="keyword">while</span> (end - start &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt;= target) &#123;   <span class="comment">// end need to be more aggresive</span></span><br><span class="line">            end = mid;      <span class="comment">// shrink down</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            start = mid;    <span class="comment">// step up</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> end == nums.length || nums[end] != target? -<span class="number">1</span>: end;  <span class="comment">// end will proceed at front</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">searchLast</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">// biase to the back</span></span><br><span class="line">    <span class="comment">// invariant relation: A[start] &lt;= target &lt; A[end] </span></span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> -<span class="number">1</span>, end = nums.length;</span><br><span class="line">    <span class="keyword">while</span> (end - start &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            end = mid;      <span class="comment">// shrink down</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;            <span class="comment">// start need to be more aggressive</span></span><br><span class="line">            start = mid;    <span class="comment">// step up</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2018-7-1-电面-x2"><a href="#2018-7-1-电面-x2" class="headerlink" title="2018.7.1 电面 x2"></a><a target="_blank" rel="noopener" href="http://www.1point3acres.com/bbs/thread-432253-1-1.html">2018.7.1 电面</a> x2</h4><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/edit-distance/description/">lc 72 edit distance</a></li>
<li>给两个字符串word1, word2，求使用addition, replacement, removement三种操作的情况下最少多少步可以从word1转换成word2。</li>
<li><code>dp[i][j]</code>表示当前长度i的子字符串1转换成长度j的子字符串2最少需要的操作数。初始条件显然是<code>dp[0][x] = dp[x][0] = x</code>。对于任意一个<code>dp[i][j]</code>，需要由上、左上、左三个方格的计算结果决定，往上<code>dp[i-1][j]</code>表示一个deletion，往左<code>dp[i][j-1]</code>表示一个addition，左上<code>dp[i-1][j-1]</code>表示一个replacement。每次选取三者中最小的，加上1就是当前的最小操作数了。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (word1 == <span class="literal">null</span> || word2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> word1.length(), len2 = word2.length();</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span> [len1 + <span class="number">1</span>][len2 + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= len1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= len2; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = j;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// s1取i-1、s2取j-1个字符的情况，然后s1和s2都取，不需要增加操作数</span></span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// left: s1取i、s2取j-1个字符的操作数，现在相当于需要往s1中加s2对应位置的字符才能匹配上</span></span><br><span class="line">                    <span class="comment">// up: s1取i-1、s2取j个字符的操作数，相当于要从s1中删除字符才能匹配上</span></span><br><span class="line">                    <span class="comment">// left-up: s1取i-1、s2取j-1个字符的操作数，现在相当于要进行替换才能匹配上</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> dp[i][j - <span class="number">1</span>], up = dp[i - <span class="number">1</span>][j], upLeft = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(left, up), upLeft) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2018-2-13-电面-x3"><a href="#2018-2-13-电面-x3" class="headerlink" title="2018.2.13 电面 x3"></a><a target="_blank" rel="noopener" href="http://www.1point3acres.com/bbs/thread-320848-1-1.html">2018.2.13 电面</a> x3</h4><ul>
<li>给一堆time range，可能有重合。比如[1,3], [2,4], [5,6]。总共的uniq的时间，即merge之后的总时间长度。类似<a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-intervals/description/">lc 56</a>，但不需要维护所有的interval了，只需要保存prev，当后续interval没有overlap的时候就累加time range即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getTimeRange</span><span class="params">(List&lt;Interval&gt; intervals)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Interval&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.sort(intervals, (a, b) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.start != b.start) &#123;</span><br><span class="line">            <span class="keyword">return</span> a.start - b.start;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a.end - b.end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Interval</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">range</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Interval itv : intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">            prev = itv;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (itv.start &gt; prev.end) &#123;</span><br><span class="line">                range += (prev.end - prev.start);</span><br><span class="line">                prev = itv;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev.end = Math.max(prev.end, itv.end);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    range += (prev.end - prev.start);</span><br><span class="line">    <span class="keyword">return</span> range;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>follow-up: 最长的连续range（能合并的合并，最长的range）.直接在上面加个取长度即可。</li>
<li>follow-up2: 求出现次数最多的range。思路也是先排序，利用一个currCount统计当前的time range数，出现了重叠就将prev设置为overlap的部分并累加，当overlap结束就更新maxCount即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Interval <span class="title function_">getMaxInterval</span><span class="params">(List&lt;Interval&gt; intervals)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals == <span class="literal">null</span> || intervals.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.sort(intervals, (a, b) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.start != b.start) &#123;</span><br><span class="line">            <span class="keyword">return</span> a.start - b.start;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a.end - b.end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxCount</span> <span class="operator">=</span> <span class="number">1</span>, currCount = <span class="number">1</span>;</span><br><span class="line">    <span class="type">Interval</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>, ret = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Interval itv : intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">            prev = itv;</span><br><span class="line">            currCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (itv.start &gt;= prev.end) &#123;</span><br><span class="line">                prev = itv;</span><br><span class="line">                currCount = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev = <span class="keyword">new</span> <span class="title class_">Interval</span>(itv.start, Math.min(prev.end, itv.end));</span><br><span class="line">                currCount += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (currCount &gt; maxCount) &#123;</span><br><span class="line">                    ret = prev;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2017-11-电面"><a href="#2017-11-电面" class="headerlink" title="2017.11 电面"></a><a target="_blank" rel="noopener" href="http://www.1point3acres.com/bbs/thread-301765-1-1.html">2017.11 电面</a></h4><ul>
<li>类似于<a target="_blank" rel="noopener" href="https://leetcode.com/problems/read-n-characters-given-read4-ii-call-multiple-times/">lc 158</a>，给一个API <code>read4(char[] buf)</code>，每次可以从某个file中读4个字符到buf，并返回实际读取的字符数。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> <span class="keyword">extends</span> <span class="title class_">Reader4</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buf Destination buffer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n   Maximum number of characters to read</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>    The number of characters read</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">4</span>, tempIndex = <span class="number">0</span>, lastLimit = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>[] temp = <span class="keyword">new</span> <span class="title class_">char</span>[N];</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">char</span>[] buf, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (tempIndex == lastLimit) &#123;</span><br><span class="line">            lastLimit = read4(temp);</span><br><span class="line">            tempIndex = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (lastLimit &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (n &gt; <span class="number">0</span> &amp;&amp; tempIndex &lt; lastLimit &amp;&amp; index &lt; buf.length) &#123;</span><br><span class="line">                buf[index++] = temp[tempIndex++];</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果n读够了，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果tempIndex到头了，可以继续读</span></span><br><span class="line">            lastLimit = read4(temp);</span><br><span class="line">            tempIndex = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2015-10-电面"><a href="#2015-10-电面" class="headerlink" title="2015.10 电面"></a><a target="_blank" rel="noopener" href="http://www.1point3acres.com/bbs/thread-145763-1-1.html">2015.10 电面</a></h4><h5 id="785-is-graph-bipartite-x3"><a href="#785-is-graph-bipartite-x3" class="headerlink" title="785. is-graph-bipartite x3"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/is-graph-bipartite/description/">785. is-graph-bipartite</a> x3</h5><ul>
<li>给一个数组，每个index对应着该node的所有邻接点。问这个graph能否只用两个颜色给node上色使得相邻两个点的颜色都不一样。</li>
<li>方法一：DFS。对于每一个点都一波直接深度搜索上色，用一个数组存储上色状态，0表示未访问过，-1和1分别表示两个颜色，在dfs时对于当前的点若已经访问过就判断是否符合当前给定的颜色，若未访问则直接上色并DFS到它所有邻接点。需要注意可能有若干独立的cluster，因此不能一次DFS搜索就结束了，而是需要一个循环保证对所有未访问过的点都进行一次DFS。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBipartite</span><span class="params">(<span class="type">int</span>[][] graph)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (graph == <span class="literal">null</span> || graph.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] colors = <span class="keyword">new</span> <span class="title class_">int</span>[graph.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (colors[i] == <span class="number">0</span> &amp;&amp; !checkColor(graph, colors, -<span class="number">1</span>, i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkColor</span><span class="params">(<span class="type">int</span>[][] graph, <span class="type">int</span>[] colors, <span class="type">int</span> currColor, <span class="type">int</span> currNode)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (colors[currNode] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> colors[currNode] == currColor;</span><br><span class="line">        &#125;</span><br><span class="line">        colors[currNode] = currColor;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> neighbor : graph[currNode]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!checkColor(graph, colors, -currColor, neighbor)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：BFS，还是用queue存放所有邻接点然后逐一上色。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBipartite</span><span class="params">(<span class="type">int</span>[][] graph)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (graph == <span class="literal">null</span> || graph.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] colors = <span class="keyword">new</span> <span class="title class_">int</span>[graph.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; graph.length; i++) &#123;    <span class="comment">// 只check没有访问过的点，即各个独立的cluster</span></span><br><span class="line">            <span class="keyword">if</span> (colors[i] == <span class="number">0</span> &amp;&amp; !checkColor(graph, colors, -<span class="number">1</span>, i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkColor</span><span class="params">(<span class="type">int</span>[][] graph, <span class="type">int</span>[] colors, <span class="type">int</span> currColor, <span class="type">int</span> currNode)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (colors[currNode] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> colors[currNode] == currColor;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">color</span> <span class="operator">=</span> currColor;</span><br><span class="line">        q.offer(currNode);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> q.size();</span><br><span class="line">            <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">node</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                <span class="keyword">if</span> (colors[node] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (colors[node] != color) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    colors[node] = color;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> neighbor : graph[node]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (colors[neighbor] == <span class="number">0</span>) q.offer(neighbor);   <span class="comment">// 避免回头路</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            color = -color;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2017-10-电面"><a href="#2017-10-电面" class="headerlink" title="2017.10 电面"></a><a target="_blank" rel="noopener" href="http://www.1point3acres.com/bbs/thread-298386-1-1.html">2017.10 电面</a></h4><h5 id="720-longest-word-in-dictionary"><a href="#720-longest-word-in-dictionary" class="headerlink" title="720. longest-word-in-dictionary"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-word-in-dictionary/description/">720. longest-word-in-dictionary</a></h5><ul>
<li>给一个string数组，只含有小写字母，这些word可能形成链式如<code>a, ap, app, appl, apple</code>，求能形成链式的最长的单词，若有多个则取lexicographical最小的。</li>
<li>用sort + Set的方式比较trivial，排序后就可以逐个取word判断prefix是否在Set中。</li>
<li>想考的方法其实是Trie。根据所给的word构建Trie，每个节点直接存储word而不是boolean isWord，因为最后要求的是最长的String，直接存String方便返回。构建完Trie之后就从root开始找最长的连续的到达leaf的路径，要求路径上每一个word都长度更长（increasing）。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">        TrieNode[] nexts = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">String</span> <span class="variable">word</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">        TrieNode root;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">            root = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">            <span class="type">TrieNode</span> <span class="variable">curr</span> <span class="operator">=</span> root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (curr.nexts[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                    curr.nexts[index] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                curr = curr.nexts[index];</span><br><span class="line">            &#125;</span><br><span class="line">            curr.word = word;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">dfs</span><span class="params">(TrieNode node)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ret</span> <span class="operator">=</span> node.word;</span><br><span class="line">        <span class="keyword">for</span> (TrieNode next : node.nexts) &#123;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="literal">null</span> &amp;&amp; next.word.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">childWord</span> <span class="operator">=</span> dfs(next);</span><br><span class="line">                <span class="keyword">if</span> (childWord.length() &gt; ret.length()) &#123;</span><br><span class="line">                    ret = childWord;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestWord</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (words == <span class="literal">null</span> || words.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">trie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            trie.insert(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(trie.root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2018-3-电面"><a href="#2018-3-电面" class="headerlink" title="2018.3 电面"></a><a target="_blank" rel="noopener" href="http://www.1point3acres.com/bbs/thread-346340-1-1.html">2018.3 电面</a></h4><ul>
<li>将二叉树转换成双向链表。应该是类似<a target="_blank" rel="noopener" href="https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/description/">lc 426</a>的。</li>
</ul>
<h5 id="426-convert-binary-search-tree-to-sorted-doubly-linked-list"><a href="#426-convert-binary-search-tree-to-sorted-doubly-linked-list" class="headerlink" title="426. convert-binary-search-tree-to-sorted-doubly-linked-list"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/description/">426. convert-binary-search-tree-to-sorted-doubly-linked-list</a></h5><ul>
<li>给一个BST，将它转换成排好序的循环双向链表（头尾相接），返回头部。可以把左右孩子就看作是当前节点的前后链表节点，不需要额外搞ListNode类。</li>
<li>BST要维持顺序，那就是用中序遍历。利用全局变量prev来记录每一个子树的结尾节点，先build左子树，然后把当前节点拼到prev的后面，再去继续build右子树即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">treeToDoublyList</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();    <span class="comment">// 伪头部的next就是head</span></span><br><span class="line">    prev = dummy;   </span><br><span class="line">    buildDoublyList(root);</span><br><span class="line">    prev.right = dummy.right;</span><br><span class="line">    dummy.right.left = prev;</span><br><span class="line">    dummy.left = dummy.right = <span class="literal">null</span>;    <span class="comment">// 清理dummy</span></span><br><span class="line">    <span class="keyword">return</span> prev.right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行buildDoublyList后会将node下面的部分都形成双向链表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildDoublyList</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buildDoublyList(node.left); <span class="comment">// 先对左子树build一下，prev会指向最后一个节点</span></span><br><span class="line">    prev.right = node;          <span class="comment">// 将node拼进去</span></span><br><span class="line">    node.left = prev;</span><br><span class="line">    prev = node;                <span class="comment">// 左半部分+当前节点的结尾就是node</span></span><br><span class="line">    buildDoublyList(node.right);<span class="comment">// 继续build右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：分治法。先把左右子树的循环双向链表build好，再把当前节点塞到中间，同时把新的前后循环连接一下。注意在分别build的时候，需要把root本身设一个自循环，这样就可以重复使用connect方法了。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">treeToDoublyList</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">leftHead</span> <span class="operator">=</span> treeToDoublyList(root.left);</span><br><span class="line">    <span class="type">Node</span> <span class="variable">rightHead</span> <span class="operator">=</span> treeToDoublyList(root.right);</span><br><span class="line">    root.left = root;</span><br><span class="line">    root.right = root;</span><br><span class="line">    <span class="keyword">return</span> connect(connect(leftHead, root), rightHead);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node leftHead, Node rightHead)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (leftHead == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> rightHead;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rightHead == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> leftHead;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">leftTail</span> <span class="operator">=</span> leftHead.left;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">rightTail</span> <span class="operator">=</span> rightHead.left;</span><br><span class="line">    leftTail.right = rightHead;</span><br><span class="line">    rightHead.left = leftTail;</span><br><span class="line">    leftHead.left = rightTail;</span><br><span class="line">    rightTail.right = leftHead;</span><br><span class="line">    <span class="keyword">return</span> leftHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2017-12-电面"><a href="#2017-12-电面" class="headerlink" title="2017.12 电面"></a><a target="_blank" rel="noopener" href="http://www.1point3acres.com/bbs/thread-310576-1-1.html">2017.12 电面</a></h4><h5 id="127-word-ladder"><a href="#127-word-ladder" class="headerlink" title="127. word-ladder"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/word-ladder/#/description">127. word-ladder</a></h5><ul>
<li>给一个List的String，然后一个初始String一个目标String，要求每次变动一个字母且变动后的词语来自该List的情况下，最短需要变几次得到目标String。</li>
<li>可以看作BFS问题，每个word就是一个node，neighbor就是换掉一个字母后且在wordList中存在的词。这样BFS最快到达dest的就是最短了。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (beginWord == <span class="literal">null</span> || endWord == <span class="literal">null</span> || beginWord.length() == <span class="number">0</span> || endWord.length() == <span class="number">0</span></span><br><span class="line">        || beginWord.length() != endWord.length() || wordList == <span class="literal">null</span> || wordList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;String&gt; wordSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordList);</span><br><span class="line">    Queue&lt;String&gt; toVisit = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    bfs(beginWord, wordSet, toVisit);</span><br><span class="line">    <span class="type">int</span> <span class="variable">dist</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (!toVisit.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> toVisit.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">curr</span> <span class="operator">=</span> toVisit.poll();</span><br><span class="line">            <span class="keyword">if</span> (curr.equals(endWord)) &#123;</span><br><span class="line">                <span class="keyword">return</span> dist;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                bfs(curr, wordSet, toVisit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dist++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(String beginWord, Set&lt;String&gt; wordSet, Queue&lt;String&gt; toVisit)</span> &#123;</span><br><span class="line">    wordSet.remove(beginWord);</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(beginWord);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sb.length(); i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">origin</span> <span class="operator">=</span> sb.charAt(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">26</span>; k++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span> + k);</span><br><span class="line">            sb.setCharAt(i, c);</span><br><span class="line">            <span class="type">String</span> <span class="variable">curr</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">            <span class="keyword">if</span> (wordSet.contains(curr)) &#123;</span><br><span class="line">                toVisit.add(curr);</span><br><span class="line">                wordSet.remove(curr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.setCharAt(i, origin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>follow-up：如何记录最短路径？其实就是<a target="_blank" rel="noopener" href="https://leetcode.com/problems/word-ladder-ii/description/">126</a>。还是用BFS找最短路径，维护一个distMap记录每个节点到达时所经过的步数，到达终点后再从头开始DFS，每次只去步数增长1的邻居点。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">findLadders</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (beginWord == <span class="literal">null</span> || endWord == <span class="literal">null</span> || beginWord.length() == <span class="number">0</span> || endWord.length() == <span class="number">0</span></span><br><span class="line">        || beginWord.length() != endWord.length() || wordList == <span class="literal">null</span> || wordList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;String, Integer&gt; distMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String word : wordList) &#123;</span><br><span class="line">        distMap.put(word, Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!distMap.containsKey(endWord)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    distMap.put(beginWord, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    Map&lt;String, Set&lt;String&gt;&gt; neighborMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Queue&lt;String&gt; toVisit = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    toVisit.offer(beginWord);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">found</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!toVisit.isEmpty() &amp;&amp; !found) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> toVisit.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">currWord</span> <span class="operator">=</span> toVisit.poll();</span><br><span class="line">            <span class="keyword">if</span> (currWord.equals(endWord)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                bfs(currWord, distMap, neighborMap, toVisit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(beginWord, endWord, distMap, neighborMap, ans, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(String fromWord, Map&lt;String, Integer&gt; distMap, </span></span><br><span class="line"><span class="params">                Map&lt;String, Set&lt;String&gt;&gt; neighborMap, Queue&lt;String&gt; q)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(fromWord);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sb.length(); i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">origin</span> <span class="operator">=</span> sb.charAt(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">26</span>; k++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span> + k);</span><br><span class="line">            sb.setCharAt(i, c);</span><br><span class="line">            <span class="type">String</span> <span class="variable">curr</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">            <span class="keyword">if</span> (distMap.containsKey(curr) &amp;&amp; distMap.get(fromWord) + <span class="number">1</span> &lt;= distMap.get(curr)) &#123;</span><br><span class="line">                q.add(curr);</span><br><span class="line">                distMap.put(curr, distMap.get(fromWord) + <span class="number">1</span>);</span><br><span class="line">                neighborMap.putIfAbsent(fromWord, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line">                neighborMap.get(fromWord).add(curr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.setCharAt(i, origin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(String fromWord, String toWord, Map&lt;String, Integer&gt; distMap, </span></span><br><span class="line"><span class="params">                Map&lt;String, Set&lt;String&gt;&gt; neighborMap, List&lt;List&lt;String&gt;&gt; ans, List&lt;String&gt; path)</span> &#123;</span><br><span class="line">    path.add(fromWord);</span><br><span class="line">    <span class="keyword">if</span> (fromWord.equals(toWord)) &#123;</span><br><span class="line">        ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;String&gt; neighbors = neighborMap.get(fromWord);</span><br><span class="line">    <span class="keyword">if</span> (neighbors != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String neighbor : neighbors) &#123;</span><br><span class="line">            <span class="keyword">if</span> (distMap.get(neighbor) == distMap.get(fromWord) + <span class="number">1</span>) &#123;</span><br><span class="line">                dfs(neighbor, toWord, distMap, neighborMap, ans, path);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2017-10-电面-x4"><a href="#2017-10-电面-x4" class="headerlink" title="2017.10 电面 x4"></a><a target="_blank" rel="noopener" href="http://www.1point3acres.com/bbs/thread-296325-1-1.html">2017.10 电面</a> x4</h4><ul>
<li><a target="_blank" rel="noopener" href="https://www.pinterest.com/categories/everything/">pinterest页面例子</a>，每个图片都等宽但不等高，给一堆pin的id、高度，求放置pin的策略，让每个col的pin都比较好看，即按顺序拼pin，每次选最短的column append到底部。例如输入<code>pins = [&#123;&#39;id&#39;:1, &#39;height&#39;: 100&#125;, &#123;&#39;id&#39;:2, &#39;height&#39;:300&#125;, &#123;&#39;id&#39;:3, &#39;height&#39;:150&#125;.....]</code>，以及<code>col = 3</code>。返回List of List<code>[[1,.....],[2,...],[3,...]]</code>，每一个List表示该column存放的图片的id。</li>
<li>如何保证每次都取最短的col去append？联想到了PriorityQueue，可以logK插入，每次都直接取到最短的进行append。时间复杂度O(NlogK)，其中K是col数量。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">getColumnPinIds</span><span class="params">(Map&lt;Integer, Integer&gt; heightMap, <span class="type">int</span> colTotal)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] colHeights = <span class="keyword">new</span> <span class="title class_">int</span>[colTotal];</span><br><span class="line">    PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((i, j) -&gt; colHeights[i] != colHeights[j] ? </span><br><span class="line">                        colHeights[i] - colHeights[j] : i - j);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; colTotal; i++) &#123;</span><br><span class="line">        pq.offer(i);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; colTotal; i++) &#123;</span><br><span class="line">        ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> pinId : heightMap.keySet()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">colIndex</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">        colHeights[colIndex] += heightMap.get(pinId);</span><br><span class="line">        ans.get(colIndex).add(pinId);</span><br><span class="line">        pq.offer(colIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果不让用heap？那就直接O(NK)，每次都遍历k个col看看谁最小即可。</li>
<li>follow-up: resize一下窗口，如何快速rearrange这些pin？</li>
</ul>
<h4 id="2017-10-电面-1"><a href="#2017-10-电面-1" class="headerlink" title="2017.10 电面"></a><a target="_blank" rel="noopener" href="http://www.1point3acres.com/bbs/thread-300818-1-1.html">2017.10 电面</a></h4><ul>
<li>behavior tree. 给一对用户的action如 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">user_id, timestamp, action</span><br><span class="line">100, 1000, A</span><br><span class="line">200, 1003, A</span><br><span class="line">300, 1009, B</span><br><span class="line">100, 1026, B</span><br><span class="line">100, 1030, C</span><br><span class="line">200, 1109, B</span><br><span class="line">200, 1503, A</span><br></pre></td></tr></table></figure>
  如何从上面的log file构造成一个system log的graph如 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|---A (2)</span><br><span class="line">|    |---B (2)</span><br><span class="line">|    |    |---C (1)</span><br><span class="line">|    |    |---A (1)</span><br><span class="line">|---B (1)</span><br></pre></td></tr></table></figure></li>
<li>这个和Trie很类似。可以考虑对于序列中每一个动作，维护一个TrieNode，其中包含action, count, 和后续操作节点nexts.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LogParser</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">        String action;</span><br><span class="line">        <span class="type">int</span> count;</span><br><span class="line">        Map&lt;String, TrieNode&gt; nexts;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TrieNode</span><span class="params">()</span> &#123;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            nexts = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertActions</span><span class="params">(TrieNode root, List&lt;String&gt; actions)</span> &#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">curr</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (String action : actions) &#123;</span><br><span class="line">            curr.nexts.putIfAbsent(action, <span class="keyword">new</span> <span class="title class_">TrieNode</span>());</span><br><span class="line">            curr.nexts.get(action).count++;</span><br><span class="line">            curr = curr.nexts.get(action);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span>  <span class="keyword">class</span> <span class="title class_">Record</span> &#123;</span><br><span class="line">        <span class="type">int</span> userId;</span><br><span class="line">        <span class="type">int</span> timestamp;</span><br><span class="line">        String action;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Record</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> timestamp, String action)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.userId = userId;</span><br><span class="line">            <span class="built_in">this</span>.timestamp = timestamp;</span><br><span class="line">            <span class="built_in">this</span>.action = action;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TrieNode <span class="title function_">getGraph</span><span class="params">(String[] logs)</span> &#123;</span><br><span class="line">        Record[] records = <span class="keyword">new</span> <span class="title class_">Record</span>[logs.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; logs.length; i++) &#123;</span><br><span class="line">            String[] splitted = logs[i].split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">userId</span> <span class="operator">=</span> Integer.parseInt(splitted[<span class="number">0</span>].trim());</span><br><span class="line">            <span class="type">int</span> <span class="variable">timestamp</span> <span class="operator">=</span> Integer.parseInt(splitted[<span class="number">1</span>].trim());</span><br><span class="line">            <span class="type">String</span> <span class="variable">action</span> <span class="operator">=</span> splitted[<span class="number">2</span>].trim();</span><br><span class="line">            records[i] = <span class="keyword">new</span> <span class="title class_">Record</span>(userId, timestamp, action);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(records, (a, b) -&gt; a.timestamp - b.timestamp);</span><br><span class="line">        Map&lt;Integer, List&lt;String&gt;&gt; userActionMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Record record : records) &#123;</span><br><span class="line">            userActionMap.putIfAbsent(record.userId, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            userActionMap.get(record.userId).add(record.action);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> userId : userActionMap.keySet()) &#123;</span><br><span class="line">            insertActions(root, userActionMap.get(userId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">PADDING_STRING</span> <span class="operator">=</span> <span class="string">&quot;|   &quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">LEADING_STRING</span> <span class="operator">=</span> <span class="string">&quot;|---&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printGraph</span><span class="params">(TrieNode node, StringBuilder sb)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String nextAction : node.nexts.keySet()) &#123;</span><br><span class="line">            System.out.print(sb);</span><br><span class="line">            System.out.print(LEADING_STRING);</span><br><span class="line">            System.out.print(nextAction);</span><br><span class="line">            System.out.println(<span class="string">&quot;(&quot;</span> + node.nexts.get(nextAction).count + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">            sb.append(PADDING_STRING);</span><br><span class="line">            printGraph(node.nexts.get(nextAction), sb);</span><br><span class="line">            sb.delete(sb.length() - PADDING_STRING.length(), sb.length());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2018-3-Onsite-1"><a href="#2018-3-Onsite-1" class="headerlink" title="2018.3 Onsite"></a><a target="_blank" rel="noopener" href="http://www.1point3acres.com/bbs/thread-345908-1-1.html">2018.3 Onsite</a></h4><h5 id="LC-146-LRU"><a href="#LC-146-LRU" class="headerlink" title="LC 146 LRU"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/lru-cache/description/">LC 146 LRU</a></h5><ul>
<li>说是设计Gmail界面，说是类似实现LRU。实现Cache就是用Map，但是least recent特性就需要额外的数据结构来提升效率：双向链表。Map中存放key - Node映射，所有的cache都放在一个双向链表上，每次get的时候就将get到的node挪到第一位。put时若capacity超了就将链表最后一个节点删除即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        Node prev;</span><br><span class="line">        Node next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">            prev = <span class="literal">null</span>;</span><br><span class="line">            next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Integer, Node&gt; map;</span><br><span class="line">    Node fakeHead, fakeTail;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        fakeHead = <span class="keyword">new</span> <span class="title class_">Node</span>(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        fakeTail = <span class="keyword">new</span> <span class="title class_">Node</span>(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        fakeHead.next = fakeTail;</span><br><span class="line">        fakeTail.prev = fakeHead;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">ret</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            moveToFirst(ret);</span><br><span class="line">            <span class="keyword">return</span> ret.val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">oldNode</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            oldNode.val = value;</span><br><span class="line">            moveToFirst(oldNode);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (map.size() == capacity) &#123;</span><br><span class="line">            map.remove(fakeTail.prev.key);</span><br><span class="line">            remove(fakeTail.prev);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, value);</span><br><span class="line">        insertToFirst(newNode);</span><br><span class="line">        map.put(key, newNode);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveToFirst</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        remove(node);</span><br><span class="line">        insertToFirst(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insertToFirst</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        node.next = fakeHead.next;</span><br><span class="line">        fakeHead.next = node;</span><br><span class="line">        node.prev = fakeHead;</span><br><span class="line">        node.next.prev = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.prev == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2018-1-Onsite"><a href="#2018-1-Onsite" class="headerlink" title="2018.1 Onsite"></a><a target="_blank" rel="noopener" href="http://www.1point3acres.com/bbs/thread-317124-1-1.html">2018.1 Onsite</a></h4><h5 id="437-path-sum-iii"><a href="#437-path-sum-iii" class="headerlink" title="437. path-sum-iii"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/path-sum-iii/description/">437. path-sum-iii</a></h5><ul>
<li>给一个二叉树，给一个目标值sum，求有几条从上往下累加的路径之和等于sum。</li>
<li>除了O(N^2)的笨方法，考虑使用cache保存已有结果，这里用到的是prefixSum的思路。在深入下层节点的时候直接累计currSum，同时在cache中找是否存在若干段path是<code>currSum - target</code>，这样就可以把这些prefix从path中给去掉就可以得到target了。在深入更下层节点之前，需要更新currSum的计数，这样在更深层的时候就知道最新的currSum作为prefixSum的计数。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    dfs(root, <span class="number">0</span>, sum, map);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> currSum, <span class="type">int</span> target, Map&lt;Integer, Integer&gt; map)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    currSum += root.val;</span><br><span class="line">    count += map.getOrDefault(currSum - target, <span class="number">0</span>);</span><br><span class="line">    map.put(currSum, map.getOrDefault(currSum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    dfs(root.left, currSum, target, map);</span><br><span class="line">    dfs(root.right, currSum, target, map);</span><br><span class="line">    </span><br><span class="line">    map.put(currSum, map.get(currSum) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="362-design-hit-counter"><a href="#362-design-hit-counter" class="headerlink" title="362. design-hit-counter"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/design-hit-counter/description/">362. design-hit-counter</a></h5><ul>
<li>实现一个hitCount类，通过hit(timestamp)表示在什么时候出现了hit（可能同一时刻有多次hit），然后通过getHits得到最近300s内hit了多少次。</li>
<li>利用循环数组记录hits即可，容量可以直接设为300，这样最多就可以同时记录300s中每一秒的hit数量，在getHis的时候直接遍历一边如何保证每个bucket都是valid的count呢，就需要记录每一个bucket对应的hit的时刻是几时，因此需要另一个time数组来记录。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HitCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] hits;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] time;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="type">int</span> <span class="variable">TIMEWINDOW</span> <span class="operator">=</span> <span class="number">300</span>;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HitCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        hits = <span class="keyword">new</span> <span class="title class_">int</span> [TIMEWINDOW];</span><br><span class="line">        time = <span class="keyword">new</span> <span class="title class_">int</span> [TIMEWINDOW];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Record a hit.</span></span><br><span class="line"><span class="comment">        <span class="doctag">@param</span> timestamp - The current timestamp (in seconds granularity). */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hit</span><span class="params">(<span class="type">int</span> timestamp)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> timestamp % TIMEWINDOW;</span><br><span class="line">        <span class="keyword">if</span> (time[index] != timestamp) &#123;</span><br><span class="line">            time[index] = timestamp;</span><br><span class="line">            hits[index] = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hits[index]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Return the number of hits in the past 5 minutes.</span></span><br><span class="line"><span class="comment">        <span class="doctag">@param</span> timestamp - The current timestamp (in seconds granularity). */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHits</span><span class="params">(<span class="type">int</span> timestamp)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; TIMEWINDOW; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timestamp - time[i] &lt; TIMEWINDOW) &#123;</span><br><span class="line">                count += hits[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2017-12-Onsite"><a href="#2017-12-Onsite" class="headerlink" title="2017.12 Onsite"></a><a target="_blank" rel="noopener" href="http://www.1point3acres.com/bbs/thread-307205-1-1.html">2017.12 Onsite</a></h4><h5 id="392-is-subsequence"><a href="#392-is-subsequence" class="headerlink" title="392. is-subsequence"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/is-subsequence/description/">392. is-subsequence</a></h5><ul>
<li>给两个字符串，判断其中一个字符串s是否是另一个字符串t的子序列串，这个字串不要求字符连续出现，只要求出现顺序一致且全部出现即可。</li>
<li>trivail的方法是直接两个指针扫，只有当s的字符和t匹配了才挪动s的指针。</li>
<li>如果t很大，而s是很多个小字符串需要连续调用这个函数呢？这就可以考虑使用记录索引+二分查找了。首先对t中每个字符记录出现的索引并存入List，这个是不会变的。然后对于输入s，每个字符都对该字符的List用二分查找找索引的「第一次出现&#x2F;插入位置」，找到后就作为后一次搜索的索引。如果插入位置是在最后，说明t无法满足s的对应位置；</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt;[] indexCache = <span class="keyword">new</span> <span class="title class_">List</span> [<span class="number">26</span>];</span><br><span class="line">    <span class="type">char</span>[] tChar = t.toCharArray();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tChar.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> tChar[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (indexCache[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">            indexCache[index] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        indexCache[index].add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span>[] sChar = s.toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">// 在t中出现的最小索引</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sChar.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> sChar[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (indexCache[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">insertPos</span> <span class="operator">=</span> Collections.binarySearch(indexCache[index], pos);</span><br><span class="line">        <span class="keyword">if</span> (insertPos &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            insertPos = -insertPos - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (insertPos == indexCache[index].size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pos = indexCache[index].get(insertPos) + <span class="number">1</span>; <span class="comment">// 下一步所需最小索引更新为已有索引的下一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2018-5-电面"><a href="#2018-5-电面" class="headerlink" title="2018.5 电面"></a><a target="_blank" rel="noopener" href="http://www.1point3acres.com/bbs/thread-421707-1-1.html">2018.5 电面</a></h4><h5 id="67-add-binary"><a href="#67-add-binary" class="headerlink" title="67. add-binary"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/add-binary/#/description">67. add-binary</a></h5><ul>
<li>给两个String表示的二进制数，返回二者相加后的二进制字符串。</li>
<li>模拟加法，可以从两个数的最后一位开始加，最后reverse一下即可，注意最后需要确认首位是否需要加上carry。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">addBinary</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span> || a.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">null</span> || b.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">char</span>[] aChar = a.toCharArray(), bChar = b.toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> aChar.length - <span class="number">1</span>, j = bChar.length - <span class="number">1</span>, carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> carry;    <span class="comment">// from prev result</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            sum += aChar[i--] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            sum += bChar[j--] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(sum % <span class="number">2</span>); <span class="comment">// what&#x27;s left after taking out carry</span></span><br><span class="line">        carry = sum / <span class="number">2</span>;    <span class="comment">// 3,2 -&gt; 1; 1,0 -&gt; 0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry != <span class="number">0</span>) &#123;</span><br><span class="line">        sb.append(carry);   <span class="comment">// warning! the most significant position</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2017-11-Onsite"><a href="#2017-11-Onsite" class="headerlink" title="2017.11 Onsite"></a><a target="_blank" rel="noopener" href="http://www.1point3acres.com/bbs/thread-302734-1-1.html">2017.11 Onsite</a></h4><h5 id="14-longest-common-prefix"><a href="#14-longest-common-prefix" class="headerlink" title="14. longest-common-prefix"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-common-prefix/#/description">14. longest-common-prefix</a></h5><ul>
<li>给一串字符串数组，求这些字符串开头的公共部分。</li>
<li>直接按照字典序排序，找首位和末尾的字符串比较看看有多少公共部分即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">longestCommonPrefix</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="literal">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(strs);</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> strs[<span class="number">0</span>];</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> strs[strs.length - <span class="number">1</span>];</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.charAt(i) != s2.charAt(i)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(s1.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2018-8-Onsite"><a href="#2018-8-Onsite" class="headerlink" title="2018.8 Onsite"></a><a target="_blank" rel="noopener" href="http://www.1point3acres.com/bbs/thread-436530-1-1.html">2018.8 Onsite</a></h4><h5 id="560-subarray-sum-equals-k"><a href="#560-subarray-sum-equals-k" class="headerlink" title="560. subarray-sum-equals-k"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/subarray-sum-equals-k/description/">560. subarray-sum-equals-k</a></h5><ul>
<li>给一个int数组和一个k，问有多少连续的subarray之和等于k。这些int都在<code>[-1000, 1000]</code>，数组长度最多20000。</li>
<li>一开始想用双指针，但有正有负，更新条件不好搞。正解是使用Map，在计算sum的时候顺便看看之前是否出现过sum - k。这其实和path sum III 很像，都是利用prefix sum.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(sum - k)) &#123;     <span class="comment">// 看之前是否已经出现了这一段prefix</span></span><br><span class="line">            count += map.get(sum - k);      <span class="comment">// 这样sum - prefix就等于k了</span></span><br><span class="line">        &#125;</span><br><span class="line">        map.put(sum, map.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2018-5-Onsite-1"><a href="#2018-5-Onsite-1" class="headerlink" title="2018.5 Onsite"></a><a target="_blank" rel="noopener" href="http://www.1point3acres.com/bbs/thread-426865-1-1.html">2018.5 Onsite</a></h4><h5 id="698-partition-to-k-equal-sum-subsets"><a href="#698-partition-to-k-equal-sum-subsets" class="headerlink" title="698. partition-to-k-equal-sum-subsets"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/partition-to-k-equal-sum-subsets/description/">698. partition-to-k-equal-sum-subsets</a></h5><ul>
<li>给一个只含有(0, 10000)的int数组和一个k，判断是否可以将该数组划分为k个相等sum的partition。</li>
<li>似乎是个NP-hard的问题。只能用暴力办法，DFS+标记数组，每次累加过后进入下一层看看是否达到了targetSum，达到了就清空继续往后找新的一组subset.最后如果只剩下一组了，直接返回true，因为此时其他k - 1个组都已经达到targetSum了，当前的<code>sum = k * targetSum - (k - 1) * targetSum = targetSum</code>.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartitionKSubsets</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span> || k &gt; nums.length || k &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> IntStream.of(nums).sum();  <span class="comment">// Java8的stream!</span></span><br><span class="line">        <span class="keyword">if</span> (sum % k != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">targetSum</span> <span class="operator">=</span> sum / k;</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        <span class="keyword">return</span> checkPartition(nums, visited, <span class="number">0</span>, targetSum, <span class="number">0</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkPartition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">boolean</span>[] visited, <span class="type">int</span> startIndex, <span class="type">int</span> targetSum, <span class="type">int</span> currSum, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;    <span class="comment">// 提前break</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (currSum == targetSum) &#123;</span><br><span class="line">            <span class="keyword">return</span> checkPartition(nums, visited, <span class="number">0</span>, targetSum, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                visited[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (checkPartition(nums, visited, i + <span class="number">1</span>, targetSum, currSum + nums[i], k)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                visited[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：更快的做法是先对数组排序，然后存k个bucket，每个bucket从后往前取元素不断累加.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartitionKSubsets</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span> || k &gt; nums.length || k &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> IntStream.of(nums).sum();  <span class="comment">// Java8的stream!</span></span><br><span class="line">        <span class="keyword">if</span> (sum % k != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">targetSum</span> <span class="operator">=</span> sum / k;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> checkPartition(nums, targetSum, <span class="keyword">new</span> <span class="title class_">int</span>[k], nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkPartition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> targetSum, <span class="type">int</span>[] buckets, <span class="type">int</span> numsIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (numsIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> bucket : buckets) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bucket != targetSum) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (buckets[i] + nums[numsIndex] &lt;= targetSum) &#123;</span><br><span class="line">                buckets[i] += nums[numsIndex];</span><br><span class="line">                <span class="keyword">if</span> (checkPartition(nums, targetSum, buckets, numsIndex - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                buckets[i] -= nums[numsIndex];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>follow-up: 如果去掉正数的限制，允许出现负数和0？</li>
<li>上面的方法只考虑了直接累积叠加，无法解决负数问题。因此需要引入一个elementCount来统计当前这一波存入了多少element，当达到targetSum的时候需要判断当前这一波是否真的存入了元素。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartitionKSubsets</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span> || k &gt; nums.length || k &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> IntStream.of(nums).sum();</span><br><span class="line">        <span class="keyword">if</span> (sum % k != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">targetSum</span> <span class="operator">=</span> sum / k;</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        <span class="keyword">return</span> checkPartition(nums, visited, <span class="number">0</span>, targetSum, <span class="number">0</span>, k, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkPartition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">boolean</span>[] visited, <span class="type">int</span> startIndex, <span class="type">int</span> targetSum, <span class="type">int</span> currSum, <span class="type">int</span> k, <span class="type">int</span> elementCount)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;      <span class="comment">// 必须算完才行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (currSum == targetSum &amp;&amp; elementCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> checkPartition(nums, visited, <span class="number">0</span>, targetSum, <span class="number">0</span>, k - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                visited[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (checkPartition(nums, visited, i + <span class="number">1</span>, targetSum, currSum + nums[i], k, elementCount + <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                visited[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>follow-up: 如何记录路径？也就是在dfs的时候多用一个List记录存入的数字即可。</li>
</ul>
<h5 id="数组与query-x2"><a href="#数组与query-x2" class="headerlink" title="数组与query x2"></a>数组与query x2</h5><ul>
<li>给一个长度为N的数组，其中每一个数字都是8bit的正整数（0～255）。给一个二维数组M，类似于<code>[[1,100],[5,1000],etc]</code>，求所给range的mean。</li>
<li>naive方法是对于每一个query，都求一个sum &#x2F; size，复杂度O(M*N)。可以用lc 303 rangeSum的思路，先求一波和，然后求sum的时候直接用两个位置的相减即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] getMeans(<span class="type">int</span>[] nums, <span class="type">int</span>[][] queries) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span></span><br><span class="line">    || queries == <span class="literal">null</span> || queries.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> nums.length, M = queries.length;</span><br><span class="line">    <span class="type">int</span>[] sums = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    sums[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">        sums[i] = sums[i - <span class="number">1</span>] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span>[] means = <span class="keyword">new</span> <span class="title class_">double</span>[M];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> quries[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> quries[i][<span class="number">1</span>];</span><br><span class="line">        means[i] = (sum[end] - (start &gt; <span class="number">0</span> ? sums[start - <span class="number">1</span>] : <span class="number">0</span>)) </span><br><span class="line">                    / (<span class="type">double</span>)(end - start + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>follow-up: 还是这些input，但query内容变为「求每个range的median」。median自然想到排序，而这个0～255的限制范围就容易想到木桶排序，然后根据个数就可以找到median了。在预处理的时候直接给每一个元素维护一个长度为256的bucket，</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">public</span> <span class="type">double</span>[] getMedians(<span class="type">int</span>[] nums, <span class="type">int</span>[][] queries) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span></span><br><span class="line">    || queries == <span class="literal">null</span> || queries.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> nums.length, M = queries.length;</span><br><span class="line">    <span class="type">int</span>[][] buckets = <span class="keyword">new</span> <span class="title class_">int</span>[N][<span class="number">256</span>];</span><br><span class="line">    buckets[<span class="number">0</span>][nums[<span class="number">0</span>]]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">        buckets[i] = Arrays.copyOf(buckets[i - <span class="number">1</span>], <span class="number">256</span>);</span><br><span class="line">        buckets[i][nums[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span>[] medians = <span class="keyword">new</span> <span class="title class_">double</span>[M];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> queries[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> queries[i][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[] tempBucket = Arrays.copyOf(buckets[end], <span class="number">256</span>);</span><br><span class="line">        <span class="keyword">if</span> (start &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">256</span>; j++) &#123;</span><br><span class="line">                tempBucket[j] -= buckets[start - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        medians[i] = getMedian(tempBucket, (end - start) / <span class="number">2</span>, ((end - start + <span class="number">1</span>) &amp; <span class="number">1</span>) == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> medians;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">private</span> <span class="type">double</span> <span class="title function_">getMedian</span><span class="params">(<span class="type">int</span>[] bucket, <span class="type">int</span> pos, <span class="type">boolean</span> isEven)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, index = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">256</span>) &#123;</span><br><span class="line">        index += bucket[i++];</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= pos) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isEven || index &gt; pos) &#123;</span><br><span class="line">        <span class="keyword">return</span> i - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">256</span>) &#123;</span><br><span class="line">        index += bucket[i++];</span><br><span class="line">        <span class="keyword">if</span> (index &gt; pos) &#123;</span><br><span class="line">            <span class="keyword">return</span> (first + i - <span class="number">1</span>) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>再follow-up: 当N特别大的时候，无法全部放入内存，如何在预处理的时候进行压缩。(给定一个压缩指标K, K&lt;&lt;N， 问怎么在预处理的时候进行压缩，同时效率还是O(M+N). 答案是每次隔K个进行存储，这样在查找的时候每次需要K次，但是K是常数，所以效率还是O(M+N).????)</li>
</ul>
<h4 id="2017-11-Onsite-1"><a href="#2017-11-Onsite-1" class="headerlink" title="2017.11 Onsite"></a><a target="_blank" rel="noopener" href="http://www.1point3acres.com/bbs/thread-301853-1-1.html">2017.11 Onsite</a></h4><h5 id="139-word-break"><a href="#139-word-break" class="headerlink" title="139. word-break"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/word-break/#/description">139. word-break</a></h5><ul>
<li>给一个List表示词典，给一个String，求能否把该String按照某种方式以空格分割，使得每个单词都来自于字典。</li>
<li>利用DP状态转换，若当前子字符串在dict中且子字符串之前的部分也符合要求，则当前这一段都true。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span> || wordDict == <span class="literal">null</span> || wordDict.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (String word : wordDict) &#123;</span><br><span class="line">        maxLen = Math.max(word.length(), maxLen);</span><br><span class="line">        set.add(word);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">1</span>; end &lt;= s.length(); end++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> end - <span class="number">1</span>; end - start &lt;= maxLen &amp;&amp; start &gt;= <span class="number">0</span>; start--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(s.substring(start, end)) &amp;&amp; dp[start]) &#123;</span><br><span class="line">                dp[end] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>follow-up: 如果wordDict很大怎么存？用Trie。用Trie也存不下呢？？？</li>
<li><code>theyearofdragon</code>可以分成<code>the year of dragon</code>或者<code>they ear of dragon</code>，显然第一种分法好些，问怎么去判断分成不同语句哪种最好。？？？</li>
</ul>
<h5 id="column放pin"><a href="#column放pin" class="headerlink" title="column放pin"></a>column放pin</h5><ul>
<li>Pinterest主页上有N个column，给一个set of pins，pins有score和length，每次把score最高的pin贴到最短的column上，<code>return List&lt;List&lt;Pin&gt;&gt;</code>表示每个column里的pins。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Pin</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Pin&gt; &#123;</span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="type">double</span> height;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pin</span><span class="params">(<span class="type">double</span> score, <span class="type">double</span> height)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Pin that)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.score == that.score ? </span><br><span class="line">            (<span class="type">int</span>)(<span class="built_in">this</span>.height - that.height)</span><br><span class="line">            : (<span class="type">int</span>)(that.score - <span class="built_in">this</span>.score);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Pin&gt;&gt; <span class="title function_">getPinPos</span><span class="params">(List&lt;Pin&gt; pinList, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">    Collections.sort(pinList);</span><br><span class="line">    List&lt;List&lt;Pin&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">double</span>[] heights = <span class="keyword">new</span> <span class="title class_">double</span>[col];</span><br><span class="line">    PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((i, j) -&gt; heights[i] != heights[j] ? (<span class="type">int</span>)(heights[i] - heights[j]) : i - j);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; col; i++) &#123;</span><br><span class="line">        ret.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        pq.offer(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Pin pin : pinList) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">        heights[index] += pin.height;</span><br><span class="line">        ret.get(index).add(pin);</span><br><span class="line">        pq.offer(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>follow up: 用户的手机屏幕只有M长，如果屏幕的顶点距离主页顶点距离为K(???)，求出能显示出的pins。</li>
</ul>
<h5 id="Merge-interval"><a href="#Merge-interval" class="headerlink" title="Merge interval"></a>Merge interval</h5><ul>
<li>给List of Interval，含有start, end, weight属性。如果两个interval overlap了，overlap部分的weight相加变成新的interval，返回merge之后的interval list。但是如果有多个overlap怎么办？比如<code>[0,1], [0,4], [0,5], [3,6]</code>这种，merge多次吗？</li>
</ul>
<h4 id="2018-7-Onsite-1"><a href="#2018-7-Onsite-1" class="headerlink" title="2018.7 Onsite"></a><a target="_blank" rel="noopener" href="https://www.1point3acres.com/bbs/thread-432512-1-1.html">2018.7 Onsite</a></h4><h5 id="相似Set"><a href="#相似Set" class="headerlink" title="相似Set"></a>相似Set</h5><ul>
<li>输入一个data stream，比如：<code>a -&gt; [b]; b -&gt; [a, d, f]; c -&gt; [b, j]; ...</code>，表示这些元素是相似的，且相似具有传递性，最后输出所有相似的set。</li>
<li>可以考虑用并查集，每一个起始点作为root，其余点就是它的children。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printGroup</span><span class="params">(Map&lt;String, List&lt;String&gt;&gt; map)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (map == <span class="literal">null</span> || map.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;String, String&gt; parentMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; nodeSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">        map.putIfAbsent(key, key);</span><br><span class="line">        nodeSet.add(key);</span><br><span class="line">        <span class="type">String</span> <span class="variable">parent</span> <span class="operator">=</span> findParent(key);</span><br><span class="line">        List&lt;String&gt; equivalents = map.get(key);</span><br><span class="line">        <span class="keyword">for</span> (String equivalent : equivalent) &#123;</span><br><span class="line">            nodeSet.add(equivalent);</span><br><span class="line">            <span class="type">String</span> <span class="variable">currParent</span> <span class="operator">=</span> findParent(equivalent);</span><br><span class="line">            <span class="keyword">if</span> (!currParent.equals(parent)) &#123;</span><br><span class="line">                map.put(currParent, parent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">findParent</span><span class="params">(String str, Map&lt;String, String&gt; parentMap)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!parentMap.getOrDefault(str, str).equals(str)) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">parent</span> <span class="operator">=</span> parentMap.get(str);</span><br><span class="line">        parentMap.put(str, parentMap.getOrDefault(parent, parent));</span><br><span class="line">        str = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>或者直接建graph之后，找connected component来搞，似乎实现起来更不容易出错？</li>
</ul>
<h4 id="2016-5-Onsite"><a href="#2016-5-Onsite" class="headerlink" title="[2016.5 Onsite]"></a>[2016.5 Onsite]</h4><h5 id="124-binary-tree-maximum-path-sum"><a href="#124-binary-tree-maximum-path-sum" class="headerlink" title="124. binary-tree-maximum-path-sum"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-maximum-path-sum/#/description">124. binary-tree-maximum-path-sum</a></h5><ul>
<li>给一个二叉树，求其中的任意一条路径使得经过所有节点的值最大，不一定要经过root。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> max;        <span class="comment">// store the value of taking current root as swag point &quot;^&quot;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">return</span> Math.max(dfs(root), max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, dfs(root.left));</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, dfs(root.right));</span><br><span class="line">        max = Math.max(max, left + right + root.val);   <span class="comment">// take both of the branches</span></span><br><span class="line">        <span class="keyword">return</span> root.val + Math.max(left, right);    <span class="comment">// means only take one of the branches</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="meeting-rooms-ii变种"><a href="#meeting-rooms-ii变种" class="headerlink" title="meeting-rooms-ii变种"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/meeting-rooms-ii/description/">meeting-rooms-ii变种</a></h5><ul>
<li>给一堆task的开始和结束时间和每个task所需的cpu数量，求完成所有task的最小cpu数。</li>
<li>先根据开始时间排序，然后往PriorityQueue中逐个加入task，若当前开始时间比队首的结束时间大，说明可以复用前面的cpu了，每次注意要更新cpu数量保证是最大值即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCPU</span><span class="params">(Task[] tasks)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tasks == <span class="literal">null</span> || tasks.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(tasks, (a, b) -&gt; a.start - b.start);</span><br><span class="line">    PriorityQueue&lt;Task&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(); <span class="comment">// 同时执行的task</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>, curr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tasks.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 若当前task比最先结束的task晚开始，就可以用之前释放的cpu了</span></span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty() &amp;&amp; tasks[i].start &gt;= pq.peek().end) &#123;</span><br><span class="line">            curr -= pq.poll().cpu;  <span class="comment">// 更新当前pq中所有任务所需cpu</span></span><br><span class="line">        &#125;</span><br><span class="line">        curr += tasks[i].cpu;</span><br><span class="line">        max = Math.max(curr, max);</span><br><span class="line">        pq.offer(tasks[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="判断相同文件"><a href="#判断相同文件" class="headerlink" title="判断相同文件"></a>判断相同文件</h5><ul>
<li>给定两个函数，<code>get_files(dir)</code>, <code>get_dir(dir)</code> 返回所有内容相同的file. 问怎么定义内容相同，用文件名还是binary， 小哥说要内容相同，那我就用recursion遍历所有file， 然后用hashing把文件的内容hash成key放在dictionary，最后返回这个dictionary。</li>
<li>follow up说， 如果hashing非常expensive怎么办? hashing前先check file size，如果文件大小一样，再用hashing判断是不是一样。 </li>
<li>2nd follow up说<code>get_files</code>, <code>get_dir</code>如果expensive怎么办，答曰用parrallel programming （gpu or multi core） 可以优化。</li>
</ul>
<h4 id="2018-5-Onsite-2"><a href="#2018-5-Onsite-2" class="headerlink" title="2018.5 Onsite"></a><a target="_blank" rel="noopener" href="https://www.1point3acres.com/bbs/thread-427590-1-1.html">2018.5 Onsite</a></h4><h5 id="read-n-characters-given-read4变种"><a href="#read-n-characters-given-read4变种" class="headerlink" title="read-n-characters-given-read4变种"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/read-n-characters-given-read4/description/">read-n-characters-given-read4变种</a></h5><ul>
<li>给一堆有序号的无限block，给你一个读给定index的单个block的API，每个block 64MB，然后给你一个开始的byte位置(例如：3MB，就是从index &#x3D; 0 开始)，和要读的byte长度(例如：67MB)，返回读的结果。就分情况，慢慢写，先是第一个block(可能，只是读部分)，然后中间连续读几个block(计算一下就好)，最后一个block可能只读部分。 感觉整体就是玩index。</li>
</ul>
<h5 id="见上面的word-ladder"><a href="#见上面的word-ladder" class="headerlink" title="见上面的word-ladder"></a>见上面的word-ladder</h5><h5 id="36-valid-sudoku"><a href="#36-valid-sudoku" class="headerlink" title="36. valid-sudoku"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-sudoku/#/description">36. valid-sudoku</a></h5><ul>
<li>给一个二维char数组，里面是一个未完成的数独9x9棋盘，要求每一行、每一列、每个3x3方块中数字1-9有且仅有出现一次。判断这个棋盘是否符合数独规则，返回布尔值。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (board == <span class="literal">null</span> || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!set.add(board[i][j] + <span class="string">&quot; in row &quot;</span> + i) </span><br><span class="line">                    || !set.add(board[i][j] + <span class="string">&quot; in col &quot;</span> + j) </span><br><span class="line">                    || !set.add(board[i][j] + <span class="string">&quot; in block &quot;</span> + (i / <span class="number">3</span>) + <span class="string">&#x27;-&#x27;</span> + (j / <span class="number">3</span>))) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="类似362-design-hit-counter详情母鸡"><a href="#类似362-design-hit-counter详情母鸡" class="headerlink" title="类似362. design-hit-counter详情母鸡"></a>类似<a target="_blank" rel="noopener" href="https://leetcode.com/problems/design-hit-counter/description/">362. design-hit-counter</a>详情母鸡</h5><ul>
<li>定义 <code>eventOccur()</code>，<code>numEvent()</code> 方法，有个sliding window size N。然后扩展，减少空间，Map，加一个功能，返回当前时间<code>eventOccur()</code> call次数最多的时间，要求 amortized O(1), 楼主一时想不到，最后只想到类似 LFU 的那种 2 map + DLL，1 个 map key 是 count，DLL 存 Cell(time, count)，一个就是整个cell。这个能保证O(logN), 面试官表示满意，方法不错，但是他后来是说，既然之前用了 queue 存所有 time + count，直接maintain 一个 max variable，每次 max variable 超过了 sliding window，则遍历 剩下的queue里的 count 就好，对于无限流，这个就是 amortized O(1), 但是楼主想不通，就举了个，每次 时间下 call evenOccur() 次数是递减的，那么就是每次都是O(n); 面试官表示是的，这个特殊的例子是O(n), generally 还是每 N 次才更新。</li>
</ul>
<p><img src="https://ww1.sinaimg.cn/large/9b3a5c2fly1fw447d2fm2j20q20q0tbb.jpg"></p>
<hr>
<h3 id="以下是卡拉特面经"><a href="#以下是卡拉特面经" class="headerlink" title="以下是卡拉特面经"></a>以下是卡拉特面经</h3><h4 id="统计点击率"><a href="#统计点击率" class="headerlink" title="统计点击率"></a><a target="_blank" rel="noopener" href="http://www.1point3acres.com/bbs/thread-381271-1-1.html">统计点击率</a></h4><ul>
<li>给一堆网址和点击率，求不同部分域名的点击率。如<code>mobile.sports.yahoo.com</code>就需要统计四个部分。<a target="_blank" rel="noopener" href="https://leetcode.com/problems/subdomain-visit-count/description/">lc 811</a></li>
<li>split之后搞就行了。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">subdomainVisits</span><span class="params">(String[] cpdomains)</span> &#123;</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (cpdomains == <span class="literal">null</span> || cpdomains.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String cpdomain : cpdomains) &#123;</span><br><span class="line">        String[] data = cpdomain.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> Integer.parseInt(data[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> data[<span class="number">1</span>].substring(index == <span class="number">0</span> ? index : index + <span class="number">1</span>);</span><br><span class="line">            map.put(key, map.getOrDefault(key, <span class="number">0</span>) + count);</span><br><span class="line">            index = data[<span class="number">1</span>].indexOf(<span class="string">&quot;.&quot;</span>, index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">        ans.add(map.get(key) + <span class="string">&quot; &quot;</span> + key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="求最长公共子数组"><a href="#求最长公共子数组" class="headerlink" title="求最长公共子数组"></a><a target="_blank" rel="noopener" href="http://www.1point3acres.com/bbs/thread-381271-1-1.html">求最长公共子数组</a></h4><ul>
<li>实现一个函数取两个数组作为input，求这两个数组的最长公共元素。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String[] longestCommonSubarray(String[] log1, String[] log2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (log1 == <span class="literal">null</span> || log2 == <span class="literal">null</span> || log1.length == <span class="number">0</span> || log2.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>, end = -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[log1.length + <span class="number">1</span>][log2.length + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= log1.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= log2.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (log1[i - <span class="number">1</span>].equals(log2[j - <span class="number">1</span>])) &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span> + dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (dp[i][j] &gt; maxLen) &#123;</span><br><span class="line">                        maxLen = dp[i][j];</span><br><span class="line">                        end = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (maxLen == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;None&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] ret = <span class="keyword">new</span> <span class="title class_">String</span>[maxLen];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ret.length; i++) &#123;</span><br><span class="line">        ret[i] = log1[end - maxLen + i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="矩阵中最长上升序列"><a href="#矩阵中最长上升序列" class="headerlink" title="矩阵中最长上升序列"></a><a target="_blank" rel="noopener" href="http://www.1point3acres.com/bbs/thread-446040-1-1.html">矩阵中最长上升序列</a></h4><ul>
<li>给一个矩阵，求最长上升序列的长度。<a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-increasing-path-in-a-matrix/description/">lc 329</a>.</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">longestIncreasingPath</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rowTotal</span> <span class="operator">=</span> matrix.length, colTotal = matrix[<span class="number">0</span>].length, len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[][] cache = <span class="keyword">new</span> <span class="title class_">int</span>[rowTotal][colTotal];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rowTotal; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; colTotal; j++) &#123;</span><br><span class="line">            len = Math.max(len, getLen(matrix, cache, i, j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[][] dirs = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getLen</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span>[][] cache, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; matrix.length || j &lt; <span class="number">0</span> || j &gt; matrix[i].length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cache[i][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cache[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] dir : dirs) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rowNext</span> <span class="operator">=</span> i + dir[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">colNext</span> <span class="operator">=</span> j + dir[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (rowNext &lt; <span class="number">0</span> || rowNext &gt;= matrix.length</span><br><span class="line">            || colNext &lt; <span class="number">0</span> || colNext &gt;= matrix[rowNext].length</span><br><span class="line">            || matrix[rowNext][colNext] &lt;= matrix[i][j]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextLen</span> <span class="operator">=</span> getLen(matrix, cache, rowNext, colNext);</span><br><span class="line">        len = Math.max(nextLen + <span class="number">1</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">    cache[i][j] = len;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2018-9-20-电面"><a href="#2018-9-20-电面" class="headerlink" title="2018.9.20 电面"></a><a target="_blank" rel="noopener" href="http://www.1point3acres.com/bbs/thread-444076-1-1.html">2018.9.20 电面</a></h4><ul>
<li>给一个String，只含有数字和加、减。实现eval返回算式的结果。</li>
<li>遇到符号就把前面的数字累加&#x2F;减即可。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> <span class="number">0</span>, num = <span class="number">0</span>, sign = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Character.isDigit(c)) &#123;</span><br><span class="line">            num = num * <span class="number">10</span> + (<span class="type">int</span>)(c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            val = val + sign * num;</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">            sign = c == <span class="string">&#x27;+&#x27;</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    val = val + sign * num;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>follow-up: 除了上面这些，还含有括号。<a target="_blank" rel="noopener" href="https://leetcode.com/problems/basic-calculator/description/">lc 224</a>。利用Stack，遇到加减还是直接算个num出来，遇到左括号说明前面的计算告一段落，将前面的数字和符号都push进stack，遇到右括号时就说明当前括号以内的结果出来了，就从栈顶取数值和符号，合并出整体num之后再继续往后。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> <span class="number">0</span>, sign = <span class="number">1</span>;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Character.isDigit(s.charAt(i))) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> s.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">while</span> (i + <span class="number">1</span> &lt; s.length() &amp;&amp; Character.isDigit(s.charAt(i + <span class="number">1</span>))) &#123;</span><br><span class="line">                num = num * <span class="number">10</span> + (<span class="type">int</span>)(s.charAt(++i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            val += sign * num;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">                sign = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                sign = -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                stack.push(val);</span><br><span class="line">                stack.push(sign);</span><br><span class="line">                val = <span class="number">0</span>;</span><br><span class="line">                sign = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                val = stack.pop() * val + stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>follow-up2: 如果再输入一个map包含一些<code>exp: val</code>对，但是算式中并不是所有的变量都能找到对应的val。可以考虑用replaceAll+正则表达式将输入字符串中的部分换成有效数字。然后还是用stack，只不过现在需要一个类来把数字、字符串、符号wrap起来。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">calculate</span><span class="params">(String s, Map&lt;String, Integer&gt; map)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">regStr</span> <span class="operator">=</span> String.format(<span class="string">&quot;(?&lt;!\\w)%s(?!\\w)&quot;</span>, key);</span><br><span class="line">        s = s.replaceAll(regStr, Integer.toString(map.get(key)));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">    Stack&lt;Part&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="type">Part</span> <span class="variable">curr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Part</span>(<span class="number">0</span>, <span class="literal">null</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Character.isDigit(s.charAt(i))) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> s.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">while</span> (i + <span class="number">1</span> &lt; s.length() &amp;&amp; Character.isDigit(s.charAt(i + <span class="number">1</span>))) &#123;</span><br><span class="line">                num = num * <span class="number">10</span> + (<span class="type">int</span>)(s.charAt(++i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            curr.num += curr.sign * num;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">                curr.sign = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                curr.sign = -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                stack.push(curr);</span><br><span class="line">                curr = <span class="keyword">new</span> <span class="title class_">Part</span>(<span class="number">0</span>, <span class="literal">null</span>, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">Part</span> <span class="variable">prev</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                curr.num = prev.sign * curr.num + prev.num;</span><br><span class="line">                <span class="keyword">if</span> (curr.<span class="keyword">var</span> != <span class="literal">null</span> &amp;&amp; prev.sign &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    curr.<span class="keyword">var</span>.setCharAt(<span class="number">0</span>, curr.<span class="keyword">var</span>.charAt(<span class="number">0</span>) == <span class="string">&#x27;+&#x27;</span> ? <span class="string">&#x27;-&#x27;</span> : <span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (prev.<span class="keyword">var</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">                        curr.<span class="keyword">var</span>.insert(<span class="number">0</span>, prev.<span class="keyword">var</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(s.charAt(i));</span><br><span class="line">                <span class="keyword">while</span> (i + <span class="number">1</span> &lt; s.length() &amp;&amp; s.charAt(i + <span class="number">1</span>) != <span class="string">&#x27; &#x27;</span></span><br><span class="line">                        &amp;&amp; s.charAt(i + <span class="number">1</span>) != <span class="string">&#x27;+&#x27;</span> &amp;&amp; s.charAt(i + <span class="number">1</span>) != <span class="string">&#x27;-&#x27;</span></span><br><span class="line">                        &amp;&amp; s.charAt(i + <span class="number">1</span>) != <span class="string">&#x27;(&#x27;</span> &amp;&amp; s.charAt(i + <span class="number">1</span>) != <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                    sb.append(s.charAt(++i));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (curr.sign &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    sb.insert(<span class="number">0</span>, <span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    sb.insert(<span class="number">0</span>, <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (curr.<span class="keyword">var</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">                    sb.insert(<span class="number">0</span>, curr.<span class="keyword">var</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                curr.<span class="keyword">var</span> = sb;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2018-3-14电面"><a href="#2018-3-14电面" class="headerlink" title="2018.3.14电面"></a><a target="_blank" rel="noopener" href="http://www.1point3acres.com/bbs/thread-353741-1-1.html">2018.3.14电面</a></h4><ul>
<li>给一个二维String数组，每一行存放每个点赞记录<code>url, user, timestamp</code>。1.求每个网站的最早点赞记录。2.给一个user，求与他点赞过的url重复最多的用户。</li>
<li>第一问略。第二问，将数据存入<code>user -&gt; set(url)</code>，和<code>url -&gt; set(user)</code>，根据给定user找到他点赞过的url集合，然后对于里面的每个url找点赞过的用户集合，统计每个用户出现的次数即可。注意这个不是最省memory的方法，可以只维护url2User，同时把这个user访问过的url存入Set，这样就可以只遍历这个set了而不用额外维护每个user访问过那些网站。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getCommonUser</span><span class="params">(String[][] logs, String user)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (logs == <span class="literal">null</span> || logs.length == <span class="number">0</span> || user == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;String, Set&lt;String&gt;&gt; user2Url = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Map&lt;String, Set&lt;String&gt;&gt; url2User = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String[] log : logs) &#123;</span><br><span class="line">        user2Url.putIfAbsent(log[<span class="number">0</span>], <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;());</span><br><span class="line">        user2Url.get(log[<span class="number">0</span>]).add(log[<span class="number">1</span>]);</span><br><span class="line">        url2User.putIfAbsent(log[<span class="number">1</span>], <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;());</span><br><span class="line">        url2User.get(log[<span class="number">1</span>]).add(log[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!user2Url.containsKey(user)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    Set&lt;String&gt; urls = user2Url.get(user);</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    Map&lt;String, Integer&gt; overlapCount = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String url : urls) &#123;</span><br><span class="line">        Set&lt;String&gt; users = url2User.get(url);</span><br><span class="line">        <span class="keyword">for</span> (String curr : users) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr.equals(user)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            overlapCount.put(curr, overlapCount.getOrDefault(curr, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (overlapCount.get(curr) &gt; max) &#123;</span><br><span class="line">                max = overlapCount.get(curr);</span><br><span class="line">                ret = curr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2018-9-15-电面"><a href="#2018-9-15-电面" class="headerlink" title="2018.9.15 电面"></a><a target="_blank" rel="noopener" href="http://www.1point3acres.com/bbs/thread-443143-1-1.html">2018.9.15 电面</a></h4><ul>
<li>给一堆edges。1. 找nodes that have no parents, and nodes that have 1 parent； 2. 找graph中两个node有无common ancestor（直接相连的不算共同祖先）；3. 找furthest ancestor from node。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">getIndependentNode</span><span class="params">(<span class="type">int</span>[][] edges)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (edges == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Integer, Set&lt;Integer&gt;&gt; parentMap = getParentMap(edges);</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> key : parentMap.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parentMap.get(key).size() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            ans.add(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">hasCommonAncestor</span><span class="params">(<span class="type">int</span>[][] edges, <span class="type">int</span> node1, <span class="type">int</span> node2)</span> &#123;</span><br><span class="line">    Map&lt;Integer, Set&lt;Integer&gt;&gt; parentMap = getParentMap(edges);</span><br><span class="line">    Set&lt;Integer&gt; ancestorSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    q.offer(node1);</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        Set&lt;Integer&gt; parentSet = parentMap.get(q.poll());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> parent : parentSet) &#123;</span><br><span class="line">            q.offer(parent);</span><br><span class="line">            ancestorSet.add(parent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    q.offer(node2);</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        Set&lt;Integer&gt; parentSet = parentMap.get(q.poll());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> parent : parentSet) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ancestorSet.contains(parent)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            q.offer(parent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getFurthestAncestor</span><span class="params">(<span class="type">int</span>[][] edges, <span class="type">int</span> node)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (edges == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Integer, Set&lt;Integer&gt;&gt; parentMap = getParentMap(edges);</span><br><span class="line">    <span class="keyword">if</span> (parentMap.get(node).isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    q.offer(node);</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        ret = q.peek();</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> q.size();</span><br><span class="line">        <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Set&lt;Integer&gt; parentSet = parentMap.get(q.poll());</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> parent : parentSet) &#123;</span><br><span class="line">                q.offer(parent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, Set&lt;Integer&gt;&gt; <span class="title function_">getParentMap</span><span class="params">(<span class="type">int</span>[][] edges)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (edges == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Integer, Set&lt;Integer&gt;&gt; parentMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">        parentMap.putIfAbsent(edge[<span class="number">0</span>], <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line">        parentMap.putIfAbsent(edge[<span class="number">1</span>], <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line">        parentMap.get(edge[<span class="number">1</span>]).add(edge[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parentMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
              <a href="/tags/algorithm/" rel="tag"># algorithm</a>
              <a href="/tags/interview/" rel="tag"># interview</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2018/09/19/twitter/" rel="prev" title="推特">
                  <i class="fa fa-angle-left"></i> 推特
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019/01/05/gcp_ssr/" rel="next" title="使用Google Cloud Platform运行SSR实现FQ">
                  使用Google Cloud Platform运行SSR实现FQ <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2016 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="futbol-o"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Bob</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"bobbyliujb","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js" defer></script>

</body>
</html>
